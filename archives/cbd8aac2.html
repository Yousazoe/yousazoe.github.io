<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。"><meta property="og:type" content="article"><meta property="og:title" content="Cherno OpenGL教程"><meta property="og:url" content="https://yousazoe.top/archives/cbd8aac2.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/K4DxcL.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/w5XRfu.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/HgBwvC.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/BeAao9.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/Nby7Um.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/lRZ6V5.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/oHw927.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/6aOZAB.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/yW5FoQ.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/Kc02rp.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/Pw7Ynd.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/eQxGQ8.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/yJD0q1.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/0vR4BK.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/3huSYC.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/o35r1Y.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/JPc6wC.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/gh0Yuv.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/2wm6Fo.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/00vAdR.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/CdVZjC.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/e6c9d24egy1h2lt68j6klj211x0kiq6s-20220526221235055.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/EKV7FE.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/zZJOiw.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/GiuTRy.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/ZuZbei.jpg"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/ehr3l7.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/I0TkZU.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/0vC2xI.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/X8XHLg.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/Z8UO7K.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/YGUC1V.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/vwl5Lr.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/D87pvb.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/si3fQb.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/yVc389.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/ojMTaf.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/0AXDNJ.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/ocURfe.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/QawyIY.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/ffGrQb.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/nivCms.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/jaskyZ.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/7wLmw4.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/qFRSBN.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/Tm0yJg.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/lwzpBj.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/qbCBaJ.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/gKsQud.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/pot3Qe.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/zJz366.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/27j93i.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/86K1aB.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/XIghUi.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/aZhz8W.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/am6Cqa.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/PFW6aM.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/yghr4f.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/yIvvCi.png"><meta property="og:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/gmyeqz.png"><meta property="article:published_time" content="2022-05-11T15:39:16.000Z"><meta property="article:modified_time" content="2022-07-30T08:45:33.000Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="OpenGL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.yousazoe.top/uPic/img/blog/CPP7/K4DxcL.jpg"><link rel="canonical" href="https://yousazoe.top/archives/cbd8aac2.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Cherno OpenGL教程 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/cbd8aac2.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Cherno OpenGL教程</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-05-11 23:39:16" itemprop="dateCreated datePublished" datetime="2022-05-11T23:39:16+08:00">2022-05-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Cherno%E7%9A%84C-%E7%AC%94%E8%AE%B0-Cherno-C/" itemprop="url" rel="index"><span itemprop="name">Cherno的C++笔记 (Cherno C++)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>104k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>3:09</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/K4DxcL.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。</p><span id="more"></span><h3 id="欢迎来到OpenGL"><a href="#欢迎来到OpenGL" class="headerlink" title="欢迎来到OpenGL"></a>欢迎来到OpenGL</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=465609139&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>在这个视频中，主要包括 OpenGL 实际是什么、怎么使用它以及它能为我们做什么和它不是什么等等，这个系列也是如此。</p><h4 id="什么是OpenGL"><a href="#什么是OpenGL" class="headerlink" title="什么是OpenGL"></a>什么是OpenGL</h4><p>首先如果你听过 OpenGL 但不确定它是什么，你可能想到与图形有关的，那就是 OpenGL。OpenGL 是一种图形接口，现在 API 代表应用程序接口，基本上就是一大堆我们能够调用的函数去做一些事情。在这种情况下，由于 OpenGL 是一种图形 API，它允许我们做一些与图形相关的事情，特别的是它允许我们访问 GPU 也就是显卡，图形处理单元（Graphics Processing Unit）。</p><p>调用显卡也更好地绘制图形，所以实际上为了利用电脑或其他设备（比如手机）中强大的图形处理器，需要调用一些 API 访问固件。OpenGL 正好是允许访问和操作 GPU 的许多接口中的一种，当然我们也有一些其他的接口，比如 Direct3D、Vulcan 和 Metal 等等，所以某种角度来说 OpenGL 允许我们控制显卡。</p><h4 id="关于OpenGL误解"><a href="#关于OpenGL误解" class="headerlink" title="关于OpenGL误解"></a>关于OpenGL误解</h4><p>让我们来澄清一些人关于 OpenGL 的误解。</p><p>首先，许多人称它为一个类库或一种引擎或一些其他的框架，但这些都不是。OpenGL 核心本身只是一种规范，和 CPP 规范差不多。实际上它没有确定任何代码和类似的事情本身就是规范，比如“嘿，这个函数应该存在，需要这些参数并且返回这个值”，它只是一种你能利用这种 API 做什么规范，没有任何具体的实现，这意味它绝不是一个类库，因为 OpenGL 本身没有代码，它只是一种规范。</p><br><p>去哪儿下载 OpenGL 是另一个常见的问题。</p><p>然而，答案是你不需要真的去下载 OpenGL，它本身只是一种规范。那么，谁去实现它呢，谁去为你调用的 OpenGL 函数写代码呢？这个答案是 GPU 制造商，所以如果你使用的是 NVIDIA 显卡，那么你的显卡驱动（也就是 NVIDIA 驱动）实际上包含了 OpenGL 的实现，每个显卡制造商比如 AMD、Intel 等都会有它们自己的实现，每家关于 OpenGL 的实现都会有些不同，这也就是有些游戏能在 NVIDIA 驱动的显卡上运行但在一个 AMD 电视或者其他显卡设备上运行有些区别、甚至会出现问题的原因。</p><p>但不管怎么说，关键在于你的显卡制造商实现的 OpenGL，这又可能导致下一个有关 OpenGL 常见的误解：它是开源的。我不知道人们为什么会这么觉得，也许是名字中带着“Open”，但是它根本不是开源的，你看不到 OpenGL 的源码，因为首先它是由 GPU 制造商实现的，它们肯定不会发布它们的驱动源码。</p><br><p>OpenGL 提供了什么能激发和导致许多人不幸地说 OpenGL 是无与伦比的？原因在于它是跨平台的，所以你的 OpenGL 代码可以在 Windows、Mac、Linux 和 Android 上正常执行，以至于人们立马就会意识到 OpenGL 比 Direct3D 更优越，因为它能在所有平台上运行，但是请不要这么说。</p><p>从我 EA 技术中心并处理过许多引擎中图形接口的经验来看，因为 OpenGL 是跨平台的 API，而制作一款游戏不会只涉及实现一个独立的图形 API。如果游戏引擎是跨平台的，那意味着它不仅实现了 Xbox，也包括其他一些平台，它们不得不实现大量其他的图形接口。</p><p>因此，我们面临的问题是图形 API 是为特定平台设计的。例如 Direct3D 是微软为 Windows 设计的，它在 Windows 上的表现要比跨平台的 API 好些。现在请记住，实际编写这些代码的人不是微软，即使微软的确为了更好的代码质量和 GPU 制造商合作过。所以关于 API 的比较是没有任何意义的，因为通常平台原生的东西会更健壮更友好。</p><br><p>就 OpenGL 的复杂性而言，它可以说是现在可以学习的最简单的 API 了，所以 OpenGL 是绝对值得学习的。Vulkan 是另一个跨平台的 API，但它更底层更严谨，不适合初学者直接入门，老实说我并不想使用 Vulkan 去开发游戏，OpenGL 更加稳定。</p><h4 id="传统与现代OpenGL"><a href="#传统与现代OpenGL" class="headerlink" title="传统与现代OpenGL"></a>传统与现代OpenGL</h4><p>另外本系列学习的主要是现代 OpenGL。OpenGL 于 90 年代发布，那时的情况和现在大不相同，那时的 GPU 是可编程的，十分灵活，制造商给了程序员和开发者更多的控制权。</p><p>传统 OpenGL 和现代 OpenGL 之间最大的区别就是着色器。如果你对图形学感兴趣的话可能听说过着色器，它可能有点像 shadow 这个单词或者是光源，有些人将它和光源或其他比较。抛开这些，着色器是程序，它是在你 GPU 上运行的代码，这就是着色器，它是在你 GPU 上运行的一段程序。。</p><p>那么如果你用 C++、Java 或 C# 或不管什么语言写代码，这段代码都会运行在你的 CPU 上。但当我们开始处理图形的大部分时间里，我们想要更为精确的控制显卡运行，可能要将大部分代码从 CPU 转到 GPU 上，因为它在 GPU 上运行更快，这就是着色器存在的意义：允许我们在 GPU 上运行代码。所以可编程的着色器是最大的区别。</p><h3 id="设置OpenGL和C-中创建一个窗口"><a href="#设置OpenGL和C-中创建一个窗口" class="headerlink" title="设置OpenGL和C++中创建一个窗口"></a>设置OpenGL和C++中创建一个窗口</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=466583251&amp;page=2&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>上一节我们只说了 OpenGL 到底是什么以及这个系列实际会讲什么。今天我们的任务是让我的操作系统为我创造一个窗口，在未来我们可能会在窗口内绘制图形。</p><br><p>我们会使用一个向我提供窗口创建和窗口管理的实际代码类库，不管 Windows、Mac 还是 Linux。GLFW 就是满足上述条件的类库，我喜欢这个类库的原因是它确实是一个轻量级类库，它虽然不如 SDL 那么全面（实际上它就是个渲染器），但依然可以创建窗口、OpenGL context 以及给我们访问一些类似输入之类的基础东西。</p><h4 id="下载类库"><a href="#下载类库" class="headerlink" title="下载类库"></a>下载类库</h4><p>由于我使用的是 Mac，所以使用 brew 下载：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">brew install glew</span><br><span class="line">brew install glfw   </span><br></pre></td></tr></tbody></table></figure><p>下载后默认的路径为 <code>/usr/local/Cellar/</code>。</p><h4 id="配置CMake文件"><a href="#配置CMake文件" class="headerlink" title="配置CMake文件"></a>配置CMake文件</h4><p>我将项目名称设置为 <code>OpenGL</code>，在 CLion 中配置：</p><figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(OpenGL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add head file</span></span><br><span class="line"><span class="keyword">set</span>(GLEW_H /usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/<span class="keyword">include</span>/GL)</span><br><span class="line"><span class="keyword">set</span>(GLFW_H /usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">7</span>/<span class="keyword">include</span>/GLFW)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${GLEW_H}</span> <span class="variable">${GLFW_H}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add target link</span></span><br><span class="line"><span class="keyword">set</span>(GLEW_LINK /usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/lib/libGLEW.<span class="number">2.2</span>.dylib)</span><br><span class="line"><span class="keyword">set</span>(GLFW_LINK /usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">7</span>/lib/libglfw.<span class="number">3</span>.dylib)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">${OPENGL}</span> <span class="variable">${GLEW_LINK}</span> <span class="variable">${GLFW_LINK}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(OpenGL <span class="variable">${SOURCE_FILES}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (APPLE)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(OpenGL <span class="string">"-framework OpenGL"</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(OpenGL <span class="string">"-framework GLUT"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></tbody></table></figure><h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><p>复制下面内容到 <code>main.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行代码，我们会得到一个黑色的窗口。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/w5XRfu.jpg"></p><h4 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h4><p>下面我们用传统 OpenGL 设定三个顶点，绘制一个三角形：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;glew.h&gt;</span><br><span class="line">#include &lt;glfw3.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    /* Initialize the library */</span><br><span class="line">    if(!glfwInit())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    /* Create a Windowed mode and its OpenGL context */</span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);</span><br><span class="line">    if(!window)</span><br><span class="line">    {</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /* Make the window's context current */</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    /* Loop until the user closes the window */</span><br><span class="line">    while(!glfwWindowShouldClose(window))</span><br><span class="line">    {</span><br><span class="line">        /* Render here */</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="addition">+       glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="addition">+       glVertex2f(-0.5f, -0.5f);</span></span><br><span class="line"><span class="addition">+       glVertex2f( 0.0f,  0.5f);</span></span><br><span class="line"><span class="addition">+       glVertex2f( 0.5f, -0.5f);</span></span><br><span class="line"><span class="addition">+       glEnd();</span></span><br><span class="line"></span><br><span class="line">        /* Swap front and back buffers */</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        /* Poll for and events */</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/HgBwvC.jpg"></p><h3 id="在C-中使用现代OpenGL"><a href="#在C-中使用现代OpenGL" class="headerlink" title="在C++中使用现代OpenGL"></a>在C++中使用现代OpenGL</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=3&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="顶点缓冲区和在现代OpenGL中画一个三角形"><a href="#顶点缓冲区和在现代OpenGL中画一个三角形" class="headerlink" title="顶点缓冲区和在现代OpenGL中画一个三角形"></a>顶点缓冲区和在现代OpenGL中画一个三角形</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=4&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>现代 OpenGL 比那种传统 OpenGL 更具可编程性，它的扩展性更好也更加强大，你可以用它做许多事情，但代价是在绘制一个简单三角形前，我们实际上需要做很多设置。而前面我们已经用传统方法简单绘制了三角形，非常简单并且不需要什么设置。</p><p>让我们聊聊需要什么东西才可以绘制一个三角形。对于现代 OpenGL 而言，首先我们需要能够创建一个顶点缓冲区，然后还要创建一个着色器（之后可能会单独讲一下图形渲染管线是如何运行的，特别是 OpenGL）。让我们快速地说一下这两个东西是什么吧。</p><h4 id="顶点缓冲区与着色器"><a href="#顶点缓冲区与着色器" class="headerlink" title="顶点缓冲区与着色器"></a>顶点缓冲区与着色器</h4><p>顶点缓冲区基本上就是去掉 vertex，它只是一个内存缓冲区，一个内存字节数组，从字面上讲就是一块用来存字节的内存。但是顶点缓冲区又和 C++ 中像字符数组的内存缓冲区不太一样，它是 OpenG 中的内存缓冲区，这意味着它实际上在显卡显存（Video RAM）上。</p><p>所以这里的基本思路就是我要定义一些数据来表示三角形，我要把它放入显卡的 VRAM 中，然后还需要发出 DrawCall 绘制指令。实际上我们还需要告诉显卡如何读取和解释这些数据，以及如何把它放到我们屏幕上，一旦我们发出 DrawCall 指令，我们需要告诉显卡：好了，一旦你在显卡端获得了这些数据，我要你像这样把它摆出来，我希望你把它画出来在屏幕上给我显示一个三角形。所以我们需要告诉显卡怎么做，需要对显卡编程，这就是着色器，着色器只是一个运行在显卡上的程序，它是一堆我们可以编写的在显卡上以一种非常特殊的方式运行的代码。</p><br><p>听起来很复杂，但是不要想太多。简而言之我们有一个可以指定的内存，还有一些我可以指定的数据，告诉显卡：嘿，这是数据。然后从显卡那边说：好了，现在读一下这些数据并解释一下（例如屏幕上的位置），可能的话把它们连成一个三角形。这就是整件事的原理，也是 OpenGL 渲染的流程。</p><p>要注意 OpenGL 是作为一个状态机来运行的，这意味着你不必把它当作一个对象或任何类似的东西来对待，你所做的是设置一系列的状态，然后当你说一些事比如给我画一个三角形，这是非常 contextual 的。我的意思是，我不只是说，嘿，给我画一个三角形，然后传递 OpenGL 需要绘制三角形的所有东西。实际上它已经知道画三角形需要什么了，因为那是状态的一部分。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><p>让我们来创建这个顶点缓冲区来看看能做些什么。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line"><span class="built_in">glVertex2f</span>(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line"><span class="built_in">glVertex2f</span>( <span class="number">0.0f</span>,  <span class="number">0.5f</span>);</span><br><span class="line"><span class="built_in">glVertex2f</span>( <span class="number">0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></tbody></table></figure><p>这是之前使用传统 OpenGL 绘制三角形的代码。现代 OpenGL 需要创建顶点缓冲区，发送到 OpenGL 显存，然后发出一个 DrawCall 指令说：嘿，请画出我的缓冲区。</p><p>首先我们要创建自己的缓冲区，这个过程非常简单，只需要调用 <code>glGenBuffers()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/BeAao9.jpg"></p><p>第一个参数指定需要几个缓冲区；第二个参数指定返回整数的内存地址，这也是生成的缓冲区的 id。记住 OpenGL 是作为一个状态机工作，这意味着你可以生成一切，而 OpenGL 中生成所有东西都分配了一个唯一的标识符，它只是一个整数，也是你实际对象的 id，当你想要使用这个对象的时候就用这个数字。</p><p>因为我要渲染我的三角形，需要说明用哪个缓冲区来渲染三角形，只需要传递这个整数即可。现在我们有了这个 id，一旦创建缓冲区后，我们现在就要选择那个缓冲区。选择（Selecting）在 OpenGL 中被称为绑定（Binding）:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/Nby7Um.jpg"></p><p>下一步是指定数据。一个简单的方式是在声明数据的时候直接把顶点数据填充进去：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着调用 <code>glBufferData()</code> ，查阅文档：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/lRZ6V5.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/oHw927.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure><p>很好，现在我们为 OpenGL 指定了 <code>positions</code>，通常还需要创建一个索引缓冲区，也都是后话了。不过我们还没有着色器，去解释如何用这些数据进行绘制，我们将在下一期讨论那个问题。今天我们要做的只是想看看能不能把它绘制出来。</p><p>在没有索引缓冲区的情况下我们可以调用 <code>glDrawArrays()</code> 绘制指定图元：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/* Render here */</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="deletion">-glVertex2f(-0.5f, -0.5f);</span></span><br><span class="line"><span class="deletion">-glVertex2f( 0.0f,  0.5f);</span></span><br><span class="line"><span class="deletion">-glVertex2f( 0.5f, -0.5f);</span></span><br><span class="line"><span class="deletion">-glEnd();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br></pre></td></tr></tbody></table></figure><p>我喜欢用 Photoshop 打比方。如果我选择一个图层，然后在该图层上用画笔绘制一些东西，它只会影响这一图层。然而如果我没有选择任何东西或者选错了东西，它不会影响到我想绘制的那个图层。OpenGL 也是一样，在使用它之前你需要选择或绑定所有东西，因为这就是它的运行原理，它是上下文相关的，它是一个状态机。</p><h3 id="OpenGL中顶点的属性和布局"><a href="#OpenGL中顶点的属性和布局" class="headerlink" title="OpenGL中顶点的属性和布局"></a>OpenGL中顶点的属性和布局</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=5&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>上一节我们讨论了顶点缓冲区，但实际上有一些部分我们忽略了：顶点属性和着色器。今天我们将学习顶点属性。</p><h4 id="顶点属性"><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h4><p>所以什么是顶点属性？OpenGL 渲染管线的工作原理是我们为我们的显卡提供数据，我们在显卡上存储一些内存，它包含了我们想要绘制的所有数据；然后我们使用一个着色器在显卡上读取数据，并且完全显示在屏幕上。</p><p>通常我们绘制几何图元的方式就是使用一个叫顶点缓冲区的东西，也就是一个存储在显卡上的内存缓冲区，所以当对着色器编程时实际上是从读取顶点缓冲区开始的，它需要知道缓冲区的布局，这个缓冲区包含的浮点数指定了每个顶点的位置、纹理坐标、法线之类的。</p><h4 id="代码实践-1"><a href="#代码实践-1" class="headerlink" title="代码实践"></a>代码实践</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在我继续之前想先定义顶点是什么意思，因为人们在错误的使用这个词。</p><p>顶点与位置无关，顶点就是几何图形上的一个点。大多数人在视觉上对它们的明显印象是通过它的位置，所以如果我给你画一个三角形，你会看到三个顶点。但顶点不是位置，一个顶点可以不仅仅包含一个位置，顶点可以包含位置更多的数据例如纹理坐标、法线、颜色等等，它们可能都在一个顶点。所以我们需要告诉 OpenGL 外面的数据布局，调用 <code>glVertexAttribPointer()</code> 函数。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/6aOZAB.jpg"></p><ul><li><p><code>index</code>：Specifies the index of the generic vertex attribute to be modified.</p><p>基本上我们的着色器读取所有这些的方式是通过索引。一般来说如果我们有一个位置在索引 0 处，我们需要把它作为索引 0 来引用；而当我们有三种属性，我想让我的位置在下标 0，纹理坐标在索引 1，法线在索引 2.所以当我开始从着色器和显卡读取数据时，然后进入那个缓冲区，我可以简单地引用它们。这就是索引，它只是缓冲区实际属性的索引。</p></li><li><p><code>size</code>：Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant <code>GL_BGRA</code> is accepted by <code>glVertexAttribPointer</code>. The initial value is 4.</p><p>这里的 <code>size</code> 可能有点误导人，它是每个通用顶点属性的组件数，只能是 1，2，3，4。所以这个 <code>size</code> 和字节没有关系，和它们实际占用了多少内存也没关系。在本例中每个顶点的坐标有 x 和 y 两组分量，所以 <code>size</code> 为 2。</p></li><li><p><code>type</code>：Specifies the data type of each component in the array. The symbolic constants <code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>, <code>GL_UNSIGNED_SHORT</code>, <code>GL_INT</code>, and <code>GL_UNSIGNED_INT</code> are accepted by <code>glVertexAttribPointer</code> and <code>glVertexAttribIPointer</code>. Additionally <code>GL_HALF_FLOAT</code>, <code>GL_FLOAT</code>, <code>GL_DOUBLE</code>, <code>GL_FIXED</code>, <code>GL_INT_2_10_10_10_REV</code>, <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> and <code>GL_UNSIGNED_INT_10F_11F_11F_REV</code> are accepted by <code>glVertexAttribPointer</code>. <code>GL_DOUBLE</code> is also accepted by <code>glVertexAttribLPointer</code> and is the only token accepted by the <em><code>type</code></em> parameter for that function. The initial value is <code>GL_FLOAT</code>.</p><p>这里是我们指定数据类型 <code>type</code>，在本例中则是位置的浮点类型 <code>GL_FLOAT</code>。</p></li><li><p><code>normalized</code>：For <code>glVertexAttribPointer</code>, specifies whether fixed-point data values should be normalized (<code>GL_TRUE</code>) or converted directly as fixed-point values (<code>GL_FALSE</code>) when they are accessed.</p><p>标准化其实不用太担心，如果我们处理的是浮点数，因为它们已经被规范化了。假设我们要指定一个颜色字节在 0 到 255 之间，它在我们的实际着色器作为一个浮点数需要被规范化到 0 到 1 之间，这不是一个你可以在 CPU 上做的事情，但你可以让 OpenGL 替你做。</p></li><li><p><code>stride</code>：Specifies the byte offset between consecutive generic vertex attributes. If <em><code>stride</code></em> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</p><p><code>stride</code> 指针会让很多人感到困惑，如文档所示它就是连续通用顶点属性之间的字节偏移量，也可以理解为每个顶点之间的字节数。举个例子我们有位置 <code>vec3</code>、纹理坐标 <code>vec2</code> 和法线 <code>vec3</code>，那么我们的 stride 就是 3 * 4 + 2 * 4 + 3 * 4 = 32 字节，它是每个顶点的字节大小。</p><p>如果我们想从一个顶点跳到下一个顶点，我需要在缓冲区中加上 32 个字节。所以如果我们有一个指针指向缓冲区的开始，然后经过缓冲区的 32 个字节，我应该在下一个顶点的起点，这就是 stride。</p></li><li><p><code>pointer</code>:Specifies an offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the <code>GL_ARRAY_BUFFER</code> target. The initial value is 0.</p><p><code>pointer</code> 文档的表述上第一个组件的一个偏移量，它是指向实际属性的指针。不要管有多少个顶点，聚焦于一个顶点，里面包含位置、纹理坐标和法线。对于位置偏移量为 0，因为它是缓冲区的第一个字节；然后我们前进 12 个字节到达纹理坐标，所以对于我的纹理坐标属性这个值（pointer）是 12；最后再前进 8 字节得到顶点的法线，所以对于顶点法线属性 20 是这个 pointer 的值。</p></li></ul><p>最后别忘了调用 <code>glEnableVertexAttribArray()</code> 去启用 <code>glVertexAttribPointer()</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p>这两段代码告诉 OpenGL 缓冲区的布局是什么，理论上如果有一个着色器就可以看到在屏幕上看到三角形了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">            <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">             <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">             <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/yW5FoQ.jpg"></p><h3 id="OpenGL中着色器的原理"><a href="#OpenGL中着色器的原理" class="headerlink" title="OpenGL中着色器的原理"></a>OpenGL中着色器的原理</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=6&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们讨论的都是关于着色器。</p><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>每个新手脑海里的第一个问题是什么是着色器？</p><p>着色器就是一个运行在显卡上的程序代码，它是我们可以在计算机上以文本或者字符串形式编写的代码，然后我们可以把它给 OpenGL 发到显卡上像其他程序一样编译链接，最后运行它，不同的是它是在我们的显卡上运行而不是 C++ 那样在我们的 CPU 上。那么为什么我们需要程序完全在显卡上运行呢？</p><p>究其原因是我们希望能够告诉显卡该做些什么，显卡处理图形的速度要快得多，我们想要利用显卡的能力在屏幕上绘制图形。这并不意味着所有的工作必须在显卡上完成，CPU 有自己擅长的部分，也许之后我们可以将结果数据发送给显卡同时仍然在 CPU 上进行处理。</p><h4 id="着色器类型"><a href="#着色器类型" class="headerlink" title="着色器类型"></a>着色器类型</h4><p>对于大多数图形编程，我们会把重点放在两种着色器：顶点着色器和片段着色器（又称像素着色器）。</p><p>虽然还没有正式讲过标准图形渲染管线，但是我们应该对它大致是如何工作的应该了解：我们在 CPU 上写了一堆数据，向显卡发送这些数据并且发出一个叫做 DrawCall 指令的东西，也绑定了某些状态，最后我们进入了着色器阶段，GPU 实际处理 DrawCall 指令并在屏幕上绘制一些东西。这个特定的过程基本上就是渲染管道，我们如何在屏幕上从数据到结果的。</p><p>现在当显卡开始绘制三角形时，着色器就派上用场了。顶点着色器和片段着色器是渲染管线两种不同的着色器类型，所以当我们真正发出 DrawCall 指令时，顶点着色器会被调用，然后片段着色器会被调用，最后我们会在屏幕上看到结果。</p><br><h5 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h5><p>那么顶点着色器是做什么的？</p><p>它会被我们渲染的每个顶点调用，在这个例子中我们有一个三角形三个顶点，这意味着顶点着色器会被调用三次，每个顶点调用一次。顶点着色器的主要目的是告诉 OpenGL 你希望这个顶点在屏幕空间的什么位置。再强调一次，顶点着色器的主要目的是提供那些顶点的位置，如果有必要我们需要能够提供一些变换以便 OpenGL 能把这些数字转化成屏幕坐标，这样我们就能在窗口中看到我们的图形在对的位置。</p><h5 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h5><p>一旦顶点着色器运行结束，我们就进入了管道的下一个阶段：片段着色器或者像素着色器。</p><p>虽然片段和像素在术语上有点小差别，但现在你可以把像素当成片段或者把片段想象成像素，因为片段着色器会为每个需要光栅化的像素运行一次。我们的窗口基本上是由像素组成的，我们指定的那三个顶点组成我们的三角形现在需要用实际的像素填充，这就是光栅化阶段所做的。</p><p>片段着色器或像素着色器就是对三角形中需要填充的每个像素调用一次，主要决定这个像素是什么颜色，这就是它的作用，它决定了像素的输出颜色，这样像素就可以用正确的颜色着色。形象一点可以把它想象成一本涂色本，当你只有东西的轮廓时需要给它上色，这就是片段着色器的职责。</p><br><p>相比于顶点着色器，片段着色器里面的东西代价要高得多，因为它会为每个像素运行。</p><p>话虽如此，有些东西显然需要按像素计算例如光源。如果你在计算光源，每个像素都有一个颜色值，这个值是由很多东西决定：光源、环境、纹理、提供给表面的材质……所有这些一起来确定一个特定像素的正确颜色。显然这取决于一些输入，例如相机的位置在哪里，而这些所有的东西结束后你在片段着色器中的决定仅仅是单个像素的颜色，这就是片段着色器的作用。</p><h3 id="OpenGL中写一个着色器"><a href="#OpenGL中写一个着色器" class="headerlink" title="OpenGL中写一个着色器"></a>OpenGL中写一个着色器</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=7&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>让我们开始写一些着色器代码吧。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先创建一个 <code>CreateShader()</code> 创建着色器函数，传入两个着色器字符串，这些字符串都是实际的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>和创建缓冲区一致，我们需要返回一个整型作为标识符，当我们想绑定的时候可以绑定那个缓冲区 id。</p><p>所以我们要做的第一件事就是创建一个程序，基本上我们只需要输入 <code>glCreateProgram()</code>，该函数不需要传入整数引用之类的东西，它会返回一个无符号的整数（顺带一提，这里和后面不使用 OpenGL 自带类型的原因是个人处理多种类型的图形 API，更倾向于 C++ 类型）：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br></pre></td></tr></tbody></table></figure><p>接下来我们需要做的是创建我们的两个着色器对象：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br></pre></td></tr></tbody></table></figure><p>考虑到这个工作在今后的复用性，可以另创建一个函数 <code>CompileShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后可以加一个初始化函数，查找字符串中的第一个字符然后返回它的内存地址：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// const char* src = &amp;source[0];</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br></pre></td></tr></tbody></table></figure><p>最后就是调用 <code>glShaderSource()</code> 和 <code>glCompileShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到 <code>CreateShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个过程很像 C++编译中将两个不同的文件链接在一起，以便可以同时使用它们：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="built_in">glValidateProgram</span>(program);</span><br></pre></td></tr></tbody></table></figure><p>最后我们实际上现在可以删了我们的着色器，因为它们已经被链接到一个程序中，所以我们可以删除这些中间文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fs);</span><br></pre></td></tr></tbody></table></figure><p>最终我们的函数源码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>让我们快速做一下这个错误处理。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译着色器实际上不会返回任何东西，所以如果任何东西出错我们无法检索找出问题。但我们可以通过调用 <code>glGetShaderiv()</code> 实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br></pre></td></tr></tbody></table></figure><p>判断 <code>result</code>，检索错误信息的长度并输出信息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to complie "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="着色器编写"><a href="#着色器编写" class="headerlink" title="着色器编写"></a>着色器编写</h4><p>首先 <code>#version 330 core</code> 意味着我们将使用 GLSL（OpenGL 的着色器），其次指定位置和颜色：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line">std::string vertexShader = R"(</span><br><span class="line">    <span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">gl_Position</span> = position;</span><br><span class="line">    }</span><br><span class="line">)";</span><br><span class="line"></span><br><span class="line">std::string fragmentShader = R"(</span><br><span class="line">    <span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()</span><br><span class="line">    {</span><br><span class="line">        color = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    }</span><br><span class="line">)";</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span>(result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">" shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Window"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    };</span><br><span class="line">  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    std::string vertexShader =</span><br><span class="line">    <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"layout(location = 0) in vec4 position;\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"{\n"</span></span><br><span class="line">    <span class="string">"   glPosition = position;\n"</span></span><br><span class="line">    <span class="string">"}\n"</span>;</span><br><span class="line">  </span><br><span class="line">    std::string fragmentShader =</span><br><span class="line">    <span class="string">"#version 450 core\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"layout(location = 0) out vec4 colour;\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"{\n"</span></span><br><span class="line">    <span class="string">"   colour = vec4(1.0, 0.0, 0.0, 1.0);\n"</span></span><br><span class="line">    <span class="string">"}\n"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="整理错误"><a href="#整理错误" class="headerlink" title="整理错误"></a>整理错误</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Failed to compile vertex shader!</span><br><span class="line">ERROR: 0:1: '' :  version '330' is not supported</span><br><span class="line">ERROR: 0:1: '' : syntax error: #version</span><br><span class="line">ERROR: 0:3: 'layout' : syntax error: syntax error</span><br><span class="line"></span><br><span class="line">Failed to compile fragment shader!</span><br><span class="line">ERROR: 0:1: '' :  version '450' is not supported</span><br><span class="line">ERROR: 0:1: '' : syntax error: #version</span><br><span class="line">ERROR: 0:3: 'layout' : syntax error: syntax error</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/Kc02rp.jpg"></p><p>在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/62990972/why-is-opengl-giving-me-the-error-error-01-version-330-is-not-support">stackoverflow</a> 有人遇到了相同的问题，解决方法如下：</p><ol><li>add these line of code in front of <code>glCreateWindow</code></li><li>add VAO as @Ali ASkari memtion above (Modern OpenGL requires a VAO be defined and bound if you are using the core profile.)</li></ol><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// GLEW</span><br><span class="line">#include &lt;glew.h&gt;</span><br><span class="line"></span><br><span class="line">// GLFW</span><br><span class="line">#include &lt;glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">static unsigned int CompileShader(unsigned int type, const std::string&amp; source)</span><br><span class="line">{</span><br><span class="line">    unsigned int id = glCreateShader(type);</span><br><span class="line">    const char* src = source.c_str();</span><br><span class="line">    glShaderSource(id, 1, &amp;src, nullptr);</span><br><span class="line">    glCompileShader(id);</span><br><span class="line"></span><br><span class="line">    // TODO: Error handling</span><br><span class="line">    int result;</span><br><span class="line">    glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    if (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        int length;</span><br><span class="line">        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">        char* message = (char*)alloca(length * sizeof(char));</span><br><span class="line">        glGetShaderInfoLog(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "Failed to complie " &lt;&lt; (type == GL_VERTEX_SHADER ? "vertex" : "fragment") &lt;&lt; "shader!" &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        glDeleteShader(id);</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">static unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader)</span><br><span class="line">{</span><br><span class="line">    unsigned int program = glCreateProgram();</span><br><span class="line">    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    glAttachShader(program, vs);</span><br><span class="line">    glAttachShader(program, fs);</span><br><span class="line">    glLinkProgram(program);</span><br><span class="line">    glValidateProgram(program);</span><br><span class="line"></span><br><span class="line">    glDeleteShader(vs);</span><br><span class="line">    glDeleteShader(fs);</span><br><span class="line"></span><br><span class="line">    return program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    /* Initialize the library */</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">    if(!glfwInit())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span></span><br><span class="line"><span class="addition">+   #ifdef __APPLE__</span></span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; "I'm apple machine" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+       glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line"><span class="addition">+   #endif</span></span><br><span class="line">    unsigned int width = 800;</span><br><span class="line">    unsigned int height = 600;</span><br><span class="line">    /* Create a Windowed mode and its OpenGL context */</span><br><span class="line">    window = glfwCreateWindow(width, height, "Hello World", NULL, NULL);</span><br><span class="line">    if(!window)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; " can't create window!!!" &lt;&lt; std::endl;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    unsigned int major = glfwGetWindowAttrib(window, GLFW_CONTEXT_VERSION_MAJOR);</span><br><span class="line">    unsigned int minor = glfwGetWindowAttrib(window, GLFW_CONTEXT_VERSION_MINOR);</span><br><span class="line">    std::cout &lt;&lt; "opengl shader version: " &lt;&lt; major &lt;&lt; "." &lt;&lt; minor &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    /* Make the window's context current */</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(glewInit() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    float positions[6] = {</span><br><span class="line">            -0.5f, -0.5f,</span><br><span class="line">             0.0f,  0.5f,</span><br><span class="line">             0.5f, -0.5f</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="addition">+   unsigned int VBO, VAO;</span></span><br><span class="line"><span class="addition">+   glGenBuffers(1, &amp;VBO);</span></span><br><span class="line"><span class="addition">+   glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="addition">+   glBindVertexArray(VAO);</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glEnableVertexAttribArray(0);</span><br><span class="line">    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);</span><br><span class="line"></span><br><span class="line">    std::string vertexShader = R"(</span><br><span class="line">        #version 330 core</span><br><span class="line"></span><br><span class="line">        layout(location = 0) in vec4 position;</span><br><span class="line"></span><br><span class="line">        void main()</span><br><span class="line">        {</span><br><span class="line">            gl_Position = position;</span><br><span class="line">        }</span><br><span class="line">    )";</span><br><span class="line"></span><br><span class="line">    std::string fragmentShader = R"(</span><br><span class="line">        #version 330 core</span><br><span class="line"></span><br><span class="line">        layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line">        void main()</span><br><span class="line">        {</span><br><span class="line">            color = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">        }</span><br><span class="line">    )";</span><br><span class="line"></span><br><span class="line">    unsigned int shader = CreateShader(vertexShader, fragmentShader);</span><br><span class="line">    glUseProgram(shader);</span><br><span class="line"></span><br><span class="line">    /* Loop until the user closes the window */</span><br><span class="line">    while(!glfwWindowShouldClose(window))</span><br><span class="line">    {</span><br><span class="line">        /* Render here */</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line"></span><br><span class="line">        /* Swap front and back buffers */</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        /* Poll for and events */</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="addition">+   glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line">    glDeleteProgram(shader);</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/Pw7Ynd.jpg"></p><h3 id="OpenGL中如何处理着色器"><a href="#OpenGL中如何处理着色器" class="headerlink" title="OpenGL中如何处理着色器"></a>OpenGL中如何处理着色器</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=8&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>个人习惯将两个着色器合并到一个只有顶点和片段着色器的文件中。不管怎样，让我们进入代码展示这一切的原理。</p><h4 id="着色器合并"><a href="#着色器合并" class="headerlink" title="着色器合并"></a>着色器合并</h4><p>首先我们实际上要做的是创建一个包含这两个着色器的文件，以便我们了解是如何处理它们的。</p><p>在项目目录中创建一个放置资源的 <code>res</code> 文件夹，在该文件夹下创建专门放置着色器的 <code>shaders</code> 文件夹，在之后我们可能会有像纹理之类的其他资源。最后在 <code>shaders/</code> 下新建文件 <code>Basic.shader</code>：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/eQxGQ8.jpg"></p><p>现在我们有了一个着色器文本，你可以看到它没有显示 C++ 图标，这非常重要因为我们不想把它编译成 C++ 代码。将之前的着色器代码复制粘贴到文件中：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">gl_Position</span> = position;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment  </span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    color = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们就无需在两个不同的着色器文件之间切换，并且很简单干净有条理。</p><h4 id="着色器读取与使用"><a href="#着色器读取与使用" class="headerlink" title="着色器读取与使用"></a>着色器读取与使用</h4><p>下面我们要做的就是读取这个文件，然后把它分成两块字符串，一个是我们的片段着色器，而另一个就是我们的顶点着色器源码。引入头文件 <code>#include&lt;fstream&gt;</code>，打开文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::fstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以现在我们需要做的就是一行一行地浏览那个文件，然后只去检查是否是指定的着色器类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">            <span class="comment">// set mode to vertex</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>添加着色器类型并在分支设定正确的类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">    NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">            type = ShaderType::VERTEX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">            type = ShaderType::FRAGMENT;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">	{</span><br><span class="line">		NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	std::string line;</span><br><span class="line">	std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">	ShaderType type = ShaderType::NONE;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::VERTEX;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::FRAGMENT;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">		<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">	<span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">	<span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">	<span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">			<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">			 <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">			 <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">	<span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 Mac 出现的各种错误太多了，相同代码跑不通太浪费时间了，所以还是转到了 Windows 上：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/yJD0q1.jpg"></p><h3 id="OpenGL中的索引缓冲区"><a href="#OpenGL中的索引缓冲区" class="headerlink" title="OpenGL中的索引缓冲区"></a>OpenGL中的索引缓冲区</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=9&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们会讨论索引缓冲区。</p><h4 id="绘制四边形"><a href="#绘制四边形" class="headerlink" title="绘制四边形"></a>绘制四边形</h4><p>在我们讨论索引缓冲区为什么用它以及它到底是什么之前，让我们先考虑一个图形编程的基础的问题：去画一个正方形。</p><p>显然我们可以通过拼接两个三角形实现，先画出来第一个三角形：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/0vR4BK.jpg"></p><p>回到我们的代码增加另一个三角形的三个顶点（其中两个顶点与第一个三角形重合）：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+float positions[12] = {</span></span><br><span class="line">    -0.5f, -0.5f,</span><br><span class="line">     0.5f, -0.5f,</span><br><span class="line">     0.5f,  0.5f,</span><br><span class="line"></span><br><span class="line"><span class="addition">+    0.5f,  0.5f,</span></span><br><span class="line"><span class="addition">+   -0.5f,  0.5f,</span></span><br><span class="line"><span class="addition">+   -0.5f, -0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>同时更改一下缓冲区的设置：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">unsigned int buffer;</span><br><span class="line">glGenBuffers(1, &amp;buffer);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="addition">+glBufferData(GL_ARRAY_BUFFER, 6 * 2 * sizeof(float), positions, GL_STATIC_DRAW);</span></span><br></pre></td></tr></tbody></table></figure><p>由于我们绘制的是六个顶点，所以这里也要改：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/3huSYC.jpg"></p><p>这里不是正方形的原因是因为窗口原因。</p><p>很酷！我们已经画出了一个正方形，它并不太难，但是绘制这个正方形的方式有些东西不太理想：我们的两个顶点是完全一样的，也就是在复制我们的内存，我们在显存中存储相同顶点的相同字节，存储了多次。因为显存并不是无限的，而我们想要降低它的内存使用。</p><h4 id="索引缓冲区"><a href="#索引缓冲区" class="headerlink" title="索引缓冲区"></a>索引缓冲区</h4><p>所以我们能做的就是使用一个叫做索引缓冲区的东西，这允许我们重用现有的顶点。对于矩形或者正方形而言可能还好，它看起来可能并不浪费，因为它没有太多的东西。然而当它换成游戏中的 3D 模型如宇宙飞船，每一个组成那个飞船的独立三角形会被连接到另一个三角形，这意味着你已经立马重复了至少两个顶点，每个顶点再包含法线、切线、纹理坐标的数据，那么你不得不复制整个缓冲区，它一次又一次地构成了那个实际的顶点，那是完全不现实的。</p><p>让我们来转换一下这种顶点缓冲，添加一个索引缓冲区并删除那些重复的冗余内存。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着创建一个无符号整型数组 <code>indices</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 0</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 1</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>,	<span class="comment">// 2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>	<span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这实际就是一个索引缓冲区，我们需要说明 OpenGL 如何去渲染这个三角形或者正方形，而不是给它提供冗余或重复的顶点位置。在这个例子中我们只有位置，但实际应用中可能会有更多的数据。</p><p>现在我们需要把它们发送到显卡上，并且告诉 OpenGL 用它们去渲染。而我们实现的方式非常类似于创建顶点缓冲区：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure><p><code>ibo</code> 代表索引缓冲区对象，表示这个特定的索引缓冲区。这里唯一的区别是把 <code>GL_ARRAY_BUFFER</code> 换为 <code>GL_ELEMENT_ARRAY_BUFFER</code>，<code>positions</code> 替换为之前的 <code>indices</code>。</p><p>需要说明一下我们会在所有这些例子中使用 <code>unsigned int</code>，因为在这种情况下不会有任何的性能差异，这里的关键是必须使用无符号类型。</p><br><p>最后需要改变的是我们的 DrawCall：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line"><span class="addition">+glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</span></span><br></pre></td></tr></tbody></table></figure><p><code>count</code> 就是我们需要绘制的 6 个索引，绘制索引的数量而非我们绘制顶点的数量；<code>type</code> 就是在索引缓冲区中的数据类型，在本例中是 <code>GL_UNSIGNED_INT</code>；最后是指向那个索引缓冲区的指针，而前面我们已经绑定了 <code>ibo</code>，所以这里可以填 <code>nullptr</code>。这就是我们绘制三角形的实际 DrawCall 指令。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/o35r1Y.jpg"></p><p>运行程序，你可以看到我们得到了一个漂亮的矩形。</p><p>我们已经删除了任何重复的顶点，在顶点缓冲区中得到了完全唯一的顶点，之后创建了一个索引以便多次绘制顶点；然后我们用 <code>ibo</code> 绑定代码把索引缓冲区发送给显卡；最终我们使用 <code>glDrawElements()</code> 绘制图形。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">	{</span><br><span class="line">		NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	std::string line;</span><br><span class="line">	std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">	ShaderType type = ShaderType::NONE;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::VERTEX;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::FRAGMENT;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">		<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">	<span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">	<span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">	<span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> positions[] = {</span><br><span class="line">			<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 0</span></span><br><span class="line">			 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 1</span></span><br><span class="line">			 <span class="number">0.5f</span>,  <span class="number">0.5f</span>,	<span class="comment">// 2</span></span><br><span class="line">			<span class="number">-0.5f</span>,  <span class="number">0.5f</span>		<span class="comment">// 3</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">		<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">	<span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenGL中处理错误"><a href="#OpenGL中处理错误" class="headerlink" title="OpenGL中处理错误"></a>OpenGL中处理错误</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=10&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们要讨论的都是错误，我们怎么知道我们做错了什么以及如何尽快地调试并修复它。</p><h4 id="glGetError"><a href="#glGetError" class="headerlink" title="glGetError"></a>glGetError</h4><p>我们有两种主要的方式来检查 OpenGL 中的错误，其中一个一个叫做 <code>glGetError()</code>，它是一个我们可以调用的 OpenGL 内置函数。它能够兼容所有版本并且原理相对简单：在我们调用 OpenGL 时如果发生错误，内存中有一个标志会被内部设置，其会说明发生了什么类型的错误，并且当我们调用 <code>glGetError()</code> 时它会返回一个标志（或者说错误码）。如果我们继续调用 <code>glGetError()</code> 它会把所有标志返回给我们，因为我们可能会产生多个类型的错误。</p><br><p>回到上次渲染正方形的代码，我们可以更改索引缓冲区类型导致错误：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</span></span><br><span class="line"><span class="addition">+glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/JPc6wC.jpg"></p><p>可以看到小小的改动得到的就是黑屏，我们的矩形根本没有渲染，这太糟糕了。</p><h4 id="glDebugMessageCallback"><a href="#glDebugMessageCallback" class="headerlink" title="glDebugMessageCallback"></a>glDebugMessageCallback</h4><p>在最近的 OpenGL 4.3 中添加了一个新的函数 <code>glDebugMessageCallback()</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/gh0Yuv.jpg"></p><p>查阅文档，可以发现它允许我们指定一个指向 OpenGL 的函数指针，当错误发生时 OpenGL 会调用我们的那个函数。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/2wm6Fo.jpg"></p><p>唯一的问题在于兼容性，它只在 4.3 及以上版本，所以你不能再早期版本中使用它。优点也很明显，它不会仅仅给你一个错误码，会提供更详细的信息。根据我的经验， <code>glDebugMessageCallback()</code> 总体上非常好，比 <code>glGetError()</code> 好得多。但今天我们只讨论 <code>glGetError()</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/00vAdR.jpg"></p><p>可以创建一个循环调用的报错函数 <code>GLClearError()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// while (glGetError() != GL_NO_ERROR);</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glGetError</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来创建另一个打印出实际错误的函数 <code>GLCheckError()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在让我们调用一下刚才的函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+GLClearError();</span></span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span><br><span class="line"><span class="addition">+GLCheckError();</span></span><br></pre></td></tr></tbody></table></figure><p>首先排除其他的错误，相当于调试的断言。通过这样的方式我们可以确保所有的错误实际上都是来自这个函数。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/CdVZjC.jpg"></p><p>可以看到错误代码是 1280。在源码中搜索 1280 找不到任何东西，因为 OpenGL 采用的是十六进制表示错误码。所以我们可以换为十六进制：0x0500。再返回 <code>&lt;glew.h&gt;</code> 文件检索：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL_INVALID_ENUM 0x0500</span></span><br></pre></td></tr></tbody></table></figure><p>500 意味着无效的枚举，而 <code>GL_INT</code>确实是我们实际传递的无效枚举，它应该是无符号整型。</p><p>实际上 <code>glClearError()</code> 和 <code>glCheckError()</code> 还是比较笨重，并且让扩展变得更加困难。但我们实际上可以做的就是得到实际的调试器，暂时执行并在导致错误的代码行上中断。我们可以通过使用断言来实现这一点，如果那个条件是 false，你通常要么将消息写入控制台，要么只是停止程序的执行并且在那行中断。</p><p>为此我需要修改 <code>GLCheckError()</code> 变为 <code>GLLogCall()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着在头文件下面定义宏断言：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  ASSERT(x) <span class="keyword">if</span> (!(x))   __debugbreak();</span></span><br></pre></td></tr></tbody></table></figure><p>这是 MSVC 特有的，在 clang、gcc 或者其他编译器中都不起作用。最后插入断言：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">GLClearError();</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span><br><span class="line"><span class="deletion">-GLCheckError();</span></span><br><span class="line"><span class="addition">+ASSERT(GLLogCall());</span></span><br></pre></td></tr></tbody></table></figure><p>为了方便起见定义宏 <code>GLCall()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError(); x; ASSERT(GLLogCall())</span></span><br></pre></td></tr></tbody></table></figure><p>更改调用：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/e6c9d24egy1h2lt68j6klj211x0kiq6s-20220526221235055.jpg"></p><p>最后加一些调试信息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError();  x;  ASSERT(GLLogCall(#x, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">"): "</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">" "</span> &lt;&lt; file &lt;&lt; <span class="string">":"</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/EKV7FE.jpg"></p><h3 id="OpenGL中的统一变量"><a href="#OpenGL中的统一变量" class="headerlink" title="OpenGL中的统一变量"></a>OpenGL中的统一变量</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=11&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们要讨论的是统一变量。</p><p>那么首先统一变量是一个非常单一的概念，它对于我们而言实际上是一种从 CPU 端获取数据的方式。在本例中是从 C++ 到我们的着色器，所以我们实际上把它当一个变量使用。</p><h4 id="颜色变量"><a href="#颜色变量" class="headerlink" title="颜色变量"></a>颜色变量</h4><p>回到着色器我们创建一个 <code>u_Color</code> 并赋值：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="addition">+uniform vec4 u_Color;</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line"><span class="deletion">-   color = vec4(0.0, 0.2, 0.8, 1.0);</span></span><br><span class="line"><span class="addition">+   color = u_Color;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每个统一变量都有一个 id，这样我们就可以引用它了。而我们查找 id 的方式通常是通过它的名称，所以我们基本上就是问我们的着色器 <code>u_Color</code> 变量的位置。</p><p>在更现代的 OpenGL 版本，你实际上可以设置和索引。所以从 4.3 开始你可以指定一个明确的统一变量位置，这是一种非常现代的新功能。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	ShaderProgramSource source = ParseShader("res/shader/basic.shader");</span><br><span class="line">	unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);</span><br><span class="line">	GLCall(glUseProgram(shader));</span><br><span class="line"></span><br><span class="line"><span class="addition">+	GLCall(int location = glGetUniformLocation(shader, "u_Color"));</span></span><br><span class="line"><span class="addition">+	ASSERT(location != -1);</span></span><br><span class="line"><span class="addition">+	GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line"></span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		......</span><br></pre></td></tr></tbody></table></figure><p>总结一下，我通过使用实际的着色器 id 编写 <code>glUseProgram()</code> 绑定着色器，获取这个颜色变量的实际位置。而当我获取那个位置的时候，就调用 <code>glUniform4f()</code> 在着色器中设置我的数据。如果一切顺利，我应该将这个颜色值写入我的矩形每个像素的实际输出颜色：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/zZJOiw.jpg"></p><p>可以看到我们得到了与之前完全相同的结果，为了区分明显一点修改颜色：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line"><span class="addition">+GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/GiuTRy.jpg"></p><h4 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h4><p>好了，那么现在做点更令人兴奋的事情吧：让我们这个颜色动起来并且在渲染循环中随时间改变它。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+	float r = 0.0f;</span></span><br><span class="line"><span class="addition">+	float increment = 0.05f;</span></span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line"><span class="addition">+		GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line">		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span><br><span class="line"></span><br><span class="line"><span class="addition">+		if (r &gt; 1.0f)</span></span><br><span class="line"><span class="addition">+			increment = -0.05f;</span></span><br><span class="line"><span class="addition">+		else if (r &lt; 0.0f)</span></span><br><span class="line"><span class="addition">+			increment = 0.05f;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		r += increment;</span></span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	GLCall(glDeleteProgram(shader));</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行程序会发现颜色变化比较快，因为我们没有限制帧率：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"><span class="addition">+	glfwSwapInterval(1);</span></span><br></pre></td></tr></tbody></table></figure><p>该设置可以同步我们主频的帧率，得到更平滑的动画。</p><h3 id="OpenGL中的顶点数组"><a href="#OpenGL中的顶点数组" class="headerlink" title="OpenGL中的顶点数组"></a>OpenGL中的顶点数组</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=12&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们会讲 OpenGL 的顶点数组。</p><h4 id="顶点数组"><a href="#顶点数组" class="headerlink" title="顶点数组"></a>顶点数组</h4><p>我们讲了很多 OpenGL 的基本概念甚至一般的图形编程，但 OpenGL 实际上有一个顶点数组。乍一看你可能会说顶点数组、顶点缓冲区它们之间的区别是什么，它们听起来非常相似。确实如此，并且这并不是 DirectX 等其他渲染接口中真正存在的东西，它是 OpenGL 独有的，也可以说是 OpenGL 的一个原始接口。它们基本上是一种通过特定的规范绑定顶点缓冲区的方式，用于实际顶点缓冲区的布局。</p><p>在我们的代码中，我们创建了 <code>buffer</code> 包含所有的顶点数据，然后创建缓冲区之后也做了绑定，启用了顶点属性指定实际数据的布局。现在一个顶点数组对象允许我们通过 <code>glVertexAttribArray()</code> 绑定指定的顶点规范到实际的顶点缓冲区，可能对于 OpenGL 的初学者比较难以理解，如果屏幕上有多个对象、多个网格、多个顶点缓冲区，需要我们绑定顶点和索引缓冲区，然后绘制实际的对象。</p><p>但我们绑定顶点缓冲区之后，我们实际也需要指定布局，让我们看看解绑一切会发生什么：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	GLCall(int location = glGetUniformLocation(shader, "u_Color"));</span><br><span class="line">	ASSERT(location != -1);</span><br><span class="line">	GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="addition">+	GLCall(glUseProgram(0));</span></span><br><span class="line"><span class="addition">+	GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));</span></span><br><span class="line"><span class="addition">+	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));</span></span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line">	/* Loop until the user closes the window */</span><br></pre></td></tr></tbody></table></figure><p>这里我基本上解绑了所有的东西，到了绘制的时候我们需要实际上绑定我们需要的所有东西，让 DrawCall 工作以此正确渲染所有东西：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">		GLCall(glUseProgram(shader));</span><br><span class="line">		GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="addition">+		GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));</span></span><br><span class="line"><span class="addition">+		GLCall(glEnableVertexAttribArray(0));</span></span><br><span class="line"><span class="addition">+		GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span></span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure><p>我们绑定着色器，设置统一变量，绑定顶点缓冲区，设置顶点缓冲区的布局，最后绑定索引缓冲区调用 <code>glDrawElements()</code>。运行这段代码看看会发生什么：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/ZuZbei.jpg"></p><p>得到了和之前一样的结果，完美。这里值得商榷的是这里：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><p>我们是否每次都要这样做？答案是肯定的，因为如果我们用不同的布局绘制另一个对象，它们可能已经改变了。所以顶点数组对象实际上就是包含这种状态的对象，因此如果我们正确地利用顶点数组对象例如为几何体的每个部分创建不同的顶点数组对象，然后只需要绑定顶点数组对象就完事儿了，因为顶点数组对象将包含顶点缓冲区之间的绑定、布局。</p><p>因此，我们的绘制方式从绑定我们的着色器、绑定我们的顶点缓冲区、设置顶点布局、绑定我们的索引缓冲区、然后发出实际的 DrawCall 指令变为了绑定我们的着色器、<strong>绑定顶点数组</strong>、绑定索引缓冲区、最终发出实际的 DrawCall 指令。所以绑定顶点缓冲区并设置其布局变为了绑定顶点数组对象，因为它包含了我们实际需要的所有状态。</p><br><p>我需要在这里提一件事情，从技术上讲顶点数组对象是必须的，它们现在正在被使用，这就是为什么我说即使我们没有创建它们这个状态仍由顶点数组对象保持。这个东西是 OpenGL 兼容性配置文件，默认情况下兼容性配置文件实际上为我们创建了一个顶点数组对象。</p><p>然而，核心配置文件没有。所以我们实际上需要自己显式地创建一个 OpenGL 顶点数组对象，绑定它确保一切正常。如果我们正在使用核心配置文件，需要手动处理：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line"><span class="addition">+	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span></span><br><span class="line"><span class="addition">+	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span></span><br><span class="line"><span class="addition">+	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure><p>前两行确定 OpenGL 的主次版本为 3.3，后一行则设置我的 OpenGL 配置为核心配置文件 <code>GLFW_OPENGL_CORE_PROFILE</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/ehr3l7.png"></p><p>运行程序触发了断言，当我们尝试启用这个 <code>vertexAttribArray</code> 的时候没有绑定顶点数组对象，因此我们无法指定顶点属性类型的规范或者 <code>enableVertexAttribArray</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/I0TkZU.png"></p><p>那么我们需要做的就是在核心配置文件中实际创建那个 VAO，也就是顶点数组对象：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	unsigned int indices[] = {</span><br><span class="line">		0, 1, 2,</span><br><span class="line">		2, 3, 0</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line"><span class="addition">+	unsigned int vao;</span></span><br><span class="line"><span class="addition">+	GLCall(glGenVertexArrays(1, &amp;vao));</span></span><br><span class="line"><span class="addition">+	GLCall(glBindVertexArray(vao));</span></span><br><span class="line"></span><br><span class="line">	unsigned int buffer;</span><br></pre></td></tr></tbody></table></figure><p>再次运行程序不再报错，这就是我们显式地创建一个 vao。有意思的是我们甚至可以删掉部分绑定的代码，程序依然可运行：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+	GLCall(glBindVertexArray(0));</span></span><br><span class="line">	GLCall(glUseProgram(0));</span><br><span class="line">	GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));</span><br><span class="line">	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));</span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line"></span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">		GLCall(glUseProgram(shader));</span><br><span class="line">		GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="deletion">-		GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));</span></span><br><span class="line"><span class="deletion">-		GLCall(glEnableVertexAttribArray(0));</span></span><br><span class="line"><span class="deletion">-		GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+		GLCall(glBindVertexArray(vao));</span></span><br><span class="line">		GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));</span><br><span class="line"></span><br><span class="line">		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure><p>当我们绑定顶点数组和缓冲区的时候，实际上没有链接两者。但当我们指定这个 <code>vertexAttribPointer</code> 的时候，我们说的是这个顶点数组索引为 0 的位置将实际绑定到当前绑定的 <code>GL_ARRAY_BUFFER</code> 插槽。</p><h4 id="应用策略"><a href="#应用策略" class="headerlink" title="应用策略"></a>应用策略</h4><p>那么我们应该一直使用顶点数组对象吗？</p><p>答案是视情况而定。如果我们使用当前的核心配置文件，我们必须创建一个顶点数组的对象；如果我们只使用兼容性配置文件，这并不意味着没有顶点数组对象，这只意味着我们有一个默认的顶点数组对象，它被绑定并设置为供我们使用。</p><ul><li>PlanA 是技术上你可以创造一个顶点数组对象，在你整个项目过程中都把它放在一边。因此始终有一个绑定的顶点数组对象，然后你可以在绘制几何体之前绑定一个顶点缓冲区并指定一个顶点布局。</li><li>PlanB 则是对于你创建的几何体的每一块创建一个顶点数组对象，然后指定那个规范一次，你就可以启用任何你需要的 vertexAttribArray 了，可以根据需要多次指定 <code>glVertexAttribPointer()</code> 把那些都设置好。然后在执行所有这些操作之前，你将看到绑定顶点缓冲区，到了绘制的时候只需每次绘制几何体之前绑定不同的顶点数组对象、将其绑定到索引缓冲区中，就可以调用 <code>glDrawElements</code> 或者任何绘制函数。</li></ul><p>所以你可以在整个项目上有一个全局 VAO，然后每次绑定不同的缓冲区和不同的顶点规范；或者你对每个几何体都有单独的 VAO。哪一个更好，还是很难回答。</p><p>在很久之前 NVIDIA 做过研究全局 VAO 然后每次绑定一切速度更快。最近我没有做过相关的基准测试，但是我还是建议使用 VAO，OpenGL 也建议去使用它们。但这个世界很复杂，与理想情况下 VAO 的工作原理略有不同，所以我的建议是如果你真的关心性能需要从这一切中挤出最后一点性能，实际上你需要做一些测试，在你的环境中、你的平台上、你的设备中等等实际生产环境中进行尝试两种方案孰优孰劣。</p><h3 id="抽象顶点索引缓冲区成类"><a href="#抽象顶点索引缓冲区成类" class="headerlink" title="抽象顶点索引缓冲区成类"></a>抽象顶点索引缓冲区成类</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=13&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="错误处理类抽象"><a href="#错误处理类抽象" class="headerlink" title="错误处理类抽象"></a>错误处理类抽象</h4><p>新建 <code>Renderer.h</code> 和 <code>Renderer.cpp</code>，将之前的错误处理代码放到新文件中。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  ASSERT(x) <span class="keyword">if</span> (!(x))   __debugbreak();</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError();  x;  ASSERT(GLLogCall(#x, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><code>Renderer.h</code> 头文件包含了之前宏定义、断言以及函数的声明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="type">const</span> GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">"): "</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">" "</span> &lt;&lt; file &lt;&lt; <span class="string">":"</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Renderer.cpp</code> 则是函数的实现。</p><h4 id="VertexBuffer类抽象"><a href="#VertexBuffer类抽象" class="headerlink" title="VertexBuffer类抽象"></a>VertexBuffer类抽象</h4><p>同理新建 <code>VertexBuffer.h</code> 和 <code>VertexBuffer.cpp</code> 两个文件。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBuffer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> <span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">VertexBuffer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>其中 <code>Vertexbuffer.h</code> 包含一个成员变量 <code>m_RendererID</code>、构造函数、析构函数以及绑定/解绑函数的声明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line">VertexBuffer::<span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> size)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">VertexBuffer::~<span class="built_in">VertexBuffer</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="IndexBuffer类抽象"><a href="#IndexBuffer类抽象" class="headerlink" title="IndexBuffer类抽象"></a>IndexBuffer类抽象</h4><p>同理新建 <code>IndexBuffer.h</code> 和 <code>IndexBuffer.cpp</code> 两个文件。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexBuffer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count);</span><br><span class="line">    ~<span class="built_in">IndexBuffer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Count; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>Indexbuffer.h</code> 包含两个成员变量 <code>m_RendererID</code> <code>m_Count</code>、构造函数、析构函数以及绑定/解绑函数的声明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line">IndexBuffer::<span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    : <span class="built_in">m_Count</span>(count)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(GLuint))</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, count * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), data, GL_STATIC_DRAW))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">IndexBuffer::~<span class="built_in">IndexBuffer</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类"><a href="#应用类" class="headerlink" title="应用类"></a>应用类</h4><p>最终封装之后 <code>Application.cpp</code> 代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">	{</span><br><span class="line">		NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	std::string line;</span><br><span class="line">	std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">	ShaderType type = ShaderType::NONE;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::VERTEX;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::FRAGMENT;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			ss[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(type)] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glCompileShader</span>(id))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result))</span><br><span class="line">	<span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length))</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* message = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message))</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(id))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, vs))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, fs))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glLinkProgram</span>(program))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glValidateProgram</span>(program))</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(vs))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(fs))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">float</span> positions[] = {</span><br><span class="line">			<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 0</span></span><br><span class="line">			 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 1</span></span><br><span class="line">			 <span class="number">0.5f</span>,  <span class="number">0.5f</span>,	<span class="comment">// 2</span></span><br><span class="line">			<span class="number">-0.5f</span>,  <span class="number">0.5f</span>	<span class="comment">// 3</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">		<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="literal">nullptr</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">const</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader))</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="type">const</span> <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">"u_Color"</span>))</span><br><span class="line">	<span class="built_in">ASSERT</span>(location != <span class="number">-1</span>)</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>))</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(<span class="number">0</span>))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line">	<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader))</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>))</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line">		ib.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">			increment = <span class="number">-0.05f</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">			increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glDeleteProgram</span>(shader))</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenGL中的缓冲区和布局的抽象"><a href="#OpenGL中的缓冲区和布局的抽象" class="headerlink" title="OpenGL中的缓冲区和布局的抽象"></a>OpenGL中的缓冲区和布局的抽象</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=14&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>首先我们抽象顶点数组的目的是什么？</p><p>对我们来说，顶点数组需要做的是将顶点缓冲区与某种布局联系在一起，所以顶点缓冲区就是有数据的缓冲区，它们没有实际的概念比如前三个浮点数是位置，没有类型或者大小之类的概念，它只是实际数据的普通缓冲区。每个字节是什么、这些顶点有多大等等才是顶点数组真正代表的，它应该把缓冲区和实际布局联系在一起。</p><p>顶点数组对象是 OpenGL 存储那种状态的方式，那么当我们考虑创建这个接口时，我们需要做的是需要一些东西来创建一个顶点数组。</p><h4 id="顶点数组布局类"><a href="#顶点数组布局类" class="headerlink" title="顶点数组布局类"></a>顶点数组布局类</h4><p>新建顶点数组布局类 <code>VertexBufferLayout.h</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexBufferElement</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> normalized;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetSizeOfType</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> GL_FLOAT:          <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> GL_UNSIGNED_INT:   <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> GL_UNSIGNED_BYTE:  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBufferLayout</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Stride;</span><br><span class="line">    std::vector&lt;VertexBufferElement&gt; m_Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VertexBufferLayout</span>()</span><br><span class="line">        : <span class="built_in">m_Stride</span>(<span class="number">0</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// static_assert(false);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    {</span><br><span class="line">        m_Elements.<span class="built_in">push_back</span>({ GL_FLOAT, count, GL_FALSE });</span><br><span class="line">        m_Stride += count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_FLOAT);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    {</span><br><span class="line">        m_Elements.<span class="built_in">push_back</span>({ GL_UNSIGNED_INT, count, GL_FALSE });</span><br><span class="line">        m_Stride += count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_INT);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    {</span><br><span class="line">        m_Elements.<span class="built_in">push_back</span>({ GL_UNSIGNED_BYTE, count, GL_TRUE });</span><br><span class="line">        m_Stride += count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_BYTE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetStride</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Stride; }</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> std::vector&lt;VertexBufferElement&gt; <span class="title">GetElements</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Elements; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="顶点数组类抽象"><a href="#顶点数组类抽象" class="headerlink" title="顶点数组类抽象"></a>顶点数组类抽象</h4><p>新建 <code>VertexArray.h</code> 和 <code>VertexArray.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBufferLayout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexArray</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VertexArray</span>();</span><br><span class="line">    ~<span class="built_in">VertexArray</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>头文件包含了成员变量 <code>m_RendererID</code>、构造函数、析构函数、缓冲区添加函数以及绑定/解绑函数的声明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexArray.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line">VertexArray::<span class="built_in">VertexArray</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">VertexArray::~<span class="built_in">VertexArray</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">Bind</span>();</span><br><span class="line">    vb.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; elements = layout.<span class="built_in">GetElements</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; elements.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; element = elements[i];</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(i))</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(i, element.count, element.type, element.normalized, layout.<span class="built_in">GetStride</span>(), (<span class="type">const</span> <span class="type">void</span>*)offset))</span><br><span class="line"></span><br><span class="line">        offset += element.count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(element.type);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-1"><a href="#应用类-1" class="headerlink" title="应用类"></a>应用类</h4><p>最后用封装好的类替换之前 <code>Application.cpp</code> 中的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexArray.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">	{</span><br><span class="line">		NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	std::string line;</span><br><span class="line">	std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">	ShaderType type = ShaderType::NONE;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::VERTEX;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::FRAGMENT;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			ss[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(type)] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glCompileShader</span>(id))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result))</span><br><span class="line">	<span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length))</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* message = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message))</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(id))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, vs))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, fs))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glLinkProgram</span>(program))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glValidateProgram</span>(program))</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(vs))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(fs))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">constexpr</span> <span class="type">float</span> positions[] = {</span><br><span class="line">			<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 0</span></span><br><span class="line">			 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 1</span></span><br><span class="line">			 <span class="number">0.5f</span>,  <span class="number">0.5f</span>,	<span class="comment">// 2</span></span><br><span class="line">			<span class="number">-0.5f</span>,  <span class="number">0.5f</span>	<span class="comment">// 3</span></span><br><span class="line">		};</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">			<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">			<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">		};</span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao))</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line"></span><br><span class="line">		VertexArray va;</span><br><span class="line">		<span class="function"><span class="type">const</span> VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">		VertexBufferLayout layout;</span><br><span class="line">		layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">		va.<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">const</span> IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">const</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader))</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="type">const</span> <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">"u_Color"</span>))</span><br><span class="line">		<span class="built_in">ASSERT</span>(location != <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>))</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>))</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(<span class="number">0</span>))</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">		<span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">		<span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line">		<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">/* Render here */</span></span><br><span class="line">			<span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line"></span><br><span class="line">			<span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader))</span><br><span class="line">			<span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			va.<span class="built_in">Bind</span>();</span><br><span class="line">			ib.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">			<span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>))</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">				increment = <span class="number">-0.05f</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">				increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">			r += increment;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">			<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Poll for and events */</span></span><br><span class="line">			<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glDeleteProgram</span>(shader))</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenG中抽象着色器"><a href="#OpenG中抽象着色器" class="headerlink" title="OpenG中抽象着色器"></a>OpenG中抽象着色器</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=15&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>着色器需要什么？</p><p>第一步首先我们希望能够传递一个文件或者字符串，把它作为着色器来编译；第二步我们希望能够绑定和解绑着色器；第三步则是我们需要能够设置着色器中各种不同的统一变量，这可能就是我们现在正在研究的东西。</p><h4 id="着色器抽象"><a href="#着色器抽象" class="headerlink" title="着色器抽象"></a>着色器抽象</h4><p>那么，让我们开始深入重构代码吧。</p><p>新建文件 <code>Shader.h</code> 和 <code>Shader.cpp</code> 抽象着色器类。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_FilePath;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m_UniformLocationCache;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath);</span><br><span class="line">    ~<span class="built_in">Shader</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set uniforms</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Shader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line">Shader::<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath)</span><br><span class="line">    : <span class="built_in">m_FilePath</span>(filepath), <span class="built_in">m_RendererID</span>(<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="type">const</span> ShaderProgramSource source = <span class="built_in">ParseShader</span>(filepath);</span><br><span class="line">    m_RendererID = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Shader::~<span class="built_in">Shader</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteProgram</span>(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(<span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(<span class="built_in">GetUniformLocation</span>(name), v0, v1, v2, v3))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (m_UniformLocationCache.<span class="built_in">find</span>(name) != m_UniformLocationCache.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> m_UniformLocationCache[name];</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="type">const</span> <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>()))</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Warning: uniform '"</span> &lt;&lt; name &lt;&lt; <span class="string">"' doesn't exist!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ShaderProgramSource <span class="title">Shader::ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">    {</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            ss[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(type)] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glCompileShader</span>(id))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result))</span><br><span class="line">    <span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length))</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* message = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message))</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(id))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, vs))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, fs))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glLinkProgram</span>(program))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glValidateProgram</span>(program))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(vs))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(fs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-2"><a href="#应用类-2" class="headerlink" title="应用类"></a>应用类</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexArray.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Shader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">float</span> positions[] = {</span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 0</span></span><br><span class="line">		 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 1</span></span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span>,	<span class="comment">// 2</span></span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>	<span class="comment">// 3</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">		<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	<span class="function"><span class="type">const</span> VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">	va.<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">"res/shader/basic.shader"</span>)</span></span>;</span><br><span class="line">	shader.<span class="built_in">Bind</span>();</span><br><span class="line">	shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">	va.<span class="built_in">Unbind</span>();</span><br><span class="line">	shader.<span class="built_in">Unbind</span>();</span><br><span class="line">	vb.<span class="built_in">Unbind</span>();</span><br><span class="line">	ib.<span class="built_in">Unbind</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line">	<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line"></span><br><span class="line">		shader.<span class="built_in">Bind</span>();</span><br><span class="line">		shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">		va.<span class="built_in">Bind</span>();</span><br><span class="line">		ib.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">			increment = <span class="number">-0.05f</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">			increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/0vC2xI.png"></p><h3 id="OpenGL写一个基础的渲染器类"><a href="#OpenGL写一个基础的渲染器类" class="headerlink" title="OpenGL写一个基础的渲染器类"></a>OpenGL写一个基础的渲染器类</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=16&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们的目标是剔除在主文件中遗留的 OpenGL 调用。</p><p>虽然前面几节我们用 <code>VertexBuffer</code>、<code>IndexBuffer</code>、<code>VertexArray</code>、<code>Shader</code> 等类抽象 OpenGL 代码，但是还有相当一部分遗留在 <code>Application.cpp</code> 中，例如 DrawCall 指令。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "VertexArray.h"</span></span><br><span class="line"><span class="addition">+#include "IndexBuffer.h"</span></span><br><span class="line"><span class="addition">+#include "Shader.h"</span></span><br><span class="line"></span><br><span class="line">#define  ASSERT(x) if (!(x))   __debugbreak();</span><br><span class="line">#define  GLCall(x) GLClearError();  x;  ASSERT(GLLogCall(#x, __FILE__, __LINE__))</span><br><span class="line"></span><br><span class="line">void GLClearError();</span><br><span class="line">bool GLLogCall(const char* function, const char* file, int line);</span><br><span class="line"></span><br><span class="line"><span class="addition">+class Renderer</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+public:</span></span><br><span class="line"><span class="addition">+   void Clear() const;</span></span><br><span class="line"><span class="addition">+   void Draw(const VertexArray&amp; va, const IndexBuffer&amp; ib,const Shader&amp; shader) const;</span></span><br><span class="line"><span class="addition">+};</span></span><br></pre></td></tr></tbody></table></figure><p>让我们想一想，在 OpenGL 绘制一些东西我们实际需要什么。我们需要顶点数组和索引缓冲区以及着色器，顶点数组实际已经绑定了顶点缓冲区，</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Clear</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Draw</span><span class="params">(<span class="type">const</span> VertexArray&amp; va, <span class="type">const</span> IndexBuffer&amp; ib, <span class="type">const</span> Shader&amp; shader)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line">    shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    va.<span class="built_in">Bind</span>();</span><br><span class="line">    ib.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, ib.<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>复制完 <code>Application.cpp</code> 中的绑定代码后并不打算解绑。在更传统的情况下，OpenGL 中解绑不是严格必要的，它可能会减少一些 bug，但从根本上来说在 OpenGL 中解绑东西只是浪费性能，你不需要这么做，因为在我们绘制下一个东西之前我们会把这些东西都绑定起来，所以解绑没有意义。更复杂的系统可能会在调试模式下会有解绑，但暂时我们还是简单处理。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	constexpr float positions[] = {</span><br><span class="line">		-0.5f, -0.5f,	// 0</span><br><span class="line">		 0.5f, -0.5f,	// 1</span><br><span class="line">		 0.5f,  0.5f,	// 2</span><br><span class="line">		-0.5f,  0.5f	// 3</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	const unsigned int indices[] = {</span><br><span class="line">		0, 1, 2,</span><br><span class="line">		2, 3, 0</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	unsigned int vao;</span><br><span class="line">	GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">	GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 2 * sizeof(float));</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">	const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">	Shader shader("res/shader/basic.shader");</span><br><span class="line">	shader.Bind();</span><br><span class="line">	shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line">	va.Unbind();</span><br><span class="line">	shader.Unbind();</span><br><span class="line">	vb.Unbind();</span><br><span class="line">	ib.Unbind();</span><br><span class="line"></span><br><span class="line"><span class="addition">+	Renderer renderer;</span></span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line"><span class="addition">+		renderer.Clear();</span></span><br><span class="line"><span class="deletion">-		GLCall(glClear(GL_COLOR_BUFFER_BIT))</span></span><br><span class="line"></span><br><span class="line">		shader.Bind();</span><br><span class="line">		shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-		va.Bind();</span></span><br><span class="line"><span class="deletion">-		ib.Bind();</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr))</span></span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenGL中的纹理"><a href="#OpenGL中的纹理" class="headerlink" title="OpenGL中的纹理"></a>OpenGL中的纹理</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=17&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们会讨论 OpenGL 中的纹理。</p><h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><p>当大部分人想到纹理的时候，他们真的只会想到在一个游戏中的 3D 对象上呈现图像（当然不一定非得是 3D 对象）。而你们在 Ps 或画图等等中创建的图像，让它出现在你们的图形应用程序中，那就是纹理的本质，或者至少是大部分人眼中的纹理。</p><p>现在，除了这些，关于纹理的理解比我刚才描述的要多得多。纹理可以用于很多事情，当后面讲到一些非常复杂的图形技术时我们会提到，但现在我只想让你们把纹理看作当渲染时是我们可以使用的图像。那么我实际能做的就是设计或创造某种图像，不管是一张照片还是画布上一条弯弯曲曲的线亦或是纯色以及任意类似的颜色，我都可以在我的电脑中创建任何图像文件，然后把它上传到我的显存中，然后在我的着色器中使用它来绘制我现在正在做的任何东西。</p><p>这可能像在我们的 OpenGL 程序中画一个矩形一样简单，它包含了渲染纹理的元素，这样我们就可以在游戏中看到纹理。或者也可能是更复杂的东西，就像使用预先计算好的数学值将其融入到我们的纹理中，然后在着色器中对它们进行采样，这样我们可以做一些很酷的灯光效果。但现在，它只会在 OpenGL 应用中从计算机获取图像到表面。</p><h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><p>回到项目，添加 <code>res/textures/Checkerboard.png</code>：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/X8XHLg.png"></p><p>首先我们需要以某种方式将 PNG 图像加载到 CPU 内存中，可以使用 <code>stb_image</code> 库加载 PNG。我们给它一个文件路径，它会给我们一个指向 RGBA 像素缓冲区的指针；然后我们会取那个像素数组把它上传到我们的显卡；最后当它绘制时就可以修改着色器来读取那个纹理，片段着色器实际计算出每个像素应该是什么，构成那个纹理每部分的颜色是什么。</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/nothings/stb">stb</a></li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/Z8UO7K.png"></p><p>复制 <code>stb_image.h</code> 中的代码到项目的 <code>vendor/stb_images/stb_image.h</code>。新建 <code>stb_image.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stb_image.h"</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="纹理类抽象"><a href="#纹理类抽象" class="headerlink" title="纹理类抽象"></a>纹理类抽象</h4><p>新建文件 <code>Texture.h</code> 和 <code>Texture.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_FilePath;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> m_LocalBuffer;</span><br><span class="line">    <span class="type">int</span> m_Width, m_Height, m_BPP;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path);</span><br><span class="line">    ~<span class="built_in">Texture</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Width; }</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Height; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>slot</code> 就是绑定纹理的插槽。在 OpenGL 我们有各种各样的插槽可以绑定纹理，Windows 上经典的现代显卡会有 32 个纹理插槽，而在诸如安卓等移动设备上可能有八个插槽，这取决于你们的实际显卡以及它们的 OpenGL 实现。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Texture.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"vendor/stb_images/stb_image.h"</span></span></span><br><span class="line"></span><br><span class="line">Texture::<span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path)</span><br><span class="line">    : <span class="built_in">m_FilePath</span>(path), <span class="built_in">m_RendererID</span>(<span class="number">0</span>), <span class="built_in">m_LocalBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">m_Width</span>(<span class="number">0</span>), <span class="built_in">m_Height</span>(<span class="number">0</span>), <span class="built_in">m_BPP</span>(<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="number">1</span>);</span><br><span class="line">    m_LocalBuffer = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;m_Width, &amp;m_Height, &amp;m_BPP, <span class="number">4</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_RendererID))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Width, m_Height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_LocalBuffer)</span><br><span class="line">        <span class="built_in">stbi_image_free</span>(m_LocalBuffer);</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Texture::~<span class="built_in">Texture</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteTextures</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Texture::Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glActiveTexture</span>(GL_TEXTURE0 + slot))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Texture::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li><code>stbi_set_flip_vertically_on_load(1)</code> 用于垂直翻转我们的纹理，OpenGL 希望我们的纹理像素从左下角开始。</li><li><code>glTexParameteri(...)</code> 用于纹理比实际大或者小时，需要放大或者缩小</li></ul><h4 id="应用类-3"><a href="#应用类-3" class="headerlink" title="应用类"></a>应用类</h4><p>回到 <code>Application.cpp</code> 加入纹理：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBufferLayout.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexArray.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Shader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Texture.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">float</span> positions[] = {</span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,	<span class="comment">// 0</span></span><br><span class="line">		 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,	<span class="comment">// 1</span></span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,	<span class="comment">// 2</span></span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>	<span class="comment">// 3</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">		<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	<span class="function"><span class="type">const</span> VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">	layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">	va.<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">"res/shader/basic.shader"</span>)</span></span>;</span><br><span class="line">	shader.<span class="built_in">Bind</span>();</span><br><span class="line">	shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> Texture <span class="title">texture</span><span class="params">(<span class="string">"res/textures/Checkerboard.png"</span>)</span></span>;</span><br><span class="line">	texture.<span class="built_in">Bind</span>();</span><br><span class="line">	shader.<span class="built_in">SetUniform1i</span>(<span class="string">"u_Texture"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	va.<span class="built_in">Unbind</span>();</span><br><span class="line">	shader.<span class="built_in">Unbind</span>();</span><br><span class="line">	vb.<span class="built_in">Unbind</span>();</span><br><span class="line">	ib.<span class="built_in">Unbind</span>();</span><br><span class="line"></span><br><span class="line">	Renderer renderer;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line">	<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">		shader.<span class="built_in">Bind</span>();</span><br><span class="line">		shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">		renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">			increment = <span class="number">-0.05f</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">			increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意这里调用了 <code>Shader.h</code> 的新增代码：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">struct ShaderProgramSource</span><br><span class="line">{</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Shader</span><br><span class="line">{</span><br><span class="line">private:</span><br><span class="line">    std::string m_FilePath;</span><br><span class="line">    unsigned int m_RendererID;</span><br><span class="line">    std::unordered_map&lt;std::string, int&gt; m_UniformLocationCache;</span><br><span class="line">public:</span><br><span class="line">    Shader(const std::string&amp; filepath);</span><br><span class="line">    ~Shader();</span><br><span class="line"></span><br><span class="line">    void Bind() const;</span><br><span class="line">    void Unbind() const;</span><br><span class="line"></span><br><span class="line">    // Set uniforms</span><br><span class="line"><span class="addition">+   void SetUniform1i(const std::string&amp; name, int value);</span></span><br><span class="line"><span class="addition">+   void SetUniform1f(const std::string&amp; name, float value);</span></span><br><span class="line">    void SetUniform4f(const std::string&amp; name, float v0, float v1, float v2, float v3);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ShaderProgramSource ParseShader(const std::string&amp; filepath) const;</span><br><span class="line">    unsigned int CompileShader(unsigned int type, const std::string&amp; source);</span><br><span class="line">    unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader);</span><br><span class="line">  </span><br><span class="line">    int GetUniformLocation(const std::string&amp; name);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "Shader.h"</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">Shader::Shader(const std::string&amp; filepath)</span><br><span class="line">    : m_FilePath(filepath), m_RendererID(0)</span><br><span class="line">{</span><br><span class="line">    const ShaderProgramSource source = ParseShader(filepath);</span><br><span class="line">    m_RendererID = CreateShader(source.VertexSource, source.FragmentSource);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Shader::~Shader()</span><br><span class="line">{</span><br><span class="line">    GLCall(glDeleteProgram(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Shader::Bind() const</span><br><span class="line">{</span><br><span class="line">    GLCall(glUseProgram(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Shader::Unbind() const</span><br><span class="line">{</span><br><span class="line">    GLCall(glUseProgram(0))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="addition">+void Shader::SetUniform1i(const std::string&amp; name, int value)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+   GLCall(glUniform1i(GetUniformLocation(name), value))</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+void Shader::SetUniform1f(const std::string&amp; name, float value)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+   GLCall(glUniform1f(GetUniformLocation(name), value))</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">void Shader::SetUniform4f(const std::string&amp; name, float v0, float v1, float v2, float v3)</span><br><span class="line">{</span><br><span class="line">    GLCall(glUniform4f(GetUniformLocation(name), v0, v1, v2, v3))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int Shader::GetUniformLocation(const std::string&amp; name)</span><br><span class="line">{</span><br><span class="line">    if (m_UniformLocationCache.find(name) != m_UniformLocationCache.end())</span><br><span class="line">        return m_UniformLocationCache[name];</span><br><span class="line">  </span><br><span class="line">    GLCall(const int location = glGetUniformLocation(m_RendererID, name.c_str()))</span><br><span class="line">    if (location == -1)</span><br><span class="line">        std::cout &lt;&lt; "Warning: uniform '" &lt;&lt; name &lt;&lt; "' doesn't exist!" &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return location;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ShaderProgramSource Shader::ParseShader(const std::string&amp; filepath) const</span><br><span class="line">{</span><br><span class="line">    std::ifstream stream(filepath);</span><br><span class="line"></span><br><span class="line">    enum class ShaderType</span><br><span class="line">    {</span><br><span class="line">        NONE = -1, VERTEX = 0, FRAGMENT = 1</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[2];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    while (getline(stream, line))</span><br><span class="line">    {</span><br><span class="line">        if (line.find("#shader") != std::string::npos)</span><br><span class="line">        {</span><br><span class="line">            if (line.find("vertex") != std::string::npos)</span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            else if (line.find("fragment") != std::string::npos)</span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">        }</span><br><span class="line">        else</span><br><span class="line">        {</span><br><span class="line">            ss[static_cast&lt;int&gt;(type)] &lt;&lt; line &lt;&lt; '\n';</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return { ss[0].str(), ss[1].str() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned int Shader::CompileShader(unsigned int type, const std::string&amp; source)</span><br><span class="line">{</span><br><span class="line">    const unsigned int id = glCreateShader(type);</span><br><span class="line">    const char* src = source.c_str();</span><br><span class="line">    GLCall(glShaderSource(id, 1, &amp;src, nullptr))</span><br><span class="line">    GLCall(glCompileShader(id))</span><br><span class="line"></span><br><span class="line">    // TODO: Error handling</span><br><span class="line">    int result;</span><br><span class="line">    GLCall(glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result))</span><br><span class="line">    if (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        int length;</span><br><span class="line">        GLCall(glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length))</span><br><span class="line"></span><br><span class="line">        char* message = static_cast&lt;char*&gt;(malloc(length * sizeof(char)));</span><br><span class="line">        GLCall(glGetShaderInfoLog(id, length, &amp;length, message))</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "Failed to compile " &lt;&lt; (type == GL_VERTEX_SHADER ? "vertex" : "fragment") &lt;&lt; "shader!" &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        GLCall(glDeleteShader(id))</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned int Shader::CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader)</span><br><span class="line">{</span><br><span class="line">    const unsigned int program = glCreateProgram();</span><br><span class="line">    const unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    const unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    GLCall(glAttachShader(program, vs))</span><br><span class="line">    GLCall(glAttachShader(program, fs))</span><br><span class="line">    GLCall(glLinkProgram(program))</span><br><span class="line">    GLCall(glValidateProgram(program))</span><br><span class="line"></span><br><span class="line">    GLCall(glDeleteShader(vs))</span><br><span class="line">    GLCall(glDeleteShader(fs))</span><br><span class="line"></span><br><span class="line">    return program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>着色器 <code>basic.shader</code> 代码如下：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">gl_Position</span> = position;</span><br><span class="line">    v_TexCoord = texCoord;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> u_Color;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Texture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(u_Texture, v_TexCoord);</span><br><span class="line">    color = texColor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/YGUC1V.png"></p><p>最终我们把纹理图片渲染到屏幕上的一个四边形上。</p><h3 id="OpenGL中的混合"><a href="#OpenGL中的混合" class="headerlink" title="OpenGL中的混合"></a>OpenGL中的混合</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=18&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>上一期其实我们在渲染纹理时遇到了一些问题，我们启用了一个叫混合的东西，设置了一个混合函数，这就随机得到了我们的纹理：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br></pre></td></tr></tbody></table></figure><h4 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h4><p>什么是混合？为什么我们的纹理渲染一开始就不正确？</p><p>混合很简单。本质上，当我们渲染一些部分或完全透明的东西时我们会想到 Ps 降低透明度，而图形编程必须告诉电脑你真正想让它做什么，因为它不知道你们想做什么。默认情况下 OpenGL 不执行任何混合，它只需要你们渲染的东西，然后把它渲染成不透明的东西。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/vwl5Lr.png"></p><p>之前我们渲染了红色方块，在它上面我们以某种形式渲染了一个半透明的蓝色方块（不透明的蓝色方块会直接覆盖红色方块），我们期望得到这两种颜色的组合：紫色。如果我们现实生活中拿红玻璃和蓝玻璃然后把它们像这样叠在一起，我们会看到穿过的光实际上是紫色的，那就是我们用眼睛所看到的。</p><ul><li>所以混合只决定了我们如何将输出颜色与目标缓冲区中已经存在的颜色结合起来</li><li>我们的输出颜色为片段着色器中输出的颜色，也被称为 source</li><li>在这个例子中我们把它画到一个已经存在的缓冲区上，也就是我们的目标 destination：红色方块</li></ul><h4 id="混合控制"><a href="#混合控制" class="headerlink" title="混合控制"></a>混合控制</h4><p>那么我们如何控制这两种颜色混合的方式呢？ 我们在 OpenGL 在有三种不同的方法，他们做的事情非常不同：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/D87pvb.png"></p><ul><li>首先，启用和禁用 <code>glEnable(GL_BLEND)</code>、<code>glDisable(GL_BLEND)</code>，参数 <code>GL_BLEND</code>。默认情况下不会启用混合</li><li><code>glBlendFunc(src, dest)</code> 指定如何将两种颜色混合在一起（丢掉 <code>dest</code> 并用 <code>src</code> 覆盖），其中 RGB 因子将乘以所有颜色通道，所以 <code>src</code> 默认为 1 而 <code>dest</code> 默认为 0</li><li><code>glBlendEquation(mode)</code> 混合不等式，参数 <code>mode</code> 为组合方式（默认为 <code>GL_FUNC_ADD</code>）</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/si3fQb.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/yVc389.png"></p><h3 id="OpenGL中的数学"><a href="#OpenGL中的数学" class="headerlink" title="OpenGL中的数学"></a>OpenGL中的数学</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=19&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="GLM库"><a href="#GLM库" class="headerlink" title="GLM库"></a>GLM库</h4><p><a target="_blank" rel="noopener" href="https://github.com/g-truc/glm"><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/ojMTaf.png"></a></p><p>在 Release 界面下载最新的 zip 文件：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/0AXDNJ.png"></p><p>下载完毕之后将 <code>glm</code> 复制粘贴到 <code>src/vendor</code> 中。</p><p>glm 是一个只包含头文件的库，这意味着没有 cpp 文件不需要编译它，所以我们不需要链接到库直接使用。右键项目属性，在 <code>C/C++</code> 找到附加包含目录，添加 <code>src/vendor</code>。</p><h4 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h4><p>投影矩阵是我们告诉窗口的一种方式，告诉它我们想要如何将所有不同的顶点映射到它。所以我们有一个填充了顶点位置顶点缓冲区这样的概念，但是我们需要把它转换到 2D 平面，因为当我们把它绘制在笔记本电脑屏幕或电脑显示器上时需要以 2D 的方式绘制出来。</p><p>那么想象一个 3D 世界，我们有一个 3D 世界的数学表示，但我们需要把它绘制在 2D 表面上。数学上我们如何从 3D 几何图形到 2D 平面图形的？那就是投影矩阵的用处。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "glm/glm.hpp"</span></span><br><span class="line"><span class="addition">+#include "glm/gtc/matrix_transform.hpp"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	constexpr float positions[] = {</span><br><span class="line">		-0.5f, -0.5f, 0.0f, 0.0f,	// 0</span><br><span class="line">		 0.5f, -0.5f, 1.0f, 0.0f,	// 1</span><br><span class="line">		 0.5f,  0.5f, 1.0f, 1.0f,	// 2</span><br><span class="line">		-0.5f,  0.5f, 0.0f, 1.0f	// 3</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	const unsigned int indices[] = {</span><br><span class="line">		0, 1, 2,</span><br><span class="line">		2, 3, 0</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	GLCall(glEnable(GL_BLEND))</span><br><span class="line">	GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">	unsigned int vao;</span><br><span class="line">	GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">	GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">	const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">	glm::mat4 proj = glm::ortho(-2.0f, 2.0f, -1.5f, 1.5f, -1.0f, 1.0f);</span><br><span class="line"></span><br><span class="line">	Shader shader("res/shader/basic.shader");</span><br><span class="line">	shader.Bind();</span><br><span class="line"><span class="deletion">-	shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">	const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">	texture.Bind();</span><br><span class="line">	shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	va.Unbind();</span><br><span class="line">	shader.Unbind();</span><br><span class="line">	vb.Unbind();</span><br><span class="line">	ib.Unbind();</span><br><span class="line"></span><br><span class="line">	Renderer renderer;</span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		renderer.Clear();</span><br><span class="line"></span><br><span class="line">		shader.Bind();</span><br><span class="line"><span class="deletion">-		shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">		renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一个正交矩阵本质上就是把所有的坐标映射到 2D 屏幕上的一种方法，离得更远的物体并不会变小。这和我们习惯的透视投影是相反的。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#shader vertex</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) in vec4 position;</span><br><span class="line">layout(location = 1) in vec2 texCoord;</span><br><span class="line"></span><br><span class="line">out vec2 v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="addition">+uniform mat4 u_MVP;</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">    gl_Position = position;</span><br><span class="line">    v_TexCoord = texCoord;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line">in vec2 v_TexCoord;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_Color;</span><br><span class="line">uniform sampler2D u_Texture;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">    vec4 texColor = texture(u_Texture, v_TexCoord);</span><br><span class="line">    color = texColor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>MVP</code> 是我们的模型 (Model) 视图 (View) 投影 (Projection) 矩阵，后面会讲到这些（请复习 GAMES101）。</p><p>接着在顶点着色器用这个矩阵乘以我的顶点位置，每个顶点运行一次基于我们提供的正交矩阵将它移到合适的空间。</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">gl_Position</span> = u_MVP * position;</span><br><span class="line">    v_TexCoord = texCoord;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了设置 <code>u_MVP</code>，我们需要在 <code>Shader.h</code> 中补充 <code>SetUniformMat4f()</code> 方法：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "glm/glm.hpp"</span></span><br><span class="line"></span><br><span class="line">struct ShaderProgramSource</span><br><span class="line">{</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Shader</span><br><span class="line">{</span><br><span class="line">private:</span><br><span class="line">    std::string m_FilePath;</span><br><span class="line">    unsigned int m_RendererID;</span><br><span class="line">    std::unordered_map&lt;std::string, int&gt; m_UniformLocationCache;</span><br><span class="line">public:</span><br><span class="line">    Shader(const std::string&amp; filepath);</span><br><span class="line">    ~Shader();</span><br><span class="line"></span><br><span class="line">    void Bind() const;</span><br><span class="line">    void Unbind() const;</span><br><span class="line"></span><br><span class="line">    // Set uniforms</span><br><span class="line">    void SetUniform1i(const std::string&amp; name, int value);</span><br><span class="line">    void SetUniform1f(const std::string&amp; name, float value);</span><br><span class="line">    void SetUniform4f(const std::string&amp; name, float v0, float v1, float v2, float v3);</span><br><span class="line"><span class="addition">+   void SetUniformMat4f(const std::string&amp; name, const glm::mat4&amp; matrix);</span></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ShaderProgramSource ParseShader(const std::string&amp; filepath) const;</span><br><span class="line">    unsigned int CompileShader(unsigned int type, const std::string&amp; source);</span><br><span class="line">    unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader);</span><br><span class="line">  </span><br><span class="line">    int GetUniformLocation(const std::string&amp; name);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>Shader.cpp</code> 中实现方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniformMat4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::mat4&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">GetUniformLocation</span>(name), <span class="number">1</span>, GL_FALSE, &amp;matrix[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后返回 <code>Application.cpp</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "glm/glm.hpp"</span></span><br><span class="line"><span class="addition">+#include "glm/gtc/matrix_transform.hpp"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	constexpr float positions[] = {</span><br><span class="line">		-0.5f, -0.5f, 0.0f, 0.0f,	// 0</span><br><span class="line">		 0.5f, -0.5f, 1.0f, 0.0f,	// 1</span><br><span class="line">		 0.5f,  0.5f, 1.0f, 1.0f,	// 2</span><br><span class="line">		-0.5f,  0.5f, 0.0f, 1.0f	// 3</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	const unsigned int indices[] = {</span><br><span class="line">		0, 1, 2,</span><br><span class="line">		2, 3, 0</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	GLCall(glEnable(GL_BLEND))</span><br><span class="line">	GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">	unsigned int vao;</span><br><span class="line">	GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">	GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">	const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line"><span class="addition">+	const glm::mat4 proj = glm::ortho(-2.0f, 2.0f, -1.5f, 1.5f, -1.0f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">	Shader shader("res/shader/basic.shader");</span><br><span class="line">	shader.Bind();</span><br><span class="line">	// shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span><br><span class="line"><span class="addition">+	shader.SetUniformMat4f("u_MVP", proj);</span></span><br><span class="line"></span><br><span class="line">	const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">	texture.Bind();</span><br><span class="line">	shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	va.Unbind();</span><br><span class="line">	shader.Unbind();</span><br><span class="line">	vb.Unbind();</span><br><span class="line">	ib.Unbind();</span><br><span class="line"></span><br><span class="line">	Renderer renderer;</span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		renderer.Clear();</span><br><span class="line"></span><br><span class="line">		shader.Bind();</span><br><span class="line">		// shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line">		renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/ocURfe.png"></p><p>最终我们得到了横纵比 4:3 的纹理图形。</p><h3 id="OpenGL中的投影矩阵"><a href="#OpenGL中的投影矩阵" class="headerlink" title="OpenGL中的投影矩阵"></a>OpenGL中的投影矩阵</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=20&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>投影矩阵本质上是一种数学，将空间中所有 3D 点转换成 2D 窗口中的东西，这就是投影矩阵。</p><p>投影矩阵的实际变换就是把所有那些位置转换成所谓的标准坐标，也就是某种标准化空间，然后映射到我们的窗口。标准空间意味着在每个 xyz 轴上都有一个 -1 和 1 之间的坐标系统，所以我想说的是一个窗口的图像分辨率在点上无关紧要。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/QawyIY.png"></p><p>我们有正交投影和透视投影。</p><p>正交投影通常用于 2D 渲染，当然也可用于 3D 对关卡编辑器或 3D 建模程序等有用。透视投影通常用于 3D，尤其是拥有深度概念 z 的时候。（后面就是更改矩阵实践体验，没有什么东西了）</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line">#include "glm/glm.hpp"</span><br><span class="line">#include "glm/gtc/matrix_transform.hpp"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="addition">+	constexpr float positions[] = {</span></span><br><span class="line"><span class="addition">+		100.0f, 100.0f, 0.0f, 0.0f,	// 0</span></span><br><span class="line"><span class="addition">+		200.0f, 100.0f, 1.0f, 0.0f,	// 1</span></span><br><span class="line"><span class="addition">+		200.0f, 200.0f, 1.0f, 1.0f,	// 2</span></span><br><span class="line"><span class="addition">+		100.0f, 200.0f, 0.0f, 1.0f	// 3</span></span><br><span class="line"><span class="addition">+	};</span></span><br><span class="line"></span><br><span class="line">	const unsigned int indices[] = {</span><br><span class="line">		0, 1, 2,</span><br><span class="line">		2, 3, 0</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	GLCall(glEnable(GL_BLEND))</span><br><span class="line">	GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">	unsigned int vao;</span><br><span class="line">	GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">	GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">	const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line"><span class="addition">+	const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f);</span></span><br><span class="line"><span class="addition">+	glm::vec4 vp(100.0f, 100.0f, 0.0f, 1.0f);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+	glm::vec4 result = proj * vp;</span></span><br><span class="line"></span><br><span class="line">	Shader shader("res/shader/basic.shader");</span><br><span class="line">	shader.Bind();</span><br><span class="line">	// shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span><br><span class="line">	shader.SetUniformMat4f("u_MVP", proj);</span><br><span class="line"></span><br><span class="line">	const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">	texture.Bind();</span><br><span class="line">	shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	va.Unbind();</span><br><span class="line">	shader.Unbind();</span><br><span class="line">	vb.Unbind();</span><br><span class="line">	ib.Unbind();</span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		Renderer renderer;</span><br><span class="line">		renderer.Clear();</span><br><span class="line"></span><br><span class="line">		shader.Bind();</span><br><span class="line">		// shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line">		renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/ffGrQb.png"></p><h3 id="OpenGL中的模型视图投影矩阵"><a href="#OpenGL中的模型视图投影矩阵" class="headerlink" title="OpenGL中的模型视图投影矩阵"></a>OpenGL中的模型视图投影矩阵</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=21&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>在我们的着色器代码中或者在 C++ 的 glm 代码中，它可以是 pvm：投影 x 视图 x 模型。而像 Direct3D 和 DirectX 因为它们确实处理的矩阵是行主序的，那么就是 mvp：模型 x 视图 x 投影。</p><h4 id="视图矩阵"><a href="#视图矩阵" class="headerlink" title="视图矩阵"></a>视图矩阵</h4><p>OpenGL 中没有相机这个东西，我们能做的就是移动几何体和顶点。所以为了模拟相机向左移动，我们需要做的是将所有东西向右移动，可以算一种逆向运算。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line">#include "glm/glm.hpp"</span><br><span class="line">#include "glm/gtc/matrix_transform.hpp"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	constexpr float positions[] = {</span><br><span class="line">		100.0f, 100.0f, 0.0f, 0.0f,	// 0</span><br><span class="line">		200.0f, 100.0f, 1.0f, 0.0f,	// 1</span><br><span class="line">		200.0f, 200.0f, 1.0f, 1.0f,	// 2</span><br><span class="line">		100.0f, 200.0f, 0.0f, 1.0f	// 3</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	const unsigned int indices[] = {</span><br><span class="line">		0, 1, 2,</span><br><span class="line">		2, 3, 0</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	GLCall(glEnable(GL_BLEND))</span><br><span class="line">	GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">	unsigned int vao;</span><br><span class="line">	GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">	GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">	const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">	const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f);</span><br><span class="line"><span class="addition">+	const glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+	glm::mat4 mvp = proj * view;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-	glm::vec4 result = proj * vp;</span></span><br><span class="line"></span><br><span class="line">	Shader shader("res/shader/basic.shader");</span><br><span class="line">	shader.Bind();</span><br><span class="line">	// shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span><br><span class="line"><span class="addition">+	shader.SetUniformMat4f("u_MVP", mvp);</span></span><br><span class="line"></span><br><span class="line">	const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">	texture.Bind();</span><br><span class="line">	shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	va.Unbind();</span><br><span class="line">	shader.Unbind();</span><br><span class="line">	vb.Unbind();</span><br><span class="line">	ib.Unbind();</span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		Renderer renderer;</span><br><span class="line">		renderer.Clear();</span><br><span class="line"></span><br><span class="line">		shader.Bind();</span><br><span class="line">		// shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line">		renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/nivCms.png"></p><p>数学上将相机向左移动就是将所有矩阵向右移动，如果使用相机类应该将这些接口封装好等待调用即可。</p><h4 id="模型矩阵"><a href="#模型矩阵" class="headerlink" title="模型矩阵"></a>模型矩阵</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f);</span><br><span class="line">	const glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));</span><br><span class="line"><span class="addition">+	const glm::mat4 model = glm::translate(glm::mat4(1.0f), glm::vec3(200, 200, 0));</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+	const glm::mat4 mvp = proj * view * model;</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/jaskyZ.png"></p><h3 id="OpenGL中的ImGui"><a href="#OpenGL中的ImGui" class="headerlink" title="OpenGL中的ImGui"></a>OpenGL中的ImGui</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=22&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们会整合一些 ImGui 的东西，它本质上是一个我们可以在 OpenGL、DirectX 以及任何渲染接口中使用的 GUI 图形用户接口库。 它的大多数接口是独立的，这是我们在屏幕上绘制 UI 界面的一种方式。</p><h4 id="ImGui"><a href="#ImGui" class="headerlink" title="ImGui"></a>ImGui</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/7wLmw4.png"></p><ul><li><a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui">Dear ImGui</a></li></ul><p>在 Release 界面下载 zip 源码，我们关心的是 OpenGL 的例子 <code>imgui-1.88/examples/example_glfw_opengl3</code> 和根目录下的头文件。所以拷贝两者到 <code>src/vendor/imgui</code> 下。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/qFRSBN.png"></p><p>注意，最新版本的 ImGui 中的 impl 两个实现文件已转移到主目录的 <code>backends</code> 下面。实在搞不懂可以参考该分支 <a target="_blank" rel="noopener" href="https://github.com/speauty/ChernoOpenGL/tree/baf72ce8e59fe1ea025ab7b453660c948f7cb68d">ChernoOpenGL</a> 的配置。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line">#include "glm/glm.hpp"</span><br><span class="line">#include "glm/gtc/matrix_transform.hpp"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "imgui/imgui.h"</span></span><br><span class="line"><span class="addition">+#include "imgui/imgui_impl_glfw.h"</span></span><br><span class="line"><span class="addition">+#include "imgui/imgui_impl_opengl3.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	constexpr float positions[] = {</span><br><span class="line">		100.0f, 100.0f, 0.0f, 0.0f,	// 0</span><br><span class="line">		200.0f, 100.0f, 1.0f, 0.0f,	// 1</span><br><span class="line">		200.0f, 200.0f, 1.0f, 1.0f,	// 2</span><br><span class="line">		100.0f, 200.0f, 0.0f, 1.0f	// 3</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	const unsigned int indices[] = {</span><br><span class="line">		0, 1, 2,</span><br><span class="line">		2, 3, 0</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	GLCall(glEnable(GL_BLEND))</span><br><span class="line">	GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">	unsigned int vao;</span><br><span class="line">	GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">	GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">	const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">	const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 720.0f, -1.0f, 1.0f);</span><br><span class="line">	const glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));</span><br><span class="line">	const glm::mat4 model = glm::translate(glm::mat4(1.0f), glm::vec3(200, 200, 0));</span><br><span class="line"></span><br><span class="line">	glm::mat4 mvp = proj * view * model;</span><br><span class="line"></span><br><span class="line">	Shader shader("res/shader/basic.shader");</span><br><span class="line">	shader.Bind();</span><br><span class="line">	shader.SetUniformMat4f("u_MVP", mvp);</span><br><span class="line"></span><br><span class="line">	const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">	texture.Bind();</span><br><span class="line">	shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	va.Unbind();</span><br><span class="line">	shader.Unbind();</span><br><span class="line">	vb.Unbind();</span><br><span class="line">	ib.Unbind();</span><br><span class="line"></span><br><span class="line"><span class="addition">+	ImGui::CreateContext();</span></span><br><span class="line"><span class="addition">+	ImGui_ImplGlfw_InitForOpenGL(window, true);</span></span><br><span class="line"><span class="addition">+	ImGui::StyleColorsDark();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+	const char* glsl_version = "#version 330";</span></span><br><span class="line"><span class="addition">+	ImGui_ImplOpenGL3_Init(glsl_version);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line"><span class="addition">+	glm::vec3 translation(200, 200, 0);</span></span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		Renderer renderer;</span><br><span class="line">		renderer.Clear();</span><br><span class="line"></span><br><span class="line"><span class="addition">+		ImGui_ImplOpenGL3_NewFrame();</span></span><br><span class="line"><span class="addition">+		ImGui_ImplGlfw_NewFrame();</span></span><br><span class="line"><span class="addition">+		ImGui::NewFrame();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+		glm::mat4 model = glm::translate(glm::mat4(1.0f), translation);</span></span><br><span class="line"><span class="addition">+		glm::mat4 mvp = proj * view * model;</span></span><br><span class="line"></span><br><span class="line">		shader.Bind();</span><br><span class="line">		// shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"><span class="addition">+		shader.SetUniformMat4f("u_MVP", mvp);</span></span><br><span class="line"></span><br><span class="line">		renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">		vb.Bind();</span><br><span class="line">		ib.Bind();</span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line"><span class="addition">+		{</span></span><br><span class="line"><span class="addition">+			ImGui::Begin("ImGui");</span></span><br><span class="line"><span class="addition">+			ImGui::SliderFloat3("Translation", &amp;translation.x, 0.0f, 960.0f);</span></span><br><span class="line"><span class="addition">+			ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);</span></span><br><span class="line"><span class="addition">+			ImGui::End();</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+		ImGui::Render();</span></span><br><span class="line"><span class="addition">+		ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+	ImGui_ImplOpenGL3_Shutdown();</span></span><br><span class="line"><span class="addition">+	ImGui_ImplGlfw_Shutdown();</span></span><br><span class="line"><span class="addition">+	ImGui::DestroyContext();</span></span><br><span class="line"></span><br><span class="line">	glfwDestroyWindow(window);</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/Tm0yJg.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/lwzpBj.png"></p><h3 id="批量渲染对象"><a href="#批量渲染对象" class="headerlink" title="批量渲染对象"></a>批量渲染对象</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=23&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们要讲的是如何在屏幕上渲染多个目标。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line">#include "glm/glm.hpp"</span><br><span class="line">#include "glm/gtc/matrix_transform.hpp"</span><br><span class="line"></span><br><span class="line">#include "imgui/imgui.h"</span><br><span class="line">#include "imgui/imgui_impl_glfw.h"</span><br><span class="line">#include "imgui/imgui_impl_opengl3.h"</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	constexpr float positions[] = {</span><br><span class="line"><span class="addition">+		-50.0f, -50.0f, 0.0f, 0.0f,	// 0</span></span><br><span class="line"><span class="addition">+		 50.0f, -50.0f, 1.0f, 0.0f,	// 1</span></span><br><span class="line"><span class="addition">+		 50.0f,  50.0f, 1.0f, 1.0f,	// 2</span></span><br><span class="line"><span class="addition">+		-50.0f,  50.0f, 0.0f, 1.0f	// 3</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	const unsigned int indices[] = {</span><br><span class="line">		0, 1, 2,</span><br><span class="line">		2, 3, 0</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	GLCall(glEnable(GL_BLEND))</span><br><span class="line">	GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">	unsigned int vao;</span><br><span class="line">	GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">	GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">	VertexArray va;</span><br><span class="line">	const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">	VertexBufferLayout layout;</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	layout.Push&lt;float&gt;(2);</span><br><span class="line">	va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">	const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">	const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 720.0f, -1.0f, 1.0f);</span><br><span class="line"><span class="addition">+	const glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, 0));</span></span><br><span class="line"></span><br><span class="line">	Shader shader("res/shader/basic.shader");</span><br><span class="line">	shader.Bind();</span><br><span class="line"></span><br><span class="line">	const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">	texture.Bind();</span><br><span class="line">	shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	va.Unbind();</span><br><span class="line">	shader.Unbind();</span><br><span class="line">	vb.Unbind();</span><br><span class="line">	ib.Unbind();</span><br><span class="line"></span><br><span class="line">	ImGui::CreateContext();</span><br><span class="line">	ImGui_ImplGlfw_InitForOpenGL(window, true);</span><br><span class="line">	ImGui::StyleColorsDark();</span><br><span class="line"></span><br><span class="line">	const char* glsl_version = "#version 330";</span><br><span class="line">	ImGui_ImplOpenGL3_Init(glsl_version);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line"><span class="addition">+	glm::vec3 translationA(200, 200, 0);</span></span><br><span class="line"><span class="addition">+	glm::vec3 translationB(400, 400, 0);</span></span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		Renderer renderer;</span><br><span class="line">		renderer.Clear();</span><br><span class="line"></span><br><span class="line">		ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">		ImGui_ImplGlfw_NewFrame();</span><br><span class="line">		ImGui::NewFrame();</span><br><span class="line"></span><br><span class="line"><span class="addition">+		{</span></span><br><span class="line"><span class="addition">+			glm::mat4 model = glm::translate(glm::mat4(1.0f), translationA);</span></span><br><span class="line"><span class="addition">+			glm::mat4 mvp = proj * view * model;</span></span><br><span class="line"><span class="addition">+			shader.Bind();</span></span><br><span class="line"><span class="addition">+			shader.SetUniformMat4f("u_MVP", mvp);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+			renderer.Draw(va, ib, shader);</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+		{</span></span><br><span class="line"><span class="addition">+			glm::mat4 model = glm::translate(glm::mat4(1.0f), translationB);</span></span><br><span class="line"><span class="addition">+			glm::mat4 mvp = proj * view * model;</span></span><br><span class="line"><span class="addition">+			shader.Bind();</span></span><br><span class="line"><span class="addition">+			shader.SetUniformMat4f("u_MVP", mvp);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+			renderer.Draw(va, ib, shader);</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		{</span><br><span class="line">			ImGui::Begin("ImGui");</span><br><span class="line"><span class="addition">+			ImGui::SliderFloat3("Translation A", &amp;translationA.x, 0.0f, 960.0f);</span></span><br><span class="line"><span class="addition">+			ImGui::SliderFloat3("Translation B", &amp;translationB.x, 0.0f, 960.0f);</span></span><br><span class="line">			ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", static_cast&lt;double&gt;(1000.0f / ImGui::GetIO().Framerate), static_cast&lt;double&gt;(ImGui::GetIO().Framerate));</span><br><span class="line">			ImGui::End();</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		ImGui::Render();</span><br><span class="line">		ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ImGui_ImplOpenGL3_Shutdown();</span><br><span class="line">	ImGui_ImplGlfw_Shutdown();</span><br><span class="line">	ImGui::DestroyContext();</span><br><span class="line"></span><br><span class="line">	glfwDestroyWindow(window);</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际上有两种不同的策略，但这里我们不必浪费内存，选择通过采用不同的模型矩阵实现批量渲染对象。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/qbCBaJ.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/gKsQud.png"></p><h3 id="为OpenGL建立一个测试框架"><a href="#为OpenGL建立一个测试框架" class="headerlink" title="为OpenGL建立一个测试框架"></a>为OpenGL建立一个测试框架</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=24&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>现在我们的应用程序只是为 OpenGL 创建了一堆接口类，比如顶点缓冲区、顶点数组、索引缓冲区、纹理之类的东西，然后我们就有了这个 <code>Application.cpp</code> 文件也就是一些对 OpenGL 的调用。但我真正想做的是让我们有能力进行不同的测试，也就是说不同的应用领域不同的场景我们可以在每一个测试或者场景中循环，并且它的实现非常简单，我们只是在 ImGui 添加一个菜单显示所有可用的场景或测试或示例。</p><h4 id="测试基类"><a href="#测试基类" class="headerlink" title="测试基类"></a>测试基类</h4><p>在 <code>src/</code> 下创建 <code>tests</code> 文件夹，新建 <code>Test.h</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Test</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>{}</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> </span>{}</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> </span>{} </span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过该测试基类我们可以自由分配堆栈资源而不必手动释放，因为其生命周期与该类同步，创建和销毁直接调用构造函数和析构函数。</p><h4 id="颜色测试"><a href="#颜色测试" class="headerlink" title="颜色测试"></a>颜色测试</h4><p>新建 <code>TestClearColor.h</code> 和 <code>TestClearColor.cpp</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TestClearColor</span> : <span class="keyword">public</span> Test</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TestClearColor</span>();</span><br><span class="line">        ~<span class="built_in">TestClearColor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">float</span> m_ClearColor[<span class="number">4</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* m_Label;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>头文件 <code>TestClearColor.h</code> 的变量 <code>m_ClearColor[4]</code> 就是颜色的 RGBA，<code>m_Label</code> 为 UI 的标题字符串。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"TestClearColor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    TestClearColor::<span class="built_in">TestClearColor</span>()</span><br><span class="line">        : m_ClearColor{ <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span> }, <span class="built_in">m_Label</span>(<span class="string">"ClearColor"</span>)</span><br><span class="line">    {</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TestClearColor::~<span class="built_in">TestClearColor</span>()</span><br><span class="line">    {</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(m_ClearColor[<span class="number">0</span>], m_ClearColor[<span class="number">1</span>], m_ClearColor[<span class="number">2</span>], m_ClearColor[<span class="number">3</span>]))</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ImGui::<span class="built_in">ColorEdit4</span>(m_Label, m_ClearColor);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-4"><a href="#应用类-4" class="headerlink" title="应用类"></a>应用类</h4><p>重新整理应用类 <code>Application.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Shader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"glm/glm.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui_impl_glfw.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui_impl_opengl3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"tests/TestClearColor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND))</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">	<span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line">	ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* glsl_version = <span class="string">"#version 330"</span>;</span><br><span class="line">	<span class="built_in">ImGui_ImplOpenGL3_Init</span>(glsl_version);</span><br><span class="line"></span><br><span class="line">	test::TestClearColor test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		Renderer renderer;</span><br><span class="line">		renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">		test.<span class="built_in">OnUpdate</span>(<span class="number">0.0f</span>);</span><br><span class="line">		test.<span class="built_in">OnRender</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">		<span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">		ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">		{</span><br><span class="line">			test.<span class="built_in">OnImGuiRender</span>();</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		ImGui::<span class="built_in">Render</span>();</span><br><span class="line">		<span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line">	<span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">	ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/pot3Qe.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/zJz366.png"></p><h3 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=25&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="测试菜单"><a href="#测试菜单" class="headerlink" title="测试菜单"></a>测试菜单</h4><p>在 <code>Test.h</code> 中新加入 <code>TestMenu</code> 测试菜单类：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"><span class="addition">+#include &lt;iostream&gt;</span></span><br><span class="line"><span class="addition">+#include &lt;string&gt;</span></span><br><span class="line"><span class="addition">+#include &lt;vector&gt;</span></span><br><span class="line"><span class="addition">+#include &lt;functional&gt;</span></span><br><span class="line"></span><br><span class="line">namespace test</span><br><span class="line">{</span><br><span class="line">    class Test</span><br><span class="line">    {</span><br><span class="line">    public:</span><br><span class="line">        Test() = default;</span><br><span class="line">        virtual ~Test() = default;</span><br><span class="line"></span><br><span class="line">        virtual void OnUpdate(float deltaTime) {}</span><br><span class="line">        virtual void OnRender() {}</span><br><span class="line">        virtual void OnImGuiRender() {} </span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="addition">+   class TestMenu : public Test</span></span><br><span class="line"><span class="addition">+   {</span></span><br><span class="line"><span class="addition">+   public:</span></span><br><span class="line"><span class="addition">+       TestMenu(Test*&amp; currentTestPointer);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       void OnImGuiRender() override;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       template&lt;typename T&gt;</span></span><br><span class="line"><span class="addition">+       void RegisterTest(const std::string&amp; name)</span></span><br><span class="line"><span class="addition">+       {</span></span><br><span class="line"><span class="addition">+           std::cout &lt;&lt; "Registering test " &lt;&lt; name &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+           m_Tests.push_back(std::make_pair(name, [](){ return new T(); }));</span></span><br><span class="line"><span class="addition">+       }</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+   private:</span></span><br><span class="line"><span class="addition">+       Test*&amp; m_CurrentTest;</span></span><br><span class="line"><span class="addition">+       std::vector&lt;std::pair&lt;std::string, std::function&lt;Test*()&gt;&gt;&gt; m_Tests;</span></span><br><span class="line"><span class="addition">+   };</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>新建 <code>Test.cpp</code> 实现方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    TestMenu::<span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer)</span><br><span class="line">        : <span class="built_in">m_CurrentTest</span>(currentTestPointer)</span><br><span class="line">    {</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestMenu::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; test : m_Tests)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(test.first.<span class="built_in">c_str</span>()))</span><br><span class="line">                m_CurrentTest = test.<span class="built_in">second</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-5"><a href="#应用类-5" class="headerlink" title="应用类"></a>应用类</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "Shader.h"</span><br><span class="line"></span><br><span class="line">#include "imgui/imgui.h"</span><br><span class="line">#include "imgui/imgui_impl_glfw.h"</span><br><span class="line">#include "imgui/imgui_impl_opengl3.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "tests/Test.h"</span></span><br><span class="line">#include "tests/TestClearColor.h"</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	GLCall(glEnable(GL_BLEND))</span><br><span class="line">	GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ImGui::CreateContext();</span><br><span class="line">	ImGui_ImplGlfw_InitForOpenGL(window, true);</span><br><span class="line">	ImGui::StyleColorsDark();</span><br><span class="line"></span><br><span class="line">	const char* glsl_version = "#version 330";</span><br><span class="line">	ImGui_ImplOpenGL3_Init(glsl_version);</span><br><span class="line"></span><br><span class="line"><span class="addition">+	test::Test* currentTest = nullptr;</span></span><br><span class="line"><span class="addition">+	test::TestMenu* testMenu = new test::TestMenu(currentTest);</span></span><br><span class="line"><span class="addition">+	currentTest = testMenu;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+	testMenu-&gt;RegisterTest&lt;test::TestClearColor&gt;("Clear Color");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line"><span class="addition">+		GLCall(glClearColor(0.0f, 0.0f, 0.0f, 1.0f));</span></span><br><span class="line"></span><br><span class="line">		Renderer renderer;</span><br><span class="line">		renderer.Clear();</span><br><span class="line"></span><br><span class="line">		ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">		ImGui_ImplGlfw_NewFrame();</span><br><span class="line">		ImGui::NewFrame();</span><br><span class="line"></span><br><span class="line"><span class="addition">+		if (currentTest)</span></span><br><span class="line"><span class="addition">+		{</span></span><br><span class="line"><span class="addition">+			currentTest-&gt;OnUpdate(0.0f);</span></span><br><span class="line"><span class="addition">+			currentTest-&gt;OnRender();</span></span><br><span class="line"><span class="addition">+			ImGui::Begin("ImGui-Test");</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+			if (currentTest != testMenu &amp;&amp; ImGui::Button("&lt;-"))</span></span><br><span class="line"><span class="addition">+			{</span></span><br><span class="line"><span class="addition">+				delete currentTest;</span></span><br><span class="line"><span class="addition">+				currentTest = testMenu;</span></span><br><span class="line"><span class="addition">+			}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+			currentTest-&gt;OnImGuiRender();</span></span><br><span class="line"><span class="addition">+			ImGui::End();</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ImGui::Render();</span><br><span class="line">		ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+	delete currentTest;</span></span><br><span class="line"><span class="addition">+	if (currentTest != testMenu)</span></span><br><span class="line"><span class="addition">+	{</span></span><br><span class="line"><span class="addition">+		delete testMenu;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ImGui_ImplOpenGL3_Shutdown();</span><br><span class="line">	ImGui_ImplGlfw_Shutdown();</span><br><span class="line">	ImGui::DestroyContext();</span><br><span class="line"></span><br><span class="line">	glfwDestroyWindow(window);</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/27j93i.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/86K1aB.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/XIghUi.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/aZhz8W.png"></p><h3 id="创建一个纹理测试"><a href="#创建一个纹理测试" class="headerlink" title="创建一个纹理测试"></a>创建一个纹理测试</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=26&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="纹理测试类"><a href="#纹理测试类" class="headerlink" title="纹理测试类"></a>纹理测试类</h4><p>新建纹理测试类 <code>TestTexture2D.h</code> 和 <code>TestTexture2D.cpp</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBufferLayout.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Texture.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TestTexture2D</span> : <span class="keyword">public</span> Test</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::unique_ptr&lt;VertexArray&gt; m_VAO;</span><br><span class="line">        std::unique_ptr&lt;IndexBuffer&gt; m_IndexBuffer;</span><br><span class="line">        std::unique_ptr&lt;VertexBuffer&gt; m_VertexBuffer;</span><br><span class="line">        std::unique_ptr&lt;Shader&gt; m_Shader;</span><br><span class="line">        std::unique_ptr&lt;Texture&gt; m_Texture;</span><br><span class="line"></span><br><span class="line">        glm::mat4 m_Proj, m_View;</span><br><span class="line">        glm::vec3 m_TranslationA, m_TranslationB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TestTexture2D</span>();</span><br><span class="line">        ~<span class="built_in">TestTexture2D</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实就是把之前 <code>Application.cpp</code> 清理的琐碎代码整合到一个抽象类中供测试菜单调用：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"TestTexture2D.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"glm/glm.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"glm/gtc/matrix_transform.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">	TestTexture2D::<span class="built_in">TestTexture2D</span>()</span><br><span class="line">        :<span class="built_in">m_Proj</span>(glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">960.0f</span>, <span class="number">0.0f</span>, <span class="number">720.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)),</span><br><span class="line">        <span class="built_in">m_View</span>(glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>))),</span><br><span class="line">        <span class="built_in">m_TranslationA</span>(glm::<span class="built_in">vec3</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>)), <span class="built_in">m_TranslationB</span>(glm::<span class="built_in">vec3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">0</span>))</span><br><span class="line">	{</span><br><span class="line">        <span class="type">float</span> positions[] = {</span><br><span class="line">            <span class="number">100.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">// 0</span></span><br><span class="line">            <span class="number">200.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">// 1</span></span><br><span class="line">            <span class="number">200.0f</span>, <span class="number">200.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">// 2</span></span><br><span class="line">            <span class="number">100.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">// 3</span></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND))</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">        m_VAO = std::<span class="built_in">make_unique</span>&lt;VertexArray&gt;();</span><br><span class="line"></span><br><span class="line">        m_VertexBuffer = std::<span class="built_in">make_unique</span>&lt;VertexBuffer&gt;(positions, <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">        VertexBufferLayout layout;</span><br><span class="line">        layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">        layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">        m_VAO-&gt;<span class="built_in">AddBuffer</span>(*m_VertexBuffer, layout);</span><br><span class="line"></span><br><span class="line">        m_IndexBuffer = std::<span class="built_in">make_unique</span>&lt;IndexBuffer&gt;(indices, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        m_Shader = std::<span class="built_in">make_unique</span>&lt;Shader&gt;(<span class="string">"res/shader/Basic.shader"</span>);</span><br><span class="line">        m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        m_Shader-&gt;<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        m_Shader-&gt;<span class="built_in">SetUniform1i</span>(<span class="string">"u_Texture"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        m_Texture = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">"res/textures/Checkerboard.png"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>))</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constexpr</span> Renderer renderer;</span><br><span class="line"></span><br><span class="line">        m_Texture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationA);</span><br><span class="line">            <span class="type">const</span> glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line"></span><br><span class="line">            m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">            m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">"u_MVP"</span>, mvp);</span><br><span class="line"></span><br><span class="line">            renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationB);</span><br><span class="line">            <span class="type">const</span> glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line"></span><br><span class="line">            m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">            m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">"u_MVP"</span>, mvp);</span><br><span class="line"></span><br><span class="line">            renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">        ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">"m_TranslationA"</span>, &amp;m_TranslationA.x, <span class="number">0.0f</span>, <span class="number">960.0f</span>);</span><br><span class="line">        ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">"m_TranslationB"</span>, &amp;m_TranslationB.x, <span class="number">0.0f</span>, <span class="number">960.0f</span>);</span><br><span class="line">        ImGui::<span class="built_in">Text</span>(<span class="string">"Application average %.3f ms/frame (%.1f FPS)"</span>, <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(ImGui::<span class="built_in">GetIO</span>().Framerate));</span><br><span class="line">	}</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-6"><a href="#应用类-6" class="headerlink" title="应用类"></a>应用类</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include "imgui/imgui.h"</span><br><span class="line">#include "imgui/imgui_impl_glfw.h"</span><br><span class="line">#include "imgui/imgui_impl_opengl3.h"</span><br><span class="line"></span><br><span class="line">#include "tests/TestClearColor.h"</span><br><span class="line"><span class="addition">+#include "tests/TestTexture2D.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	/* Initialize the library */</span><br><span class="line">	if (!glfwInit())</span><br><span class="line">		return -1;</span><br><span class="line"></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">	if (!window)</span><br><span class="line">	{</span><br><span class="line">		GLCall(glfwTerminate())</span><br><span class="line">		return -1;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">	if (glewInit() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	GLCall(glEnable(GL_BLEND))</span><br><span class="line">	GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ImGui::CreateContext();</span><br><span class="line">	ImGui_ImplGlfw_InitForOpenGL(window, true);</span><br><span class="line">	ImGui::StyleColorsDark();</span><br><span class="line"></span><br><span class="line">	const char* glsl_version = "#version 330";</span><br><span class="line">	ImGui_ImplOpenGL3_Init(glsl_version);</span><br><span class="line"></span><br><span class="line">	test::Test* currentTest = nullptr;</span><br><span class="line">	test::TestMenu* testMenu = new test::TestMenu(currentTest);</span><br><span class="line">	currentTest = testMenu;</span><br><span class="line"></span><br><span class="line">	testMenu-&gt;RegisterTest&lt;test::TestClearColor&gt;("Clear Color");</span><br><span class="line"><span class="addition">+</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/am6Cqa.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/PFW6aM.png"></p><h3 id="如何让统一变量更快"><a href="#如何让统一变量更快" class="headerlink" title="如何让统一变量更快"></a>如何让统一变量更快</h3><p>span</p><p>之前已经实现了将读取的统一变量位置存入缓存，不再赘述。</p><h3 id="批渲染"><a href="#批渲染" class="headerlink" title="批渲染"></a>批渲染</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=28&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>对于学习 OpenGL 或图形编程的人来说，你们可能听说过所谓的批处理或者批处理渲染，这是一种非常有用的渲染技术。批渲染本身很难精确地定义，因为它可以指很多不同地东西，它的复杂度从几分钟就能写完的简单东西到一个更大的系统部分。我们今天要具体讨论的是如何将几何图形批处理在一起，这意味着我们可以在独立的 DrawCall 中渲染多个几何图形，这也是批处理和批渲染对我的核心意义。</p><p>所以让我们把它分解一下，能够在单个 DrawCall 中渲染多个几何体是什么意思？为什么它有用，它是什么样子的。传统的说法我们已经绘制了很多，现在我们已经建立了一个顶点缓冲区、一个索引缓冲区，然后我们用类似 <code>glDrawElements</code> 的东西来做渲染，那就是我们的绘制，那就是我们在屏幕上看到东西的方式。如果我们想要一个不同的对线，或者想要另一个矩形出现在屏幕上，我们基本上就是重复这个过程。如果形状不变我们当然可以重用相同的顶点缓冲区和索引缓冲区，然后我们在顶点着色器中使用统一变量矩阵，能够真正定位和潜在地转换特定的几何图形，那是非常棒的。但是如果我们想要渲染大量的几何图形呢？</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="2D游戏贴图绘制"><a href="#2D游戏贴图绘制" class="headerlink" title="2D游戏贴图绘制"></a>2D游戏贴图绘制</h6><p>让我们从一些例子开始，这样我们就能理解我们要做的是什么。例如我们正在制作一款自上而下的 2D-RPG 游戏，我们在世界各地移动，而世界本身是由不同的贴图组成的（像 Stardew Valley）。现在这些游戏在很多情况下确实显示了从上面看的视角并且相机可能变得很远，在我们当前的策略下，屏幕上很可能会出现许多不同的贴图。如果我们决定将每个贴图渲染为带有纹理的独立四边形，那有点困难，它将不会有很好的性能表现。因为如果我们有成百上千的贴图在世界中作为单独的 DrawCall 一个接一个的绘制，我们的 GPU 就跟不上了。</p><p>现在在现代硬件上，我们绝对可以侥幸通过数千次 DrawCall，这并不是什么大问题，但它绝对不是理想情况，尤其是对于像四边形这样简单的物体。如果你们单独绘制每个四边形，那是很低效的，当我们添加更多的四边形或者缩小相机，我们可以看到更多的地图时，我们的游戏可能会开始掉帧，因为它跟不上要绘制成千上万个贴图的速度。</p><h6 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h6><p>我们要展示的另一个很好的例子是粒子系统。</p><p>在 Infinite 引擎中我制作了<a target="_blank" rel="noopener" href="https://github.com/Yousazoe/Infinite/commit/52cb7bf569e22bb96665f33934d34cacd959069d">简单的粒子特效</a>，包括像燃烧的粒子和烟熏的粒子之类的东西。现在我渲染这些粒子的方式仅仅是通过使用简单的变换单独的四边形，但是如果我们有成千上万个这样的粒子又会发生什么？这是一个巨大的粒子系统，即使在现代的硬件上也很难渲染，但是有一种简单的方法，或者说更有效的方法，那就是批处理或批处理渲染。</p><p>简而言之，批渲染意味着将所有几何图形批处理到一个独立顶点缓冲区和索引缓冲区，然后简单地绘制一次。我们把所有东西放在一起，就好像它是一个几何图形，然后我们只渲染一次。刚才描述的将所有场景批量处理在性能上的提升是巨大的。</p><h5 id="批渲染测试类"><a href="#批渲染测试类" class="headerlink" title="批渲染测试类"></a>批渲染测试类</h5><p><code>test/</code> 新建批渲染测试类 <code>TestBatchRender.h</code> 和 <code>TestBatchRender.cpp</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBufferLayout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TestBatchRender</span> : <span class="keyword">public</span> Test</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::unique_ptr&lt;VertexArray&gt; m_VAO;</span><br><span class="line">        std::unique_ptr&lt;IndexBuffer&gt; m_IndexBuffer;</span><br><span class="line">        std::unique_ptr&lt;VertexBuffer&gt; m_VertexBuffer;</span><br><span class="line">        std::unique_ptr&lt;Shader&gt; m_Shader;</span><br><span class="line"></span><br><span class="line">        glm::mat4 m_Proj, m_View;</span><br><span class="line">        glm::vec3 m_Translation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TestBatchRender</span>();</span><br><span class="line">        ~<span class="built_in">TestBatchRender</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该测试类头文件包含顶点数组、索引缓冲区、顶点缓冲区、着色器以及 MVP 矩阵。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">span</span><br></pre></td></tr></tbody></table></figure><h5 id="批处理着色器"><a href="#批处理着色器" class="headerlink" title="批处理着色器"></a>批处理着色器</h5><p>新建着色器 <code>batch.shader</code>：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>)<span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_MVP;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">gl_Position</span> = u_MVP * position;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>)<span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">	color = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">1.0</span>f, <span class="number">1.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="应用类-7"><a href="#应用类-7" class="headerlink" title="应用类"></a>应用类</h5><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include "imgui/imgui.h"</span><br><span class="line">#include "imgui/imgui_impl_glfw.h"</span><br><span class="line">#include "imgui/imgui_impl_opengl3.h"</span><br><span class="line"></span><br><span class="line">#include "tests/TestClearColor.h"</span><br><span class="line">#include "tests/TestTexture2D.h"</span><br><span class="line"><span class="addition">+#include "tests/TestBatchRender.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	test::Test* currentTest = nullptr;</span><br><span class="line">	test::TestMenu* testMenu = new test::TestMenu(currentTest);</span><br><span class="line">	currentTest = testMenu;</span><br><span class="line"></span><br><span class="line">	testMenu-&gt;RegisterTest&lt;test::TestClearColor&gt;("Clear Color");</span><br><span class="line">	testMenu-&gt;RegisterTest&lt;test::TestTexture2D&gt;("2D Texture");</span><br><span class="line"><span class="addition">+	testMenu-&gt;RegisterTest&lt;test::TestBatchRender&gt;("Batch Render");</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">	    ......</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/yghr4f.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/yIvvCi.png"></p><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=29&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>让我们继续批处理渲染。</p><p>今天讲的都是颜色，我们如何绘制两个不同颜色的四边形或者任意数量的不同颜色的四边形。当我们想画一个有颜色的四边形时，最简单的方法是用顶点位置填充顶点缓冲区然后渲染那个四边形，再在片段着色器中传入一个包含颜色的统一变量。我们要做的就是使用两个不同的绘制调用用来渲染我们的矩形两次，然后在我们的片段着色器中有一个 <code>color</code> 设置输出颜色。</p><p>但我们不能那么做了，因为我们只有一个 <code>DrawElement</code> 调用，所以我们不能将统一变量设置为绘制之间的两个不同值。</p><p>目前我们的顶点只简单地包含一个位置，所以每个顶点都有三个浮点数 <code>x</code>、<code>y</code>、<code>z</code>，它定义了顶点的位置。但是位置并不是顶点能够包含的唯一内容，你们可以在顶点中存储任何东西然后在顶点着色器中访问这些数据。</p><h4 id="着色器-1"><a href="#着色器-1" class="headerlink" title="着色器"></a>着色器</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#shader vertex</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0)in vec4 position;</span><br><span class="line"><span class="addition">+layout(location = 2)in vec4 u_Color;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+out vec4 v_Color;</span></span><br><span class="line"></span><br><span class="line">uniform mat4 u_MVP;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">	gl_Position = u_MVP * position;</span><br><span class="line"><span class="addition">+	v_Color = u_Color;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0)out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="addition">+in vec4 v_Color;</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line"><span class="deletion">-	color = vec4(1.0f, 1.0f, 1.0f, 1.0f);</span></span><br><span class="line"><span class="addition">+	color = v_Color;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="批处理测试类"><a href="#批处理测试类" class="headerlink" title="批处理测试类"></a>批处理测试类</h4><p>改变顶点属性声明：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">    m_Translation(glm::vec3(0, 0, 0))</span><br><span class="line">	{</span><br><span class="line">        float positions[] = {</span><br><span class="line"><span class="deletion">-           100.0f, 100.0f,</span></span><br><span class="line"><span class="deletion">-           200.0f, 100.0f,</span></span><br><span class="line"><span class="deletion">-           200.0f, 200.0f,</span></span><br><span class="line"><span class="deletion">-           100.0f, 200.0f,</span></span><br><span class="line"><span class="addition">+           100.0f, 100.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,</span></span><br><span class="line"><span class="addition">+           200.0f, 100.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,</span></span><br><span class="line"><span class="addition">+           200.0f, 200.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,</span></span><br><span class="line"><span class="addition">+           100.0f, 200.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-           300.0f, 100.0f,</span></span><br><span class="line"><span class="deletion">-           400.0f, 100.0f,</span></span><br><span class="line"><span class="deletion">-           400.0f, 200.0f,</span></span><br><span class="line"><span class="deletion">-           300.0f, 200.0f,</span></span><br><span class="line"><span class="addition">+           300.0f, 100.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,</span></span><br><span class="line"><span class="addition">+           400.0f, 100.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,</span></span><br><span class="line"><span class="addition">+           400.0f, 200.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,</span></span><br><span class="line"><span class="addition">+           300.0f, 200.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,</span></span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        m_VAO = std::make_unique&lt;VertexArray&gt;();</span><br><span class="line"></span><br><span class="line"><span class="deletion">-       m_VertexBuffer = std::make_unique&lt;VertexBuffer&gt;(positions, 8 * 2 * sizeof(float));</span></span><br><span class="line"><span class="addition">+       m_VertexBuffer = std::make_unique&lt;VertexBuffer&gt;(positions, 8 * 8 * sizeof(float));</span></span><br><span class="line">        VertexBufferLayout layout;</span><br><span class="line"><span class="addition">+       layout.Push&lt;float&gt;(2); </span></span><br><span class="line">        layout.Push&lt;float&gt;(2);</span><br><span class="line"><span class="addition">+       layout.Push&lt;float&gt;(4);</span></span><br><span class="line">        m_VAO-&gt;AddBuffer(*m_VertexBuffer, layout);</span><br><span class="line"></span><br><span class="line">        m_IndexBuffer = std::make_unique&lt;IndexBuffer&gt;(indices, 12);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/CPP7/gmyeqz.png"></p><h4 id="纹理-1"><a href="#纹理-1" class="headerlink" title="纹理"></a>纹理</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=30&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="动态几何"><a href="#动态几何" class="headerlink" title="动态几何"></a>动态几何</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=31&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=32&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="挑战一小时完成批渲染器"><a href="#挑战一小时完成批渲染器" class="headerlink" title="挑战一小时完成批渲染器"></a>挑战一小时完成批渲染器</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=33&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br></div><footer class="post-footer"><div class="post-tags"><a href="/tags/OpenGL/" rel="tag"># OpenGL</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/781b26a.html" rel="prev" title="如何用很短的代码创造「秋日氛围感」？"><i class="fa fa-chevron-left"></i> 如何用很短的代码创造「秋日氛围感」？</a></div><div class="post-nav-item"><a href="/archives/3a2065a8.html" rel="next" title="悲惨歌喉下的隐喻--Love, Death &amp; Robots Season 3">悲惨歌喉下的隐喻--Love, Death &amp; Robots Season 3 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0OpenGL"><span class="nav-number">2.</span> <span class="nav-text">欢迎来到OpenGL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFOpenGL"><span class="nav-number">2.1.</span> <span class="nav-text">什么是OpenGL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EOpenGL%E8%AF%AF%E8%A7%A3"><span class="nav-number">2.2.</span> <span class="nav-text">关于OpenGL误解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E4%B8%8E%E7%8E%B0%E4%BB%A3OpenGL"><span class="nav-number">2.3.</span> <span class="nav-text">传统与现代OpenGL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEOpenGL%E5%92%8CC-%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">设置OpenGL和C++中创建一个窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E7%B1%BB%E5%BA%93"><span class="nav-number">3.1.</span> <span class="nav-text">下载类库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AECMake%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">配置CMake文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE"><span class="nav-number">3.3.</span> <span class="nav-text">编译项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">3.4.</span> <span class="nav-text">画一个三角形</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8C-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3OpenGL"><span class="nav-number">4.</span> <span class="nav-text">在C++中使用现代OpenGL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E5%9C%A8%E7%8E%B0%E4%BB%A3OpenGL%E4%B8%AD%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">5.</span> <span class="nav-text">顶点缓冲区和在现代OpenGL中画一个三角形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">顶点缓冲区与着色器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.2.</span> <span class="nav-text">代码实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E9%A1%B6%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B8%83%E5%B1%80"><span class="nav-number">6.</span> <span class="nav-text">OpenGL中顶点的属性和布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">顶点属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-1"><span class="nav-number">6.2.</span> <span class="nav-text">代码实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">OpenGL中着色器的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">7.1.</span> <span class="nav-text">着色器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">着色器类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">7.2.1.</span> <span class="nav-text">顶点着色器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">片段着色器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E5%86%99%E4%B8%80%E4%B8%AA%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">OpenGL中写一个着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">8.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E5%86%99"><span class="nav-number">8.3.</span> <span class="nav-text">着色器编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">8.4.</span> <span class="nav-text">整理错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">9.</span> <span class="nav-text">OpenGL中如何处理着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E5%90%88%E5%B9%B6"><span class="nav-number">9.1.</span> <span class="nav-text">着色器合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">9.2.</span> <span class="nav-text">着色器读取与使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">10.</span> <span class="nav-text">OpenGL中的索引缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%9B%9B%E8%BE%B9%E5%BD%A2"><span class="nav-number">10.1.</span> <span class="nav-text">绘制四边形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">10.2.</span> <span class="nav-text">索引缓冲区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">11.</span> <span class="nav-text">OpenGL中处理错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#glGetError"><span class="nav-number">11.1.</span> <span class="nav-text">glGetError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#glDebugMessageCallback"><span class="nav-number">11.2.</span> <span class="nav-text">glDebugMessageCallback</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F"><span class="nav-number">12.</span> <span class="nav-text">OpenGL中的统一变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E5%8F%98%E9%87%8F"><span class="nav-number">12.1.</span> <span class="nav-text">颜色变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-number">12.2.</span> <span class="nav-text">动态变化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84"><span class="nav-number">13.</span> <span class="nav-text">OpenGL中的顶点数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84"><span class="nav-number">13.1.</span> <span class="nav-text">顶点数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%AD%96%E7%95%A5"><span class="nav-number">13.2.</span> <span class="nav-text">应用策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E9%A1%B6%E7%82%B9%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA%E6%88%90%E7%B1%BB"><span class="nav-number">14.</span> <span class="nav-text">抽象顶点索引缓冲区成类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%B1%BB%E6%8A%BD%E8%B1%A1"><span class="nav-number">14.1.</span> <span class="nav-text">错误处理类抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VertexBuffer%E7%B1%BB%E6%8A%BD%E8%B1%A1"><span class="nav-number">14.2.</span> <span class="nav-text">VertexBuffer类抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IndexBuffer%E7%B1%BB%E6%8A%BD%E8%B1%A1"><span class="nav-number">14.3.</span> <span class="nav-text">IndexBuffer类抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB"><span class="nav-number">14.4.</span> <span class="nav-text">应用类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E5%B8%83%E5%B1%80%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="nav-number">15.</span> <span class="nav-text">OpenGL中的缓冲区和布局的抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E5%B8%83%E5%B1%80%E7%B1%BB"><span class="nav-number">15.1.</span> <span class="nav-text">顶点数组布局类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E7%B1%BB%E6%8A%BD%E8%B1%A1"><span class="nav-number">15.2.</span> <span class="nav-text">顶点数组类抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB-1"><span class="nav-number">15.3.</span> <span class="nav-text">应用类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenG%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">16.</span> <span class="nav-text">OpenG中抽象着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E6%8A%BD%E8%B1%A1"><span class="nav-number">16.1.</span> <span class="nav-text">着色器抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB-2"><span class="nav-number">16.2.</span> <span class="nav-text">应用类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B8%B2%E6%9F%93%E5%99%A8%E7%B1%BB"><span class="nav-number">17.</span> <span class="nav-text">OpenGL写一个基础的渲染器类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E7%BA%B9%E7%90%86"><span class="nav-number">18.</span> <span class="nav-text">OpenGL中的纹理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86"><span class="nav-number">18.1.</span> <span class="nav-text">纹理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="nav-number">18.2.</span> <span class="nav-text">第三方库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E7%B1%BB%E6%8A%BD%E8%B1%A1"><span class="nav-number">18.3.</span> <span class="nav-text">纹理类抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB-3"><span class="nav-number">18.4.</span> <span class="nav-text">应用类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%90%88"><span class="nav-number">19.</span> <span class="nav-text">OpenGL中的混合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88"><span class="nav-number">19.1.</span> <span class="nav-text">混合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E6%8E%A7%E5%88%B6"><span class="nav-number">19.2.</span> <span class="nav-text">混合控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6"><span class="nav-number">20.</span> <span class="nav-text">OpenGL中的数学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GLM%E5%BA%93"><span class="nav-number">20.1.</span> <span class="nav-text">GLM库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="nav-number">20.2.</span> <span class="nav-text">投影矩阵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="nav-number">21.</span> <span class="nav-text">OpenGL中的投影矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E8%A7%86%E5%9B%BE%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="nav-number">22.</span> <span class="nav-text">OpenGL中的模型视图投影矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9F%A9%E9%98%B5"><span class="nav-number">22.1.</span> <span class="nav-text">视图矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">22.2.</span> <span class="nav-text">模型矩阵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84ImGui"><span class="nav-number">23.</span> <span class="nav-text">OpenGL中的ImGui</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ImGui"><span class="nav-number">23.1.</span> <span class="nav-text">ImGui</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%B8%B2%E6%9F%93%E5%AF%B9%E8%B1%A1"><span class="nav-number">24.</span> <span class="nav-text">批量渲染对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BAOpenGL%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="nav-number">25.</span> <span class="nav-text">为OpenGL建立一个测试框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%B1%BB"><span class="nav-number">25.1.</span> <span class="nav-text">测试基类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E6%B5%8B%E8%AF%95"><span class="nav-number">25.2.</span> <span class="nav-text">颜色测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB-4"><span class="nav-number">25.3.</span> <span class="nav-text">应用类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95"><span class="nav-number">26.</span> <span class="nav-text">创建测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%8F%9C%E5%8D%95"><span class="nav-number">26.1.</span> <span class="nav-text">测试菜单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB-5"><span class="nav-number">26.2.</span> <span class="nav-text">应用类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%B9%E7%90%86%E6%B5%8B%E8%AF%95"><span class="nav-number">27.</span> <span class="nav-text">创建一个纹理测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="nav-number">27.1.</span> <span class="nav-text">纹理测试类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB-6"><span class="nav-number">27.2.</span> <span class="nav-text">应用类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F%E6%9B%B4%E5%BF%AB"><span class="nav-number">28.</span> <span class="nav-text">如何让统一变量更快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E6%B8%B2%E6%9F%93"><span class="nav-number">29.</span> <span class="nav-text">批渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">29.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">29.1.1.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2D%E6%B8%B8%E6%88%8F%E8%B4%B4%E5%9B%BE%E7%BB%98%E5%88%B6"><span class="nav-number">29.1.1.1.</span> <span class="nav-text">2D游戏贴图绘制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">29.1.1.2.</span> <span class="nav-text">粒子系统</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%B9%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="nav-number">29.1.2.</span> <span class="nav-text">批渲染测试类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">29.1.3.</span> <span class="nav-text">批处理着色器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB-7"><span class="nav-number">29.1.4.</span> <span class="nav-text">应用类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2"><span class="nav-number">29.2.</span> <span class="nav-text">颜色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8-1"><span class="nav-number">29.3.</span> <span class="nav-text">着色器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="nav-number">29.4.</span> <span class="nav-text">批处理测试类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86-1"><span class="nav-number">29.5.</span> <span class="nav-text">纹理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%87%A0%E4%BD%95"><span class="nav-number">29.6.</span> <span class="nav-text">动态几何</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">29.7.</span> <span class="nav-text">索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%91%E6%88%98%E4%B8%80%E5%B0%8F%E6%97%B6%E5%AE%8C%E6%88%90%E6%89%B9%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="nav-number">30.</span> <span class="nav-text">挑战一小时完成批渲染器</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">310</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">77</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/399504060" title="Bilibili → https://space.bilibili.com/399504060" rel="noopener" target="_blank"><i class="fa fa-th-large fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.6m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
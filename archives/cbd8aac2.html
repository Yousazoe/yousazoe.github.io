<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//fastly.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。"><meta property="og:type" content="article"><meta property="og:title" content="Cherno OpenGL教程"><meta property="og:url" content="https://yousazoe.top/archives/cbd8aac2.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/geexlab-opengl-21-demopack-20190921.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220513001615672.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220513001355838.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220515233624735.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220515233946266.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516000555444.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516000710441.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516230107887.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220517191158369.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519175413584.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519190823652.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519194358890.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521172242769.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521184045420.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521185412152.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523105558657.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523155149402.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523163539153.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523163715052.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523165538131.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523201100782.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/e6c9d24egy1h2lt68j6klj211x0kiq6s-20220526221235055.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/3H98MK.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/VJAoqd.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/R9IiGp.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/m3fzfo.png"><meta property="article:published_time" content="2022-05-11T15:39:16.000Z"><meta property="article:modified_time" content="2022-06-30T16:48:56.511Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="OpenGL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/geexlab-opengl-21-demopack-20190921.jpg"><link rel="canonical" href="https://yousazoe.top/archives/cbd8aac2.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Cherno OpenGL教程 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/cbd8aac2.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Cherno OpenGL教程</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-05-11 23:39:16" itemprop="dateCreated datePublished" datetime="2022-05-11T23:39:16+08:00">2022-05-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Cherno%E7%9A%84C-%E7%AC%94%E8%AE%B0-Cherno-C/" itemprop="url" rel="index"><span itemprop="name">Cherno的C++笔记 (Cherno C++)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>37k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>1:07</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/geexlab-opengl-21-demopack-20190921.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。</p><span id="more"></span><h3 id="欢迎来到OpenGL"><a href="#欢迎来到OpenGL" class="headerlink" title="欢迎来到OpenGL"></a>欢迎来到OpenGL</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=465609139&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>在这个视频中，主要包括 OpenGL 实际是什么、怎么使用它以及它能为我们做什么和它不是什么等等，这个系列也是如此。</p><h4 id="什么是OpenGL"><a href="#什么是OpenGL" class="headerlink" title="什么是OpenGL"></a>什么是OpenGL</h4><p>首先如果你听过 OpenGL 但不确定它是什么，你可能想到与图形有关的，那就是 OpenGL。OpenGL 是一种图形接口，现在 API 代表应用程序接口，基本上就是一大堆我们能够调用的函数去做一些事情。在这种情况下，由于 OpenGL 是一种图形 API，它允许我们做一些与图形相关的事情，特别的是它允许我们访问 GPU 也就是显卡，图形处理单元（Graphics Processing Unit）。</p><p>调用显卡也更好地绘制图形，所以实际上为了利用电脑或其他设备（比如手机）中强大的图形处理器，需要调用一些 API 访问固件。OpenGL 正好是允许访问和操作 GPU 的许多接口中的一种，当然我们也有一些其他的接口，比如 Direct3D、Vulcan 和 Metal 等等，所以某种角度来说 OpenGL 允许我们控制显卡。</p><h4 id="关于OpenGL误解"><a href="#关于OpenGL误解" class="headerlink" title="关于OpenGL误解"></a>关于OpenGL误解</h4><p>让我们来澄清一些人关于 OpenGL 的误解。</p><p>首先，许多人称它为一个类库或一种引擎或一些其他的框架，但这些都不是。OpenGL 核心本身只是一种规范，和 CPP 规范差不多。实际上它没有确定任何代码和类似的事情本身就是规范，比如“嘿，这个函数应该存在，需要这些参数并且返回这个值”，它只是一种你能利用这种 API 做什么规范，没有任何具体的实现，这意味它绝不是一个类库，因为 OpenGL 本身没有代码，它只是一种规范。</p><br><p>去哪儿下载 OpenGL 是另一个常见的问题。</p><p>然而，答案是你不需要真的去下载 OpenGL，它本身只是一种规范。那么，谁去实现它呢，谁去为你调用的 OpenGL 函数写代码呢？这个答案是 GPU 制造商，所以如果你使用的是 NVIDIA 显卡，那么你的显卡驱动（也就是 NVIDIA 驱动）实际上包含了 OpenGL 的实现，每个显卡制造商比如 AMD、Intel 等都会有它们自己的实现，每家关于 OpenGL 的实现都会有些不同，这也就是有些游戏能在 NVIDIA 驱动的显卡上运行但在一个 AMD 电视或者其他显卡设备上运行有些区别、甚至会出现问题的原因。</p><p>但不管怎么说，关键在于你的显卡制造商实现的 OpenGL，这又可能导致下一个有关 OpenGL 常见的误解：它是开源的。我不知道人们为什么会这么觉得，也许是名字中带着“Open”，但是它根本不是开源的，你看不到 OpenGL 的源码，因为首先它是由 GPU 制造商实现的，它们肯定不会发布它们的驱动源码。</p><br><p>OpenGL 提供了什么能激发和导致许多人不幸地说 OpenGL 是无与伦比的？原因在于它是跨平台的，所以你的 OpenGL 代码可以在 Windows、Mac、Linux 和 Android 上正常执行，以至于人们立马就会意识到 OpenGL 比 Direct3D 更优越，因为它能在所有平台上运行，但是请不要这么说。</p><p>从我 EA 技术中心并处理过许多引擎中图形接口的经验来看，因为 OpenGL 是跨平台的 API，而制作一款游戏不会只涉及实现一个独立的图形 API。如果游戏引擎是跨平台的，那意味着它不仅实现了 Xbox，也包括其他一些平台，它们不得不实现大量其他的图形接口。</p><p>因此，我们面临的问题是图形 API 是为特定平台设计的。例如 Direct3D 是微软为 Windows 设计的，它在 Windows 上的表现要比跨平台的 API 好些。现在请记住，实际编写这些代码的人不是微软，即使微软的确为了更好的代码质量和 GPU 制造商合作过。所以关于 API 的比较是没有任何意义的，因为通常平台原生的东西会更健壮更友好。</p><br><p>就 OpenGL 的复杂性而言，它可以说是现在可以学习的最简单的 API 了，所以 OpenGL 是绝对值得学习的。Vulkan 是另一个跨平台的 API，但它更底层更严谨，不适合初学者直接入门，老实说我并不想使用 Vulkan 去开发游戏，OpenGL 更加稳定。</p><h4 id="传统与现代OpenGL"><a href="#传统与现代OpenGL" class="headerlink" title="传统与现代OpenGL"></a>传统与现代OpenGL</h4><p>另外本系列学习的主要是现代 OpenGL。OpenGL 于 90 年代发布，那时的情况和现在大不相同，那时的 GPU 是可编程的，十分灵活，制造商给了程序员和开发者更多的控制权。</p><p>传统 OpenGL 和现代 OpenGL 之间最大的区别就是着色器。如果你对图形学感兴趣的话可能听说过着色器，它可能有点像 shadow 这个单词或者是光源，有些人将它和光源或其他比较。抛开这些，着色器是程序，它是在你 GPU 上运行的代码，这就是着色器，它是在你 GPU 上运行的一段程序。。</p><p>那么如果你用 C++、Java 或 C# 或不管什么语言写代码，这段代码都会运行在你的 CPU 上。但当我们开始处理图形的大部分时间里，我们想要更为精确的控制显卡运行，可能要将大部分代码从 CPU 转到 GPU 上，因为它在 GPU 上运行更快，这就是着色器存在的意义：允许我们在 GPU 上运行代码。所以可编程的着色器是最大的区别。</p><h3 id="设置OpenGL和C-中创建一个窗口"><a href="#设置OpenGL和C-中创建一个窗口" class="headerlink" title="设置OpenGL和C++中创建一个窗口"></a>设置OpenGL和C++中创建一个窗口</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=466583251&amp;page=2&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>上一节我们只说了 OpenGL 到底是什么以及这个系列实际会讲什么。今天我们的任务是让我的操作系统为我创造一个窗口，在未来我们可能会在窗口内绘制图形。</p><br><p>我们会使用一个向我提供窗口创建和窗口管理的实际代码类库，不管 Windows、Mac 还是 Linux。GLFW 就是满足上述条件的类库，我喜欢这个类库的原因是它确实是一个轻量级类库，它虽然不如 SDL 那么全面（实际上它就是个渲染器），但依然可以创建窗口、OpenGL context 以及给我们访问一些类似输入之类的基础东西。</p><h4 id="下载类库"><a href="#下载类库" class="headerlink" title="下载类库"></a>下载类库</h4><p>由于我使用的是 Mac，所以使用 brew 下载：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">brew install glew</span><br><span class="line">brew install glfw   </span><br></pre></td></tr></tbody></table></figure><p>下载后默认的路径为 <code>/usr/local/Cellar/</code>。</p><h4 id="配置CMake文件"><a href="#配置CMake文件" class="headerlink" title="配置CMake文件"></a>配置CMake文件</h4><p>我将项目名称设置为 <code>OpenGL</code>，在 CLion 中配置：</p><figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(OpenGL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add head file</span></span><br><span class="line"><span class="keyword">set</span>(GLEW_H /usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/<span class="keyword">include</span>/GL)</span><br><span class="line"><span class="keyword">set</span>(GLFW_H /usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">7</span>/<span class="keyword">include</span>/GLFW)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${GLEW_H}</span> <span class="variable">${GLFW_H}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add target link</span></span><br><span class="line"><span class="keyword">set</span>(GLEW_LINK /usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/lib/libGLEW.<span class="number">2.2</span>.dylib)</span><br><span class="line"><span class="keyword">set</span>(GLFW_LINK /usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">7</span>/lib/libglfw.<span class="number">3</span>.dylib)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">${OPENGL}</span> <span class="variable">${GLEW_LINK}</span> <span class="variable">${GLFW_LINK}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(OpenGL <span class="variable">${SOURCE_FILES}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (APPLE)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(OpenGL <span class="string">"-framework OpenGL"</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(OpenGL <span class="string">"-framework GLUT"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></tbody></table></figure><h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><p>复制下面内容到 <code>main.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行代码，我们会得到一个黑色的窗口。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220513001615672.png"></p><h4 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h4><p>下面我们用传统 OpenGL 设定三个顶点，绘制一个三角形：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;glew.h&gt;</span><br><span class="line">#include &lt;glfw3.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    /* Initialize the library */</span><br><span class="line">    if(!glfwInit())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    /* Create a Windowed mode and its OpenGL context */</span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);</span><br><span class="line">    if(!window)</span><br><span class="line">    {</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /* Make the window's context current */</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    /* Loop until the user closes the window */</span><br><span class="line">    while(!glfwWindowShouldClose(window))</span><br><span class="line">    {</span><br><span class="line">        /* Render here */</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="addition">+       glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="addition">+       glVertex2f(-0.5f, -0.5f);</span></span><br><span class="line"><span class="addition">+       glVertex2f( 0.0f,  0.5f);</span></span><br><span class="line"><span class="addition">+       glVertex2f( 0.5f, -0.5f);</span></span><br><span class="line"><span class="addition">+       glEnd();</span></span><br><span class="line"></span><br><span class="line">        /* Swap front and back buffers */</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        /* Poll for and events */</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220513001355838.png"></p><h3 id="在C-中使用现代OpenGL"><a href="#在C-中使用现代OpenGL" class="headerlink" title="在C++中使用现代OpenGL"></a>在C++中使用现代OpenGL</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=3&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="顶点缓冲区和在现代OpenGL中画一个三角形"><a href="#顶点缓冲区和在现代OpenGL中画一个三角形" class="headerlink" title="顶点缓冲区和在现代OpenGL中画一个三角形"></a>顶点缓冲区和在现代OpenGL中画一个三角形</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=4&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>现代 OpenGL 比那种传统 OpenGL 更具可编程性，它的扩展性更好也更加强大，你可以用它做许多事情，但代价是在绘制一个简单三角形前，我们实际上需要做很多设置。而前面我们已经用传统方法简单绘制了三角形，非常简单并且不需要什么设置。</p><p>让我们聊聊需要什么东西才可以绘制一个三角形。对于现代 OpenGL 而言，首先我们需要能够创建一个顶点缓冲区，然后还要创建一个着色器（之后可能会单独讲一下图形渲染管线是如何运行的，特别是 OpenGL）。让我们快速地说一下这两个东西是什么吧。</p><h4 id="顶点缓冲区与着色器"><a href="#顶点缓冲区与着色器" class="headerlink" title="顶点缓冲区与着色器"></a>顶点缓冲区与着色器</h4><p>顶点缓冲区基本上就是去掉 vertex，它只是一个内存缓冲区，一个内存字节数组，从字面上讲就是一块用来存字节的内存。但是顶点缓冲区又和 C++ 中像字符数组的内存缓冲区不太一样，它是 OpenG 中的内存缓冲区，这意味着它实际上在显卡显存（Video RAM）上。</p><p>所以这里的基本思路就是我要定义一些数据来表示三角形，我要把它放入显卡的 VRAM 中，然后还需要发出 DrawCall 绘制指令。实际上我们还需要告诉显卡如何读取和解释这些数据，以及如何把它放到我们屏幕上，一旦我们发出 DrawCall 指令，我们需要告诉显卡：好了，一旦你在显卡端获得了这些数据，我要你像这样把它摆出来，我希望你把它画出来在屏幕上给我显示一个三角形。所以我们需要告诉显卡怎么做，需要对显卡编程，这就是着色器，着色器只是一个运行在显卡上的程序，它是一堆我们可以编写的在显卡上以一种非常特殊的方式运行的代码。</p><br><p>听起来很复杂，但是不要想太多。简而言之我们有一个可以指定的内存，还有一些我可以指定的数据，告诉显卡：嘿，这是数据。然后从显卡那边说：好了，现在读一下这些数据并解释一下（例如屏幕上的位置），可能的话把它们连成一个三角形。这就是整件事的原理，也是 OpenGL 渲染的流程。</p><p>要注意 OpenGL 是作为一个状态机来运行的，这意味着你不必把它当作一个对象或任何类似的东西来对待，你所做的是设置一系列的状态，然后当你说一些事比如给我画一个三角形，这是非常 contextual 的。我的意思是，我不只是说，嘿，给我画一个三角形，然后传递 OpenGL 需要绘制三角形的所有东西。实际上它已经知道画三角形需要什么了，因为那是状态的一部分。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><p>让我们来创建这个顶点缓冲区来看看能做些什么。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line"><span class="built_in">glVertex2f</span>(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line"><span class="built_in">glVertex2f</span>( <span class="number">0.0f</span>,  <span class="number">0.5f</span>);</span><br><span class="line"><span class="built_in">glVertex2f</span>( <span class="number">0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></tbody></table></figure><p>这是之前使用传统 OpenGL 绘制三角形的代码。现代 OpenGL 需要创建顶点缓冲区，发送到 OpenGL 显存，然后发出一个 DrawCall 指令说：嘿，请画出我的缓冲区。</p><p>首先我们要创建自己的缓冲区，这个过程非常简单，只需要调用 <code>glGenBuffers()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220515233624735.png"></p><p>第一个参数指定需要几个缓冲区；第二个参数指定返回整数的内存地址，这也是生成的缓冲区的 id。记住 OpenGL 是作为一个状态机工作，这意味着你可以生成一切，而 OpenGL 中生成所有东西都分配了一个唯一的标识符，它只是一个整数，也是你实际对象的 id，当你想要使用这个对象的时候就用这个数字。</p><p>因为我要渲染我的三角形，需要说明用哪个缓冲区来渲染三角形，只需要传递这个整数即可。现在我们有了这个 id，一旦创建缓冲区后，我们现在就要选择那个缓冲区。选择（Selecting）在 OpenGL 中被称为绑定（Binding）:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220515233946266.png"></p><p>下一步是指定数据。一个简单的方式是在声明数据的时候直接把顶点数据填充进去：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着调用 <code>glBufferData()</code> ，查阅文档：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516000555444.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516000710441.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure><p>很好，现在我们为 OpenGL 指定了 <code>positions</code>，通常还需要创建一个索引缓冲区，也都是后话了。不过我们还没有着色器，去解释如何用这些数据进行绘制，我们将在下一期讨论那个问题。今天我们要做的只是想看看能不能把它绘制出来。</p><p>在没有索引缓冲区的情况下我们可以调用 <code>glDrawArrays()</code> 绘制指定图元：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/* Render here */</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="deletion">-glVertex2f(-0.5f, -0.5f);</span></span><br><span class="line"><span class="deletion">-glVertex2f( 0.0f,  0.5f);</span></span><br><span class="line"><span class="deletion">-glVertex2f( 0.5f, -0.5f);</span></span><br><span class="line"><span class="deletion">-glEnd();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br></pre></td></tr></tbody></table></figure><p>我喜欢用 Photoshop 打比方。如果我选择一个图层，然后在该图层上用画笔绘制一些东西，它只会影响这一图层。然而如果我没有选择任何东西或者选错了东西，它不会影响到我想绘制的那个图层。OpenGL 也是一样，在使用它之前你需要选择或绑定所有东西，因为这就是它的运行原理，它是上下文相关的，它是一个状态机。</p><h3 id="OpenGL中顶点的属性和布局"><a href="#OpenGL中顶点的属性和布局" class="headerlink" title="OpenGL中顶点的属性和布局"></a>OpenGL中顶点的属性和布局</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=5&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>上一节我们讨论了顶点缓冲区，但实际上有一些部分我们忽略了：顶点属性和着色器。今天我们将学习顶点属性。</p><h4 id="顶点属性"><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h4><p>所以什么是顶点属性？OpenGL 渲染管线的工作原理是我们为我们的显卡提供数据，我们在显卡上存储一些内存，它包含了我们想要绘制的所有数据；然后我们使用一个着色器在显卡上读取数据，并且完全显示在屏幕上。</p><p>通常我们绘制几何图元的方式就是使用一个叫顶点缓冲区的东西，也就是一个存储在显卡上的内存缓冲区，所以当对着色器编程时实际上是从读取顶点缓冲区开始的，它需要知道缓冲区的布局，这个缓冲区包含的浮点数指定了每个顶点的位置、纹理坐标、法线之类的。</p><h4 id="代码实践-1"><a href="#代码实践-1" class="headerlink" title="代码实践"></a>代码实践</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在我继续之前想先定义顶点是什么意思，因为人们在错误的使用这个词。</p><p>顶点与位置无关，顶点就是几何图形上的一个点。大多数人在视觉上对它们的明显印象是通过它的位置，所以如果我给你画一个三角形，你会看到三个顶点。但顶点不是位置，一个顶点可以不仅仅包含一个位置，顶点可以包含位置更多的数据例如纹理坐标、法线、颜色等等，它们可能都在一个顶点。所以我们需要告诉 OpenGL 外面的数据布局，调用 <code>glVertexAttribPointer()</code> 函数。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516230107887.png"></p><ul><li><p><code>index</code>：Specifies the index of the generic vertex attribute to be modified.</p><p>基本上我们的着色器读取所有这些的方式是通过索引。一般来说如果我们有一个位置在索引 0 处，我们需要把它作为索引 0 来引用；而当我们有三种属性，我想让我的位置在下标 0，纹理坐标在索引 1，法线在索引 2.所以当我开始从着色器和显卡读取数据时，然后进入那个缓冲区，我可以简单地引用它们。这就是索引，它只是缓冲区实际属性的索引。</p></li><li><p><code>size</code>：Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant <code>GL_BGRA</code> is accepted by <code>glVertexAttribPointer</code>. The initial value is 4.</p><p>这里的 <code>size</code> 可能有点误导人，它是每个通用顶点属性的组件数，只能是 1，2，3，4。所以这个 <code>size</code> 和字节没有关系，和它们实际占用了多少内存也没关系。在本例中每个顶点的坐标有 x 和 y 两组分量，所以 <code>size</code> 为 2。</p></li><li><p><code>type</code>：Specifies the data type of each component in the array. The symbolic constants <code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>, <code>GL_UNSIGNED_SHORT</code>, <code>GL_INT</code>, and <code>GL_UNSIGNED_INT</code> are accepted by <code>glVertexAttribPointer</code> and <code>glVertexAttribIPointer</code>. Additionally <code>GL_HALF_FLOAT</code>, <code>GL_FLOAT</code>, <code>GL_DOUBLE</code>, <code>GL_FIXED</code>, <code>GL_INT_2_10_10_10_REV</code>, <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> and <code>GL_UNSIGNED_INT_10F_11F_11F_REV</code> are accepted by <code>glVertexAttribPointer</code>. <code>GL_DOUBLE</code> is also accepted by <code>glVertexAttribLPointer</code> and is the only token accepted by the <em><code>type</code></em> parameter for that function. The initial value is <code>GL_FLOAT</code>.</p><p>这里是我们指定数据类型 <code>type</code>，在本例中则是位置的浮点类型 <code>GL_FLOAT</code>。</p></li><li><p><code>normalized</code>：For <code>glVertexAttribPointer</code>, specifies whether fixed-point data values should be normalized (<code>GL_TRUE</code>) or converted directly as fixed-point values (<code>GL_FALSE</code>) when they are accessed.</p><p>标准化其实不用太担心，如果我们处理的是浮点数，因为它们已经被规范化了。假设我们要指定一个颜色字节在 0 到 255 之间，它在我们的实际着色器作为一个浮点数需要被规范化到 0 到 1 之间，这不是一个你可以在 CPU 上做的事情，但你可以让 OpenGL 替你做。</p></li><li><p><code>stride</code>：Specifies the byte offset between consecutive generic vertex attributes. If <em><code>stride</code></em> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</p><p><code>stride</code> 指针会让很多人感到困惑，如文档所示它就是连续通用顶点属性之间的字节偏移量，也可以理解为每个顶点之间的字节数。举个例子我们有位置 <code>vec3</code>、纹理坐标 <code>vec2</code> 和法线 <code>vec3</code>，那么我们的 stride 就是 3 * 4 + 2 * 4 + 3 * 4 = 32 字节，它是每个顶点的字节大小。</p><p>如果我们想从一个顶点跳到下一个顶点，我需要在缓冲区中加上 32 个字节。所以如果我们有一个指针指向缓冲区的开始，然后经过缓冲区的 32 个字节，我应该在下一个顶点的起点，这就是 stride。</p></li><li><p><code>pointer</code>:Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the <code>GL_ARRAY_BUFFER</code> target. The initial value is 0.</p><p><code>pointer</code> 文档的表述上第一个组件的一个偏移量，它是指向实际属性的指针。不要管有多少个顶点，聚焦于一个顶点，里面包含位置、纹理坐标和法线。对于位置偏移量为 0，因为它是缓冲区的第一个字节；然后我们前进 12 个字节到达纹理坐标，所以对于我的纹理坐标属性这个值（pointer）是 12；最后再前进 8 字节得到顶点的法线，所以对于顶点法线属性 20 是这个 pointer 的值。</p></li></ul><p>最后别忘了调用 <code>glEnableVertexAttribArray()</code> 去启用 <code>glVertexAttribPointer()</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p>这两段代码告诉 OpenGL 缓冲区的布局是什么，理论上如果有一个着色器就可以看到在屏幕上看到三角形了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">            <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">             <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">             <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220517191158369.png"></p><h3 id="OpenGL中着色器的原理"><a href="#OpenGL中着色器的原理" class="headerlink" title="OpenGL中着色器的原理"></a>OpenGL中着色器的原理</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=6&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们讨论的都是关于着色器。</p><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>每个新手脑海里的第一个问题是什么是着色器？</p><p>着色器就是一个运行在显卡上的程序代码，它是我们可以在计算机上以文本或者字符串形式编写的代码，然后我们可以把它给 OpenGL 发到显卡上像其他程序一样编译链接，最后运行它，不同的是它是在我们的显卡上运行而不是 C++ 那样在我们的 CPU 上。那么为什么我们需要程序完全在显卡上运行呢？</p><p>究其原因是我们希望能够告诉显卡该做些什么，显卡处理图形的速度要快得多，我们想要利用显卡的能力在屏幕上绘制图形。这并不意味着所有的工作必须在显卡上完成，CPU 有自己擅长的部分，也许之后我们可以将结果数据发送给显卡同时仍然在 CPU 上进行处理。</p><h4 id="着色器类型"><a href="#着色器类型" class="headerlink" title="着色器类型"></a>着色器类型</h4><p>对于大多数图形编程，我们会把重点放在两种着色器：顶点着色器和片段着色器（又称像素着色器）。</p><p>虽然还没有正式讲过标准图形渲染管线，但是我们应该对它大致是如何工作的应该了解：我们在 CPU 上写了一堆数据，向显卡发送这些数据并且发出一个叫做 DrawCall 指令的东西，也绑定了某些状态，最后我们进入了着色器阶段，GPU 实际处理 DrawCall 指令并在屏幕上绘制一些东西。这个特定的过程基本上就是渲染管道，我们如何在屏幕上从数据到结果的。</p><p>现在当显卡开始绘制三角形时，着色器就派上用场了。顶点着色器和片段着色器是渲染管线两种不同的着色器类型，所以当我们真正发出 DrawCall 指令时，顶点着色器会被调用，然后片段着色器会被调用，最后我们会在屏幕上看到结果。</p><br><h5 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h5><p>那么顶点着色器是做什么的？</p><p>它会被我们渲染的每个顶点调用，在这个例子中我们有一个三角形三个顶点，这意味着顶点着色器会被调用三次，每个顶点调用一次。顶点着色器的主要目的是告诉 OpenGL 你希望这个顶点在屏幕空间的什么位置。再强调一次，顶点着色器的主要目的是提供那些顶点的位置，如果有必要我们需要能够提供一些变换以便 OpenGL 能把这些数字转化成屏幕坐标，这样我们就能在窗口中看到我们的图形在对的位置。</p><h5 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h5><p>一旦顶点着色器运行结束，我们就进入了管道的下一个阶段：片段着色器或者像素着色器。</p><p>虽然片段和像素在术语上有点小差别，但现在你可以把像素当成片段或者把片段想象成像素，因为片段着色器会为每个需要光栅化的像素运行一次。我们的窗口基本上是由像素组成的，我们指定的那三个顶点组成我们的三角形现在需要用实际的像素填充，这就是光栅化阶段所做的。</p><p>片段着色器或像素着色器就是对三角形中需要填充的每个像素调用一次，主要决定这个像素是什么颜色，这就是它的作用，它决定了像素的输出颜色，这样像素就可以用正确的颜色着色。形象一点可以把它想象成一本涂色本，当你只有东西的轮廓时需要给它上色，这就是片段着色器的职责。</p><br><p>相比于顶点着色器，片段着色器里面的东西代价要高得多，因为它会为每个像素运行。</p><p>话虽如此，有些东西显然需要按像素计算例如光源。如果你在计算光源，每个像素都有一个颜色值，这个值是由很多东西决定：光源、环境、纹理、提供给表面的材质……所有这些一起来确定一个特定像素的正确颜色。显然这取决于一些输入，例如相机的位置在哪里，而这些所有的东西结束后你在片段着色器中的决定仅仅是单个像素的颜色，这就是片段着色器的作用。</p><h3 id="OpenGL中写一个着色器"><a href="#OpenGL中写一个着色器" class="headerlink" title="OpenGL中写一个着色器"></a>OpenGL中写一个着色器</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=7&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>让我们开始写一些着色器代码吧。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先创建一个 <code>CreateShader()</code> 创建着色器函数，传入两个着色器字符串，这些字符串都是实际的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>和创建缓冲区一致，我们需要返回一个整型作为标识符，当我们想绑定的时候可以绑定那个缓冲区 id。</p><p>所以我们要做的第一件事就是创建一个程序，基本上我们只需要输入 <code>glCreateProgram()</code>，该函数不需要传入整数引用之类的东西，它会返回一个无符号的整数（顺带一提，这里和后面不使用 OpenGL 自带类型的原因是个人处理多种类型的图形 API，更倾向于 C++ 类型）：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br></pre></td></tr></tbody></table></figure><p>接下来我们需要做的是创建我们的两个着色器对象：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br></pre></td></tr></tbody></table></figure><p>考虑到这个工作在今后的复用性，可以另创建一个函数 <code>CompileShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后可以加一个初始化函数，查找字符串中的第一个字符然后返回它的内存地址：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// const char* src = &amp;source[0];</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br></pre></td></tr></tbody></table></figure><p>最后就是调用 <code>glShaderSource()</code> 和 <code>glCompileShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到 <code>CreateShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个过程很像 C++编译中将两个不同的文件链接在一起，以便可以同时使用它们：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="built_in">glValidateProgram</span>(program);</span><br></pre></td></tr></tbody></table></figure><p>最后我们实际上现在可以删了我们的着色器，因为它们已经被链接到一个程序中，所以我们可以删除这些中间文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fs);</span><br></pre></td></tr></tbody></table></figure><p>最终我们的函数源码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>让我们快速做一下这个错误处理。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译着色器实际上不会返回任何东西，所以如果任何东西出错我们无法检索找出问题。但我们可以通过调用 <code>glGetShaderiv()</code> 实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br></pre></td></tr></tbody></table></figure><p>判断 <code>result</code>，检索错误信息的长度并输出信息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to complie "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="着色器编写"><a href="#着色器编写" class="headerlink" title="着色器编写"></a>着色器编写</h4><p>首先 <code>#version 330 core</code> 意味着我们将使用 GLSL（OpenGL 的着色器），其次指定位置和颜色：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line">std::string vertexShader = R"(</span><br><span class="line">    <span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">gl_Position</span> = position;</span><br><span class="line">    }</span><br><span class="line">)";</span><br><span class="line"></span><br><span class="line">std::string fragmentShader = R"(</span><br><span class="line">    <span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()</span><br><span class="line">    {</span><br><span class="line">        color = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    }</span><br><span class="line">)";</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span>(result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">" shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Window"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    std::string vertexShader =</span><br><span class="line">    <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"layout(location = 0) in vec4 position;\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"{\n"</span></span><br><span class="line">    <span class="string">"   glPosition = position;\n"</span></span><br><span class="line">    <span class="string">"}\n"</span>;</span><br><span class="line">    </span><br><span class="line">    std::string fragmentShader =</span><br><span class="line">    <span class="string">"#version 450 core\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"layout(location = 0) out vec4 colour;\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"{\n"</span></span><br><span class="line">    <span class="string">"   colour = vec4(1.0, 0.0, 0.0, 1.0);\n"</span></span><br><span class="line">    <span class="string">"}\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="整理错误"><a href="#整理错误" class="headerlink" title="整理错误"></a>整理错误</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Failed to compile vertex shader!</span><br><span class="line">ERROR: 0:1: '' :  version '330' is not supported</span><br><span class="line">ERROR: 0:1: '' : syntax error: #version</span><br><span class="line">ERROR: 0:3: 'layout' : syntax error: syntax error</span><br><span class="line"></span><br><span class="line">Failed to compile fragment shader!</span><br><span class="line">ERROR: 0:1: '' :  version '450' is not supported</span><br><span class="line">ERROR: 0:1: '' : syntax error: #version</span><br><span class="line">ERROR: 0:3: 'layout' : syntax error: syntax error</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519175413584.png"></p><p>在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/62990972/why-is-opengl-giving-me-the-error-error-01-version-330-is-not-support">stackoverflow</a> 有人遇到了相同的问题，解决方法如下：</p><ol><li>add these line of code in front of <code>glCreateWindow</code></li><li>add VAO as @Ali ASkari memtion above (Modern OpenGL requires a VAO be defined and bound if you are using the core profile.)</li></ol><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// GLEW</span><br><span class="line">#include &lt;glew.h&gt;</span><br><span class="line"></span><br><span class="line">// GLFW</span><br><span class="line">#include &lt;glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">static unsigned int CompileShader(unsigned int type, const std::string&amp; source)</span><br><span class="line">{</span><br><span class="line">    unsigned int id = glCreateShader(type);</span><br><span class="line">    const char* src = source.c_str();</span><br><span class="line">    glShaderSource(id, 1, &amp;src, nullptr);</span><br><span class="line">    glCompileShader(id);</span><br><span class="line"></span><br><span class="line">    // TODO: Error handling</span><br><span class="line">    int result;</span><br><span class="line">    glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    if (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        int length;</span><br><span class="line">        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">        char* message = (char*)alloca(length * sizeof(char));</span><br><span class="line">        glGetShaderInfoLog(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "Failed to complie " &lt;&lt; (type == GL_VERTEX_SHADER ? "vertex" : "fragment") &lt;&lt; "shader!" &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        glDeleteShader(id);</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">static unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader)</span><br><span class="line">{</span><br><span class="line">    unsigned int program = glCreateProgram();</span><br><span class="line">    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    glAttachShader(program, vs);</span><br><span class="line">    glAttachShader(program, fs);</span><br><span class="line">    glLinkProgram(program);</span><br><span class="line">    glValidateProgram(program);</span><br><span class="line"></span><br><span class="line">    glDeleteShader(vs);</span><br><span class="line">    glDeleteShader(fs);</span><br><span class="line"></span><br><span class="line">    return program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    /* Initialize the library */</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">    if(!glfwInit())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span></span><br><span class="line"><span class="addition">+   #ifdef __APPLE__</span></span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; "I'm apple machine" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+       glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line"><span class="addition">+   #endif</span></span><br><span class="line">    unsigned int width = 800;</span><br><span class="line">    unsigned int height = 600;</span><br><span class="line">    /* Create a Windowed mode and its OpenGL context */</span><br><span class="line">    window = glfwCreateWindow(width, height, "Hello World", NULL, NULL);</span><br><span class="line">    if(!window)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; " can't create window!!!" &lt;&lt; std::endl;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    unsigned int major = glfwGetWindowAttrib(window, GLFW_CONTEXT_VERSION_MAJOR);</span><br><span class="line">    unsigned int minor = glfwGetWindowAttrib(window, GLFW_CONTEXT_VERSION_MINOR);</span><br><span class="line">    std::cout &lt;&lt; "opengl shader version: " &lt;&lt; major &lt;&lt; "." &lt;&lt; minor &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    /* Make the window's context current */</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(glewInit() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    float positions[6] = {</span><br><span class="line">            -0.5f, -0.5f,</span><br><span class="line">             0.0f,  0.5f,</span><br><span class="line">             0.5f, -0.5f</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="addition">+   unsigned int VBO, VAO;</span></span><br><span class="line"><span class="addition">+   glGenBuffers(1, &amp;VBO);</span></span><br><span class="line"><span class="addition">+   glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="addition">+   glBindVertexArray(VAO);</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glEnableVertexAttribArray(0);</span><br><span class="line">    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);</span><br><span class="line"></span><br><span class="line">    std::string vertexShader = R"(</span><br><span class="line">        #version 330 core</span><br><span class="line"></span><br><span class="line">        layout(location = 0) in vec4 position;</span><br><span class="line"></span><br><span class="line">        void main()</span><br><span class="line">        {</span><br><span class="line">            gl_Position = position;</span><br><span class="line">        }</span><br><span class="line">    )";</span><br><span class="line"></span><br><span class="line">    std::string fragmentShader = R"(</span><br><span class="line">        #version 330 core</span><br><span class="line"></span><br><span class="line">        layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line">        void main()</span><br><span class="line">        {</span><br><span class="line">            color = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">        }</span><br><span class="line">    )";</span><br><span class="line"></span><br><span class="line">    unsigned int shader = CreateShader(vertexShader, fragmentShader);</span><br><span class="line">    glUseProgram(shader);</span><br><span class="line"></span><br><span class="line">    /* Loop until the user closes the window */</span><br><span class="line">    while(!glfwWindowShouldClose(window))</span><br><span class="line">    {</span><br><span class="line">        /* Render here */</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line"></span><br><span class="line">        /* Swap front and back buffers */</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        /* Poll for and events */</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="addition">+   glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line">    glDeleteProgram(shader);</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519190823652.png"></p><h3 id="OpenGL中如何处理着色器"><a href="#OpenGL中如何处理着色器" class="headerlink" title="OpenGL中如何处理着色器"></a>OpenGL中如何处理着色器</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=8&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>个人习惯将两个着色器合并到一个只有顶点和片段着色器的文件中。不管怎样，让我们进入代码展示这一切的原理。</p><h4 id="着色器合并"><a href="#着色器合并" class="headerlink" title="着色器合并"></a>着色器合并</h4><p>首先我们实际上要做的是创建一个包含这两个着色器的文件，以便我们了解是如何处理它们的。</p><p>在项目目录中创建一个放置资源的 <code>res</code> 文件夹，在该文件夹下创建专门放置着色器的 <code>shaders</code> 文件夹，在之后我们可能会有像纹理之类的其他资源。最后在 <code>shaders/</code> 下新建文件 <code>Basic.shader</code>：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519194358890.png"></p><p>现在我们有了一个着色器文本，你可以看到它没有显示 C++ 图标，这非常重要因为我们不想把它编译成 C++ 代码。将之前的着色器代码复制粘贴到文件中：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">gl_Position</span> = position;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment    </span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    color = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们就无需在两个不同的着色器文件之间切换，并且很简单干净有条理。</p><h4 id="着色器读取与使用"><a href="#着色器读取与使用" class="headerlink" title="着色器读取与使用"></a>着色器读取与使用</h4><p>下面我们要做的就是读取这个文件，然后把它分成两块字符串，一个是我们的片段着色器，而另一个就是我们的顶点着色器源码。引入头文件 <code>#include&lt;fstream&gt;</code>，打开文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::fstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以现在我们需要做的就是一行一行地浏览那个文件，然后只去检查是否是指定的着色器类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">            <span class="comment">// set mode to vertex</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>添加着色器类型并在分支设定正确的类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">    NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">            type = ShaderType::VERTEX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">            type = ShaderType::FRAGMENT;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;            </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">	{</span><br><span class="line">		NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	std::string line;</span><br><span class="line">	std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">	ShaderType type = ShaderType::NONE;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::VERTEX;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::FRAGMENT;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">		<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">	<span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">	<span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">	<span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">			<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">			 <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">			 <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">	<span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 Mac 出现的各种错误太多了，相同代码跑不通太浪费时间了，所以还是转到了 Windows 上：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521172242769.png"></p><h3 id="OpenGL中的索引缓冲区"><a href="#OpenGL中的索引缓冲区" class="headerlink" title="OpenGL中的索引缓冲区"></a>OpenGL中的索引缓冲区</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=9&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们会讨论索引缓冲区。</p><h4 id="绘制四边形"><a href="#绘制四边形" class="headerlink" title="绘制四边形"></a>绘制四边形</h4><p>在我们讨论索引缓冲区为什么用它以及它到底是什么之前，让我们先考虑一个图形编程的基础的问题：去画一个正方形。</p><p>显然我们可以通过拼接两个三角形实现，先画出来第一个三角形：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521184045420.png"></p><p>回到我们的代码增加另一个三角形的三个顶点（其中两个顶点与第一个三角形重合）：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+float positions[12] = {</span></span><br><span class="line">    -0.5f, -0.5f,</span><br><span class="line">     0.5f, -0.5f,</span><br><span class="line">     0.5f,  0.5f,</span><br><span class="line"></span><br><span class="line"><span class="addition">+    0.5f,  0.5f,</span></span><br><span class="line"><span class="addition">+   -0.5f,  0.5f,</span></span><br><span class="line"><span class="addition">+   -0.5f, -0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>同时更改一下缓冲区的设置：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">unsigned int buffer;</span><br><span class="line">glGenBuffers(1, &amp;buffer);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="addition">+glBufferData(GL_ARRAY_BUFFER, 6 * 2 * sizeof(float), positions, GL_STATIC_DRAW);</span></span><br></pre></td></tr></tbody></table></figure><p>由于我们绘制的是六个顶点，所以这里也要改：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521185412152.png"></p><p>这里不是正方形的原因是因为窗口原因。</p><p>很酷！我们已经画出了一个正方形，它并不太难，但是绘制这个正方形的方式有些东西不太理想：我们的两个顶点是完全一样的，也就是在复制我们的内存，我们在显存中存储相同顶点的相同字节，存储了多次。因为显存并不是无限的，而我们想要降低它的内存使用。</p><h4 id="索引缓冲区"><a href="#索引缓冲区" class="headerlink" title="索引缓冲区"></a>索引缓冲区</h4><p>所以我们能做的就是使用一个叫做索引缓冲区的东西，这允许我们重用现有的顶点。对于矩形或者正方形而言可能还好，它看起来可能并不浪费，因为它没有太多的东西。然而当它换成游戏中的 3D 模型如宇宙飞船，每一个组成那个飞船的独立三角形会被连接到另一个三角形，这意味着你已经立马重复了至少两个顶点，每个顶点再包含法线、切线、纹理坐标的数据，那么你不得不复制整个缓冲区，它一次又一次地构成了那个实际的顶点，那是完全不现实的。</p><p>让我们来转换一下这种顶点缓冲，添加一个索引缓冲区并删除那些重复的冗余内存。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着创建一个无符号整型数组 <code>indices</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 0</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 1</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>,	<span class="comment">// 2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>	<span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这实际就是一个索引缓冲区，我们需要说明 OpenGL 如何去渲染这个三角形或者正方形，而不是给它提供冗余或重复的顶点位置。在这个例子中我们只有位置，但实际应用中可能会有更多的数据。</p><p>现在我们需要把它们发送到显卡上，并且告诉 OpenGL 用它们去渲染。而我们实现的方式非常类似于创建顶点缓冲区：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure><p><code>ibo</code> 代表索引缓冲区对象，表示这个特定的索引缓冲区。这里唯一的区别是把 <code>GL_ARRAY_BUFFER</code> 换为 <code>GL_ELEMENT_ARRAY_BUFFER</code>，<code>positions</code> 替换为之前的 <code>indices</code>。</p><p>需要说明一下我们会在所有这些例子中使用 <code>unsigned int</code>，因为在这种情况下不会有任何的性能差异，这里的关键是必须使用无符号类型。</p><br><p>最后需要改变的是我们的 DrawCall：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line"><span class="addition">+glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</span></span><br></pre></td></tr></tbody></table></figure><p><code>count</code> 就是我们需要绘制的 6 个索引，绘制索引的数量而非我们绘制顶点的数量；<code>type</code> 就是在索引缓冲区中的数据类型，在本例中是 <code>GL_UNSIGNED_INT</code>；最后是指向那个索引缓冲区的指针，而前面我们已经绑定了 <code>ibo</code>，所以这里可以填 <code>nullptr</code>。这就是我们绘制三角形的实际 DrawCall 指令。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523105558657.png"></p><p>运行程序，你可以看到我们得到了一个漂亮的矩形。</p><p>我们已经删除了任何重复的顶点，在顶点缓冲区中得到了完全唯一的顶点，之后创建了一个索引以便多次绘制顶点；然后我们用 <code>ibo</code> 绑定代码把索引缓冲区发送给显卡；最终我们使用 <code>glDrawElements()</code> 绘制图形。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">	{</span><br><span class="line">		NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	std::string line;</span><br><span class="line">	std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">	ShaderType type = ShaderType::NONE;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::VERTEX;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">				type = ShaderType::FRAGMENT;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">		<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">	<span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">	<span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">	<span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!window)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window's context current */</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> positions[] = {</span><br><span class="line">			<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 0</span></span><br><span class="line">			 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,	<span class="comment">// 1</span></span><br><span class="line">			 <span class="number">0.5f</span>,  <span class="number">0.5f</span>,	<span class="comment">// 2</span></span><br><span class="line">			<span class="number">-0.5f</span>,  <span class="number">0.5f</span>		<span class="comment">// 3</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">		<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">	<span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenGL中处理错误"><a href="#OpenGL中处理错误" class="headerlink" title="OpenGL中处理错误"></a>OpenGL中处理错误</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=10&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们要讨论的都是错误，我们怎么知道我们做错了什么以及如何尽快地调试并修复它。</p><h4 id="glGetError"><a href="#glGetError" class="headerlink" title="glGetError"></a>glGetError</h4><p>我们有两种主要的方式来检查 OpenGL 中的错误，其中一个一个叫做 <code>glGetError()</code>，它是一个我们可以调用的 OpenGL 内置函数。它能够兼容所有版本并且原理相对简单：在我们调用 OpenGL 时如果发生错误，内存中有一个标志会被内部设置，其会说明发生了什么类型的错误，并且当我们调用 <code>glGetError()</code> 时它会返回一个标志（或者说错误码）。如果我们继续调用 <code>glGetError()</code> 它会把所有标志返回给我们，因为我们可能会产生多个类型的错误。</p><br><p>回到上次渲染正方形的代码，我们可以更改索引缓冲区类型导致错误：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</span></span><br><span class="line"><span class="addition">+glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523155149402.png"></p><p>可以看到小小的改动得到的就是黑屏，我们的矩形根本没有渲染，这太糟糕了。</p><h4 id="glDebugMessageCallback"><a href="#glDebugMessageCallback" class="headerlink" title="glDebugMessageCallback"></a>glDebugMessageCallback</h4><p>在最近的 OpenGL 4.3 中添加了一个新的函数 <code>glDebugMessageCallback()</code>。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523163539153.png"></p><p>查阅文档，可以发现它允许我们指定一个指向 OpenGL 的函数指针，当错误发生时 OpenGL 会调用我们的那个函数。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523163715052.png"></p><p>唯一的问题在于兼容性，它只在 4.3 及以上版本，所以你不能再早期版本中使用它。优点也很明显，它不会仅仅给你一个错误码，会提供更详细的信息。根据我的经验， <code>glDebugMessageCallback()</code> 总体上非常好，比 <code>glGetError()</code> 好得多。但今天我们只讨论 <code>glGetError()</code>。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523165538131.png"></p><p>可以创建一个循环调用的报错函数 <code>GLClearError()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// while (glGetError() != GL_NO_ERROR);</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glGetError</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来创建另一个打印出实际错误的函数 <code>GLCheckError()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在让我们调用一下刚才的函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+GLClearError();</span></span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span><br><span class="line"><span class="addition">+GLCheckError();</span></span><br></pre></td></tr></tbody></table></figure><p>首先排除其他的错误，相当于调试的断言。通过这样的方式我们可以确保所有的错误实际上都是来自这个函数。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523201100782.png"></p><p>可以看到错误代码是 1280。在源码中搜索 1280 找不到任何东西，因为 OpenGL 采用的是十六进制表示错误码。所以我们可以换为十六进制：0x0500。再返回 <code>&lt;glew.h&gt;</code> 文件检索：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL_INVALID_ENUM 0x0500</span></span><br></pre></td></tr></tbody></table></figure><p>500 意味着无效的枚举，而 <code>GL_INT</code>确实是我们实际传递的无效枚举，它应该是无符号整型。</p><p>实际上 <code>glClearError()</code> 和 <code>glCheckError()</code> 还是比较笨重，并且让扩展变得更加困难。但我们实际上可以做的就是得到实际的调试器，暂时执行并在导致错误的代码行上中断。我们可以通过使用断言来实现这一点，如果那个条件是 false，你通常要么将消息写入控制台，要么只是停止程序的执行并且在那行中断。</p><p>为此我需要修改 <code>GLCheckError()</code> 变为 <code>GLLogCall()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">	{</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着在头文件下面定义宏断言：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  ASSERT(x) <span class="keyword">if</span> (!(x))   __debugbreak();</span></span><br></pre></td></tr></tbody></table></figure><p>这是 MSVC 特有的，在 clang、gcc 或者其他编译器中都不起作用。最后插入断言：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">GLClearError();</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span><br><span class="line"><span class="deletion">-GLCheckError();</span></span><br><span class="line"><span class="addition">+ASSERT(GLLogCall());</span></span><br></pre></td></tr></tbody></table></figure><p>为了方便起见定义宏 <code>GLCall()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError(); x; ASSERT(GLLogCall())</span></span><br></pre></td></tr></tbody></table></figure><p>更改调用：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/e6c9d24egy1h2lt68j6klj211x0kiq6s-20220526221235055.jpg"></p><p>最后加一些调试信息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError();  x;  ASSERT(GLLogCall(#x, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">"): "</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">" "</span> &lt;&lt; file &lt;&lt; <span class="string">":"</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/3H98MK.png"></p><h3 id="OpenGL中的统一变量"><a href="#OpenGL中的统一变量" class="headerlink" title="OpenGL中的统一变量"></a>OpenGL中的统一变量</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=11&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们要讨论的是统一变量。</p><p>那么首先统一变量是一个非常单一的概念，它对于我们而言实际上是一种从 CPU 端获取数据的方式。在本例中是从 C++ 到我们的着色器，所以我们实际上把它当一个变量使用。</p><h4 id="颜色变量"><a href="#颜色变量" class="headerlink" title="颜色变量"></a>颜色变量</h4><p>回到着色器我们创建一个 <code>u_Color</code> 并赋值：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="addition">+uniform vec4 u_Color;</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line"><span class="deletion">-   color = vec4(0.0, 0.2, 0.8, 1.0);</span></span><br><span class="line"><span class="addition">+   color = u_Color;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每个统一变量都有一个 id，这样我们就可以引用它了。而我们查找 id 的方式通常是通过它的名称，所以我们基本上就是问我们的着色器 <code>u_Color</code> 变量的位置。</p><p>在更现代的 OpenGL 版本，你实际上可以设置和索引。所以从 4.3 开始你可以指定一个明确的统一变量位置，这是一种非常现代的新功能。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	ShaderProgramSource source = ParseShader("res/shader/basic.shader");</span><br><span class="line">	unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);</span><br><span class="line">	GLCall(glUseProgram(shader));</span><br><span class="line"></span><br><span class="line"><span class="addition">+	GLCall(int location = glGetUniformLocation(shader, "u_Color"));</span></span><br><span class="line"><span class="addition">+	ASSERT(location != -1);</span></span><br><span class="line"><span class="addition">+	GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line"></span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		......</span><br></pre></td></tr></tbody></table></figure><p>总结一下，我通过使用实际的着色器 id 编写 <code>glUseProgram()</code> 绑定着色器，获取这个颜色变量的实际位置。而当我获取那个位置的时候，就调用 <code>glUniform4f()</code> 在着色器中设置我的数据。如果一切顺利，我应该将这个颜色值写入我的矩形每个像素的实际输出颜色：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/VJAoqd.png"></p><p>可以看到我们得到了与之前完全相同的结果，为了区分明显一点修改颜色：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line"><span class="addition">+GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/R9IiGp.png"></p><h4 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h4><p>好了，那么现在做点更令人兴奋的事情吧：让我们这个颜色动起来并且在渲染循环中随时间改变它。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+	float r = 0.0f;</span></span><br><span class="line"><span class="addition">+	float increment = 0.05f;</span></span><br><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line"><span class="addition">+		GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line">		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span><br><span class="line"></span><br><span class="line"><span class="addition">+		if (r &gt; 1.0f)</span></span><br><span class="line"><span class="addition">+			increment = -0.05f;</span></span><br><span class="line"><span class="addition">+		else if (r &lt; 0.0f)</span></span><br><span class="line"><span class="addition">+			increment = 0.05f;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		r += increment;</span></span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	GLCall(glDeleteProgram(shader));</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行程序会发现颜色变化比较快，因为我们没有限制帧率：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	/* Make the window's context current */</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"><span class="addition">+	glfwSwapInterval(1);</span></span><br></pre></td></tr></tbody></table></figure><p>该设置可以同步我们主频的帧率，得到更平滑的动画。</p><h3 id="OpenGL中的顶点数组"><a href="#OpenGL中的顶点数组" class="headerlink" title="OpenGL中的顶点数组"></a>OpenGL中的顶点数组</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=12&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><p>今天我们会讲 OpenGL 的顶点数组。</p><p>我们讲了很多 OpenGL 的基本概念甚至一般的图形编程，但 OpenGL 实际上有一个顶点数组。乍一看你可能会说顶点数组、顶点缓冲区它们之间的区别是什么，它们听起来非常相似。确实如此，并且这并不是 DirectX 等其他渲染接口中真正存在的东西，它是 OpenGL 独有的，也可以说是 OpenGL 的一个原始接口。它们基本上是一种通过特定的规范绑定顶点缓冲区的方式，用于实际顶点缓冲区的布局。</p><p>在我们的代码中，我们创建了 <code>buffer</code> 包含所有的顶点数据，然后创建缓冲区之后也做了绑定，启用了顶点属性指定实际数据的布局。现在一个顶点数组对象允许我们通过 <code>glVertexAttribArray()</code> 绑定指定的顶点规范到实际的顶点缓冲区，可能对于 OpenGL 的初学者比较难以理解，如果屏幕上有多个对象、多个网格、多个顶点缓冲区，需要我们绑定顶点和索引缓冲区，然后绘制实际的对象。</p><p>但我们绑定顶点缓冲区之后，我们实际也需要指定布局，让我们看看解绑一切会发生什么：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	GLCall(int location = glGetUniformLocation(shader, "u_Color"));</span><br><span class="line">	ASSERT(location != -1);</span><br><span class="line">	GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="addition">+	GLCall(glUseProgram(0));</span></span><br><span class="line"><span class="addition">+	GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));</span></span><br><span class="line"><span class="addition">+	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));</span></span><br><span class="line"></span><br><span class="line">	float r = 0.0f;</span><br><span class="line">	float increment = 0.05f;</span><br><span class="line">	/* Loop until the user closes the window */</span><br></pre></td></tr></tbody></table></figure><p>这里我基本上解绑了所有的东西，到了绘制的时候我们需要实际上绑定我们需要的所有东西，让 DrawCall 工作以此正确渲染所有东西：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">	/* Loop until the user closes the window */</span><br><span class="line">	while (!glfwWindowShouldClose(window))</span><br><span class="line">	{</span><br><span class="line">		/* Render here */</span><br><span class="line">		GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">		GLCall(glUseProgram(shader));</span><br><span class="line">		GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="addition">+		GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));</span></span><br><span class="line"><span class="addition">+		GLCall(glEnableVertexAttribArray(0));</span></span><br><span class="line"><span class="addition">+		GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span></span><br><span class="line"></span><br><span class="line">		if (r &gt; 1.0f)</span><br><span class="line">			increment = -0.05f;</span><br><span class="line">		else if (r &lt; 0.0f)</span><br><span class="line">			increment = 0.05f;</span><br><span class="line"></span><br><span class="line">		r += increment;</span><br><span class="line"></span><br><span class="line">		/* Swap front and back buffers */</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">		/* Poll for and events */</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure><p>我们绑定着色器，设置统一变量，绑定顶点缓冲区，设置顶点缓冲区的布局，最后绑定索引缓冲区调用 <code>glDrawElements()</code>。运行这段代码看看会发生什么：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/m3fzfo.png"></p><p>得到了和之前一样的结果，完美。这里值得商榷的是这里：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><p>我们是否每次都要这样做？答案是肯定的，因为如果我们用不同的布局绘制另一个对象，它们可能已经改变了。所以顶点数组对象实际上就是包含这种状态的对象，因此如果我们正确地利用顶点数组对象例如为几何体的每个部分创建不同的顶点数组对象，然后只需要绑定顶点数组对象就完事儿了，因为顶点数组对象将包含顶点缓冲区之间的绑定、布局。</p><p>因此，我们的绘制方式从绑定我们的着色器、绑定我们的顶点缓冲区、设置顶点布局、绑定我们的索引缓冲区、然后发出实际的 DrawCall 指令变为了绑定我们的着色器、<strong>绑定顶点数组</strong>、绑定索引缓冲区、最终发出实际的 DrawCall 指令。所以绑定顶点缓冲区并设置其布局变为了绑定顶点数组对象，因为它包含了我们实际需要的所有状态。</p><br><p>我需要在这里提一件事情，从技术上讲顶点数组对象是必须的，它们现在正在被使用，这就是为什么我说即使我们没有创建它们这个状态仍由顶点数组对象保持。这个东西是 OpenGL 兼容性配置文件，默认情况下兼容性配置文件实际上为我们创建了一个顶点数组对象。</p><h3 id="抽象顶点索引缓冲区成类"><a href="#抽象顶点索引缓冲区成类" class="headerlink" title="抽象顶点索引缓冲区成类"></a>抽象顶点索引缓冲区成类</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=13&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenGL中的缓冲区和布局的抽象"><a href="#OpenGL中的缓冲区和布局的抽象" class="headerlink" title="OpenGL中的缓冲区和布局的抽象"></a>OpenGL中的缓冲区和布局的抽象</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=14&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenG中抽象着色器"><a href="#OpenG中抽象着色器" class="headerlink" title="OpenG中抽象着色器"></a>OpenG中抽象着色器</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=15&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenGL写一个基础的渲染器类"><a href="#OpenGL写一个基础的渲染器类" class="headerlink" title="OpenGL写一个基础的渲染器类"></a>OpenGL写一个基础的渲染器类</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=16&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenGL中的纹理"><a href="#OpenGL中的纹理" class="headerlink" title="OpenGL中的纹理"></a>OpenGL中的纹理</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=17&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenGL中的混合"><a href="#OpenGL中的混合" class="headerlink" title="OpenGL中的混合"></a>OpenGL中的混合</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=18&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenGL中的数学"><a href="#OpenGL中的数学" class="headerlink" title="OpenGL中的数学"></a>OpenGL中的数学</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=19&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenGL中的投影矩阵"><a href="#OpenGL中的投影矩阵" class="headerlink" title="OpenGL中的投影矩阵"></a>OpenGL中的投影矩阵</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=20&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenGL中的模型视图投影矩阵"><a href="#OpenGL中的模型视图投影矩阵" class="headerlink" title="OpenGL中的模型视图投影矩阵"></a>OpenGL中的模型视图投影矩阵</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=21&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="OpenGL中的ImGui"><a href="#OpenGL中的ImGui" class="headerlink" title="OpenGL中的ImGui"></a>OpenGL中的ImGui</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=22&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="批量渲染对象"><a href="#批量渲染对象" class="headerlink" title="批量渲染对象"></a>批量渲染对象</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=23&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="为OpenGL建立一个测试框架"><a href="#为OpenGL建立一个测试框架" class="headerlink" title="为OpenGL建立一个测试框架"></a>为OpenGL建立一个测试框架</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=24&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=25&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="创建一个纹理测试"><a href="#创建一个纹理测试" class="headerlink" title="创建一个纹理测试"></a>创建一个纹理测试</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=26&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="如何让统一变量更快"><a href="#如何让统一变量更快" class="headerlink" title="如何让统一变量更快"></a>如何让统一变量更快</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=27&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="批渲染"><a href="#批渲染" class="headerlink" title="批渲染"></a>批渲染</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=28&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=29&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=30&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="动态几何"><a href="#动态几何" class="headerlink" title="动态几何"></a>动态几何</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=31&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=32&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br><h3 id="挑战一小时完成批渲染器"><a href="#挑战一小时完成批渲染器" class="headerlink" title="挑战一小时完成批渲染器"></a>挑战一小时完成批渲染器</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=33&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen=""></iframe><br></div><footer class="post-footer"><div class="post-tags"><a href="/tags/OpenGL/" rel="tag"># OpenGL</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/781b26a.html" rel="prev" title="如何用很短的代码创造「秋日氛围感」？"><i class="fa fa-chevron-left"></i> 如何用很短的代码创造「秋日氛围感」？</a></div><div class="post-nav-item"><a href="/archives/3a2065a8.html" rel="next" title="悲惨歌喉下的隐喻--Love, Death &amp; Robots Season 3">悲惨歌喉下的隐喻--Love, Death &amp; Robots Season 3 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0OpenGL"><span class="nav-number">2.</span> <span class="nav-text">欢迎来到OpenGL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFOpenGL"><span class="nav-number">2.1.</span> <span class="nav-text">什么是OpenGL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EOpenGL%E8%AF%AF%E8%A7%A3"><span class="nav-number">2.2.</span> <span class="nav-text">关于OpenGL误解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E4%B8%8E%E7%8E%B0%E4%BB%A3OpenGL"><span class="nav-number">2.3.</span> <span class="nav-text">传统与现代OpenGL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEOpenGL%E5%92%8CC-%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">设置OpenGL和C++中创建一个窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E7%B1%BB%E5%BA%93"><span class="nav-number">3.1.</span> <span class="nav-text">下载类库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AECMake%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">配置CMake文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE"><span class="nav-number">3.3.</span> <span class="nav-text">编译项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">3.4.</span> <span class="nav-text">画一个三角形</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8C-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3OpenGL"><span class="nav-number">4.</span> <span class="nav-text">在C++中使用现代OpenGL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E5%9C%A8%E7%8E%B0%E4%BB%A3OpenGL%E4%B8%AD%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">5.</span> <span class="nav-text">顶点缓冲区和在现代OpenGL中画一个三角形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">顶点缓冲区与着色器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.2.</span> <span class="nav-text">代码实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E9%A1%B6%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B8%83%E5%B1%80"><span class="nav-number">6.</span> <span class="nav-text">OpenGL中顶点的属性和布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">顶点属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-1"><span class="nav-number">6.2.</span> <span class="nav-text">代码实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">OpenGL中着色器的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">7.1.</span> <span class="nav-text">着色器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">着色器类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">7.2.1.</span> <span class="nav-text">顶点着色器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">片段着色器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E5%86%99%E4%B8%80%E4%B8%AA%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">OpenGL中写一个着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">8.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E5%86%99"><span class="nav-number">8.3.</span> <span class="nav-text">着色器编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">8.4.</span> <span class="nav-text">整理错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">9.</span> <span class="nav-text">OpenGL中如何处理着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E5%90%88%E5%B9%B6"><span class="nav-number">9.1.</span> <span class="nav-text">着色器合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">9.2.</span> <span class="nav-text">着色器读取与使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">10.</span> <span class="nav-text">OpenGL中的索引缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%9B%9B%E8%BE%B9%E5%BD%A2"><span class="nav-number">10.1.</span> <span class="nav-text">绘制四边形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">10.2.</span> <span class="nav-text">索引缓冲区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">11.</span> <span class="nav-text">OpenGL中处理错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#glGetError"><span class="nav-number">11.1.</span> <span class="nav-text">glGetError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#glDebugMessageCallback"><span class="nav-number">11.2.</span> <span class="nav-text">glDebugMessageCallback</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F"><span class="nav-number">12.</span> <span class="nav-text">OpenGL中的统一变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E5%8F%98%E9%87%8F"><span class="nav-number">12.1.</span> <span class="nav-text">颜色变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-number">12.2.</span> <span class="nav-text">动态变化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84"><span class="nav-number">13.</span> <span class="nav-text">OpenGL中的顶点数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E9%A1%B6%E7%82%B9%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA%E6%88%90%E7%B1%BB"><span class="nav-number">14.</span> <span class="nav-text">抽象顶点索引缓冲区成类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E5%B8%83%E5%B1%80%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="nav-number">15.</span> <span class="nav-text">OpenGL中的缓冲区和布局的抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenG%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">16.</span> <span class="nav-text">OpenG中抽象着色器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B8%B2%E6%9F%93%E5%99%A8%E7%B1%BB"><span class="nav-number">17.</span> <span class="nav-text">OpenGL写一个基础的渲染器类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E7%BA%B9%E7%90%86"><span class="nav-number">18.</span> <span class="nav-text">OpenGL中的纹理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%90%88"><span class="nav-number">19.</span> <span class="nav-text">OpenGL中的混合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6"><span class="nav-number">20.</span> <span class="nav-text">OpenGL中的数学</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="nav-number">21.</span> <span class="nav-text">OpenGL中的投影矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E8%A7%86%E5%9B%BE%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="nav-number">22.</span> <span class="nav-text">OpenGL中的模型视图投影矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenGL%E4%B8%AD%E7%9A%84ImGui"><span class="nav-number">23.</span> <span class="nav-text">OpenGL中的ImGui</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%B8%B2%E6%9F%93%E5%AF%B9%E8%B1%A1"><span class="nav-number">24.</span> <span class="nav-text">批量渲染对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BAOpenGL%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="nav-number">25.</span> <span class="nav-text">为OpenGL建立一个测试框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95"><span class="nav-number">26.</span> <span class="nav-text">创建测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%B9%E7%90%86%E6%B5%8B%E8%AF%95"><span class="nav-number">27.</span> <span class="nav-text">创建一个纹理测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F%E6%9B%B4%E5%BF%AB"><span class="nav-number">28.</span> <span class="nav-text">如何让统一变量更快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E6%B8%B2%E6%9F%93"><span class="nav-number">29.</span> <span class="nav-text">批渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">29.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2"><span class="nav-number">29.2.</span> <span class="nav-text">颜色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86"><span class="nav-number">29.3.</span> <span class="nav-text">纹理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%87%A0%E4%BD%95"><span class="nav-number">29.4.</span> <span class="nav-text">动态几何</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">29.5.</span> <span class="nav-text">索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%91%E6%88%98%E4%B8%80%E5%B0%8F%E6%97%B6%E5%AE%8C%E6%88%90%E6%89%B9%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="nav-number">30.</span> <span class="nav-text">挑战一小时完成批渲染器</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">275</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.1m</span></div><div class="powered-by">今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//fastly.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//fastly.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//fastly.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="/lib/three/three.min.js"></script><script defer="" src="//fastly.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//fastly.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script async="" src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script>!function(t,h,e,j){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:2272201,hjsv:6},e=h.getElementsByTagName("head")[0],(j=h.createElement("script")).async=1,j.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,e.appendChild(j)}(window,document)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
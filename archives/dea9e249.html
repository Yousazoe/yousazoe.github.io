<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言这是 Basics 系列之后的第一个伪随机噪声的系列教程.教大家如何使用一种小型特化版的xxHash函数来生成伪随机数。"><meta property="og:type" content="article"><meta property="og:title" content="Hashing Small xxHash"><meta property="og:url" content="https://yousazoe.top/archives/dea9e249.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言这是 Basics 系列之后的第一个伪随机噪声的系列教程.教大家如何使用一种小型特化版的xxHash函数来生成伪随机数。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tutorial-image.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/shader-graph.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/game-object.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/grid.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/misaligned-resolution-41.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/lowest-eight-bits-32.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/sequence-32.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/sequence-41.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/uv-32.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/uv-41.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/diagonal-pattern.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bit-rotation.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/extra-multiplication.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/avalanche-32.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/centered-32.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/centered-64.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/centered-32-20220202171347811.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/second-byte.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rgb-colors.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/seed-inspector.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/seed-1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/seed-2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/offset-inspector.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/offset-scene.png"><meta property="article:published_time" content="2022-02-02T08:38:44.000Z"><meta property="article:modified_time" content="2023-10-23T16:36:05.839Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Game Develop"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tutorial-image.jpg"><link rel="canonical" href="https://yousazoe.top/archives/dea9e249.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Hashing Small xxHash | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/dea9e249.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Hashing Small xxHash</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-02-02 16:38:44" itemprop="dateCreated datePublished" datetime="2022-02-02T16:38:44+08:00">2022-02-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-Game-Development/" itemprop="url" rel="index"><span itemprop="name">游戏开发 (Game Development)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>13k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>24 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tutorial-image.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这是 <a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/">Basics</a> 系列之后的第一个伪随机噪声的系列教程.教大家如何使用一种小型特化版的xxHash函数来生成伪随机数。</p><span id="more"></span><ul><li>创建一个可视化Hash网格</li><li>把2D坐标转换成伪随机值</li><li>实现一个小型的xxHash算法</li><li>使用该Hash算法计算方块位置和颜色</li></ul><blockquote><p>如果你觉得这篇教程不错,请去支持原作者：</p><ul><li><a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/hashing/">Pseudorandom Noise-Hashing</a></li></ul></blockquote><h3 id="可视化-Visualization"><a href="#可视化-Visualization" class="headerlink" title="可视化(Visualization)"></a>可视化(Visualization)</h3><p>随机可以让事情变得不可预测,多变以及出现得更加自然.不论我们感受到的是真正的随机,还是由于信息的不对称感觉到的随机,还是由于我们自身观察到结果后理解的随机,都不重要,只要是像随机就行.所以我们为何不能使用一种完全确定的随机序列呢?因为只要使用的人觉得随机就行了.垃圾的多线程设计可以产生莫名其妙的随机效果,但是这个方法太不稳定了,没有意义.真正的随机只存在于非计算机环境中,比如采集大气噪声得到的结果.但是这些东西基本用不上.</p><p>在开发中,真随机基本都是用不到的.因为它产生的事件真的独一无二无法控制.我们真正需要的是一个可以得到固定随机值的算法,也就是可预测随机数.这就是使用Hash的原因.</p><p>这个教程将教大家创建一个用许多Cube建立的2D网格,看上去就像一个可视化的Hash函数.就像<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/">Basics</a>教程教的一样,我们建立一个新的工程项目,因为要使用Job系统,先导入Burst包.我还将使用URP,所以还需要导入Unity的UniversalRP包.</p><h4 id="Hash-Job"><a href="#Hash-Job" class="headerlink" title="Hash Job"></a>Hash Job</h4><p>我们使用Unity的Job功能来创建一个HashValue的生成器.就像<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/">Basics</a>教程里面说的那样,首先创建一个名叫HashVisualization的组件类,里面包含一个Job.使用这个HashJob填充NativeArray.</p><p>HashValues本质上是一组没有内在意义的值.我们使用uint这个类型,因为它可以包含32位4字节整形的最大值.现在只是用Job的Execution Index来作为最初的HashValue.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Burst;</span><br><span class="line"><span class="keyword">using</span> Unity.Collections;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> Unity.Mathematics.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HashVisualization</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">	[<span class="meta">BurstCompile(FloatPrecision.Standard, FloatMode.Fast, CompileSynchronously = true)</span>]</span><br><span class="line">	<span class="keyword">struct</span> HashJob : IJobFor</span><br><span class="line">	{</span><br><span class="line">		[<span class="meta">WriteOnly</span>]</span><br><span class="line">		<span class="keyword">public</span> NativeArray&lt;<span class="built_in">uint</span>&gt; hashes;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">		{</span><br><span class="line">			hashes[i] = (<span class="built_in">uint</span>)i;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>为什么不是用int作为HashValue的类型?</p><p>因为int是有符号整形,最高位是用来判断正负的,并不是用来实际计数的,在底层计算中这一位的计算方式和其他位不一样.</p></blockquote><h4 id="初始化与渲染-Initialization-and-Rendering"><a href="#初始化与渲染-Initialization-and-Rendering" class="headerlink" title="初始化与渲染(Initialization and Rendering)"></a>初始化与渲染(Initialization and Rendering)</h4><p>就如同在<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/">Basics</a>教程中一样,我们在HashVisualization类中声明以下内容(Hashes和Config是在Shader注册的ID)</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> hashesId = Shader.PropertyToID(<span class="string">"_Hashes"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> configId = Shader.PropertyToID(<span class="string">"_Config"</span>);</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Mesh instanceMesh;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Material material;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField, Range(1, 512)</span>]</span><br><span class="line"><span class="built_in">int</span> resolution = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">NativeArray&lt;<span class="built_in">uint</span>&gt; hashes;</span><br><span class="line"></span><br><span class="line">ComputeBuffer hashesBuffer;</span><br><span class="line"></span><br><span class="line">MaterialPropertyBlock propertyBlock;</span><br></pre></td></tr></tbody></table></figure><p><code>OnEnable</code>函数中初始化所有的内容,为了填充Buffer数据,我们需要运行一次HashJob以便得到初始的数据,这样就不用每帧都来一遍.因为还需在Shader中操作分辨率(<strong>resolution</strong>)相关的内容,所以需要传入<strong>resolution</strong>的值以及它的倒数<strong>1/resolution</strong>的值.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">int</span> length = resolution * resolution;</span><br><span class="line">	hashes = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">uint</span>&gt;(length, Allocator.Persistent);</span><br><span class="line">	hashesBuffer = <span class="keyword">new</span> ComputeBuffer(length, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> HashJob</span><br><span class="line">	{</span><br><span class="line">		hashes = hashes</span><br><span class="line">	}.ScheduleParallel(hashes.Length, resolution, <span class="literal">default</span>).Complete();</span><br><span class="line"></span><br><span class="line">	hashesBuffer.SetData(hashes);</span><br><span class="line"></span><br><span class="line">	propertyBlock ??= <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">	propertyBlock.SetBuffer(hashesId, hashesBuffer);</span><br><span class="line">	propertyBlock.SetVector(configId, <span class="keyword">new</span> Vector4(resolution, <span class="number">1f</span> / resolution));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>OnDisable</code>函数中清理数据,<code>OnValidate</code>函数中进行重置操作以便在播放模式下可以刷新Mesh数据.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> </span><br><span class="line">{</span><br><span class="line">	hashes.Dispose();</span><br><span class="line">	hashesBuffer.Release();</span><br><span class="line">	hashesBuffer = <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span>()</span> </span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (hashesBuffer != <span class="literal">null</span> &amp;&amp; enabled)</span><br><span class="line">	{</span><br><span class="line">		OnDisable();</span><br><span class="line">		OnEnable();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们只需要在<code>Update</code>中不断绘制数据就行了.这个做法将网格塞在了原点的一个方块当中.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">	Graphics.DrawMeshInstancedProcedural(</span><br><span class="line">        instanceMesh,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        material,</span><br><span class="line">        <span class="keyword">new</span> Bounds(Vector3.zero, Vector3.one),</span><br><span class="line">        hashes.Length,</span><br><span class="line">        propertyBlock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="着色器-Shader"><a href="#着色器-Shader" class="headerlink" title="着色器(Shader)"></a>着色器(Shader)</h4><p>使用HLSL语法写一个如下的Shader,与<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/">Basics</a>的早期版本不同之处在于,我们直接使用实例的ID(unity_InstanceID)来计算坐标.</p><p>为了将1D的线转换成2D的格子,需要将其等分切断,依次排好后在第二个维度上平移[^1](<a target="_blank" rel="noopener" href="https://tzkt623.github.io/2022/01/05/Pseudorandom">https://tzkt623.github.io/2022/01/05/Pseudorandom</a> Noise-01 Hashing/说得这么别扭也就是横竖对着切).我们可以用实例的ID除以分辨率(<strong>1/resolution</strong> * <strong>unity_InstanceID</strong>),不过GPU并没有整数除法,可以通过<code>floor</code>函数来抛弃小数部分从而得到结果.这个结果V,是第二个维度上的坐标(可以理解成Y),U坐标(可以理解成X)是通过ID减去V坐标乘以分辨率(<strong>resolution</strong>)计算得到的.</p><p>然后我们使用UV坐标将这个实例放在XZ坐标平面上,平移缩放将其保持在原点的Cube内.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)</span></span><br><span class="line">	StructuredBuffer&lt;<span class="built_in">uint</span>&gt; _Hashes;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">float4 _Config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureProcedural</span>()</span> </span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)</span></span><br><span class="line">	<span class="built_in">float</span> v = floor(_Config.y * unity_InstanceID);</span><br><span class="line">	<span class="built_in">float</span> u = unity_InstanceID - _Config.x * v;</span><br><span class="line">		</span><br><span class="line">	unity_ObjectToWorld = <span class="number">0.0</span>;</span><br><span class="line">	unity_ObjectToWorld._m03_m13_m23_m33 = float4(</span><br><span class="line">		_Config.y * (u + <span class="number">0.5</span>) - <span class="number">0.5</span>,</span><br><span class="line">		<span class="number">0.0</span>,</span><br><span class="line">		_Config.y * (v + <span class="number">0.5</span>) - <span class="number">0.5</span>,</span><br><span class="line">		<span class="number">1.0</span></span><br><span class="line">	);</span><br><span class="line">	unity_ObjectToWorld._m00_m11_m22 = _Config.y;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后使用下面的方法来查找Hash值,并用它来计算RGB值.通过将hash值除以分辨率的平方,可以得到由黑到白的渐变效果.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">GetHashColor</span>()</span> </span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)</span></span><br><span class="line">	<span class="built_in">uint</span> hash = _Hashes[unity_InstanceID];</span><br><span class="line">	<span class="keyword">return</span> _Config.y * _Config.y * hash;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来的函数是用于计算颜色和位置的</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShaderGraphFunction_float</span>(<span class="params">float3 In, <span class="keyword">out</span> float3 Out, <span class="keyword">out</span> float3 Color</span>)</span></span><br><span class="line">{</span><br><span class="line">	Out = In;</span><br><span class="line">	Color = GetHashColor();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShaderGraphFunction_half</span>(<span class="params">half3 In, <span class="keyword">out</span> half3 Out, <span class="keyword">out</span> half3 Color</span>)</span></span><br><span class="line">{</span><br><span class="line">	Out = In;</span><br><span class="line">	Color = GetHashColor();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>就如同<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/">Basics</a>里教的一样,创建一个ShaderGraph文件.不过我们使用了新的HLSL文件和方法,并且直接将我们计算的color赋给片段着色器.并且使用默认值0.5来保证平滑度,而不是让其可以被动态设置.</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/shader-graph.png"></p><p>下面的代码是InjectPragmas函数节点的内容</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> instancing_options assumeuniformscaling procedural:ConfigureProcedural</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> editor_sync_compilation</span></span><br><span class="line"></span><br><span class="line">Out = In;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>为什么我没有使用URP?</p><p>你当然也可以使用URP,或者创建一个使用HLSL语法,包含默认RP的Surface Sharde.就如同Basics教程里写的那样.</p></blockquote><p>现在我们可以创建一个使用我们自己shader的material,再创建一个GameObject并挂上HashVisualization脚本,并且设置好material和instance mesh.</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/game-object.png"></p><p>此时在Unity的PlayMode中应当可以看到如下效果</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/grid.png"></p><p>在PlayMode下通过调整分辨率滑块可以动态生成不同分辨率下的网格效果.在绝大多数情况下这种方式是没问题的,但是在小部分情况下会出现网格没有对齐的现象</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/misaligned-resolution-41.png"></p><p>这个错误是由于<strong>float</strong>的浮点精度限制造成的.在某些情况下,在调用<code>floor</code>之前,我们会得到一个稍微小于整数的值,这会造成实例被放置到错误的位置上.在我们的项目中,可以在丢弃小数之前,简单地通过加<strong>0.00001</strong>来解决这个问题.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> v = floor(_Config.y * unity_InstanceID + <span class="number">0.00001</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="模式-Patterns"><a href="#模式-Patterns" class="headerlink" title="模式(Patterns)"></a>模式(Patterns)</h4><p>在真正的实现Hash函数之前,让我们先考虑一下简单的数学问题.第一步,需要让灰度值被限制在256个单位的范围内.在<code>GetHashColor</code>函数中,使用255(也就是11111111这个二进制掩码)和_Hashes[unity_InstanceID]进行与(AND)运算,从而屏蔽掉了8位以上的值,只保留uint中最低8位的值,将值限制在了[0,255]这个范围内.然后通过除以255来归一化到[0,1]之间.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">uint</span> hash = _Hashes[unity_InstanceID];</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> / <span class="number">255.0</span>) * (hash &amp; <span class="number">255</span>);</span><br></pre></td></tr></tbody></table></figure><p>渲染的效果取决于分辨率(<strong>resolution</strong>).分辨率为32时,我们得到了一个在Z方向上重复4次的灰度效果.分辨率为41时,就会变成倾斜的效果.</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/lowest-eight-bits-32.png"></p><p>让我们用Weyl序列算法替换简单的渐变算法,就像我们在<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/organic-variety/">Organic Variety</a>教程中最初用来给分形上色一样.在HashJob类的<code>Execute</code>方法中,我们将<code>frac</code>计算结果乘以256f,从而得到了在[0,255]的之间的hash值.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">hashes[i] = (<span class="built_in">uint</span>)(frac(i * <span class="number">0.381f</span>) * <span class="number">256f</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/sequence-32.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/sequence-41.png"></p><p>我们发现现在的效果还是有明显的重复,方向取决于分辨率.为了使效果不依赖分辨率这个值,我们必须将函数建立在点的UV坐标上,而不是索引上.所以可以把计算坐标的操作移动到Job中,就像我们在Shader中做的那样,用U和V作为序列的基进行计算,不过还需要添加分辨率及其倒数的字段.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> resolution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> invResolution;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">float</span> v = floor(invResolution * i + <span class="number">0.00001f</span>);</span><br><span class="line">	<span class="built_in">float</span> u = i - resolution * v;</span><br><span class="line">	hashes[i] = (<span class="built_in">uint</span>)(frac(u * v * <span class="number">0.381f</span>) * <span class="number">255f</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>我们能用整数除法来代替floor方法吗?</p><p>可以,但是这不是一个好主意.因为整数除法不能向量化,这会使计算效率降低.你可以研究Burst生成的代码来验证这一点.</p><p>Note that the SSE2 instruction set doesn’t include a vectorized floor operation, so when limited to that instruction set you get four un-vectorized calls to a floor function instead, which is suboptimal. Because in this specific case we’re only dealing with positive values you could also cast to an integer instead, which does vectorize with SSE2. But I ignore this to keep things consistent.</p></blockquote><p>把修改后的数据填到<code>OnEnable</code>函数中的HashJob上</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HashJob</span><br><span class="line">{</span><br><span class="line">	hashes = hashes,</span><br><span class="line">	resolution = resolution,</span><br><span class="line">	invResolution = <span class="number">1f</span> / resolution</span><br><span class="line">}.ScheduleParallel(hashes.Length, resolution, <span class="literal">default</span>).Complete();</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/uv-32.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/uv-41.png"></p><p>现在我们得到了一个更有趣的效果,看起来比以前更随机,但它也有非常明显的重复.为了得到更好的效果,我们需要一个更好的哈希函数.</p><h3 id="Small-xxHash"><a href="#Small-xxHash" class="headerlink" title="Small xxHash"></a>Small xxHash</h3><p>Hash函数有很多,不过我们不需要那些用于数据加密级别的Hash函数.我们需要的是快速而又能产生不错效果的.<a target="_blank" rel="noopener" href="http://xxhash.com/">Yann Collet的xxHash算法</a>就是一个非常不错的选择.因为我们的数据输入量非常的小,只有2个Int,所以我写了一个XXH32的改版,跳过了<a target="_blank" rel="noopener" href="https://github.com/Cyan4973/xxHash/blob/dev/doc/xxhash_spec.md">原本算法</a>的2,3,4步.我将它命名为SmallXXHash.</p><h4 id="Hash-Struct"><a href="#Hash-Struct" class="headerlink" title="Hash Struct"></a>Hash Struct</h4><p>创建一个结构体SmallXXHash.定义如下5个const变量.这是5个2进制质数,用于后续的位运算.是由Yann Collet精细挑选而来的.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SmallXXHash</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeA = <span class="number">0b10011110001101110111100110110001</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeB = <span class="number">0b10000101111010111100101001110111</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeC = <span class="number">0b11000010101100101010111000111101</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeD = <span class="number">0b00100111110101001110101100101111</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeE = <span class="number">0b00010110010101100110011110110001</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该算法通过将hash bits存储在累加器中来工作,因此需要一个uint字段.创建此算法的第一步就是写一个带参构造函数,用Seed+primeE将<strong>accumulator</strong>初始化.我们将Seed强转为uint.不过由于int在代码中更常用,所以Seed被声明为int类型.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">uint</span> accumulator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SmallXXHash</span>(<span class="params"><span class="built_in">int</span> seed</span>)</span></span><br><span class="line">{</span><br><span class="line">	accumulator = (<span class="built_in">uint</span>)seed + primeE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>How is a constructor method defined?</p><p>It is declared as a regular method that returns the type that it constructs, except that it doesn’t have a name. It also doesn’t explicitly return anything, because the method is always used to initialize a new object instance or struct value.</p></blockquote><p>初始化之后,我们有了一个计算过的SmallXXHash值.为了得到最终结果,用下述方法来直接返回<strong>accumulator</strong>.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">uint</span> <span class="title">ToUint</span>()</span> =&gt; accumulator;</span><br></pre></td></tr></tbody></table></figure><p>不过我们可以通过隐式转换更加方便的得到这个值,重载隐式转换操作符.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">uint</span> (<span class="params">SmallXXHash hash</span>)</span> =&gt; hash.accumulator;</span><br></pre></td></tr></tbody></table></figure><p>现在我们可以在Job中创建一个新的SamllXXHash值,并且使用0作为初始种子,便可以隐式转换赋值给hashes.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> </span><br><span class="line">{</span><br><span class="line">	<span class="built_in">float</span> v = floor(invResolution * i + <span class="number">0.00001f</span>);</span><br><span class="line">	<span class="built_in">float</span> u = i - resolution * v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> hash = <span class="keyword">new</span> SmallXXHash(<span class="number">0</span>);</span><br><span class="line">	hashes[i] = hash;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Eating-Data"><a href="#Eating-Data" class="headerlink" title="Eating Data"></a>Eating Data</h4><p>XXHash32算法同时处理输入数据的32个位.而我们的小型版只消化掉1位.在SmallXXHash类中建立一个返回void的<code>Eat(int)</code>方法,同样使用int作为形参并且在计算时强转为uint,然后将其与配置参数<strong>primeC</strong>相乘,接着再加到<strong>accumulator</strong>中.这种做法会导致int类型的数据溢出,但是无所谓,因为得到什么样的值都可以.所以所有的操作得到的都是232的有效模.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public void Eat(int data)</span><br><span class="line">{</span><br><span class="line">	accumulator += (uint)data * primeC;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来修改代码,在<code>Execute</code>处理U,V两个值.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public void Execute(int i)</span><br><span class="line">{</span><br><span class="line">	int v = (int)floor(invResolution * i + 0.00001f);</span><br><span class="line">	int u = i - resolution * v;</span><br><span class="line">	</span><br><span class="line">	var hash = new SmallXXHash(0);</span><br><span class="line">	hash.Eat(u);</span><br><span class="line">	hash.Eat(v);</span><br><span class="line">	hashes[i] = hash;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/diagonal-pattern.png"></p><p>这是Eat操作中的第一步.我们还需要将累加之后的值进行一个比特位上的旋转.添加一个下面的静态私有方法来,使用左移&lt;&lt;操作符来旋转.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">uint</span> <span class="title">RotateLeft</span>(<span class="params"><span class="built_in">uint</span> data, <span class="built_in">int</span> steps</span>)</span> =&gt; data &lt;&lt; steps;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>位移运算是如何进行的?</p><p>Bit位依次左移,不够的位补0, 例如</p><p>0b11111111_00000000_11111111_00000001 &lt;&lt; 3 后,等于 0b11111000_00000111_11111000_00001000</p></blockquote><p>旋转与位移的区别就是,旋转是要把位移之后丢失掉的bit位在另一边重新填上.对于32位的数据,可以通过32减去移动的位数得出反向移动的长度来得到另一边的数据,然后执行或运算进行补齐.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">uint</span> <span class="title">RotateLeft</span>(<span class="params"><span class="built_in">uint</span> data, <span class="built_in">int</span> steps</span>)</span> =&gt; (data &lt;&lt; steps) | (data &gt;&gt; <span class="number">32</span> - steps);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>CPU里没有自带左旋转指令集?</p><p>有,Burst编译器会自动识别这种代码进行优化.但是在编码过程必须得像上面那样写.</p></blockquote><p>现在在<code>Eat</code>中将<strong>accumulator</strong>左移17位,然后右移15位,再或到一起.这样做的好处是避免了单纯+-型的数学运算,Burst编译器也会对此函数做内联处理,速度更快.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>(<span class="params"><span class="built_in">int</span> data</span>)</span></span><br><span class="line">{</span><br><span class="line">	accumulator = RotateLeft(accumulator + (<span class="built_in">uint</span>)data * primeC, <span class="number">17</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bit-rotation.png" alt="旋转之后的效果"></p><p><code>Eat</code>操作的最后一步就是将上面计算好的值与<strong>primeD</strong>相乘</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>(<span class="params"><span class="built_in">int</span> data</span>)</span></span><br><span class="line">{</span><br><span class="line">	accumulator = RotateLeft(accumulator + (<span class="built_in">uint</span>)data * primeC, <span class="number">17</span>) * primeD;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/extra-multiplication.png" alt="相乘之后的效果"></p><p>虽然这么做之后,效果看上去也不尽人意,但<code>Eat</code>的内容就是这样了.我们再添加它的另一个变种方法,虽然在这个教程中并不会使用这个变种.这个新的<code>Eat</code>用来处理byte数据,就像XXHash32原版那样,这次是移动11位,并且与<strong>primeE</strong>和<strong>primeA</strong>相乘.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>(<span class="params"><span class="built_in">byte</span> data</span>)</span></span><br><span class="line">{</span><br><span class="line">	accumulator = RotateLeft(accumulator + data * primeE, <span class="number">11</span>) * primeA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="雪崩效应-Avalanche"><a href="#雪崩效应-Avalanche" class="headerlink" title="雪崩效应(Avalanche)"></a>雪崩效应(Avalanche)</h4><p>XXHash算法的最后一步就是要打乱<strong>accumulator</strong>参数的bit位,分散输入数据对bit位的影响.<br>这就是雪崩效应.我们在Eat掉所有数据之后,最后强转为uint的阶段来做这个操作.</p><p>雪崩算法开始于我们的最终累加值,先右移15位后与原始数据^运算.然后乘以<strong>primeB</strong>,再右移13位后与上一步的数据^在一起,接着乘以<strong>primeC</strong>,最后右移16位后与上一步数据^.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">uint</span>(<span class="params">SmallXXHash hash</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">uint</span> avalanche = hash.accumulator;</span><br><span class="line">	avalanche ^= avalanche &gt;&gt; <span class="number">15</span>;</span><br><span class="line">	avalanche *= primeB;</span><br><span class="line">	avalanche ^= avalanche &gt;&gt; <span class="number">13</span>;</span><br><span class="line">	avalanche *= primeC;</span><br><span class="line">	avalanche ^= avalanche &gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> avalanche;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>What does bitwise XOR do?</p><p>It is the eXclusive bitwise OR operator. Each bit becomes 1 when either the first or the second operand has the same bit set to 1. When both or neither operand bits are 1 the bit becomes 0.</p><p>For example, 0b00111100 ^ 0b00001111 yields 0b00110011.</p><p>不翻译了,这是位运算中异或运算的规则</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/avalanche-32.png"></p><p>雪崩算法后的效果,分辨率为32和64.</p><h4 id="负坐标-Negative-Coordinates"><a href="#负坐标-Negative-Coordinates" class="headerlink" title="负坐标(Negative Coordinates)"></a>负坐标(Negative Coordinates)</h4><p>为了让我们的算法同样适用于负坐标,必须要将UV值减去一半.修改<code>HashJob.Execute</code>函数如下.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> v = (<span class="built_in">int</span>)floor(invResolution * i + <span class="number">0.00001f</span>);</span><br><span class="line"><span class="built_in">int</span> u = i - resolution * v - resolution / <span class="number">2</span>;</span><br><span class="line">v -= resolution / <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/centered-32.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/centered-64.png"></p><p>现在修改分辨率时Hash的效果将居中对齐,不过分辨率在奇数和偶数间切换的时候会有小幅度的抖动.</p><h4 id="链式调用-Method-Chaining"><a href="#链式调用-Method-Chaining" class="headerlink" title="链式调用(Method Chaining)"></a>链式调用(Method Chaining)</h4><p>虽然SamllXXHash的功能已经完成了,但是我们还可以修改一下加入链试调用使使用更加方便.修改<code>Eat</code>方法使其返回类本身来达到这个效果.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SmallXXHash <span class="title">Eat</span>(<span class="params"><span class="built_in">int</span> data</span>)</span></span><br><span class="line">{</span><br><span class="line">	accumulator = RotateLeft(accumulator + (<span class="built_in">uint</span>)data * primeC) * primeD;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SmallXXHash <span class="title">Eat</span>(<span class="params"><span class="built_in">byte</span> data</span>)</span></span><br><span class="line">{</span><br><span class="line">	accumulator = RotateLeft(accumulator + data * primeE, <span class="number">11</span>) * primeA;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后将代码修改成如下调用方式.这样就只需要一排代码就能完成所有的计算.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//var hash = new SmallXXHash(0).Eat(u).Eat(v);</span></span><br><span class="line"><span class="comment">//hash.Eat(u);</span></span><br><span class="line"><span class="comment">//hash.Eat(v);</span></span><br><span class="line">hashes[i] = <span class="keyword">new</span> SmallXXHash(<span class="number">0</span>).Eat(u).Eat(v);</span><br></pre></td></tr></tbody></table></figure><h4 id="不变性-Immutability"><a href="#不变性-Immutability" class="headerlink" title="不变性(Immutability)"></a>不变性(Immutability)</h4><p>我们可以继续修改一下SamllXXHash类,确保<code>Eat</code>方法在调用时不会改变它内部的值.这样我们就能保存计算的中间值以方便后面的计算.把SamllXXHash改成只读模式,使它的行为看上去更像一个单纯的值.</p><p>添加上只读操作符.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> SmallXXHash { … }</span><br></pre></td></tr></tbody></table></figure><p><strong>accumulator</strong>也要只读.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">uint</span> accumulator;</span><br></pre></td></tr></tbody></table></figure><p>现在修改<strong>accumulator</strong>的唯一方法就是通过构造函数.因为<em>readonly</em>关键字修饰的参数只能在构造函数里赋值.修改一下构造函数变成单纯的赋值而不是计算种子.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SmallXXHash</span>(<span class="params"><span class="built_in">uint</span> accumulator</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>.accumulator = accumulator;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们有了一个将uint转化成SmallXXHash类的方法,建立一个隐式转换来方便操作.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">SmallXXHash</span>(<span class="params"><span class="built_in">uint</span> accumulator</span>)</span> =&gt; <span class="keyword">new</span> SmallXXHash(accumulator);</span><br></pre></td></tr></tbody></table></figure><p><code>Eat</code>方法现在就可以直接返回新生成的SmallXXHash对象了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SmallXXHash <span class="title">Eat</span>(<span class="params"><span class="built_in">int</span> data</span>)</span> =&gt; RotateLeft(accumulator + (<span class="built_in">uint</span>)data * primeC, <span class="number">17</span>) * primeD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SmallXXHash <span class="title">Eat</span>(<span class="params"><span class="built_in">byte</span> data</span>)</span> =&gt; RotateLeft(accumulator + data * primeE, <span class="number">11</span>) * primeA;</span><br></pre></td></tr></tbody></table></figure><p>最后为了可以使用Seed来初始化SmallXXHash,需要增加一个静态的方法来创建新的hash值对象.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SmallXXHash <span class="title">Seed</span>(<span class="params"><span class="built_in">int</span> seed</span>)</span> =&gt; (<span class="built_in">uint</span>)seed + primeE;</span><br></pre></td></tr></tbody></table></figure><p>用现在的新方式来初始化Hash值就不需要显示调用构造函数了,只需要调用一个静态方法链就行了.修改<code>HashJob.Execute</code>如下.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">hashes[i] = SmallXXHash.Seed(<span class="number">0</span>).Eat(u).Eat(v);</span><br></pre></td></tr></tbody></table></figure><p>请注意,这些写法完全是为了装逼,编译器最终生成的代码不会有任何区别.</p><h3 id="更多关于Hash的东西-Showing-More-of-the-Hash"><a href="#更多关于Hash的东西-Showing-More-of-the-Hash" class="headerlink" title="更多关于Hash的东西(Showing More of the Hash)"></a>更多关于Hash的东西(Showing More of the Hash)</h3><p>SmallXXHash类做完了,现在轮到讨论生成效果的时候了.</p><h4 id="用不同的bit位-Using-Different-Bits"><a href="#用不同的bit位-Using-Different-Bits" class="headerlink" title="用不同的bit位(Using Different Bits)"></a>用不同的bit位(Using Different Bits)</h4><p>到目前为止,我们只看过了处理低8位数据后的Hash效果图.通过在<code>GetHashColor</code>函数中简单的对hash进行位移操作,就可以看到处理第二个字节后生成的效果了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> / <span class="number">255.0</span>) * ((hash &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/centered-32-20220202171347811.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/second-byte.png"></p><p>通过这种移位的方法,我们能只用一个Hash流程创造4种完全不同的计算效果(因为一个uint32有4字节32位).当然你也可以使用其他的位移量来达到相同的Hash流程.</p><h4 id="上色-Coloring"><a href="#上色-Coloring" class="headerlink" title="上色(Coloring)"></a>上色(Coloring)</h4><p>我们可以通过组合<strong>hash</strong>值上的3个字节来组成RGB颜色通道上的3位数据.最低位作为红色R,第二位作为绿色G,第三位作为蓝色B.所以需要对<strong>hash</strong>右移0位,右移8位和右移16位.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">uint</span> hash = _Hashes[unity_InstanceID];</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> / <span class="number">255.0</span>) * float3(hash &amp; <span class="number">255</span>, (hash &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>, (hash &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rgb-colors.png"></p><h4 id="可配置的Seed-Configurable-Seed"><a href="#可配置的Seed-Configurable-Seed" class="headerlink" title="可配置的Seed(Configurable Seed)"></a>可配置的Seed(Configurable Seed)</h4><p>现在有了一个可以把hash值可视化75%的效果了.接下来我们把seed参数设计成可配置的模式.在HashJob里修改代码变成如下.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public int seed;</span><br><span class="line"></span><br><span class="line">public void Execute(int i)</span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">	hashes[i] = SmallXXHash.Seed(seed).Eat(u).Eat(v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再HashVisualization类中添加一个Unity属性来修饰seed字段使它可以自由的编辑.然后赋值到HashJob类中.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[SerializeField]</span><br><span class="line">int seed;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">void OnEnable()</span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">	new HashJob</span><br><span class="line">	{</span><br><span class="line">		hashes = hashes,</span><br><span class="line">		resolution = resolution,</span><br><span class="line">		invResolution = 1f / resolution,</span><br><span class="line">		seed = seed</span><br><span class="line">	}.ScheduleParallel(hashes.Length, resolution, default).Complete();</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/seed-inspector.png"></p><p>现在你可以通过修改Seed参数来创建不同的Hash效果了,而且他们看起来都是完全不一样的.</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/seed-1.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/seed-2.png"></p><p>我们还能更进一步,将SamllXXHash的初始化拿到Job外面去,这样就不用每次<code>Execute</code>都新建一个了,除了速度上的优势,你还能在程序进到Job之前就设定好你需要的seed.</p><p>在HashJob中移除seed字段,然后添加一个SamllXXHash结构体的字段hash.然后修改<code>Execute</code>的对应部分.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//public int seed;</span></span><br><span class="line"><span class="keyword">public</span> SmallXXHash hash;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">	hashes[i] = hash.Eat(u).Eat(v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>OnEnable</code>函数中把Seed传进去初始化hash.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HashJob</span><br><span class="line">{</span><br><span class="line">	hashes = hashes,</span><br><span class="line">	resolution = resolution,</span><br><span class="line">	invResolution = <span class="number">1f</span> / resolution,</span><br><span class="line">	hash = SmallXXHash.Seed(seed)</span><br><span class="line">}.ScheduleParallel(hashes.Length, resolution, <span class="literal">default</span>).Compl</span><br></pre></td></tr></tbody></table></figure><h4 id="用上最后一个字节-Using-the-Last-Byte"><a href="#用上最后一个字节-Using-the-Last-Byte" class="headerlink" title="用上最后一个字节(Using the Last Byte)"></a>用上最后一个字节(Using the Last Byte)</h4><p>我们生成的hash值到这里还剩一个byte没有被可视化,可以把它用在不透明度(opacity)上,但是这样会让显示效果很难被看清,还需要考虑透明通道渲染深度的排序问题.所以我们决定用这一字节来做垂直方向上的位移效果(偏移Z轴).</p><p>把垂直偏移量设计为可配置模式,设定范围(-2f, 2f],默认值为1.我们让这个偏移量相对于Cube的大小,所以需要除以分辨率(<strong>resolution</strong>).然后把这个计算后的结果作为Shader参数vector4中的第三个数据传入.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[SerializeField, Range(-2f, 2f)]</span><br><span class="line">float verticalOffset = 1f;</span><br><span class="line">…</span><br><span class="line">void OnEnable()</span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">	propertyBlock.SetVector(configId,</span><br><span class="line">	new Vector4(resolution, 1f / resolution, verticalOffset / resolution));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在Shader中的<code>ConfigureProcedural</code>函数里面应用计算好的Hash值.最后一个字节是通过把hash值向右移动24位得到的,位移之后其他的位会自动填9补齐,所以我们就不用特意处理它们了.接下来把这个值乘以(1.0/255.0)归一化到[0,1]之间,然后再减去0.5归一化到[-0.5,0.5]之间.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">unity_ObjectToWorld._m03_m13_m23_m33 = float4(</span><br><span class="line">	_Config.y * (u + <span class="number">0.5</span>) - <span class="number">0.5</span>,</span><br><span class="line">	_Config.z * ((<span class="number">1.0</span> / <span class="number">255.0</span>) * (_Hashes[unity_InstanceID] &gt;&gt; <span class="number">24</span>) - <span class="number">0.5</span>),</span><br><span class="line">	_Config.y * (v + <span class="number">0.5</span>) - <span class="number">0.5</span>,</span><br><span class="line">	<span class="number">1.0</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/offset-inspector.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/offset-scene.png"></p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/d33850b7.html" rel="bookmark">浅谈游戏中的道德困境</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/539ed278.html" rel="bookmark">让巨大化角色充满真实感的五大法则</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/a3a6db15.html" rel="bookmark">Hashing Space Hashing in an Arbitrary Grid</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Game-Develop/" rel="tag"># Game Develop</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/33b7c27d.html" rel="prev" title="Renderer API Abstraction"><i class="fa fa-chevron-left"></i> Renderer API Abstraction</a></div><div class="post-nav-item"><a href="/archives/a3a6db15.html" rel="next" title="Hashing Space Hashing in an Arbitrary Grid">Hashing Space Hashing in an Arbitrary Grid <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96-Visualization"><span class="nav-number">2.</span> <span class="nav-text">可视化(Visualization)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash-Job"><span class="nav-number">2.1.</span> <span class="nav-text">Hash Job</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%B2%E6%9F%93-Initialization-and-Rendering"><span class="nav-number">2.2.</span> <span class="nav-text">初始化与渲染(Initialization and Rendering)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8-Shader"><span class="nav-number">2.3.</span> <span class="nav-text">着色器(Shader)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F-Patterns"><span class="nav-number">2.4.</span> <span class="nav-text">模式(Patterns)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Small-xxHash"><span class="nav-number">3.</span> <span class="nav-text">Small xxHash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash-Struct"><span class="nav-number">3.1.</span> <span class="nav-text">Hash Struct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Eating-Data"><span class="nav-number">3.2.</span> <span class="nav-text">Eating Data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94-Avalanche"><span class="nav-number">3.3.</span> <span class="nav-text">雪崩效应(Avalanche)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E5%9D%90%E6%A0%87-Negative-Coordinates"><span class="nav-number">3.4.</span> <span class="nav-text">负坐标(Negative Coordinates)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8-Method-Chaining"><span class="nav-number">3.5.</span> <span class="nav-text">链式调用(Method Chaining)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%98%E6%80%A7-Immutability"><span class="nav-number">3.6.</span> <span class="nav-text">不变性(Immutability)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8EHash%E7%9A%84%E4%B8%9C%E8%A5%BF-Showing-More-of-the-Hash"><span class="nav-number">4.</span> <span class="nav-text">更多关于Hash的东西(Showing More of the Hash)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84bit%E4%BD%8D-Using-Different-Bits"><span class="nav-number">4.1.</span> <span class="nav-text">用不同的bit位(Using Different Bits)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E8%89%B2-Coloring"><span class="nav-number">4.2.</span> <span class="nav-text">上色(Coloring)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%85%8D%E7%BD%AE%E7%9A%84Seed-Configurable-Seed"><span class="nav-number">4.3.</span> <span class="nav-text">可配置的Seed(Configurable Seed)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%B8%8A%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82-Using-the-Last-Byte"><span class="nav-number">4.4.</span> <span class="nav-text">用上最后一个字节(Using the Last Byte)</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">307</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">76</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/399504060" title="Bilibili → https://space.bilibili.com/399504060" rel="noopener" target="_blank"><i class="fa fa-th-large fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.6m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
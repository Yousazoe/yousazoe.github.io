<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Ray Tracing: The Next Week             å¼•è¨€ã€ŠRay Tracing: The Next Weekã€‹ï¼ˆã€Šä¸€å‘¨æå®šå…‰çº¿è¿½è¸ªã€‹ï¼‰ï¼Œ ç”± Peter Shirleyï¼ˆå°±æ˜¯é‚£æœ¬å›¾å½¢å­¦è™ä¹¦çš„ä½œè€…ï¼‰æ‰€ç¼–å†™çš„çš„è½¯æ¸²å…‰è¿½ä¸‰éƒ¨æ›²ç¬¬äºŒæœ¬ï¼Œæ˜¯ä¸€æœ¬éå¸¸å¥½çš„å…¥é—¨çº§ä¹¦ç±ï¼Œå½“å‰ç‰ˆæœ¬ v3.0ã€‚"><meta property="og:type" content="article"><meta property="og:title" content="Ray Tracing the Next Week"><meta property="og:url" content="https://yousazoe.top/archives/30e31a9b.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Ray Tracing: The Next Week             å¼•è¨€ã€ŠRay Tracing: The Next Weekã€‹ï¼ˆã€Šä¸€å‘¨æå®šå…‰çº¿è¿½è¸ªã€‹ï¼‰ï¼Œ ç”± Peter Shirleyï¼ˆå°±æ˜¯é‚£æœ¬å›¾å½¢å­¦è™ä¹¦çš„ä½œè€…ï¼‰æ‰€ç¼–å†™çš„çš„è½¯æ¸²å…‰è¿½ä¸‰éƒ¨æ›²ç¬¬äºŒæœ¬ï¼Œæ˜¯ä¸€æœ¬éå¸¸å¥½çš„å…¥é—¨çº§ä¹¦ç±ï¼Œå½“å‰ç‰ˆæœ¬ v3.0ã€‚"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.01-bouncing-spheres.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.01-bvol-hierarchy.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.02-2d-aabb.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.03-ray-slab.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.04-ray-slab-interval.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.02-checker-ground.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.03-checker-spheres.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.04-white-noise.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.05-white-noise-blurred.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.06-tile-random.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.07-hash-random.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.08-perlin-trilerp.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.09-perlin-trilerp-smooth.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.10-perlin-hifreq.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.11-perlin-shift.png"><meta property="og:image" content="https://raytracing.github.io/images/img-2.12-perlin-turb.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.13-perlin-marble.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/earthmap.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.15-earth-sphere.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.05-ray-rect.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.17-rect-sphere-light.png"><meta property="og:image" content="https://raytracing.github.io/images/img-2.18-cornell-empty.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.19-cornell-blocks.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.06-ray-box.jpg"><meta property="og:image" content="https://raytracing.github.io/images/fig-2.07-rot-z.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.20-cornell-standard.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.08-ray-vol.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.21-cornell-smoke.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final-20210730003326518.jpg"><meta property="article:published_time" content="2021-07-29T16:42:59.000Z"><meta property="article:modified_time" content="2022-06-12T14:19:35.903Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final.jpg"><link rel="canonical" href="https://yousazoe.top/archives/30e31a9b.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Ray Tracing the Next Week | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/30e31a9b.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Ray Tracing the Next Week</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-07-30 00:42:59" itemprop="dateCreated datePublished" datetime="2021-07-30T00:42:59+08:00">2021-07-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">å…‰çº¿è¿½è¸ª (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>74k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>2:14</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final.jpg"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">Ray Tracing: The Next Week</a></i></font></div><h3 id="å¼•è¨€"><a href="#å¼•è¨€" class="headerlink" title="å¼•è¨€"></a>å¼•è¨€</h3><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">ã€ŠRay Tracing: The Next Weekã€‹</a>ï¼ˆã€Šä¸€å‘¨æå®šå…‰çº¿è¿½è¸ªã€‹ï¼‰ï¼Œ ç”± Peter Shirleyï¼ˆå°±æ˜¯é‚£æœ¬å›¾å½¢å­¦è™ä¹¦çš„ä½œè€…ï¼‰æ‰€ç¼–å†™çš„çš„è½¯æ¸²å…‰è¿½ä¸‰éƒ¨æ›²ç¬¬äºŒæœ¬ï¼Œæ˜¯ä¸€æœ¬éå¸¸å¥½çš„å…¥é—¨çº§ä¹¦ç±ï¼Œå½“å‰ç‰ˆæœ¬ v3.0ã€‚</p><span id="more"></span><blockquote><p>åŸæ–‡æºè‡ª <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">Ray Tracing: The Next Week</a></p><p>æœ¬æ–‡è½¬è½½è‡ª <a target="_blank" rel="noopener" href="https://matrix4f.com/Graphic/Ray-tracing-the-next-week/">Ray tracing the next week ä¸­æ–‡ç¿»è¯‘</a>çš„ç¿»è¯‘ï¼Œå¦‚æœæ‚¨æ„¿æ„å¸®åŠ©è¯‘è€…æ”¹è¿›è¿™ä¸ªç¿»è¯‘ï¼Œè¯·ç›´æ¥<strong>å‘é€é‚®ä»¶</strong>åˆ° <a href="mailto:zgxmy@126.com">zgxmy@126.com</a>, ä¸‡åˆ†æ„Ÿæ¿€</p></blockquote><h3 id="æ¦‚è¿°"><a href="#æ¦‚è¿°" class="headerlink" title="æ¦‚è¿°"></a>æ¦‚è¿°</h3><blockquote><p>In Ray Tracing in One Weekend, you built a simple brute force path tracer. In this installment weâ€™ll add textures, volumes (like fog), rectangles, instances, lights, and support for lots of objects using a BVH. When done, youâ€™ll have a â€œrealâ€ ray tracer.</p></blockquote><p>åœ¨<a target="_blank" rel="noopener" href="https://raytracing.github.io/books">Ray Tracing in One Weekend</a>ä¸­, ä½ å®ç°äº†ä¸€ä¸ªæš´åŠ›çš„å…‰çº¿è·¯å¾„è¿½è¸ªå™¨ã€‚åœ¨æœ¬éƒ¨åˆ†ä¸­, æˆ‘ä»¬å°†åŠ å…¥çº¹ç†, ä½“ç§¯ä½“(ä¾‹å¦‚çƒŸé›¾), çŸ©å½¢, å®ä¾‹, å…‰æº, å¹¶ç”¨BVHæ¥åŒ…è£¹æˆ‘ä»¬çš„ç‰©ä½“ã€‚å½“ä½ å®Œæˆè¿™äº›å, ä½ å°†æ‹¥æœ‰ä¸€ä¸ªâ€œçœŸæ­£çš„â€å…‰çº¿è¿½è¸ªå™¨ã€‚</p><blockquote><p>A heuristic in ray tracing that many peopleâ€”including meâ€”believe, is that most optimizations complicate the code without delivering much speedup. What I will do in this mini-book is go with the simplest approach in each design decision I make. Check <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> for readings and references to a more sophisticated approach. However, I strongly encourage you to do no premature optimization; if it doesnâ€™t show up high in the execution time profile, it doesnâ€™t need optimization until all the features are supported!</p></blockquote><p>åœ¨å…‰çº¿è¿½è¸ªæ–¹é¢, å…·æœ‰å¯å‘æ€§çš„ä¸€ç‚¹æ˜¯, è®¸å¤šäºº(åŒ…æ‹¬ä½œè€…æœ¬äºº)ç›¸ä¿¡å¤§å¤šæ•°ç”¨æ¥ä¼˜åŒ–çš„ä»£ç åªä¼šè®©ç¨‹åºæ›´å¤æ‚, è€Œå¹¶ä¸ä¼šæå‡å¤ªå¤šçš„è¿è¡Œé€Ÿåº¦ã€‚æˆ‘åœ¨è¿™æœ¬è¿·ä½ ä¹¦ä¸­å°†é‡‡å–æœ€ç®€å•ç›´æ¥çš„æ–¹å¼æ¥å®ç°ä»£ç ã€‚å¦‚æœä½ æƒ³çœ‹å¤æ‚çš„ä¼˜åŒ–ç‰ˆæœ¬, è¯·ç‚¹å‡»<a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">è¿™é‡Œ</a>ã€‚å¹¶ä¸”æˆ‘åœ¨è¿™é‡Œå»ºè®®è¯»è€…ä¸è¦è‡ªå·±è¿‡æ—©çš„å»ä¼˜åŒ–ã€‚å¦‚æœè¯´ç¨‹åºåœ¨æ‰§è¡Œæ—¶é—´ä¸Šæ¥çœ‹å¹¶æ²¡æœ‰å¤ªå¤§çš„å˜åŒ–, é‚£ä¹ˆå®ƒå°±å¹¶ä¸éœ€è¦ä½ å»ä¼˜åŒ–ã€‚ç›´åˆ°æœ€åæ‰€æœ‰çš„åŠŸèƒ½éƒ½è¢«å®ç°å‰, ä½ å¯ä»¥ä¸€ç›´å°±è¿™æ ·å¾€é‡Œé¢æ·»åŠ ä»£ç ã€‚</p><blockquote><p>The two hardest parts of this book are the BVH and the Perlin textures. This is why the title suggests you take a week rather than a weekend for this endeavor. But you can save those for last if you want a weekend project. Order is not very important for the concepts presented in this book, and without BVH and Perlin texture you will still get a Cornell Box!</p></blockquote><p>æœ¬ä¹¦ä¸­æœ€éš¾çš„ä¸¤éƒ¨åˆ†æ˜¯BVHå’ŒæŸæ—å™ªå£°è´´å›¾ã€‚æ‰€ä»¥æˆ‘å°†æ ‡é¢˜å–åä¸ºâ€œä¸€å‘¨â€è€Œä¸æ˜¯åƒä¸Šä¸€æœ¬ä¸€æ ·çš„â€œä¸€ä¸ªå‘¨æœ«â€ã€‚å¦‚æœä½ æƒ³ä¸€ä¸ªå‘¨æœ«æå®šè¿™æœ¬ä¹¦, é‚£ä¹ˆä½ å¯ä»¥æŠŠè¿™ä¸¤ä¸ªéƒ¨åˆ†ç•™åˆ°æœ€åã€‚è¿™æœ¬ä¹¦ä¸­æåˆ°çš„æ¦‚å¿µ, å„ç« èŠ‚çš„é¡ºåºå¹¶ä¸æ˜¯å¾ˆé‡è¦, æ²¡æœ‰BVHå’ŒæŸæ—å™ªå£°è´´å›¾ä½ ä»ç„¶èƒ½æ¸²æŸ“å‡ºå±äºè‡ªå·±æ¼‚äº®çš„Cornell Box!</p><h3 id="åŠ¨æ€æ¨¡ç³Š"><a href="#åŠ¨æ€æ¨¡ç³Š" class="headerlink" title="åŠ¨æ€æ¨¡ç³Š"></a>åŠ¨æ€æ¨¡ç³Š</h3><blockquote><p>When you decided to ray trace, you decided that visual quality was worth more than run-time. In your fuzzy reflection and defocus blur you needed multiple samples per pixel. Once you have taken a step down that road, the good news is that almost all effects can be brute-forced. Motion blur is certainly one of those. In a real camera, the shutter opens and stays open for a time interval, and the camera and objects may move during that time. Its really an average of what the camera sees over that interval that we want.</p><p>We can get a random estimate by sending each ray at some random time when the shutter is open. As long as the objects are where they should be at that time, we can get the right average answer with a ray that is at exactly a single time. This is fundamentally why random ray tracing tends to be simple.</p></blockquote><p>å½“ä½ åœ¨åšå…‰çº¿è¿½è¸ªæ—¶, æƒ³è¦æ›´å¥½çš„å‡ºå›¾è´¨é‡å°±æ„å‘³ç€æ›´å¤šçš„ç¨‹åºè¿è¡Œæ—¶é—´ã€‚ä¾‹å¦‚ä¸Šä¸€æœ¬ä¹¦ä¸­çš„åå°„éƒ¨åˆ†å’Œé•œå¤´æ•£ç„¦æ¨¡ç³Šä¸­, ä½ éœ€è¦å¯¹æ¯ä¸ªåƒç´ è¿›è¡Œå¤šé‡é‡‡æ ·ã€‚å½“ä½ å†³å®šåœ¨è¿™æ¡è·¯ä¸Šèµ°å¾—æ›´æ·±ä¸€äº›æ—¶, å¥½æ¶ˆæ¯æ¥äº†: å‡ ä¹æ‰€æœ‰çš„ç‰¹æ•ˆéƒ½èƒ½è¿™æ ·æš´åŠ›å®ç°ã€‚åŠ¨æ€æ¨¡ç³Šä¹Ÿæ˜¯å±äºèƒ½è¿™æ ·å®ç°çš„ç‰¹æ•ˆä¹‹ä¸€ã€‚æƒ³è±¡ä¸€ä¸ªçœŸå®ä¸–ç•Œçš„æ‘„åƒæœº, åœ¨å¿«é—¨æ‰“å¼€çš„æ—¶é—´é—´éš”ä¸­, æ‘„åƒæœºå’Œç‰©ä½“éƒ½æœ‰å¯èƒ½ç§»åŠ¨ã€‚é‚£æ‹å‡ºæ¥çš„ç»“æœè‚¯å®šæ˜¯è¿™ä¸ªè¿åŠ¨è¿‡ç¨‹æ¯ä¸€å¸§çš„å¹³å‡å€¼, æˆ–è€…è¯´, ä¸€å›¢ç³Šäº†ã€‚æˆ‘ä»¬å¯ä»¥ç”¨éšæœºçš„æ–¹æ³•åœ¨ä¸åŒæ—¶é—´å‘å°„å¤šæ¡å°„çº¿æ¥æ¨¡æ‹Ÿå¿«é—¨çš„æ‰“å¼€ã€‚åªè¦ç‰©ä½“åœ¨é‚£ä¸ªæ—¶é—´å¤„äºå…¶æ­£ç¡®çš„ä½ç½®, é‚£ä¹ˆæˆ‘ä»¬å°±èƒ½å¾—å‡ºè¿™æ¡å…‰çº¿åœ¨é‚£ä¸ªæ—¶é—´ç‚¹çš„ç²¾ç¡®å¹³å‡å€¼ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆéšæœºå…‰è¿½çœ‹ä¸Šå»å¾ˆç®€å•çš„åŸå› ã€‚</p><h4 id="Introduction-of-SpaceTime-Ray-Tracing"><a href="#Introduction-of-SpaceTime-Ray-Tracing" class="headerlink" title="Introduction of SpaceTime Ray Tracing"></a>Introduction of SpaceTime Ray Tracing</h4><blockquote><p>The basic idea is to generate rays at random times while the shutter is open and intersect the model at that one time. The way it is usually done is to have the camera move and the objects move, but have each ray exist at exactly one time. This way the â€œengineâ€ of the ray tracer can just make sure the objects are where they need to be for the ray, and the intersection guts donâ€™t change much.</p></blockquote><p>ä¸€ä¸ªåŸºç¡€çš„æ€è·¯æ˜¯, åœ¨å¿«é—¨æ‰“å¼€æ—¶, éšç€æ—¶é—´å˜åŒ–éšæœºç”Ÿæˆå…‰çº¿, å¹¶åŒæ—¶å‘å‡ºå°„çº¿ä¸æ¨¡å‹ç›¸äº¤ã€‚ä¸€èˆ¬æ¥è¯´æˆ‘ä»¬è®©æ‘„åƒæœºå’Œç‰©ä½“åŒæ—¶è¿åŠ¨, å¹¶è®©æ¯ä¸€æ¡å°„çº¿éƒ½æ‹¥æœ‰è‡ªå·±å­˜åœ¨çš„ä¸€ä¸ªæ—¶é—´ç‚¹ã€‚è¿™æ ·å…‰çº¿è¿½è¸ªå™¨çš„â€œå¼•æ“â€å°±èƒ½ç¡®å®š, å¯¹äºæŒ‡å®šçš„æŸæ¡å…‰çº¿æ¥è¯´, åœ¨è¯¥æ—¶åˆ», ç‰©ä½“åˆ°åº•åœ¨å“ªå„¿ã€‚æ±‚å°„çº¿ä¸çƒç›¸äº¤çš„éƒ¨åˆ†å†™æ³•å’Œä¹‹å‰å¹¶æ²¡æœ‰å¤ªå¤šåŒºåˆ«ã€‚</p><blockquote><p>For this we will first need to have a ray store the time it exists at:</p></blockquote><p>ä¸ºäº†å®ç°åˆšåˆšçš„æ€è·¯, æˆ‘ä»¬é¦–å…ˆåœ¨ <code>ray.h</code> ä¸­è¦è®©æ¯æ¡å…‰çº¿éƒ½èƒ½å‚¨å­˜è‡ªå·±æ‰€åœ¨çš„æ—¶åˆ», å°±åƒè¿™æ ·:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class ray {</span><br><span class="line">public:</span><br><span class="line">    ray() {}</span><br><span class="line"><span class="addition">+   ray(const vec3&amp; origin, const vec3&amp; direction, double time = 0)</span></span><br><span class="line"><span class="addition">+       : orig(origin), dir(direction), tm(time){</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    vec3 origin() const { return orig; }</span><br><span class="line">    vec3 direction() const { return dir; }</span><br><span class="line"><span class="addition">+   double time() const { return tm; }</span></span><br><span class="line"></span><br><span class="line">    vec3 at(double t) const {</span><br><span class="line">        return orig + t * dir;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vec3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line"><span class="addition">+   double tm;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Updating-the-Camera-to-Simulate-Motion-Blur"><a href="#Updating-the-Camera-to-Simulate-Motion-Blur" class="headerlink" title="Updating the Camera to Simulate Motion Blur"></a>Updating the Camera to Simulate Motion Blur</h4><blockquote><p>Now we need to modify the camera to generate rays at a random time between <code>time1</code> and <code>time2</code>. Should the camera keep track of <code>time1</code> and <code>time2</code> or should that be up to the user of camera when a ray is created? When in doubt, I like to make constructors complicated if it makes calls simple, so I will make the camera keep track, but thatâ€™s a personal preference. Not many changes are needed to camera because for now it is not allowed to move; it just sends out rays over a time period.</p></blockquote><p>ç°åœ¨æˆ‘ä»¬éœ€è¦è®©æ‘„åƒæœºåœ¨<code>time1</code>åˆ°<code>time2</code>çš„æ—¶é—´æ®µä¸­éšæœºç”Ÿæˆå°„çº¿ã€‚å…‰çº¿çš„ç”Ÿæˆæ—¶åˆ»æ˜¯è®©cameraç±»è‡ªå·±æ¥è¿ç®—è¿½è¸ªå‘¢, è¿˜æ˜¯è¯´å¯ä»¥è®©ç”¨æˆ·æ¥è‡ªè¡ŒæŒ‡å®šå…‰çº¿åœ¨å“ªä¸ªæ—¶åˆ»ç”Ÿæˆæ¯”è¾ƒå¥½å‘¢? å½“å‡ºç°è¿™æ ·çš„ç–‘é—®æ—¶, æˆ‘å–œæ¬¢è®©æ„é€ å‡½æ•°æ›´åŠ å¤æ‚,åŒæ—¶è°ƒç”¨èµ·æ¥ä¼šæ›´åŠ ç®€å•ã€‚æ‰€ä»¥æˆ‘è®©cameraç±»æ¥å‚¨å­˜ç€ä¸¤ä¸ªå˜é‡ã€‚ä½†è¿™åªæ˜¯æˆ‘çš„ä¸ªäººå–œå¥½ã€‚cameraç±»å¹¶ä¸éœ€è¦å¤ªå¤šä¿®æ”¹, å› ä¸ºç°åœ¨å®ƒä¸ä¼šåŠ¨, åªä¼šåœ¨ä¸€ä¸ªæ—¶é—´æ®µå†…å‘å‡ºå°„çº¿ã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class camera {</span><br><span class="line">public:</span><br><span class="line">    camera() {</span><br><span class="line">        lower_left_corner = vec3(-2.0,-1.0,-1.0);</span><br><span class="line">        horizontal = vec3(4.0,0.0,0.0);</span><br><span class="line">        vertical = vec3(0.0,2.0,0.0);</span><br><span class="line">        origin = vec3(0.0,0.0,0.0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    camera(vec3 lookfrom, vec3 lookat, vec3 vup,</span><br><span class="line"><span class="addition">+           double vfov, double aspect, double aperture, double focus_dist, double t0 = 0, double t1 = 0) { // top to bottom, in degress</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        lens_radius = aperture / 2;</span><br><span class="line"></span><br><span class="line">        auto theta = degree_to_radians(vfov);</span><br><span class="line">        auto half_height = tan(theta / 2);</span><br><span class="line">        auto half_width = aspect * half_height;</span><br><span class="line"><span class="addition">+       time0 = t0;</span></span><br><span class="line"><span class="addition">+       time1 = t1;</span></span><br><span class="line">        w = unit_vector(lookfrom - lookat);</span><br><span class="line">        u = unit_vector(cross(vup, w));</span><br><span class="line">        v = cross(w, u);</span><br><span class="line"></span><br><span class="line">        lower_left_corner = origin</span><br><span class="line">                          - half_width * focus_dist * u</span><br><span class="line">                          - half_height * focus_dist * v</span><br><span class="line">                          - focus_dist * w;</span><br><span class="line"></span><br><span class="line">        horizontal = 2 * half_width * focus_dist * u;</span><br><span class="line">        vertical = 2 * half_height * focus_dist * v;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ray get_ray(double s, double t) {</span><br><span class="line">        vec3 rd = lens_radius * random_in_unit_disk();</span><br><span class="line">        vec3 offset = u * rd.x() + v * rd.y();</span><br><span class="line"></span><br><span class="line">        return ray(</span><br><span class="line">                origin + offset,</span><br><span class="line">                lower_left_corner + s * horizontal + t * vertical - origin - offset,</span><br><span class="line"><span class="addition">+               random_double(time0, time1)</span></span><br><span class="line">                );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vec3 origin;</span><br><span class="line">    vec3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    double lens_radius;</span><br><span class="line"><span class="addition">+   double time0, time1;  // shutter open/close times</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Adding-Moving-Spheres"><a href="#Adding-Moving-Spheres" class="headerlink" title="Adding Moving Spheres"></a>Adding Moving Spheres</h4><blockquote><p>We also need a moving object. Iâ€™ll create a sphere class that has its center move linearly from <code>center0</code> at <code>time0</code> to <code>center1</code> at <code>time1</code>. Outside that time interval it continues on, so those times need not match up with the camera aperture open and close.</p></blockquote><p>æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªè¿åŠ¨ä¸­çš„ç‰©ä½“ã€‚æˆ‘å»ºç«‹äº†ä¸€ä¸ªæ–°çš„sphereç±», è®©å®ƒçš„çƒå¿ƒåœ¨<code>time0</code>åˆ°<code>time1</code>çš„æ—¶é—´æ®µå†…ä»<code>center0</code>çº¿æ€§è¿åŠ¨åˆ°<code>center1</code>ã€‚è¶…å‡ºè¿™ä¸ªæ—¶é—´æ®µ, è¿™ä¸ªçƒå¿ƒä¾ç„¶åœ¨åŠ¨, <em>ã€è¯‘æ³¨ï¼šå°±æ˜¯è¯´åœ¨åšçº¿æ€§æ’å€¼çš„æ—¶å€™tå¯ä»¥å¤§äº1.0 ä¹Ÿå¯ä»¥å°äº0ã€‘</em>, æ‰€ä»¥è¿™é‡Œçš„ä¸¤ä¸ªæ—¶é—´å˜é‡å’Œæ‘„åƒæœºå¿«é—¨çš„å¼€å…³æ—¶åˆ»å¹¶ä¸éœ€è¦ä¸€ä¸€å¯¹åº”ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">moving_sphere</span> : <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">moving_sphere</span>() {}</span><br><span class="line">    <span class="built_in">moving_sphere</span>(</span><br><span class="line">            vec3 cen0, vec3 cen1, <span class="type">double</span> t0, <span class="type">double</span> t1, <span class="type">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">            : <span class="built_in">center0</span>(cen0), <span class="built_in">center1</span>(cen1), <span class="built_in">time0</span>(t0), <span class="built_in">time1</span>(t1), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 center0, center1;</span><br><span class="line">    <span class="type">double</span> time0, time1;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">moving_sphere::center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> center0 + ((time - time0) / (time1 - time0)) * (center1 - center0);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>An alternative to making a new moving sphere class is to just make them all move, while stationary spheres have the same begin and end position. Iâ€™m on the fence about that trade-off between fewer classes and more efficient stationary spheres, so let your design taste guide you.</p><p>The <code>moving_sphere::hit()</code> function is almost identical to the <code>sphere::hit()</code> function: <code>center</code> just needs to become a function <code>center(time)</code>:</p></blockquote><p>å¦å¤–ä¸€ç§è®©çƒéšç€æ—¶é—´åŠ¨èµ·æ¥çš„æ–¹æ³•æ˜¯, å–ä»£å…ˆå‰æ–°å»ºä¸€ä¸ªåŠ¨æ€çƒç±»çš„åšæ³•, åªç•™ä¸€ä¸ªçƒç±», è®©æ‰€æœ‰çš„çƒéƒ½åŠ¨èµ·æ¥, åªæ˜¯é‚£äº›é™æ­¢çš„çƒèµ·ç‚¹ä¸ç»ˆç‚¹ä½ç½®ç›¸åŒã€‚æˆ‘åœ¨ç¬¬ä¸€ç§æ–¹æ¡ˆå’Œç¬¬äºŒç§æ–¹æ¡ˆé—´åå¤å¾ˆè·³ã€‚æ‰€ä»¥å°±è¯·ä½ ä»¬è‡ªå·±æ ¹æ®è‡ªå·±çš„å–œå¥½æ¥é€‰æ‹©å§ã€‚çƒä¸å…‰çº¿æ±‚äº¤çš„ä»£ç å‡ ä¹æ²¡æœ‰æ”¹å˜: åªè¦æŠŠ<code>center</code>æ”¹æˆä¸€ä¸ªæ’å€¼å‡½æ•°<code>center(time)</code>å°±è¡Œäº†ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">moving_sphere::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>{</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - <span class="built_in">center</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc,r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - <span class="built_in">sqrt</span>(discriminant)) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min){</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">            vec3 outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">            rec.<span class="built_in">set_face_normal</span>(r,outward_normal);</span><br><span class="line">            rec.mat_ptr = mat_ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        temp = (-half_b + root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min){</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">            vec3 outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">            rec.<span class="built_in">set_face_normal</span>(r,outward_normal);</span><br><span class="line">            rec.mat_ptr = mat_ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Tracking-the-Time-of-Ray-Intersection"><a href="#Tracking-the-Time-of-Ray-Intersection" class="headerlink" title="Tracking the Time of Ray Intersection"></a>Tracking the Time of Ray Intersection</h4><blockquote><p>Now that rays have a time property, we need to update the <code>material::scatter()</code> methods to account for the time of intersection:</p></blockquote><p>è¯·ç¡®ä¿ä½ çš„æè´¨åœ¨è¿ç®—å…‰çº¿æ•£å°„æ—¶, æ•£å°„å…‰çº¿ä¸å…¥å°„å…‰çº¿æ‰€å­˜åœ¨çš„æ—¶é—´ç‚¹ç›¸åŒã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class lambertian : public material {</span><br><span class="line">public:</span><br><span class="line">    lambertian(const vec3&amp; a) : albedo(a) {}</span><br><span class="line"></span><br><span class="line">    virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span><br><span class="line">    ) const {</span><br><span class="line">        vec3 scatter_direction = rec.normal + random_unit_vector();</span><br><span class="line"><span class="addition">+       scattered = ray(rec.p, scatter_direction, r_in.time());</span></span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class metal : public material {</span><br><span class="line">		......</span><br><span class="line">    virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span><br><span class="line">    ) const {</span><br><span class="line">        vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);</span><br><span class="line"><span class="addition">+       scattered = ray(rec.p, reflected + fuzz * random_in_sphere(), r_in.time());</span></span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        return (dot(scattered.direction(), rec.normal) &gt; 0);</span><br><span class="line">    }</span><br><span class="line">		......</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class dielectric : public material {</span><br><span class="line">		......</span><br><span class="line">    virtual bool scatter (</span><br><span class="line">    		......</span><br><span class="line"><span class="addition">+       scattered = ray(rec.p, refracted, r_in.time());</span></span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Putting-Everything-Together"><a href="#Putting-Everything-Together" class="headerlink" title="Putting Everything Together"></a>Putting Everything Together</h4><blockquote><p>The code below takes the example diffuse spheres from the scene at the end of the last book, and makes them move during the image render. (Think of a camera with shutter opening at time 0 and closing at time 1.) Each sphere moves from its center <strong>ğ‚</strong> at time ğ‘¡=0 to <strong>ğ‚</strong>+(0,ğ‘Ÿ/2,0) at time ğ‘¡=1, where ğ‘Ÿ is a random number in [0,1):</p></blockquote><p>ä¸‹é¢çš„ä»£ç æ˜¯åœ¨ä¸Šæœ¬ä¹¦ç»“å°¾å¤„æœ€ç»ˆåœºæ™¯çš„ä¾‹å­ä¸ŠåŠ ä»¥æ”¹åŠ¨, ä½¿å…¶ä¸­æ¼«åå°„æè´¨çš„çƒåŠ¨èµ·æ¥ã€‚(æƒ³è±¡ä¸€ä¸‹æ‘„åƒæœºçš„å¿«é—¨åœ¨ <code>time0</code> æ—¶æ‰“å¼€, åœ¨ <code>time1</code> æ—¶å…³é—­)æ¯ä¸ªçƒçš„ä¸­å¿ƒåœ¨ <code>time0</code> åˆ° <code>time1</code> çš„æ—¶é—´æ®µå†…ä»åŸå§‹ä½ç½® $C$ çº¿æ€§è¿åŠ¨åˆ° $C+(0,r/2,0)$, å…¶ä¸­ $r$ æ˜¯[0,1)ä¹‹é—´çš„éšæœºæ•°ã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list random_scene() {</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(</span><br><span class="line">            vec3(0,-1000,0), 1000, make_shared&lt;lambertian&gt;(vec3(0.5, 0.5, 0.5))));</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    for (int a = -10; a &lt; 10; a++) {</span><br><span class="line">        for (int b = -10; b &lt; 10; b++) {</span><br><span class="line">            auto choose_mat = random_double();</span><br><span class="line">            vec3 center(a + 0.9*random_double(), 0.2, b + 0.9*random_double());</span><br><span class="line">            if ((center - vec3(4, 0.2, 0)).length() &gt; 0.9) {</span><br><span class="line">                if (choose_mat &lt; 0.8) {</span><br><span class="line">                    // diffuse</span><br><span class="line">                    auto albedo = vec3::random() * vec3::random();</span><br><span class="line"><span class="addition">+                   world.add(make_shared&lt;moving_sphere&gt;(</span></span><br><span class="line"><span class="addition">+                           center, center + vec3(0, random_double(0, 0.5), 0), 0.0, 1.0, 0.2,</span></span><br><span class="line"><span class="addition">+                           make_shared&lt;lambertian&gt;(albedo)));</span></span><br><span class="line"></span><br><span class="line">                } else if (choose_mat &lt; 0.95) {</span><br><span class="line">                    // metal</span><br><span class="line">                    auto albedo = vec3::random(0.5, 1);</span><br><span class="line">                    auto fuzz = random_double(0, 0.5);</span><br><span class="line">                    world.add(</span><br><span class="line">                            make_shared&lt;sphere&gt;(center, 0.2, make_shared&lt;metal&gt;(albedo, fuzz)));</span><br><span class="line">                } else {</span><br><span class="line">                    // glass</span><br><span class="line">                    world.add(make_shared&lt;sphere&gt;(center, 0.2, make_shared&lt;dielectric&gt;(1.5)));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(vec3(0, 1, 0), 1.0, make_shared&lt;dielectric&gt;(1.5)));</span><br><span class="line">    world.add(</span><br><span class="line">            make_shared&lt;sphere&gt;(vec3(-4, 1, 0), 1.0, make_shared&lt;lambertian&gt;(vec3(0.4, 0.2, 0.1))));</span><br><span class="line">    world.add(</span><br><span class="line">            make_shared&lt;sphere&gt;(vec3(4, 1, 0), 1.0, make_shared&lt;metal&gt;(vec3(0.7, 0.6, 0.5), 0.0)));</span><br><span class="line"></span><br><span class="line">    return world;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>å¹¶ä½¿ç”¨ä»¥ä¸‹çš„æ‘„åƒæœºå‚æ•°:</p><p>ä½ å°†ä¼šå¾—åˆ°ç±»ä¼¼ä¸‹é¢çš„ç»“æœ:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.01-bouncing-spheres.png"></p><h3 id="å±‚æ¬¡åŒ…å›´ç›’"><a href="#å±‚æ¬¡åŒ…å›´ç›’" class="headerlink" title="å±‚æ¬¡åŒ…å›´ç›’"></a>å±‚æ¬¡åŒ…å›´ç›’</h3><blockquote><p>This part is by far the most difficult and involved part of the ray tracer we are working on. I am sticking it in this chapter so the code can run faster, and because it refactors <code>hittable</code> a little, and when I add rectangles and boxes we wonâ€™t have to go back and refactor them.</p></blockquote><p>è¿™éƒ¨åˆ†æ˜¯ä¹¦ä¸­æœ€éš¾,ä¹Ÿæ˜¯ä¸æˆ‘ä»¬æ­£åœ¨å†™çš„å…‰çº¿è¿½è¸ªå™¨å…³è”æœ€æ·±çš„ä¸€éƒ¨åˆ†ã€‚æˆ‘æŠŠè¿™éƒ¨åˆ†æ”¾åœ¨è¿™ä¹ˆå‰é¢, æ˜¯å› ä¸ºå®ƒæ”¹å†™äº†<code>hittable</code>çš„éƒ¨åˆ†ä»£ç , ç¨‹åºè¿è¡Œèµ·æ¥æ›´åŠ çš„å¿«äº†ã€‚è€Œä¸”å½“æˆ‘ä»¬åé¢æ·»åŠ ä¸‰è§’å½¢å’Œç®±å­ç±»çš„æ—¶å€™, æˆ‘ä»¬ä¹Ÿä¸å¿…å›æ¥æ”¹å†™<code>hittable</code>äº†ã€‚</p><blockquote><p>The ray-object intersection is the main time-bottleneck in a ray tracer, and the time is linear with the number of objects. But itâ€™s a repeated search on the same model, so we ought to be able to make it a logarithmic search in the spirit of binary search. Because we are sending millions to billions of rays on the same model, we can do an analog of sorting the model, and then each ray intersection can be a sublinear search. The two most common families of sorting are to 1) divide the space, and 2) divide the objects. The latter is usually much easier to code up and just as fast to run for most models.</p></blockquote><p>å…‰çº¿çš„æ±‚äº¤è¿ç®—ä¸€ç›´æ˜¯å…‰çº¿è¿½è¸ªå™¨çš„ä¸»è¦æ—¶é—´ç“¶é¢ˆ, å¹¶ä¸”è¿è¡Œæ—¶é—´ä¸åœºæ™¯ä¸­çš„ç‰©ä½“æ•°é‡çº¿æ€§ç›¸å…³ã€‚ä½¿ç”¨éå†åå¤æŸ¥æ‰¾åŒä¸€ä¸ªæ¨¡å‹ä¼šæœ‰è®¸å¤šå¤šä½™çš„è®¡ç®—, æ‰€ä»¥æˆ‘ä»¬åº”è¯¥ç”¨äºŒå‰æœç´¢çš„æ–¹æ³•æ¥åŠ é€ŸæŸ¥æ‰¾ã€‚æˆ‘ä»¬å¯¹æ¯ä¸ªæ¨¡å‹éƒ½å°„å‡ºäº†æˆåƒä¸Šä¸‡çš„å°„çº¿, æˆ‘ä»¬å¯ä»¥å¯¹æ¨¡å‹çš„æ’åºè¿›è¡Œæ¨¡æ‹Ÿ, æ¯ä¸€æ¬¡å…‰çº¿æ±‚äº¤éƒ½æ˜¯ä¸€ä¸ªäºšçº¿æ€§(subliner)çš„æŸ¥æ‰¾ <em>ã€è¯‘æ³¨:äºšçº¿æ€§æŒ‡å‚æ•°çš„æŒ‡æ•°å°äº1, å³ä¸åˆ°çº¿æ€§, å¹³è¡¡æŸ¥æ‰¾æ ‘çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(log2(n))ã€‘</em>ã€‚æœ€å¸¸è§çš„ä¸¤ç§æ’åºæ–¹æ³•æ˜¯ 1) æŒ‰ç©ºé—´åˆ†å‰² <em>ã€è¯‘æ³¨: å¦‚KDæ ‘ã€å…«å‰æ ‘ã€‘</em> 2) æŒ‰ç‰©ä½“åˆ†å‰²ã€‚åè€…ä¸€èˆ¬æ¥è¯´å®ç°èµ·æ¥æ›´ç®€å•å¹¶ä¸”å¯¹å¤§å¤šæ•°æ¨¡å‹æ¥è¯´è¿è¡Œé€Ÿåº¦éƒ½ä¸é”™ã€‚</p><h4 id="The-Key-Idea"><a href="#The-Key-Idea" class="headerlink" title="The Key Idea"></a>The Key Idea</h4><blockquote><p>The key idea of a bounding volume over a set of primitives is to find a volume that fully encloses (bounds) all the objects. For example, suppose you computed a bounding sphere of 10 objects. Any ray that misses the bounding sphere definitely misses all ten objects. If the ray hits the bounding sphere, then it might hit one of the ten objects. So the bounding code is always of the form:</p></blockquote><p>åŒ…å›´ç›’çš„æ ¸å¿ƒæ€æƒ³æ˜¯å»æ‰¾åˆ°ä¸€ä¸ªèƒ½åŒ…å›´æ‰€æœ‰ç‰©ä½“çš„ç›’å­ã€‚ä¸¾ä¾‹æ¥è¯´, å‡è®¾ä½ è®¡ç®—äº†ä¸€ä¸ªåŒ…å›´10ä¸ªç‰©ä½“çš„å¤§çƒ, é‚£ä¹ˆä»»ä½•å°„ä¸åˆ°è¿™ä¸ªå¤§çƒçš„å°„çº¿, å®ƒéƒ½å°„ä¸åˆ°çƒé‡Œé¢çš„é‚£10ä¸ªç‰©ä½“ã€‚åä¹‹äº¦ç„¶, å¦‚æœå°„çº¿ç¢°åˆ°å¤§çƒäº†, é‚£ä¹ˆå®ƒå’Œé‡Œé¢é‚£10ä¸ªç‰©ä½“éƒ½æœ‰å¯èƒ½å‘ç”Ÿå…³ç³»ã€‚æ‰€ä»¥åŒ…å›´ç›’çš„ä»£ç çœ‹ä¸Šå»æ€»æ˜¯è¿™æ ·çš„:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ray hits bounding object)</span><br><span class="line">    <span class="keyword">return</span> whether ray hits bounded objects</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>A key thing is we are dividing objects into subsets. We are not dividing the screen or the volume. Any object is in just one bounding volume, but bounding volumes can overlap.</p></blockquote><p>è®°ä½, æˆ‘ä»¬çš„æ ¸å¿ƒæ€æƒ³æ˜¯æŠŠå¾ˆå¤šå¾ˆå¤šç‰©ä½“åˆ†å‰²ä¸ºå­é›†ã€‚æˆ‘ä»¬å¹¶ä¸åˆ’åˆ†å±å¹•æˆ–è€…æ˜¯ç©ºé—´ã€‚æ¯ä¸ªç‰©ä½“éƒ½åªåœ¨ä¸€ä¸ªåŒ…å›´ç›’é‡Œé¢, å¹¶ä¸”è¿™äº›åŒ…å›´ç›’è¿˜å¯ä»¥é‡å ã€‚</p><h4 id="Hierarchies-of-Bounding-Volumes"><a href="#Hierarchies-of-Bounding-Volumes" class="headerlink" title="Hierarchies of Bounding Volumes"></a>Hierarchies of Bounding Volumes</h4><blockquote><p>To make things sub-linear we need to make the bounding volumes hierarchical. For example, if we divided a set of objects into two groups, red and blue, and used rectangular bounding volumes, weâ€™d have:</p></blockquote><p>ä¸ºäº†åšåˆ°æ¯æ¬¡å…‰çº¿æ±‚äº¤éƒ½æ˜¯ä¸€ä¸ªäºšçº¿æ€§çš„æŸ¥æ‰¾, æˆ‘ä»¬éœ€è¦ç”¨åŒ…å›´ç›’æ„å»ºå‡ºå±‚çº§(hierarchical)ã€‚ä¸¾ä¸ªä¾‹å­, å¦‚æœæˆ‘ä»¬æŠŠä¸€å †ç‰©ä½“åˆ†æˆä¸¤é˜Ÿ, çº¢é˜Ÿå’Œè“é˜Ÿ, å¹¶ä½¿ç”¨æ–¹æ–¹æ­£æ­£çš„åŒ…å›´ç›’æ¥åŒ…å›´ä»–ä»¬, ä½ å°†çœ‹åˆ°å¦‚ä¸‹åœºæ™¯:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.01-bvol-hierarchy.jpg"></p><blockquote><p>Note that the blue and red bounding volumes are contained in the purple one, but they might overlap, and they are not ordered â€” they are just both inside. So the tree shown on the right has no concept of ordering in the left and right children; they are simply inside. The code would be:</p></blockquote><p>æ³¨æ„è“ç›’å­å’Œçº¢ç›’å­ç°åœ¨éƒ½åœ¨ç´«ç›’å­é‡Œé¢, ä»–ä»¬å¯ä»¥é‡åˆ, å¹¶ä¸”æ— åº â€”â€” ä»–ä»¬éƒ½å¹³å¹³ç­‰ç­‰çš„èººåœ¨ç´«ç›’å­çš„è‚šå­é‡Œã€‚æ‰€ä»¥å›¾ç‰‡é‡Œå³è¾¹çš„é‚£é¢—æ ‘å¹¶æ²¡æœ‰ä»€ä¹ˆå·¦å­æ ‘å³å­æ ‘çš„æ¦‚å¿µ <em>ã€è¯‘æ³¨: ä½œè€…è¿™é‡Œåªæ˜¯æƒ³å¼ºè°ƒä»–ä»¬å±äºåŒä¸€å±‚, åœ°ä½å¹³ç­‰ã€‚ç­‰å¾…ä¼šå®é™…å†™è¿™ä¸ªäºŒå‰æŸ¥æ‰¾æ ‘çš„æ—¶å€™è¿˜æ˜¯ä¼šæœ‰å·¦å­æ ‘å³å­æ ‘çš„ã€‘</em>, è¿™ä¸¤ä¸ªåˆ†æ”¯æ˜¯åŒçº§çš„ã€‚ä»£ç çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hits purple)</span><br><span class="line">    hit0 = hits blue enclosed objects</span><br><span class="line">    hit1 = hits red enclosed objects</span><br><span class="line">    <span class="keyword">if</span>(hit0 <span class="keyword">or</span> hit1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">and</span> info of closer hit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Axis-Aligned-Bounding-Boxes-AABBs"><a href="#Axis-Aligned-Bounding-Boxes-AABBs" class="headerlink" title="Axis-Aligned Bounding Boxes (AABBs)"></a>Axis-Aligned Bounding Boxes (AABBs)</h4><blockquote><p>To get that all to work we need a way to make good divisions, rather than bad ones, and a way to intersect a ray with a bounding volume. A ray bounding volume intersection needs to be fast, and bounding volumes need to be pretty compact. In practice for most models, axis-aligned boxes work better than the alternatives, but this design choice is always something to keep in mind if you encounter unusual types of models.</p></blockquote><p>ä¸ºäº†èƒ½ä½¿ä¸Šè¿°ä»£ç è‰¯å¥½çš„è·‘èµ·æ¥, æˆ‘ä»¬éœ€è¦å¥½å¥½è§„åˆ’ä¸€ä¸‹æ€ä¹ˆåˆ†å †ã€‚è¿˜å¾—æƒ³æƒ³æ€ä¹ˆå»æ£€æµ‹å…‰çº¿å’ŒåŒ…å›´ç›’ç›¸äº¤ã€‚æ±‚äº¤è®¡ç®—ä¸€å®šè¦é«˜æ•ˆ, å¹¶ä¸”åŒ…å›´ç›’è¦å°½é‡å¯†é›†ã€‚å¾ˆå¯¹å¤§å¤šæ•°æ¨¡å‹æ¥è¯´, è½´å¯¹é½çš„åŒ…å›´ç›’æ¯”å…¶ä»–ç§ç±»çš„åŒ…å›´ç›’æ•ˆæœæ›´å¥½ã€‚ä½†æ˜¯å½“ä½ é‡åˆ°æ›´å¤æ‚çš„æ¨¡å‹ç§ç±»æ—¶, ä½ å°±å…ˆåˆ«æƒ³ç€ç”¨è¿™ç§æ–¹æ³•äº†ã€‚</p><blockquote><p>From now on we will call axis-aligned bounding rectangular parallelepiped (really, that is what they need to be called if precise) axis-aligned bounding boxes, or AABBs. Any method you want to use to intersect a ray with an AABB is fine. And all we need to know is whether or not we hit it; we donâ€™t need hit points or normals or any of that stuff that we need for an object we want to display.</p></blockquote><p>ä»ç°åœ¨å¼€å§‹, æˆ‘ä»¬ä¼šæŠŠè½´å¯¹é½çš„åŒ…å›´ç›’å«æˆçŸ©å½¢å¹³è¡Œç®¡é“(è®²çœŸçš„, è¿™æ‰æ˜¯ä»–æœ¬æ¥è¯¥æœ‰çš„ç²¾ç¡®æè¿°), æˆ–è€…è¿˜æ˜¯å«ä»– <strong>AABB</strong>å§ ã€‚ä½ æƒ³ç”¨å•¥æ–¹æ³•å»ç®—å…‰çº¿å’ŒAABBæ˜¯å¦ç›¸äº¤éƒ½è¡Œã€‚æˆ‘ä»¬ç°åœ¨åªè¦èƒ½åˆ¤æ–­æˆ‘ä»¬èƒ½ä¸èƒ½å°„ä¸­è¿™ä¸ªAABBå°±è¡Œäº†ã€‚å’Œå‡»ä¸­é‚£äº›ä¼šåœ¨å±å¹•ä¸Šæ˜¾ç¤ºå‡ºæ¥çš„ç‰©ä½“æ—¶ä¸åŒ, å°„çº¿ä¸AABBæ±‚äº¤å¹¶ä¸éœ€è¦å»è·å–é‚£äº›æ³•å‘å•Šäº¤ç‚¹å•Šè¿™äº›ä¸œè¥¿, AABBä¸éœ€è¦åœ¨å±å¹•ä¸Šæ¸²æŸ“å‡ºæ¥ã€‚</p><blockquote><p>Most people use the â€œslabâ€ method. This is based on the observation that an n-dimensional AABB is just the intersection of n axis-aligned intervals, often called â€œslabsâ€ An interval is just the points between two endpoints, <em>e.g.</em>, ğ‘¥ such that 3&lt;ğ‘¥&lt;5, or more succinctly ğ‘¥x in (3,5). In 2D, two intervals overlapping makes a 2D AABB (a rectangle):</p></blockquote><p>å¤§å¤šæ•°äººé‡‡ç”¨ä¸€ä¸ªå«å †å æ³•(slab)çš„æ–¹æ³•ã€‚æ˜¾ç„¶ä¸€ä¸ªnç»´çš„AABBç›’æ˜¯ç”±nä¸ªå¹³è¡Œçº¿æ‰€æˆªçš„åŒºé—´çš„é‡å æ‹¼å‡ºæ¥çš„åŒºåŸŸ <em>ã€è¯‘æ³¨: è¿™é‡Œçœ‹å›¾å°±è¡Œäº†, åˆ«çœ‹å­—ã€‘</em>, æˆ‘ä»¬ç®¡è¿™ä¸ªå«â€slabâ€ã€‚ä¸€ä¸ªåŒºé—´å°±æ˜¯ä¸¤ä¸ªç«¯ç‚¹é—´çš„è·ç¦»ã€‚æ¯”å¦‚å¯¹äº$x$, 3&lt;x&lt;5, æˆ–è€…æ›´åŠ ç®€æ´çš„ $x$ å±äº (3,5) ã€‚åœ¨äºŒç»´çš„æƒ…å†µä¸‹, ä¸¤æ®µåŒºé—´é‡å çš„éƒ¨åˆ†å°±æ˜¯ä¸€ä¸ªäºŒç»´çš„AABB(ä¸€ä¸ªçŸ©å½¢):</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.02-2d-aabb.jpg"></p><blockquote><p>For a ray to hit one interval we first need to figure out whether the ray hits the boundaries. For example, again in 2D, this is the ray parameters ğ‘¡0 and ğ‘¡1. (If the ray is parallel to the plane those will be undefined.)</p></blockquote><p>å¯¹äºæ£€æµ‹å°„çº¿æ˜¯å¦å°„å…¥ä¸€æ®µåŒºé—´æ¥è¯´, æˆ‘ä»¬é¦–å…ˆè¦çœ‹çœ‹å°„çº¿æœ‰æ²¡æœ‰å°„å…¥è¿™ä¸ªåŒºé—´çš„è¾¹ç•Œã€‚è¿˜æ˜¯æ‹¿äºŒç»´æ¥ä¸¾ä¾‹å­, è¿™æ˜¯å…‰çº¿å˜é‡t0, t1ã€‚(åœ¨å…‰çº¿å’Œç›®æ ‡å¹³é¢å¹³è¡Œçš„æƒ…å†µä¸‹, å› ä¸ºå¹¶æ²¡æœ‰äº¤ç‚¹, è¿™ä¸¤ä¸ªå˜é‡å°†æœªå®šä¹‰)</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.03-ray-slab.jpg"></p><blockquote><p>In 3D, those boundaries are planes. The equations for the planes are $ğ‘¥=ğ‘¥_0$â€‹, and $ğ‘¥=ğ‘¥_1$. Where does the ray hit that plane? Recall that the ray can be thought of as just a function that given a ğ‘¡t returns a location <strong>ğ</strong>(ğ‘¡):</p></blockquote><p>åœ¨ä¸‰ç»´çš„æƒ…å†µä¸‹, è¿™äº›å°„å…¥çš„è¾¹ç•Œä¸å†æ˜¯ä¸€æ¡çº¿, è€Œæ˜¯ä¸€ä¸ªå¹³é¢ã€‚ è¿™ä¸¤ä¸ªè¾¹ç•Œå¹³é¢çš„æ–¹ç¨‹åˆ†åˆ«æ˜¯ $x=x0$ å’Œ $x=x1$â€‹ã€‚é‚£ä¹ˆæ€æ ·æ¥è®¡ç®—å°„çº¿å’Œå¹³é¢ç›¸äº¤å‘¢? è®©æˆ‘ä»¬å›æƒ³ä¸€ä¸‹ä¸Šä¸€æœ¬ä¹¦ä¸­æˆ‘ä»¬ç»™å‡ºçš„, ç‚¹på…³äºå‚æ•°tçš„æ–¹ç¨‹ï¼š</p><p>$P(t) = A + tb$</p><p>è¿™ä¸ªç­‰å¼ç”¨åœ¨ä¸‰ä¸ªåæ ‡è½´ä¸Šéƒ½è¡Œ, æ¯”å¦‚ï¼š</p><p>$x(t)=A_x+t_0â‹…B_x$â€‹</p><p>ç„¶åæˆ‘ä»¬æŠŠè¿™ä¸ªæ–¹ç¨‹å’Œå¹³é¢æ–¹ç¨‹ $x=x_0$ è”ç«‹, ä½¿å¾—å­˜åœ¨ä¸€ä¸ªå€¼ $t$, æ»¡è¶³ä¸‹é¢æ–¹ç¨‹:</p><p>$x_0=A_x+t_0â‹…B_x$</p><p>æˆ‘ä»¬ç¨ç¨å˜ä¸‹å½¢:</p><p>$t_0=\frac{x0âˆ’A_x}{B_x}$â€‹</p><p>åŒç†, å¯¹äº$x_1$çš„é‚£ä¸ªå¹³é¢æ¥è¯´:</p><p>$t_1=\frac{x_1âˆ’A_x}{B_x}$</p><blockquote><p>The key observation to turn that 1D math into a hit test is that for a hit, the ğ‘¡t-intervals need to overlap. For example, in 2D the green and blue overlapping only happens if there is a hit:</p></blockquote><p>æŠŠè¿™ä¸ª1Dçš„ç­‰å¼è¿ç”¨åˆ°æˆ‘ä»¬AABBæ±‚äº¤è¿ç®—çš„å…³é”®æ˜¯, ä½ éœ€è¦æŠŠnä¸ªç»´åº¦çš„tåŒºé—´é‡å åœ¨ä¸€èµ·ã€‚ä¸¾ä¾‹æ¥è¯´, åœ¨2Dæƒ…å†µä¸‹, ç»¿è‰²çš„tåŒºé—´å’Œè“è‰²çš„tåŒºé—´å‘ç”Ÿé‡å çš„æƒ…å†µå¦‚ä¸‹:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.04-ray-slab-interval.jpg"></p><p><em>ã€è¯‘æ³¨: è¿™å¼ å›¾æŒºå¥½çš„, ä¸Šé¢çš„é‚£æ¡å°„çº¿, è“è‰²ä¸ç»¿è‰²éƒ¨åˆ†æ²¡æœ‰é‡å , å¾ˆè‡ªç„¶çš„å°±æ²¡æœ‰ç©¿è¿‡è¿™ä¸ªAABBçŸ©å½¢, ä¸‹é¢é‚£æ¡å°„çº¿å‘ç”Ÿäº†é‡å , è¯´æ˜å°„çº¿åŒæ—¶ä¼ è¿‡äº†è“è‰²åŒºåŸŸå’Œç»¿è‰²åŒºåŸŸ, å³ç©¿è¿‡äº†AABBçŸ©å½¢ã€‚æ³¨æ„å¯¹æ¯ä¸€ä¸ªç»´åº¦æ¥è¯´, è¿™é‡Œæˆ‘ä»¬è§£å‡ºæ¥çš„t0, t1éƒ½è¡¨ç¤ºç›´çº¿ä¸Šä¸€ä¸ªå›ºå®šçš„ç‚¹çš„ä½ç½®, æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è‡ªç„¶åœ°æŒ‰ç…§ç»´åº¦æ‹†åˆ†è®¡ç®—, ç„¶ååœ¨é€šè¿‡tè¿™ä¸ªç»Ÿä¸€çš„æ ‡è¯†è¿›è¡Œæ±‚äº¤è¿ç®—ã€‘</em></p><h4 id="Ray-Intersection-with-an-AABB"><a href="#Ray-Intersection-with-an-AABB" class="headerlink" title="Ray Intersection with an AABB"></a>Ray Intersection with an AABB</h4><blockquote><p>The following pseudocode determines whether the ğ‘¡t intervals in the slab overlap:</p></blockquote><p>ç”¨ä»£ç è¡¨ç¤ºâ€åŒºé—´ä»¬æ˜¯å¦é‡å â€çœ‹ä¸Šå»ä¼šæ˜¯è¿™æ ·:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">compute</span>(tx0,tx1)</span><br><span class="line"><span class="built_in">compute</span>(ty0,ty1)</span><br><span class="line"><span class="keyword">return</span> overlap?( (tx0, tx1), (ty0, ty1))</span><br></pre></td></tr></tbody></table></figure><blockquote><p>That is awesomely simple, and the fact that the 3D version also works is why people love the slab method:</p></blockquote><p>è¿™çœ‹ä¸Šå»çœŸæ˜¯ç®€æ´! è€Œä¸”æ”¾åˆ°3Dçš„æƒ…å†µä¸‹ä¾æ—§é€‚ç”¨, æ‰€ä»¥å¤§å®¶éƒ½çˆ±å †å æ³•:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">compute</span>(tx0, tx1)</span><br><span class="line"><span class="built_in">compute</span>(ty0, ty1)</span><br><span class="line"><span class="built_in">compute</span>(tz0, tz1)</span><br><span class="line"><span class="keyword">return</span> overlap?( (tx0, tx1), (ty0, ty1), (tz0, tz1))</span><br></pre></td></tr></tbody></table></figure><blockquote><p>There are some caveats that make this less pretty than it first appears. First, suppose the ray is travelling in the negative ğ‘¥ direction. The interval $(ğ‘¡_{ğ‘¥0},ğ‘¡_{ğ‘¥1})$ as computed above might be reversed, <em>e.g.</em> something like (7,3). Second, the divide in there could give us infinities. And if the ray origin is on one of the slab boundaries, we can get a <code>NaN</code>. There are many ways these issues are dealt with in various ray tracersâ€™ AABB. (There are also vectorization issues like SIMD which we will not discuss here. Ingo Waldâ€™s papers are a great place to start if you want to go the extra mile in vectorization for speed.) For our purposes, this is unlikely to be a major bottleneck as long as we make it reasonably fast, so letâ€™s go for simplest, which is often fastest anyway! First letâ€™s look at computing the intervals:</p></blockquote><p>å½“ç„¶æˆ‘ä»¬è¿˜è¦å¯¹å®ƒåšä¸€äº›é™åˆ¶, è¿™ä¼šä½¿å®ƒçœ‹ä¸Šå»æ²¡æœ‰ä¸€å¼€å§‹é‚£ä¹ˆç®€æ´ã€‚é¦–å…ˆ, å‡è®¾å°„çº¿ä»xxè½´è´Ÿæ–¹å‘å°„å…¥, è¿™æ ·å‰é¢<code>compute</code>çš„è¿™ä¸ªåŒºé—´$(t_{x0},t_{x1})$â€‹å°±ä¼šåè¿‡æ¥äº†, e.g. (7,3)ã€‚ç¬¬äºŒ, é™¤æ•°ä¸ºé›¶æ—¶æˆ‘ä»¬ä¼šå¾—åˆ°æ— ç©·, å¦‚æœå°„çº¿çš„åŸç‚¹å°±åœ¨è¿™ä¸ªå †å çš„è¾¹ç•Œä¸Š, æˆ‘ä»¬å°±ä¼šå¾—åˆ° <code>NaN</code>ã€‚ä¸åŒçš„å…‰çº¿è¿½è¸ªå™¨çš„AABBéƒ¨åˆ†è§£å†³ä¸Šè¿°é—®é¢˜çš„æ–¹æ³•å¤šç§å¤šæ ·ã€‚(è¿™é‡Œè¿˜æœ‰ä¸€äº›çŸ¢é‡å¹³è¡ŒåŠ é€Ÿçš„æ–¹é¢æ¯”å¦‚SIMD, æˆ‘ä»¬æœ¬ä¹¦ä¸­ä¸è®¨è®ºã€‚å¦‚æœä½ æƒ³èµ°å¾—æ›´è¿œäº›, ä½¿ç”¨è¿™ç§æ–¹æ³•åŠ é€Ÿçš„è¯, <a target="_blank" rel="noopener" href="http://www.sci.utah.edu/~wald/PhD/wald_phd.pdf">Ingo Waldçš„è®ºæ–‡</a>å°†æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©)ã€‚å¯¹æˆ‘ä»¬æ¥è¯´, è¿™å¹¶ä¸æ˜¯ä¸€ä¸ªè¿ç®—çš„ä¸»è¦ç“¶é¢ˆã€‚æ‰€ä»¥ç›´æ¥è®©æˆ‘ä»¬ç”¨æœ€å¿«æ·æœ€ç®€å•çš„æ–¹å¼æèµ·æ¥å§! é¦–å…ˆæˆ‘ä»¬æ¥çœ‹çœ‹éœ€è¦è®¡ç®—çš„è¿™äº›åŒºé—´ã€‚</p><p>$t_{x0} = \frac{x_0 - A_x}{B_x}$</p><p>$t_{x1}=\frac{x_1-A_x}{b_x}$</p><blockquote><p>One troublesome thing is that perfectly valid rays will have $ğ‘<em>ğ‘¥=0$, causing division by zero. Some of those rays are inside the slab, and some are not. Also, the zero will have a Â± sign under IEEE floating point. The good news for $ğ‘_ğ‘¥=0$ is that $ğ‘¡</em>{ğ‘¥0}$ and $ğ‘¡_{ğ‘¥1}$ will both be +âˆ or both be -âˆ if not between $ğ‘¥_0$ and $ğ‘¥_1$. So, using min and max should get us the right answers:</p></blockquote><p>æˆ‘ä»¬çš„éº»çƒ¦æ˜¯ä¸€äº›å°„çº¿æ°å¥½ $b_x=0$, è¿™æ ·å°±ä¼šæœ‰é™¤æ•°ä¸º0çš„é”™è¯¯ã€‚ä¸€äº›å…‰çº¿åœ¨å †å çš„é‡Œé¢, ä¸€äº›ä¸åœ¨ã€‚æµ®ç‚¹0åœ¨ IEEE å·¥ç¨‹æ ‡å‡†ä¸‹æ˜¯æœ‰æ­£è´Ÿå·çš„ã€‚å¥½æ¶ˆæ¯æ˜¯, åœ¨$x_0$åˆ°$x_1$åŒºé—´å†…, $t_{x0}$ä¸$t_{x1}$è¦ä¹ˆåŒä¸ºâˆè¦ä¹ˆåŒä¸ºâˆ’âˆã€‚æ‰€ä»¥ä½¿ç”¨ min ä¸ max å‡½æ•°å°±èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æœ:</p><p>$t_{x0}=\min{(\frac{x_0-A_x}{B_x}, \frac{x_1- A_x}{B_x})}$</p><p>$t_{x1} = \max{(\frac{x_0-A_x}{B_x}, \frac{x_1-A_x}{B_x})}$</p><blockquote><p>The remaining troublesome case if we do that is if $ğ‘_ğ‘¥=0$â€‹ and either $ğ‘¥_0âˆ’ğ´_ğ‘¥=0$â€‹ or $ğ‘¥_1âˆ’ğ´_ğ‘¥=0$ so we get a <code>NaN</code>. In that case we can probably accept either hit or no hit answer, but weâ€™ll revisit that later.</p></blockquote><p>ç°åœ¨åªå‰©ä¸‹åˆ†æ¯ $B_x=0$â€‹â€‹ å¹¶ä¸” $x_0âˆ’A_x=0$â€‹â€‹ å’Œ$x_1âˆ’A_x=0$â€‹â€‹ è¿™ä¸¤ä¸ªåˆ†å­ä¹‹ä¸€ä¸ºé›¶çš„ç‰¹æ®Šæƒ…å†µäº†ã€‚è¿™æ ·æˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ª<code>NaN</code><em>ã€è¯‘æ³¨: 0/0 = NaNã€‘</em>ã€‚è¿™ç§æƒ…å†µæˆ‘ä»¬è®¤ä¸ºä»–å°„ä¸­äº†æˆ–è€…æ²¡å°„ä¸­è¿™ä¸ªåŒºåŸŸéƒ½è¡Œã€‚æˆ‘ä»¬è¿‡ä¼šå„¿å†æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p><blockquote><p>Now, letâ€™s look at that overlap function. Suppose we can assume the intervals are not reversed (so the first value is less than the second value in the interval) and we want to return true in that case. The boolean overlap that also computes the overlap interval (ğ‘“,ğ¹) of intervals (ğ‘‘,ğ·) and (ğ‘’,ğ¸) would be:</p></blockquote><p>ç°åœ¨è®©æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹<code>overlap</code>å‡½æ•°, å‡è®¾æˆ‘ä»¬èƒ½ä¿è¯åŒºé—´æ²¡æœ‰è¢«å€’è¿‡æ¥(å³ç¬¬ä¸€ä¸ªå€¼æ¯”ç¬¬äºŒä¸ªå€¼å°), åœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬ <code>return true</code>, é‚£ä¹ˆä¸€ä¸ªè®¡ç®— (d,D) å’Œ (e,E) çš„é‡å åŒºé—´ (f,F) çš„å‡½æ•°çœ‹ä¸Šå»æ˜¯è¿™æ ·çš„:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">overlap</span><span class="params">(d, D, e, E, f, F)</span></span></span><br><span class="line"><span class="function">    f </span>= <span class="built_in">max</span>(d, e)</span><br><span class="line">    F = <span class="built_in">min</span>(D, E)</span><br><span class="line">    <span class="built_in">return</span> (f &lt; F)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>If there are any <code>NaN</code>s running around there, the compare will return false so we need to be sure our bounding boxes have a little padding if we care about grazing cases (and we probably should because in a ray tracer all cases come up eventually). With all three dimensions in a loop, and passing in the interval $[ğ‘¡_{ğ‘šğ‘–ğ‘›}, ğ‘¡_{ğ‘šğ‘ğ‘¥}]$, we get:</p></blockquote><p>å¦‚æœè¿™é‡Œå‡ºç°äº†ä»»ä½•çš„ <code>NaN</code>, æ¯”è¾ƒç»“æœéƒ½ä¼š return false, æ‰€æœ‰å¦‚æœè€ƒè™‘åˆ°é‚£äº›æ“¦è¾¹çš„æƒ…å†µ, æˆ‘ä»¬è¦ä¿è¯æˆ‘ä»¬çš„åŒ…å›´ç›’æœ‰ä¸€äº›å†…é—´è·(è€Œä¸”æˆ‘ä»¬ä¹Ÿè®¸ç†åº”è¿™ä¹ˆåš, å› ä¸ºåœ¨å…‰çº¿è¿½è¸ªä¸­æ‰€æœ‰çš„æƒ…å†µæœ€ç»ˆéƒ½ä¼šå‘ç”Ÿ)ã€‚æŠŠä¸‰ä¸ªç»´åº¦éƒ½å†™åœ¨ä¸€ä¸ªå¾ªç¯ä¸­å¹¶ä¼ å…¥æ—¶é—´é—´éš” $[ğ‘¡_{ğ‘šğ‘–ğ‘›}, ğ‘¡_{ğ‘šğ‘ğ‘¥}]$ æˆ‘ä»¬å¾—åˆ°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">aabb</span>() {}</span><br><span class="line">        <span class="built_in">aabb</span>(<span class="type">const</span> vec3&amp; a, <span class="type">const</span> vec3&amp; b) { _min = a; _max = b;}</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">min</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> _min; }</span><br><span class="line">        <span class="function">vec3 <span class="title">max</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> _max; }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a++) {</span><br><span class="line">                <span class="keyword">auto</span> t0 = <span class="built_in">ffmin</span>((_min[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a],</span><br><span class="line">                                (_max[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a]);</span><br><span class="line">                <span class="keyword">auto</span> t1 = <span class="built_in">ffmax</span>((_min[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a],</span><br><span class="line">                                (_max[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a]);</span><br><span class="line">                tmin = <span class="built_in">ffmax</span>(t0, tmin);</span><br><span class="line">                tmax = <span class="built_in">ffmin</span>(t1, tmax);</span><br><span class="line">                <span class="keyword">if</span> (tmax &lt;= tmin)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        vec3 _min;</span><br><span class="line">        vec3 _max;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>æ³¨æ„æˆ‘ä»¬æŠŠ<code>cmath</code>å†…ç½®çš„<code>fmax()</code>å‡½æ•°æ¢æˆäº†æˆ‘ä»¬è‡ªå·±çš„<code>ffmax()</code>(åœ¨rtweekendä¸­å®šä¹‰)ã€‚è¿™æ ·ä¼šæ›´å¿«ä¸€ç‚¹ï¼Œ å› ä¸ºæˆ‘ä»¬è‡ªå·±å†™çš„å‡½æ•°å¹¶ä¸éœ€è¦è€ƒè™‘åˆ° <code>NaN</code> å’Œå…¶ä»–çš„å¼‚å¸¸æƒ…å†µã€‚</p><h4 id="An-Optimized-AABB-Hit-Method"><a href="#An-Optimized-AABB-Hit-Method" class="headerlink" title="An Optimized AABB Hit Method"></a>An Optimized AABB Hit Method</h4><blockquote><p>In reviewing this intersection method, Andrew Kensler at Pixar tried some experiments and proposed the following version of the code. It works extremely well on many compilers, and I have adopted it as my go-to method:</p></blockquote><p>æ¥è‡ªçš®å…‹æ–¯çš„Andrew Kensleråœ¨é˜…è¯»æˆ‘çš„è¿™ä¸ªæ±‚äº¤æ–¹æ³•æ—¶åšäº†ä¸€äº›è¯•éªŒ, å¹¶æå‡ºäº†ä¸€ä¸ªè‡ªå·±çš„ç‰ˆæœ¬ã€‚è¿™ä¸ªç‰ˆæœ¬åœ¨å¤§å¤šæ•°ç¼–è¯‘å™¨ä¸Šéƒ½è¿è¡Œçš„éå¸¸å¥½ã€‚æ‰€ä»¥æˆ‘é‡‡ç”¨äº†è¿™ä¸ªæ–¹æ³•ä½œä¸ºæˆ‘ä»¬æ¥ä¸‹æ¥è¦ä½¿ç”¨çš„æ–¹æ³•ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">aabb::hit</span><span class="params">(<span class="type">const</span> ray &amp;r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">        <span class="keyword">auto</span> invD = <span class="number">1.0f</span> / r.<span class="built_in">direction</span>()[i];</span><br><span class="line">        <span class="keyword">auto</span> t0 = (<span class="built_in">min</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">auto</span> t1 = (<span class="built_in">max</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">        tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">        tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">        <span class="keyword">if</span>(tmax &lt;= tmin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Constructing-Bounding-Boxes-for-Hittables"><a href="#Constructing-Bounding-Boxes-for-Hittables" class="headerlink" title="Constructing Bounding Boxes for Hittables"></a>Constructing Bounding Boxes for Hittables</h4><blockquote><p>We now need to add a function to compute the bounding boxes of all the hittables. Then we will make a hierarchy of boxes over all the primitives, and the individual primitivesâ€”like spheresâ€”will live at the leaves. That function returns a bool because not all primitives have bounding boxes (<em>e.g.</em>, infinite planes). In addition, moving objects will have a bounding box that encloses the object for the entire time interval [<code>time0</code>,<code>time1</code>].</p></blockquote><p>ç°åœ¨æˆ‘ä»¬éœ€è¦åŠ å…¥ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—è¿™äº›åŒ…è£¹ç€hittableç±»çš„åŒ…å›´ç›’ã€‚ç„¶åæˆ‘ä»¬å°†åšä¸€ä¸ªå±‚æ¬¡æ ‘ã€‚åœ¨è¿™ä¸ªå±‚æ¬¡æ ‘ä¸­, æ‰€æœ‰çš„å›¾å…ƒ, æ¯”å¦‚çƒä½“, éƒ½ä¼šåœ¨æ ‘çš„æœ€åº•ç«¯(å¶å­èŠ‚ç‚¹)ã€‚è¿™ä¸ªå‡½æ•°è¿”å›å€¼æ˜¯ä¸€ä¸ª bool å› ä¸ºä¸æ˜¯æ‰€æœ‰çš„å›¾å…ƒéƒ½æœ‰åŒ…å›´ç›’çš„(e.g æ— é™å»¶ä¼¸çš„å¹³é¢)ã€‚å¦å¤–, ç‰©ä½“ä¼šåŠ¨, æ‰€ä»¥ä»–è¿˜è¦æ¥æ”¶<code>time1</code>å’Œ<code>time2</code>, åŒ…å›´ç›’ä¼šæŠŠåœ¨è¿™ä¸ªæ—¶é—´åŒºé—´å†…è¿åŠ¨çš„ç‰©ä½“å®Œæ•´çš„åŒ…èµ·æ¥ã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "ray.h"</span><br><span class="line"><span class="addition">+#include "aabb.h"</span></span><br><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">class hittable {</span><br><span class="line">public:</span><br><span class="line">    virtual bool hit(const ray&amp; r,double  t_min,double  t_max,hit_record&amp; rec) const = 0;</span><br><span class="line"><span class="addition">+   virtual bool bounding_box(double t0, double t1, aabb&amp; output_box) const = 0;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Creating-Bounding-Boxes-of-Lists-of-Objects"><a href="#Creating-Bounding-Boxes-of-Lists-of-Objects" class="headerlink" title="Creating Bounding Boxes of Lists of Objects"></a>Creating Bounding Boxes of Lists of Objects</h4><blockquote><p>For a sphere, that <code>bounding_box</code> function is easy:</p></blockquote><p>å¯¹ä¸€ä¸ª<code>sphere</code>ç±»æ¥è¯´, æ±‚åŒ…å›´ç›’çœŸçš„å¤ªç®€å•äº†:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"aabb.h"</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        center - <span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + <span class="built_in">vec3</span>(radius, radius, radius));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>For <code>moving sphere</code>, we can take the box of the sphere at $ğ‘¡_0$â€‹, and the box of the sphere at $ğ‘¡_1$â€‹, and compute the box of those two boxes:</p></blockquote><p>å¯¹äº<code>moving_sphere</code>, æˆ‘ä»¬å…ˆæ±‚çƒä½“åœ¨ $t_0$ æ—¶åˆ»çš„åŒ…å›´ç›’, å†æ±‚çƒä½“åœ¨ $t_1$ æ—¶åˆ»çš„åŒ…å›´ç›’, ç„¶åå†è®¡ç®—è¿™ä¸¤ä¸ªç›’å­çš„åŒ…å›´ç›’:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"aabb.h"</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">moving_sphere::bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="function">aabb <span class="title">box0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(t0) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(t0) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="function">aabb <span class="title">box1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(t1) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(t1) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    output_box = <span class="built_in">surrounding_box</span>(box0, box1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>For lists you can store the bounding box at construction, or compute it on the fly. I like doing it the fly because it is only usually called at BVH construction.</p></blockquote><p>å¯¹äº<code>hittable_list</code>æ¥è¯´, æˆ‘ä»¬å¯ä»¥åœ¨æ„é€ å‡½æ•°ä¸­å°±è¿›è¡ŒåŒ…å›´ç›’çš„è¿ç®—, æˆ–è€…åœ¨ç¨‹åºè¿è¡Œæ—¶è®¡ç®—ã€‚æˆ‘å–œæ¬¢åœ¨è¿è¡Œæ—¶è®¡ç®—, å› ä¸ºè¿™äº›åŒ…å›´ç›’çš„è®¡ç®—ä¸€èˆ¬åªæœ‰åœ¨BVHæ„é€ æ—¶æ‰ä¼šè¢«è°ƒç”¨ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"aabb.h"</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb &amp;output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    aabb temp_box;</span><br><span class="line">    <span class="type">bool</span> first_box = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) {</span><br><span class="line">        <span class="keyword">if</span> (!object-&gt;<span class="built_in">bounding_box</span>(t0, t1, temp_box))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        output_box = first_box ? temp_box : <span class="built_in">surrounding_box</span>(output_box, temp_box);</span><br><span class="line">        first_box = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This requires the <code>surrounding_box</code> function for <code>aabb</code> which computes the bounding box of two boxes:</p></blockquote><p>æˆ‘ä»¬éœ€è¦ä¸€ä¸ª<code>surrounding_box</code>å‡½æ•°æ¥è®¡ç®—åŒ…å›´ç›’çš„åŒ…å›´ç›’ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">aabb <span class="title">surrounding_box</span><span class="params">(aabb box0, aabb box1)</span> </span>{</span><br><span class="line">    <span class="function">vec3 <span class="title">small</span><span class="params">(ffmin(box0.min().x(), box1.min().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">               ffmin(box0.min().y(), box1.min().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">               ffmin(box0.min().z(), box1.min().z()))</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">big</span>  <span class="params">(ffmax(box0.max().x(), box1.max().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">               ffmax(box0.max().y(), box1.max().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">               ffmax(box0.max().z(), box1.max().z()))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">aabb</span>(small,big);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="The-BVH-Node-Class"><a href="#The-BVH-Node-Class" class="headerlink" title="The BVH Node Class"></a>The BVH Node Class</h4><blockquote><p>A BVH is also going to be a <code>hittable</code> â€” just like lists of <code>hittable</code>s. Itâ€™s really a container, but it can respond to the query â€œdoes this ray hit you?â€. One design question is whether we have two classes, one for the tree, and one for the nodes in the tree; or do we have just one class and have the root just be a node we point to. I am a fan of the one class design when feasible. Here is such a class:</p></blockquote><p>BVHä¹Ÿåº”è¯¥æ˜¯<code>hittable</code>çš„ä¸€å‘˜, å°±åƒ<code>hittable_list</code>ç±»é‚£æ ·ã€‚BVHè™½ç„¶æ˜¯ä¸ªå®¹å™¨, ä½†ä¹Ÿèƒ½å¯¹äºé—®é¢˜â€œè¿™æ¡å…‰çº¿å°„ä¸­ä½ äº†ä¹ˆ?â€åšå‡ºå›ç­”ã€‚ä¸€ä¸ªè®¾è®¡ä¸Šçš„é—®é¢˜æ˜¯, æˆ‘ä»¬æ˜¯ä¸ºæ ‘å’Œæ ‘çš„èŠ‚ç‚¹è®¾è®¡ä¸¤ä¸ªä¸åŒçš„ç±»å‘¢, è¿˜æ˜¯ç”¨ä¸€ä¸ªç±»åŠ ä¸ŠæŒ‡é’ˆæ¥æå®šã€‚æˆ‘æ˜¯ä¸€ä¸ªç±»æå®šæ´¾, æ‰€ä»¥è¿™ä¸ª <code>bvh.h</code> ç±»ä¼šæ˜¯è¿™æ ·:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAYTRACING_DEV_BVH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAYTRACING_DEV_BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable_list.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bvh_node</span> : <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bvh_node</span>() {};</span><br><span class="line">    <span class="built_in">bvh_node</span>(hittable_list&amp; list, <span class="type">double</span> time0, <span class="type">double</span> time1)</span><br><span class="line">        : <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>(), time0, time1) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bvh_node</span>(std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; objects,</span><br><span class="line">            <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bouding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; left;</span><br><span class="line">    shared_ptr&lt;hittable&gt; right;</span><br><span class="line">    aabb box;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::bouding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb &amp;output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    output_box = box;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//RAYTRACING_DEV_BVH_H</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Note that the children pointers are to generic hittables. They can be other <code>bvh_nodes</code>, or <code>spheres</code>, or any other <code>hittable</code>.</p><p>The <code>hit</code> function is pretty straightforward: check whether the box for the node is hit, and if so, check the children and sort out any details:</p></blockquote><p>æ³¨æ„æˆ‘ä»¬çš„å­èŠ‚ç‚¹æŒ‡é’ˆæ˜¯<code>hittable*</code>, æ‰€ä»¥è¿™ä¸ªæŒ‡é’ˆå¯ä»¥æŒ‡å‘æ‰€æœ‰çš„<code>hittable</code>ç±»ã€‚ä¾‹å¦‚èŠ‚ç‚¹<code>bvh_node</code>ï¼Œ æˆ–è€…æ˜¯<code>sphere</code>, æˆ–è€…æ˜¯å…¶ä»–å„ç§å„æ ·çš„å›¾å…ƒã€‚</p><p><code>hit</code> å‡½æ•°ä¹Ÿæ˜¯ååˆ†çš„ç›´æ¥æ˜äº†: æ£€æŸ¥è¿™ä¸ªèŠ‚ç‚¹çš„boxæ˜¯å¦è¢«å‡»ä¸­, å¦‚æœæ˜¯çš„è¯, é‚£å°±å¯¹è¿™ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹è¿›è¡Œåˆ¤æ–­ã€‚<em>ã€è¯‘æ³¨: å¯¹äºäºŒå‰æ ‘æ¥è¯´, è¿™æ ·çš„é€’å½’ç»“æ„ç›¸ä¿¡å¤§å®¶å¹¶ä¸é™Œç”Ÿã€‘</em></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::hit</span><span class="params">(<span class="type">const</span> ray &amp;r, <span class="type">double</span> tmin, <span class="type">double</span> tmax, hit_record &amp;rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, tmin, tmax))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, tmin, tmax, rec);</span><br><span class="line">    <span class="type">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, tmin, hit_left ? rec.t : tmax, rec);</span><br><span class="line">    <span class="keyword">return</span> hit_left || hit_right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Splitting-BVH-Volumes"><a href="#Splitting-BVH-Volumes" class="headerlink" title="Splitting BVH Volumes"></a>Splitting BVH Volumes</h4><blockquote><p>The most complicated part of any efficiency structure, including the BVH, is building it. We do this in the constructor. A cool thing about BVHs is that as long as the list of objects in a <code>bvh_node</code> gets divided into two sub-lists, the hit function will work. It will work best if the division is done well, so that the two children have smaller bounding boxes than their parentâ€™s bounding box, but that is for speed not correctness. Iâ€™ll choose the middle ground, and at each node split the list along one axis. Iâ€™ll go for simplicity:</p><ol><li>randomly choose an axis</li><li>sort the primitives (<code>using std::sort</code>)</li><li>put half in each subtree</li></ol><p>When the list coming in is two elements, I put one in each subtree and end the recursion. The traversal algorithm should be smooth and not have to check for null pointers, so if I just have one element I duplicate it in each subtree. Checking explicitly for three elements and just following one recursion would probably help a little, but I figure the whole method will get optimized later. This yields:</p></blockquote><p>ä»»ä½•é«˜æ•ˆçš„æ•°æ®ç»“æ„, ä¾‹å¦‚BVH, æœ€å¤æ‚çš„éƒ¨åˆ†å°±æ˜¯å¦‚ä½•å»æ„å»ºä»–ã€‚æˆ‘ä»¬ä¼šåœ¨æ„é€ å‡½æ•°é‡Œå®Œæˆã€‚ å¯¹äºBVHæ¥è¯´, å¾ˆé…·çš„ä¸€ç‚¹æ˜¯å½“ä½ ä¸æ–­åœ°æŠŠ<code>bvh_node</code>ä¸­çš„ç‰©ä½“åˆ†å‰²æˆä¸¤ä¸ªå­é›†çš„åŒæ—¶, hitå‡½æ•°ä¹Ÿä¼šè·Ÿç€æ‰§è¡Œã€‚å¦‚æœè¯´ä½ åˆ†å‰²çš„ç®—æ³•å¾ˆå¥½, ä¸¤ä¸ªå­©å­çš„åŒ…å›´ç›’éƒ½æ¯”å…¶çˆ¶èŠ‚ç‚¹çš„åŒ…å›´ç›’è¦å°, é‚£ä¹ˆè‡ªç„¶hitå‡½æ•°ä¹Ÿä¼šè¿è¡Œçš„å¾ˆå¥½ã€‚ä½†æ˜¯è¿™æ ·åªæ˜¯å¿«, å¹¶ä¸æ­£ç¡®, æˆ‘å°†åœ¨æ­£ç¡®å’Œå¿«ç›´æ¥åšå–èˆ, åœ¨æ¯æ¬¡åˆ†å‰²æ—¶æˆ‘æ²¿ç€ä¸€ä¸ªè½´æŠŠç‰©ä½“åˆ—è¡¨åˆ†æˆä¸¤åŠã€‚æˆ‘å°†é‡‡ç”¨æœ€ç®€å•ç›´æ¥çš„åˆ†å‰²åŸåˆ™:</p><p>1.éšæœºé€‰å–ä¸€ä¸ªè½´æ¥åˆ†å‰²<br>2.ä½¿ç”¨åº“å‡½æ•°<code>sort()</code>å¯¹å›¾å…ƒè¿›è¡Œæ’åº<br>3.å¯¹åŠåˆ†, æ¯ä¸ªå­æ ‘åˆ†ä¸€åŠçš„ç‰©ä½“</p><p>ç‰©ä½“åˆ†å‰²è¿‡ç¨‹é€’å½’æ‰§è¡Œ, å½“æ•°ç»„ä¼ å…¥æ—¶åªå‰©ä¸‹ä¸¤ä¸ªå…ƒç´ æ—¶, æˆ‘åœ¨ä¸¤ä¸ªå­æ ‘èŠ‚ç‚¹å„æ”¾ä¸€ä¸ª, å¹¶ç»“æŸé€’å½’ã€‚ä¸ºäº†ä½¿éå†ç®—æ³•å¹³æ»‘, å¹¶ä¸”ä¸å»æ£€æŸ¥ç©ºæŒ‡é’ˆ, å½“åªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶, æˆ‘å°†å…¶é‡å¤çš„æ”¾åœ¨æ¯ä¸€ä¸ªå­æ ‘é‡Œã€‚æƒ³è±¡ä¸€ä¸‹æœ‰ä¸‰ä¸ªå…ƒç´ , ç„¶åä»”ç»†çš„ä¸€æ­¥æ­¥é€’å½’ä¸€éæœ‰åŠ©ä½ ç†è§£ç®—æ³•, ä½†æˆ‘è¿™é‡Œå…ˆæä¸€ä¸‹, ä¹‹åæˆ‘ä»¬ä¼šä¼˜åŒ–æ•´ä¸ªç®—æ³•ã€‚ç°åœ¨ä»£ç æ˜¯è¿™æ ·çš„:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">bvh_node::<span class="built_in">bvh_node</span>(</span><br><span class="line">    std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; objects,</span><br><span class="line">    <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1</span><br><span class="line">) {</span><br><span class="line">    <span class="type">int</span> axis = <span class="built_in">random_int</span>(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis == <span class="number">0</span>) ? box_x_compare</span><br><span class="line">                    : (axis == <span class="number">1</span>) ? box_y_compare</span><br><span class="line">                                  : box_z_compare;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> object_span = end - start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object_span == <span class="number">1</span>) {</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (object_span == <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comparator</span>(objects[start], objects[start+<span class="number">1</span>])) {</span><br><span class="line">            left = objects[start];</span><br><span class="line">            right = objects[start+<span class="number">1</span>];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            left = objects[start+<span class="number">1</span>];</span><br><span class="line">            right = objects[start];</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>() + start, objects.<span class="built_in">begin</span>() + end, comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span/<span class="number">2</span>;</span><br><span class="line">        left = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid, time0, time1);</span><br><span class="line">        right = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end, time0, time1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    aabb box_left, box_right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (  !left-&gt;<span class="built_in">bounding_box</span> (time0, time1, box_left)</span><br><span class="line">       || !right-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_right)</span><br><span class="line">    )</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"No bounding box in bvh_node constructor.\n"</span>;</span><br><span class="line"></span><br><span class="line">    box = <span class="built_in">surrounding_box</span>(box_left, box_right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>è¿™é‡Œæš‚æ—¶æœ‰æŠ¥é”™ä¹Ÿä¸è¦ç€æ€¥ï¼Œåé¢ä¼šæŠŠè¿™äº›æœªå£°æ˜å‡½æ•°è¡¥ä¸Šå»ã€‚</p><blockquote><p>This uses a new function: <code>random_int()</code>:</p></blockquote><p>åœ¨ <code>rtweekend.h</code> ä¸­æ·»åŠ å‡½æ•° <code>random_int()</code>ï¼š</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">random_int</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>{</span><br><span class="line">    <span class="comment">// Returns a random integer in [min,max].</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">random_double</span>(min, max+<span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The check for whether there is a bounding box at all is in case you sent in something like an infinite plane that doesnâ€™t have a bounding box. We donâ€™t have any of those primitives, so it shouldnâ€™t happen until you add such a thing.</p></blockquote><p>è¿™è¾¹åšäº†ä¸€ä¸ªç‰©ä½“æ˜¯å¦æœ‰åŒ…å›´ç›’çš„æ£€æŸ¥, æ˜¯ä¸ºäº†é˜²æ­¢ä½ æŠŠä¸€äº›å¦‚æ— é™å»¶ä¼¸çš„å¹³é¢è¿™æ ·æ²¡æœ‰åŒ…å›´ç›’çš„ä¸œè¥¿ä¼ è¿›å»å½“å‚æ•°ã€‚æˆ‘ä»¬ç°åœ¨å¹¶æ²¡æœ‰è¿™æ ·çš„å›¾å…ƒ, æ‰€ä»¥åœ¨ä½ æ‰‹åŠ¨æ·»åŠ è¿™æ ·çš„å›¾å…ƒä¹‹å‰, è¿™ä¸ª<code>std::cerr</code>å¹¶ä¸ä¼šè¢«æ‰§è¡Œã€‚</p><h4 id="The-Box-Comparison-Functions"><a href="#The-Box-Comparison-Functions" class="headerlink" title="The Box Comparison Functions"></a>The Box Comparison Functions</h4><blockquote><p>Now we need to implement the box comparison functions, used by <code>std::sort()</code>. To do this, create a generic comparator returns true if the first argument is less than the second, given an additional axis index argument. Then define axis-specific comparison functions that use the generic comparison function.</p></blockquote><p>ç°åœ¨æˆ‘ä»¬éœ€è¦å®ç°<code>std::sort()</code>ä½¿ç”¨çš„æ¯”è¾ƒå‡½æ•°ã€‚æˆ‘ä»¬å…ˆåˆ¤æ–­æ˜¯å“ªä¸ªè½´, ç„¶åå¯¹åº”çš„ä¸ºæˆ‘ä»¬çš„æ¯”è¾ƒå™¨èµ‹å€¼ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">box_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b, <span class="type">int</span> axis)</span> </span>{</span><br><span class="line">    aabb box_a;</span><br><span class="line">    aabb box_b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>,<span class="number">0</span>, box_a) || !b-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>,<span class="number">0</span>, box_b))</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"No bounding box in bvh_node constructor.\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> box_a.<span class="built_in">min</span>().e[axis] &lt; box_b.<span class="built_in">min</span>().e[axis];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_x_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_y_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_z_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em>ã€è¯‘æ³¨: ä½¿ç”¨æ–¹æ³•ï¼šåœ¨ <code>random_scene()</code>å‡½æ•°æœ€å<code>return static_cast&lt;hittable_list&gt;(make_shared&lt;bvh_node&gt;(world,0,1));</code>ã€‘</em></p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list random_scene() {</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="addition">+	return static_cast&lt;hittable_list&gt;(make_shared&lt;bvh_node&gt;(world,0,1));</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="å›ºä½“è´´å›¾"><a href="#å›ºä½“è´´å›¾" class="headerlink" title="å›ºä½“è´´å›¾"></a>å›ºä½“è´´å›¾</h3><blockquote><p>A texture in graphics usually means a function that makes the colors on a surface procedural. This procedure can be synthesis code, or it could be an image lookup, or a combination of both. We will first make all colors a texture. Most programs keep constant rgb colors and textures in different classes, so feel free to do something different, but I am a big believer in this architecture because being able to make any color a texture is great.</p></blockquote><p>åœ¨å›¾å½¢å­¦ä¸­, çº¹ç†è´´å›¾å¸¸å¸¸æ„å‘³ç€ä¸€ä¸ªå°†é¢œè‰²èµ‹äºˆç‰©é¢˜è¡¨é¢çš„ä¸€ä¸ªè¿‡ç¨‹ã€‚è¿™ä¸ªè¿‡ç¨‹å¯ä»¥æ˜¯çº¹ç†ç”Ÿæˆä»£ç , æˆ–è€…æ˜¯ä¸€å¼ å›¾ç‰‡, æˆ–è€…æ˜¯ä¸¤è€…çš„ç»“åˆã€‚æˆ‘ä»¬é¦–å…ˆæ¥ä½¿ç”¨é¢œè‰²ä½œä¸ºè´´å›¾ã€‚å¤§å¤šæ•°ç¨‹åºå‘˜æŠŠé™æ€rgbé¢œè‰²å’Œè´´å›¾å†™æˆä¸¤ä¸ªä¸åŒçš„ç±», ä»¥æ­¤æ¥åŒºåˆ†ä¸¤è€…, ä½†æˆ‘æ›´åŠ å–œæ¬¢ä¸‹é¢çš„åšæ³•, å› ä¸ºè¿™æ ·å°±å¯ä»¥æŠŠä»»ä½•é¢œè‰²å¼„æˆä¸€å¼ è´´å›¾, ååˆ†çš„greatã€‚</p><h4 id="The-First-Texture-Class-Constant-Texture"><a href="#The-First-Texture-Class-Constant-Texture" class="headerlink" title="The First Texture Class: Constant Texture"></a>The First Texture Class: Constant Texture</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">texture</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constant_texture</span> : <span class="keyword">public</span> texture {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">constant_texture</span>() {}</span><br><span class="line">    <span class="built_in">constant_texture</span>(vec3 c) : <span class="built_in">color</span>(c) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 color;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Weâ€™ll need to update the <code>hit_record</code> structure to store the U,V surface coordinates of the ray-object hit point.</p></blockquote><p>æˆ‘ä»¬éœ€è¦æ›´æ–°<code>hit_record</code>ç»“æ„ä½“æ¥å‚¨å­˜å‡»ä¸­ç‚¹çš„uvä¿¡æ¯:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">struct hit_record {</span><br><span class="line">    vec3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">    double t;</span><br><span class="line"><span class="addition">+   double u;</span></span><br><span class="line"><span class="addition">+   double v;</span></span><br><span class="line">    bool front_face;</span><br><span class="line">	......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Now we can make textured materials by replacing the <code>const color&amp; a</code> with a texture pointer:</p></blockquote><p>æŠŠvec3çš„é¢œè‰²æ¢æˆä¸€ä¸ªçº¹ç†æŒ‡é’ˆ, ä½ å°†å¾—åˆ°ä¸€ä¸ªçº¹ç†æè´¨ã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+#include "texture.h"</span></span><br><span class="line"></span><br><span class="line">class lambertian : public material {</span><br><span class="line">public:</span><br><span class="line"><span class="deletion">-   lambertian(const vec3&amp; a) : albedo(a) {}</span></span><br><span class="line"><span class="addition">+   lambertian(shared_ptr&lt;texture&gt; a) : albedo(a) {}</span></span><br><span class="line"><span class="addition">+   lambertian(const vec3&amp; a) : albedo(make_shared&lt;constant_texture&gt;(a)) {}</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">class lambertian : public material {</span><br><span class="line">public:</span><br><span class="line">    lambertian(const vec3&amp; a) : albedo(a) {}</span><br><span class="line"></span><br><span class="line">    virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span><br><span class="line">    ) const {</span><br><span class="line">        vec3 scatter_direction = rec.normal + random_unit_vector();</span><br><span class="line">        scattered = ray(rec.p, scatter_direction, r_in.time());</span><br><span class="line"><span class="deletion">-       attenuation = albedo;</span></span><br><span class="line"><span class="addition">+		attenuation = albedo-&gt;value(rec.u, rec.v, rec.p);</span></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">public:</span><br><span class="line"><span class="deletion">-   vec3 albedo;</span></span><br><span class="line"><span class="addition">+	shared_ptr&lt;texture&gt; albedo;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>åœ¨ä¹‹å‰ä¸€ä¸ªlambertæè´¨æ˜¯è¿™æ ·çš„:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">...<span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))</span><br></pre></td></tr></tbody></table></figure><p>ç°åœ¨æˆ‘ä»¬æŠŠ<code>vec3(...)</code>æ¢æˆ<code>make_shared&lt;constant_texture&gt;(vec3(...))</code></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">...<span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)))</span><br></pre></td></tr></tbody></table></figure><h4 id="A-Checker-Texture"><a href="#A-Checker-Texture" class="headerlink" title="A Checker Texture"></a>A Checker Texture</h4><blockquote><p>We can create a checker texture by noting that the sign of sine and cosine just alternates in a regular way, and if we multiply trig functions in all three dimensions, the sign of that product forms a 3D checker pattern.</p></blockquote><p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨sineå’Œcosineå‡½æ•°å‘¨æœŸæ€§çš„å˜åŒ–æ¥åšä¸€ä¸ªæ£‹ç›˜æ ¼çº¹ç†ã€‚å¦‚æœæˆ‘ä»¬åœ¨ä¸‰ä¸ªç»´åº¦éƒ½ä¹˜ä¸Šè¿™ä¸ªå‘¨æœŸå‡½æ•°, å°±ä¼šå½¢æˆä¸€ä¸ª3Dçš„æ£‹ç›˜æ ¼æ¨¡å‹ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">constant_texture</span> : <span class="keyword">public</span> texture {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">constant_texture</span>() {}</span><br><span class="line">    <span class="built_in">constant_texture</span>(vec3 c) : <span class="built_in">color</span>(c) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 color;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">checker_texture</span> : <span class="keyword">public</span> texture {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">checker_texture</span>() {}</span><br><span class="line">    <span class="built_in">checker_texture</span>(shared_ptr&lt;texture&gt; t0, shared_ptr&lt;texture&gt; t1) : <span class="built_in">odd</span>(t0), <span class="built_in">even</span>(t1) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> sines = <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">x</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">y</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="keyword">if</span> (sines &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> odd-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> even-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; odd;</span><br><span class="line">    shared_ptr&lt;texture&gt; even;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Those checker odd/even pointers can be to a constant texture or to some other procedural texture. This is in the spirit of shader networks introduced by Pat Hanrahan back in the 1980s.</p><p>If we add this to our <code>random_scene()</code> functionâ€™s base sphere:</p></blockquote><p>è¿™äº›å¥‡å¶æ ¼çš„æŒ‡é’ˆå¯ä»¥æŒ‡å‘ä¸€ä¸ªé™æ€çº¹ç†, ä¹Ÿå¯ä»¥æŒ‡å‘ä¸€äº›ç¨‹åºç”Ÿæˆçš„çº¹ç†ã€‚è¿™å°±æ˜¯Pat Hanrahanåœ¨1980å¹´ä»£æå‡ºçš„ç€è‰²å™¨ç½‘ç»œçš„æ ¸å¿ƒæ€æƒ³ã€‚</p><p>å¦‚æœæˆ‘ä»¬æŠŠè¿™ä¸ªçº¹ç†è´´åœ¨æˆ‘ä»¬<code>random_scene()</code>å‡½æ•°é‡Œåº•ä¸‹é‚£ä¸ªå¤§çƒä¸Š:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list random_scene() {</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   world.add(make_shared&lt;sphere&gt;(</span></span><br><span class="line"><span class="deletion">-           vec3(0,-1000,0), 1000, make_shared&lt;lambertian&gt;(vec3(0.5, 0.5, 0.5))));</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto checker = make_shared&lt;checker_texture&gt;(</span></span><br><span class="line"><span class="addition">+           make_shared&lt;constant_texture&gt;(vec3(0.2, 0.3, 0.1)),</span></span><br><span class="line"><span class="addition">+           make_shared&lt;constant_texture&gt;(vec3(0.9, 0.9, 0.9))</span></span><br><span class="line"><span class="addition">+   );</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   world.add(make_shared&lt;sphere&gt;(vec3(0, -1000, 0), 1000, make_shared&lt;lambertian&gt;(checker)));</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We get:</p></blockquote><p>æˆ‘ä»¬å°†å¾—åˆ°:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.02-checker-ground.png"></p><h4 id="Rendering-a-Scene-with-a-Checkered-Texture"><a href="#Rendering-a-Scene-with-a-Checkered-Texture" class="headerlink" title="Rendering a Scene with a Checkered Texture"></a>Rendering a Scene with a Checkered Texture</h4><blockquote><p>Weâ€™re going to add a second scene to our program, and will add more scenes after that as we progress through this book. To help with this, weâ€™ll set up a hard-coded switch statement to select the desired scene for a given run. Clearly, this is a crude approach, but weâ€™re trying to keep things dead simple and focus on the raytracing. You may want to use a different approach in your own raytracer.</p><p>Hereâ€™s the scene construction function:</p></blockquote><p>å¦‚æœæˆ‘ä»¬æ·»åŠ ä¸€ä¸ªæ–°åœºæ™¯:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">two_spheres</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>)),</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ä½¿ç”¨ä»¥ä¸‹çš„æ‘„åƒæœºå‚æ•°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// World</span></span><br><span class="line"><span class="comment">//auto world = random_scene();</span></span><br><span class="line"><span class="keyword">auto</span> world = <span class="built_in">two_spheres</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Camera</span></span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We get this result:</p></blockquote><p>æˆ‘ä»¬å°†å¾—åˆ°:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.03-checker-spheres.png"></p><h3 id="æŸæ—å™ªéŸ³"><a href="#æŸæ—å™ªéŸ³" class="headerlink" title="æŸæ—å™ªéŸ³"></a>æŸæ—å™ªéŸ³</h3><blockquote><p>To get cool looking solid textures most people use some form of Perlin noise. These are named after their inventor Ken Perlin. Perlin texture doesnâ€™t return white noise like this:</p></blockquote><p>ä¸ºäº†å¾—åˆ°ä¸€ä¸ªçœ‹ä¸Šå»å¾ˆcoolçš„çº¹ç†, å¤§éƒ¨åˆ†äººä½¿ç”¨æŸæ—å™ªå£°(Perlin noise)ã€‚æŸæ—å™ªå£°æ˜¯ä»¥å®ƒçš„å‘æ˜è€…Ken Perlinå‘½åçš„ã€‚æŸæ—å™ªå£°å¹¶ä¸ä¼šå¾—åˆ°ä»¥ä¸‹çš„ç™½å™ªå£°:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.04-white-noise.jpg"></p><blockquote><p>Instead it returns something similar to blurred white noise:</p></blockquote><p>å–è€Œä»£ä¹‹çš„æ˜¯ä¸€äº›ç±»ä¼¼æ¨¡ç³Šåçš„ç™½å™ªå£°:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.05-white-noise-blurred.jpg"></p><blockquote><p>A key part of Perlin noise is that it is repeatable: it takes a 3D point as input and always returns the same randomish number. Nearby points return similar numbers. Another important part of Perlin noise is that it be simple and fast, so itâ€™s usually done as a hack. Iâ€™ll build that hack up incrementally based on Andrew Kenslerâ€™s description.</p></blockquote><p>æŸæ—å™ªå£°çš„å…³é”®ç‰¹ç‚¹æ˜¯å¯å¤ç°æ€§ã€‚å¦‚æœè¾“å…¥çš„æ˜¯åŒä¸€ä¸ªä¸‰ç»´ç©ºé—´ä¸­çš„ç‚¹, ä»–çš„è¾“å‡ºå€¼æ€»æ˜¯ç›¸åŒçš„ã€‚æŸæ—å™ªå£°çš„å¦ä¸€ä¸ªç‰¹ç‚¹æ˜¯å®ƒå®ç°èµ·æ¥ç®€å•å¿«æ·ã€‚æ‰€ä»¥é€šå¸¸æ¥è¯´æˆ‘ä»¬æ‹¿æŸæ—å™ªå£°æ¥åšä¸€äº›hackçš„äº‹æƒ…ã€‚æˆ‘ä¼šåœ¨Andrew Kenslerçš„æè¿°ä¸‹é€æ­¥çš„å®ç°è¿™äº›hackçš„äº‹æƒ…ã€‚</p><h4 id="Using-Blocks-of-Random-Numbers"><a href="#Using-Blocks-of-Random-Numbers" class="headerlink" title="Using Blocks of Random Numbers"></a>Using Blocks of Random Numbers</h4><blockquote><p>We could just tile all of space with a 3D array of random numbers and use them in blocks. You get something blocky where the repeating is clear:</p></blockquote><p>æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªéšæœºç”Ÿæˆçš„ä¸‰ç»´æ•°ç»„é“ºæ»¡(tile)æ•´ä¸ªç©ºé—´, ä½ ä¼šå¾—åˆ°æ˜æ˜¾é‡å¤çš„åŒºå—:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.06-tile-random.jpg"></p><blockquote><p>Letâ€™s just use some sort of hashing to scramble this, instead of tiling. This has a bit of support code to make it all happen:</p></blockquote><p>ä¸ä½¿ç”¨ç“·ç –è´´å›¾çš„æ–¹æ³•, è®©æˆ‘ä»¬ç”¨å“ˆå¸Œè¡¨å»å®Œæˆä»–, ä»£ç å¦‚ä¸‹:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">perlin</span>() {</span><br><span class="line">            ranfloat = <span class="keyword">new</span> <span class="type">double</span>[point_count];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) {</span><br><span class="line">                ranfloat[i] = <span class="built_in">random_double</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">            perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">            perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">perlin</span>() {</span><br><span class="line">            <span class="keyword">delete</span>[] ranfloat;</span><br><span class="line">            <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">            <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">            <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">            <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">            <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>*p.<span class="built_in">x</span>()) &amp; <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>*p.<span class="built_in">y</span>()) &amp; <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>*p.<span class="built_in">z</span>()) &amp; <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ranfloat[perm_x[i] ^ perm_y[j] ^ perm_z[k]];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">        <span class="type">double</span>* ranfloat;</span><br><span class="line">        <span class="type">int</span>* perm_x;</span><br><span class="line">        <span class="type">int</span>* perm_y;</span><br><span class="line">        <span class="type">int</span>* perm_z;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">                p[i] = i;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">                <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">                <span class="type">int</span> tmp = p[i];</span><br><span class="line">                p[i] = p[target];</span><br><span class="line">                p[target] = tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Now if we create an actual texture that takes these floats between 0 and 1 and creates grey colors:</p></blockquote><p>ç°åœ¨è®©æˆ‘ä»¬æ¥ç”Ÿæˆä¸€ä¸ªçº¹ç†, ä½¿ç”¨èŒƒå›´ä¸º0åˆ°1çš„ä¸€ä¸ªfloatå˜é‡æ¥åˆ¶é€ ç°åº¦å›¾:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+#include "perlin.h"</span></span><br><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="addition">+class nosie_texture : public texture {</span></span><br><span class="line"><span class="addition">+public:</span></span><br><span class="line"><span class="addition">+   nosie_texture() {}</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   virtual vec3 value(double u, double v, const vec3&amp; p) const {</span></span><br><span class="line"><span class="addition">+       return vec3(1, 1, 1) * noise.noise(p);</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+public:</span></span><br><span class="line"><span class="addition">+   perlin noise;</span></span><br><span class="line"><span class="addition">+};</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can use that texture on some spheres:</p></blockquote><p>æˆ‘ä»¬å¯ä»¥æŠŠçº¹ç†è¿ç”¨åœ¨ä¸€äº›çƒä¸Š:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list objects;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> pertex = <span class="built_in">make_shared</span>&lt;nosie_texture&gt;();</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertex)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertex)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>å¹¶ä½¿ç”¨å’Œä¹‹å‰ç›¸åŒçš„æ‘„åƒæœºå‚æ•°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="built_in">double</span>(image_width) / image_height;</span><br><span class="line">...</span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Add the hashing does scramble as hoped:</p></blockquote><p>å¦‚æˆ‘ä»¬æ‰€æ„¿, æˆ‘ä»¬æˆåŠŸçš„ä½¿ç”¨å“ˆå¸Œç”Ÿæˆäº†ä¸‹é¢çš„å›¾æ¡ˆ:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.07-hash-random.png"></p><h4 id="Smoothing-out-the-Result"><a href="#Smoothing-out-the-Result" class="headerlink" title="Smoothing out the Result"></a>Smoothing out the Result</h4><blockquote><p>To make it smooth, we can linearly interpolate:</p></blockquote><p>ä¸ºäº†è®©å®ƒçœ‹ä¸Šå»æ›´åŠ å¹³æ»‘, æˆ‘ä»¬å¯ä»¥é‡‡ç”¨çº¿æ€§æ’å€¼:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+inline double trilinear_interp(double c[2][2][2], double u, double v, double w) {</span></span><br><span class="line"><span class="addition">+   auto accum = 0.0;</span></span><br><span class="line"><span class="addition">+   for (int i = 0; i &lt; 2; ++i) {</span></span><br><span class="line"><span class="addition">+       for (int j = 0; j &lt; 2; ++j) {</span></span><br><span class="line"><span class="addition">+           for (int k = 0; k &lt; 2; ++k) {</span></span><br><span class="line"><span class="addition">+               accum += (i * u + (1 - i) * (1 - u)) *</span></span><br><span class="line"><span class="addition">+                        (j * v + (1 - j) * (1 - v)) *</span></span><br><span class="line"><span class="addition">+                        (k * w + (1 - k) * (1 - w)) * c[i][j][k];</span></span><br><span class="line"><span class="addition">+           }</span></span><br><span class="line"><span class="addition">+       }</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">    </span><br><span class="line"><span class="addition">+   return accum;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">class perlin {</span><br><span class="line">public:</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    double noise(const vec3&amp; p) const {</span><br><span class="line">        auto u = p.x() - floor(p.x());</span><br><span class="line">        auto v = p.y() - floor(p.y());</span><br><span class="line">        auto w = p.z() - floor(p.z());</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="addition">+		int i = floor(p.x());</span></span><br><span class="line"><span class="addition">+       int j = floor(p.y());</span></span><br><span class="line"><span class="addition">+       int k = floor(p.z());</span></span><br><span class="line"><span class="addition">+       double c[2][2][2];</span></span><br><span class="line"><span class="deletion">-       auto i = static_cast&lt;int&gt;(4 * p.x()) &amp; 255;</span></span><br><span class="line"><span class="deletion">-       auto j = static_cast&lt;int&gt;(4 * p.y()) &amp; 255;</span></span><br><span class="line"><span class="deletion">-       auto k = static_cast&lt;int&gt;(4 * p.z()) &amp; 255;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+       return trilinear_interp(c, u, v, w);</span></span><br><span class="line"><span class="deletion">-       return ranfloat[perm_x[i] ^ perm_y[j] ^ perm_z[k]];</span></span><br><span class="line">    }</span><br><span class="line">	......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And we get:</p></blockquote><p>æˆ‘ä»¬ä¼šå¾—åˆ°:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.08-perlin-trilerp.png"></p><h4 id="Improvement-with-Hermitian-Smoothing"><a href="#Improvement-with-Hermitian-Smoothing" class="headerlink" title="Improvement with Hermitian Smoothing"></a>Improvement with Hermitian Smoothing</h4><blockquote><p>Smoothing yields an improved result, but there are obvious grid features in there. Some of it is Mach bands, a known perceptual artifact of linear interpolation of color. A standard trick is to use a Hermite cubic to round off the interpolation:</p></blockquote><p>å—¯, ç°åœ¨çœ‹ä¸Šå»æ›´å¥½äº†, ä½†æ˜¯è¿˜æ˜¯èƒ½æ˜æ˜¾çš„çœ‹å‡ºæ¥æœ‰æ ¼å­çš„ç—•è¿¹ã€‚å…¶ä¸­çš„ä¸€éƒ¨åˆ†æ˜¯é©¬èµ«å¸¦(Mach bands), æ˜¯ç”±çº¿æ€§å˜åŒ–çš„é¢œè‰²æ„æˆçš„æœ‰åçš„è§†è§‰æ„ŸçŸ¥æ•ˆæœã€‚è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªæ ‡å‡†çš„è§£æ³•ï¼šç”¨hermite cubeæ¥å¹³æ»‘å·®å€¼ã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">    double noise(const vec3&amp; p) const {</span><br><span class="line">        auto u = p.x() - floor(p.x());</span><br><span class="line">        auto v = p.y() - floor(p.y());</span><br><span class="line">        auto w = p.z() - floor(p.z());</span><br><span class="line"></span><br><span class="line"><span class="addition">+       u = u * u * (3 - 2 * u);</span></span><br><span class="line"><span class="addition">+       v = v * v * (3 - 2 * v);</span></span><br><span class="line"><span class="addition">+       w = w * w * (3 - 2 * w);</span></span><br><span class="line">        </span><br><span class="line">        int i = floor(p.x());</span><br><span class="line">        int j = floor(p.y());</span><br><span class="line">        int k = floor(p.z());</span><br><span class="line">        double c[2][2][2];</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This gives a smoother looking image:</p></blockquote><p>è¿™æ ·çœ‹èµ·æ¥å°±æ›´åŠ å¹³æ»‘äº†:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.09-perlin-trilerp-smooth.png"></p><h4 id="Tweaking-The-Frequency"><a href="#Tweaking-The-Frequency" class="headerlink" title="Tweaking The Frequency"></a>Tweaking The Frequency</h4><blockquote><p>It is also a bit low frequency. We can scale the input point to make it vary more quickly:</p></blockquote><p>ç°åœ¨è¿™ä¸ªçƒçœ‹ä¸Šå»å˜åŒ–çš„é¢‘ç‡å¤ªä½äº†, æ²¡ä»€ä¹ˆèŠ±çº¹, æˆ‘ä»¬åŠ å…¥ä¸€ä¸ª<code>scale</code>å˜é‡è®©å®ƒæ›´å¿«çš„å‘ç”Ÿå˜åŒ–:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class nosie_texture : public texture {</span><br><span class="line">public:</span><br><span class="line">    nosie_texture() {}</span><br><span class="line"><span class="addition">+   nosie_texture(double sc) : scale(sc) {}</span></span><br><span class="line"></span><br><span class="line">    virtual vec3 value(double u, double v, const vec3&amp; p) const {</span><br><span class="line"><span class="addition">+       return vec3(1, 1, 1) * noise.noise(scale * p);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    perlin noise;</span><br><span class="line"><span class="addition">+   double scale;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We then add that scale to the <code>two_perlin_spheres()</code> scene description:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list two_perlin_spheres() {</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto pertex = make_shared&lt;nosie_texture&gt;(4);</span></span><br><span class="line">    objects.add(make_shared&lt;sphere&gt;(vec3(0, -1000, 0), 1000, make_shared&lt;lambertian&gt;(pertex)));</span><br><span class="line">    objects.add(make_shared&lt;sphere&gt;(vec3(0, 2, 0), 2, make_shared&lt;lambertian&gt;(pertex)));</span><br><span class="line"></span><br><span class="line">    return objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.10-perlin-hifreq.png"></p><h4 id="Using-Random-Vectors-on-the-Lattice-Points"><a href="#Using-Random-Vectors-on-the-Lattice-Points" class="headerlink" title="Using Random Vectors on the Lattice Points"></a>Using Random Vectors on the Lattice Points</h4><blockquote><p>This is still a bit blocky looking, probably because the min and max of the pattern always lands exactly on the integer x/y/z. Ken Perlinâ€™s very clever trick was to instead put random unit vectors (instead of just floats) on the lattice points, and use a dot product to move the min and max off the lattice. So, first we need to change the random floats to random vectors. These vectors are any reasonable set of irregular directions, and I wonâ€™t bother to make them exactly uniform:</p></blockquote><p>ç°åœ¨çœ‹ä¸Šå»è¿˜æ˜¯æœ‰ä¸€ç‚¹æ ¼å­çš„æ„Ÿè§‰, ä¹Ÿè®¸æ˜¯å› ä¸ºè¿™æ–¹æ³•çš„æœ€å¤§å€¼å’Œæœ€å°å€¼æ€»æ˜¯ç²¾ç¡®åœ°è½åœ¨äº†æ•´æ•°çš„x/y/zä¸Š, Ken Perlinæœ‰ä¸€ä¸ªååˆ†èªæ˜çš„trick, åœ¨ç½‘æ ¼ç‚¹ä½¿ç”¨éšæœºçš„å•ä½å‘é‡æ›¿ä»£float(å³æ¢¯åº¦å‘é‡), ç”¨ç‚¹ä¹˜å°†minå’Œmaxå€¼æ¨ç¦»ç½‘æ ¼ç‚¹, æ‰€ä»¥æˆ‘ä»¬é¦–å…ˆè¦æŠŠrandom floatsæ”¹æˆrandom vectorsã€‚è¿™äº›æ¢¯åº¦å‘é‡å¯ä»¥æ˜¯ä»»æ„åˆç†çš„ä¸è§„åˆ™æ–¹å‘çš„é›†åˆ, æ‰€ä»¥æˆ‘å¹²è„†ä½¿ç”¨å•ä½å‘é‡ä½œä¸ºæ¢¯åº¦å‘é‡:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#ifndef RAYTRACING_DEV_PERLIN_H</span><br><span class="line">#define RAYTRACING_DEV_PERLIN_H</span><br><span class="line"></span><br><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">class perlin {</span><br><span class="line">public:</span><br><span class="line">    perlin() {</span><br><span class="line"><span class="deletion">-       ranfloat = new double[point_count];</span></span><br><span class="line"><span class="addition">+       ranvec = new vec3[point_count];</span></span><br><span class="line">        for (int i = 0; i &lt; point_count; ++i) {</span><br><span class="line"><span class="deletion">-           ranfloat[i] = random_double();</span></span><br><span class="line"><span class="addition">+           ranvec[i] = unit_vector(vec3::random(-1, 1));</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        perm_x = perlin_generate_perm();</span><br><span class="line">        perm_y = perlin_generate_perm();</span><br><span class="line">        perm_z = perlin_generate_perm();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~perlin() {</span><br><span class="line"><span class="deletion">-       delete[] ranfloat;</span></span><br><span class="line"><span class="addition">+       delete[] ranvec;</span></span><br><span class="line">        delete[] perm_x;</span><br><span class="line">        delete[] perm_y;</span><br><span class="line">        delete[] perm_z;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    static const int point_count = 256;</span><br><span class="line"><span class="deletion">-   double* ranfloat;</span></span><br><span class="line">    int* perm_x;</span><br><span class="line">    int* perm_y;</span><br><span class="line">    int* perm_z;</span><br><span class="line"><span class="addition">+   vec3* ranvec;</span></span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">#endif //RAYTRACING_DEV_PERLIN_H</span><br></pre></td></tr></tbody></table></figure><p>ç°åœ¨çš„<code>Perlin</code>ç±»å¦‚ä¸‹:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class perlin {</span><br><span class="line">public:</span><br><span class="line">    double noise(const vec3&amp; p) const {</span><br><span class="line">        auto u = p.x() - floor(p.x());</span><br><span class="line">        auto v = p.y() - floor(p.y());</span><br><span class="line">        auto w = p.z() - floor(p.z());</span><br><span class="line"></span><br><span class="line">        u = u * u * (3 - 2 * u);</span><br><span class="line">        v = v * v * (3 - 2 * v);</span><br><span class="line">        w = w * w * (3 - 2 * w);</span><br><span class="line"></span><br><span class="line">        int i = floor(p.x());</span><br><span class="line">        int j = floor(p.y());</span><br><span class="line">        int k = floor(p.z());</span><br><span class="line"><span class="deletion">-       double c[2][2][2];</span></span><br><span class="line"><span class="addition">+		vec3 c[2][2][2];</span></span><br><span class="line"></span><br><span class="line">        for (int di = 0; di &lt; 2; ++di) {</span><br><span class="line">            for (int dj = 0; dj &lt; 2; ++dj) {</span><br><span class="line">                for (int dk = 0; dk &lt; 2; ++dk) {</span><br><span class="line"><span class="deletion">-                    c[di][dj][dk] = ranfloat[</span></span><br><span class="line"><span class="addition">+                    c[di][dj][dk] = ranvec[</span></span><br><span class="line">                            perm_x[(i + di) &amp; 255] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; 255] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; 255]];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="deletion">-       return trilinear_interp(c, u, v, w);</span></span><br><span class="line"><span class="addition">+       return perlin_interp(c, u, v, w);</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the interpolation becomes a bit more complicated:</p></blockquote><p>æ’å€¼éƒ¨åˆ†çš„ä»£ç çœ‹ä¸Šå»æ¯”ä¹‹å‰å¤æ‚äº†ä¸€äº›:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">perlin_interp</span><span class="params">(vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>{</span><br><span class="line">            <span class="keyword">auto</span> uu = u*u*(<span class="number">3</span><span class="number">-2</span>*u);</span><br><span class="line">            <span class="keyword">auto</span> vv = v*v*(<span class="number">3</span><span class="number">-2</span>*v);</span><br><span class="line">            <span class="keyword">auto</span> ww = w*w*(<span class="number">3</span><span class="number">-2</span>*w);</span><br><span class="line">            <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k &lt; <span class="number">2</span>; k++) {</span><br><span class="line">                        <span class="function">vec3 <span class="title">weight_v</span><span class="params">(u-i, v-j, w-k)</span></span>;</span><br><span class="line">                        accum += (i*uu + (<span class="number">1</span>-i)*(<span class="number">1</span>-uu))</span><br><span class="line">                               * (j*vv + (<span class="number">1</span>-j)*(<span class="number">1</span>-vv))</span><br><span class="line">                               * (k*ww + (<span class="number">1</span>-k)*(<span class="number">1</span>-ww))</span><br><span class="line">                               * <span class="built_in">dot</span>(c[i][j][k], weight_v);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> accum;</span><br><span class="line">        }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The output of the perlin interpretation can return negative values. These negative values will be passed to the <code>sqrt()</code> function of our gamma function and get turned into <code>NaN</code>s. We will cast the perlin output back to between 0 and 1.</p></blockquote><p>æŸæ—æ’å€¼çš„è¾“å‡ºç»“æœæœ‰å¯èƒ½æ˜¯è´Ÿæ•°, è¿™äº›è´Ÿæ•°åœ¨ä¼½é©¬æ ¡æ­£æ—¶ç»è¿‡å¼€å¹³æ–¹è·Ÿ<code>sqrt()</code>ä¼šå˜æˆNaNã€‚æˆ‘ä»¬å°†è¾“å‡ºç»“æœæ˜ å°„åˆ°0ä¸1ä¹‹é—´ã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class nosie_texture : public texture {</span><br><span class="line">public:</span><br><span class="line">    nosie_texture() {}</span><br><span class="line">    nosie_texture(double sc) : scale(sc) {}</span><br><span class="line"></span><br><span class="line">    virtual vec3 value(double u, double v, const vec3&amp; p) const {</span><br><span class="line"><span class="addition">+       return vec3(1, 1, 1) * 0.5 * (1.0 + noise.noise(scale * p));</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    perlin noise;</span><br><span class="line">    double scale;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This finally gives something more reasonable looking:</p></blockquote><p>æœ€ç»ˆæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªè®©äººæ»¡æ„çš„ç»“æœ:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.11-perlin-shift.png"></p><h4 id="Introducing-Turbulence"><a href="#Introducing-Turbulence" class="headerlink" title="Introducing Turbulence"></a>Introducing Turbulence</h4><blockquote><p>Very often, a composite noise that has multiple summed frequencies is used. This is usually called turbulence, and is a sum of repeated calls to noise:</p></blockquote><p>ä½¿ç”¨å¤šä¸ªé¢‘ç‡ç›¸åŠ å¾—åˆ°å¤åˆå™ªå£°æ˜¯ä¸€ç§å¾ˆå¸¸è§çš„åšæ³•, æˆ‘ä»¬å¸¸å¸¸ç§°ä¹‹ä¸ºæ‰°åŠ¨(turbulence), æ˜¯ä¸€ç§ç”±å¤šæ¬¡å™ªå£°è¿ç®—çš„ç»“æœç›¸åŠ å¾—åˆ°çš„äº§ç‰©ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">turb</span><span class="params">(<span class="type">const</span> vec3&amp; p, <span class="type">int</span> depth=<span class="number">7</span>)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">            vec3 temp_p = p;</span><br><span class="line">            <span class="keyword">auto</span> weight = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) {</span><br><span class="line">                accum += weight*<span class="built_in">noise</span>(temp_p);</span><br><span class="line">                weight *= <span class="number">0.5</span>;</span><br><span class="line">                temp_p *= <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>(accum);</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Here <code>fabs()</code> is the absolute value function defined in <code>&lt;cmath&gt;</code>.</p></blockquote><p>è¿™é‡Œçš„<code>fabs()</code>æ˜¯<code>math.h</code>é‡Œçš„æ±‚ç»å¯¹å€¼çš„å‡½æ•°ã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class noise_texture : public texture {</span><br><span class="line">    public:</span><br><span class="line">        noise_texture() {}</span><br><span class="line">        noise_texture(double sc) : scale(sc) {}</span><br><span class="line"></span><br><span class="line">        virtual color value(double u, double v, const point3&amp; p) const override {</span><br><span class="line"><span class="addition">+           return color(1,1,1) * noise.turb(scale * p);</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        perlin noise;</span><br><span class="line">        double scale;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Used directly, turbulence gives a sort of camouflage netting appearance:</p></blockquote><p>ç›´æ¥ä½¿ç”¨turbå‡½æ•°æ¥äº§ç”Ÿçº¹ç†, ä¼šå¾—åˆ°ä¸€ä¸ªçœ‹ä¸Šå»åƒä¼ªè£…ç½‘ä¸€æ ·çš„ä¸œè¥¿:</p><p><img data-src="./image/loading.gif" data-original="https://raytracing.github.io/images/img-2.12-perlin-turb.png"></p><h4 id="Adjusting-the-Phase"><a href="#Adjusting-the-Phase" class="headerlink" title="Adjusting the Phase"></a>Adjusting the Phase</h4><blockquote><p>However, usually turbulence is used indirectly. For example, the â€œhello worldâ€ of procedural solid textures is a simple marble-like texture. The basic idea is to make color proportional to something like a sine function, and use turbulence to adjust the phase (so it shifts ğ‘¥ in sin(ğ‘¥)) which makes the stripes undulate. Commenting out straight noise and turbulence, and giving a marble-like effect is:</p></blockquote><p>ç„¶è€Œæ‰°åŠ¨å‡½æ•°é€šå¸¸æ˜¯é—´æ¥ä½¿ç”¨çš„, åœ¨ç¨‹åºç”Ÿæˆçº¹ç†è¿™æ–¹é¢çš„â€hello worldâ€æ˜¯ä¸€ä¸ªç±»ä¼¼å¤§ç†çŸ³çš„çº¹ç†ã€‚åŸºæœ¬æ€è·¯æ˜¯è®©é¢œè‰²ä¸sineå‡½æ•°çš„å€¼æˆæ¯”ä¾‹, å¹¶ä½¿ç”¨æ‰°åŠ¨å‡½æ•°å»è°ƒæ•´ç›¸ä½(å¹³ç§»äº†sin(x)ä¸­çš„x), ä½¿å¾—å¸¦çŠ¶æ¡çº¹èµ·ä¼æ³¢è¡ã€‚ä¿®æ­£æˆ‘ä»¬ç›´æ¥ä½¿ç”¨æ‰°åŠ¨turbæˆ–è€…å™ªå£°noiseç»™é¢œè‰²èµ‹å€¼çš„æ–¹æ³•ï¼Œ æˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªç±»ä¼¼å¤§ç†çŸ³çš„çº¹ç†:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class noise_texture : public texture {</span><br><span class="line">    public:</span><br><span class="line">        noise_texture() {}</span><br><span class="line">        noise_texture(double sc) : scale(sc) {}</span><br><span class="line"></span><br><span class="line">        virtual vec3 value(double u, double v, const vec3&amp; p) const {</span><br><span class="line"><span class="addition">+            return vec3(1,1,1) * 0.5 * (1 + sin(scale*p.z() + 10*noise.turb(p)));</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        perlin noise;</span><br><span class="line">        double scale;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which yields:</p></blockquote><p>æœ€ç»ˆå¾—åˆ°:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.13-perlin-marble.png"></p><h3 id="çº¹ç†æ˜ å°„"><a href="#çº¹ç†æ˜ å°„" class="headerlink" title="çº¹ç†æ˜ å°„"></a>çº¹ç†æ˜ å°„</h3><blockquote><p>From the hitpoint <strong>ğ</strong>, we compute the surface coordinates (ğ‘¢,ğ‘£). We then use these to index into our procedural solid texture (like marble). We can also read in an image and use the 2D (ğ‘¢,ğ‘£) texture coordinate to index into the image.</p><p>A direct way to use scaled (ğ‘¢,ğ‘£) in an image is to round the ğ‘¢ and ğ‘£ to integers, and use that as (ğ‘–,ğ‘—) pixels. This is awkward, because we donâ€™t want to have to change the code when we change image resolution. So instead, one of the the most universal unofficial standards in graphics is to use texture coordinates instead of image pixel coordinates. These are just some form of fractional position in the image. For example, for pixel (ğ‘–,ğ‘—) in an $ğ‘_ğ‘¥$ by $ğ‘_ğ‘¦$â€‹ image, the image texture position is:</p></blockquote><p>æˆ‘ä»¬ä¹‹å‰ä½¿ç”¨å°„å…¥ç‚¹pæ¥æ˜ å°„(åŸæ–‡to index)ç±»ä¼¼å¤§ç†çŸ³é‚£æ ·ç¨‹åºç”Ÿæˆçš„çº¹ç†ã€‚æˆ‘ä»¬ä¹Ÿèƒ½è¯»å–ä¸€å¼ å›¾ç‰‡, å¹¶å°†ä¸€ä¸ª2D(u,v)çš„åæ ‡ç³»æ˜ å°„åœ¨å›¾ç‰‡ä¸Šã€‚</p><p>ä½¿ç”¨(u,v)åæ ‡çš„ä¸€ä¸ªç›´æ¥çš„æƒ³æ³•æ˜¯å°†uä¸vè°ƒæ•´æ¯”ä¾‹åå–æ•´, ç„¶åå°†å…¶å¯¹åº”åˆ°åƒç´ åæ ‡(i,j)ä¸Š, è¿™å¾ˆç³Ÿç³•, å› ä¸ºè¿™æ ·æ¯æ¬¡å›¾ç‰‡åˆ†è¾¨ç‡å‘ç”Ÿå˜åŒ–æ—¶, æˆ‘ä»¬éƒ½è¦ä¿®æ”¹ä»£ç ã€‚æ‰€ä»¥ç›¸å¯¹çš„, å›¾å½¢å­¦ç•Œä¸­å¹¿æ³›è®¤å¯çš„éå®˜æ–¹æ ‡å‡†ä¹‹ä¸€æ˜¯é‡‡ç”¨çº¹ç†åæ ‡ç³»ä»£æ›¿å›¾åƒåæ ‡ç³»ã€‚å³ä½¿ç”¨[0,1]çš„å°æ•°æ¥è¡¨ç¤ºå›¾åƒä¸­çš„ä½ç½®ã€‚ä¸¾ä¾‹æ¥è¯´, å¯¹äºä¸€å¼ å®½åº¦ä¸º $N_x$ é«˜åº¦ä¸º $N_y$ çš„å›¾åƒä¸­çš„åƒç´ (i,j) , å…¶åƒç´ åæ ‡ç³»ä¸‹çš„åæ ‡ä¸º:</p><p>$u = \frac{i}{N_x-1}$</p><p>$v = \frac{j}{N_y - 1}$</p><p>å¯¹äºä¸€ä¸ª<code>hittable</code>æ¥è¯´, æˆ‘ä»¬è¿˜éœ€è¦åœ¨<code>hit record</code>ä¸­åŠ å…¥ u å’Œ v çš„è®°å½•ã€‚å¯¹äºæ¤­åœ†æ¥è¯´, uvçš„è®¡ç®—æ˜¯åŸºäºç»åº¦å’Œçº¬åº¦çš„çš„, æ¢å¥è¯è¯´, æ˜¯åŸºäºçƒé¢åæ ‡çš„ã€‚æ‰€ä»¥å½“æˆ‘ä»¬æœ‰ä¸€ä¸ªçƒé¢åæ ‡(Î¸,Ï•)ï¼Œ æˆ‘ä»¬åªéœ€è¦æŒ‰æ¯”ä¾‹è½¬åŒ–ä¸€ä¸‹å°±èƒ½å¾—åˆ°uvåæ ‡ã€‚å¦‚æœÎ¸æ˜¯æœä¸‹è·ç¦»æè½´çš„è§’åº¦, Ï•æ˜¯ç»•æè½´æ—‹è½¬çš„è§’åº¦, å°†å…¶æ˜ å°„åˆ°[0,1]çš„è¿‡ç¨‹ä¸º:</p><p>$u = \frac{\phi}{2\pi}$</p><p>$v = \frac{\phi}{\pi}$</p><p>ä¸ºäº†è®¡ç®— Î¸ å’Œ Ï•, å¯¹äºä»»æ„ç»™å‡ºçš„çƒé¢ä¸Šçš„å°„å…¥ç‚¹, å°†çƒé¢åæ ‡ç³»è½¬åŒ–ä¸ºç›´è§’åæ ‡ç³»çš„æ–¹ç¨‹ä¸º:</p><p>$x = \cos(\phi)\cos(\theta)$</p><p>$y=\sin(\phi)\cos(\theta)$</p><p>$z = \sin(\theta)$</p><blockquote><p>We need to invert these equations to solve for ğœƒ and ğœ™. Because of the lovely <code>&lt;cmath&gt;</code> function <code>atan2()</code>, which takes any pair of numbers proportional to sine and cosine and returns the angle, we can pass in ğ‘¥ and ğ‘§ (the sin(ğœƒ) cancel) to solve for ğœ™:</p></blockquote><p>æˆ‘ä»¬ç°åœ¨åªè¦æŠŠå®ƒå€’è¿‡æ¥å°±è¡Œ, å› ä¸ºæˆ‘ä»¬å¯çˆ±çš„<code>&lt;cmath&gt;</code>åº“å‡½æ•°<code>atan2()</code>çš„å…³ç³», ç»™å‡ºä»»æ„ä¸€ä¸ªè§’åº¦çš„ sine å’Œ cosine å€¼, æˆ‘ä»¬å°±èƒ½å¾—åˆ°è¿™ä¸ªè§’çš„è§’åº¦å€¼ã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åƒè¿™æ ·ä¼ å…¥x, yçš„å€¼ sin(Î¸) ä¸ cos(Î¸) ç›¸é™¤æŠµæ¶ˆå¾—åˆ° tanâ¡(Î¸):</p><p>$\phi = \atan2(y, x)$</p><blockquote><p><code>atan2()</code> returns values in the range âˆ’ğœ‹ to ğœ‹, but they go from 0 to ğœ‹, then flip to âˆ’ğœ‹ and proceed back to zero. While this is mathematically correct, we want ğ‘¢ to range from 0 to 1, not from 0 to 1/2 and then from âˆ’1/2 to 0. Fortunately,</p></blockquote><p>$\atan2$ å‡½æ•°çš„è¿”å›å€¼èŒƒå›´ä¸º âˆ’Ï€ åˆ° Ï€ <em>ã€è¯‘æ³¨:å³è¿”å›å¼§åº¦(radius)ã€‘</em>æ‰€ä»¥æˆ‘ä»¬è¿™é‡Œè¿˜è¦å°å¿ƒä¸€ä¸‹ã€‚ç›¸å¯¹çš„, æ±‚è§’ Î¸ æ›´ä¸ºç®€å•ç›´æ¥:</p><p>$\theta = \asin(z)$</p><blockquote><p>So for a sphere, the (ğ‘¢,ğ‘£) coord computation is accomplished by a utility function that takes points on the unit sphere centered at the origin, and computes ğ‘¢ and ğ‘£:</p></blockquote><p>æ‰€ä»¥å¯¹äºä¸€ä¸ªçƒä½“æ¥è¯´, (u,v)(u,v) åæ ‡çš„è®¡ç®—æ˜¯ç”±ä¸€ä¸ªå·¥å…·å‡½æ•°å®Œæˆçš„, è¯¥å‡½æ•°å‡å®šè¾“å…¥å‚æ•°ä¸ºå•ä½åœ†ä¸Šçš„ç‚¹, æ‰€ä»¥æˆ‘ä»¬ä¼ å…¥å‚æ•°æ—¶éœ€è¦æ³¨æ„ä¸€ä¸‹:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_sphere_uv</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span> </span>{</span><br><span class="line">            <span class="comment">// p: a given point on the sphere of radius one, centered at the origin.</span></span><br><span class="line">            <span class="comment">// u: returned value [0,1] of angle around the Y axis from X=-1.</span></span><br><span class="line">            <span class="comment">// v: returned value [0,1] of angle from Y=-1 to Y=+1.</span></span><br><span class="line">            <span class="comment">//     &lt;1 0 0&gt; yields &lt;0.50 0.50&gt;       &lt;-1  0  0&gt; yields &lt;0.00 0.50&gt;</span></span><br><span class="line">            <span class="comment">//     &lt;0 1 0&gt; yields &lt;0.50 1.00&gt;       &lt; 0 -1  0&gt; yields &lt;0.50 0.00&gt;</span></span><br><span class="line">            <span class="comment">//     &lt;0 0 1&gt; yields &lt;0.25 0.50&gt;       &lt; 0  0 -1&gt; yields &lt;0.75 0.50&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">            <span class="keyword">auto</span> phi = <span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(), p.<span class="built_in">x</span>()) + pi;</span><br><span class="line"></span><br><span class="line">            u = phi / (<span class="number">2</span>*pi);</span><br><span class="line">            v = theta / pi;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Update the <code>sphere::hit()</code> function to use this function to update the hit record UV coordinates.</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(...)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="built_in">get_sphere_uv</span>(outward_normal, rec.u, rec.v);</span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Storing-Texture-Image-Data"><a href="#Storing-Texture-Image-Data" class="headerlink" title="Storing Texture Image Data"></a>Storing Texture Image Data</h4><blockquote><p>The representation of a packed array in that order is pretty standard. Thankfully, the <a target="_blank" rel="noopener" href="https://github.com/nothings/stb">stb_image</a> package makes that super simple â€” just write a header called <code>rtw_stb_image.h</code> that also deals with some compiler warnings:</p></blockquote><p>ç°åœ¨æˆ‘ä»¬è¿˜éœ€è¦æ–°å»ºä¸€ä¸ªtextureç±»æ¥å­˜æ”¾å›¾ç‰‡ã€‚æˆ‘ç°åœ¨å°†ä½¿ç”¨æˆ‘æœ€å–œæ¬¢çš„å›¾åƒå·¥å…·åº“<a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h"><code>stb_image.h</code></a>(ç‚¹å‡»ä¸‹è½½)ã€‚å®ƒå°†å›¾ç‰‡ä¿¡æ¯è¯»å…¥ä¸€ä¸ªæ— ç¬¦å·å­—ç¬¦ç±»å‹(unsigned char)çš„å¤§æ•°ç»„ä¸­ã€‚unsigned char(8bit, 0<del>255)çš„å€¼å³ä¸ºRGBsä¸­è¡¨ç¤ºæ˜æš—çš„0</del>255ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"texture.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image_texture</span> : <span class="keyword">public</span> texture {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">image_texture</span>() {}</span><br><span class="line">        <span class="built_in">image_texture</span>(<span class="type">unsigned</span> <span class="type">char</span> *pixels, <span class="type">int</span> A, <span class="type">int</span> B)</span><br><span class="line">            : <span class="built_in">data</span>(pixels), <span class="built_in">nx</span>(A), <span class="built_in">ny</span>(B) {}</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">image_texture</span>() {</span><br><span class="line">            <span class="keyword">delete</span> data;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="comment">// If we have no texture data, then always emit cyan (as a debugging aid).</span></span><br><span class="line">            <span class="keyword">if</span> (data == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((  u)*nx);</span><br><span class="line">            <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((<span class="number">1</span>-v)*ny<span class="number">-0.001</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; nx<span class="number">-1</span>) i = nx<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; ny<span class="number">-1</span>) j = ny<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data[<span class="number">3</span>*i + <span class="number">3</span>*nx*j+<span class="number">0</span>]) / <span class="number">255.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data[<span class="number">3</span>*i + <span class="number">3</span>*nx*j+<span class="number">1</span>]) / <span class="number">255.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data[<span class="number">3</span>*i + <span class="number">3</span>*nx*j+<span class="number">2</span>]) / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vec3</span>(r, g, b);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *data;</span><br><span class="line">        <span class="type">int</span> nx, ny;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>ä½¿ç”¨è¿™æ ·çš„æ•°ç»„æ¥å‚¨å­˜å›¾åƒååˆ†çš„åŸºç¡€ã€‚æ„Ÿè°¢<a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h"><code>stb_image.h</code></a>, å¯¼å…¥å›¾ç‰‡å˜å¾—å¼‚å¸¸ç®€å•, åªéœ€åœ¨<code>main.cpp</code>ä¸­åŒ…å«å‡½æ•°å¤´<code>stb_image.h</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stb_image.h"</span></span></span><br></pre></td></tr></tbody></table></figure><p>æˆ‘ä»¬earthmap.jpgä¸­ä»è¯»å–æ•°æ®(è¿™å¼ å›¾æ˜¯æˆ‘ä»ç½‘ä¸Šéšä¾¿æ‰¾çš„ â€“ è¿™é‡Œä½ ä½¿ç”¨ä»»ä½•å›¾ç‰‡éƒ½è¡Œ, æœ€å¥½ç¬¦åˆçƒä½“çš„æŠ•å½±æ ‡å‡†), å¹¶å°†å®ƒéƒ¨ç½²ç»™ä¸€ä¸ªæ¼«åå°„æè´¨, ä»£ç å¦‚ä¸‹:</p><h4 id="Using-an-Image-Texture"><a href="#Using-an-Image-Texture" class="headerlink" title="Using an Image Texture"></a>Using an Image Texture</h4><blockquote><p>I just grabbed a random earth map from the web â€” any standard projection will do for our purposes.</p></blockquote><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/earthmap.jpg"></p><blockquote><p>Hereâ€™s the code to read an image from a file and then assign it to a diffuse material:</p></blockquote><p>æˆ‘ä»¬ earthmap.jpg ä¸­ä»è¯»å–æ•°æ®(è¿™å¼ å›¾æ˜¯æˆ‘ä»ç½‘ä¸Šéšä¾¿æ‰¾çš„ â€“ è¿™é‡Œä½ ä½¿ç”¨ä»»ä½•å›¾ç‰‡éƒ½è¡Œ, æœ€å¥½ç¬¦åˆçƒä½“çš„æŠ•å½±æ ‡å‡†), å¹¶å°†å®ƒéƒ¨ç½²ç»™ä¸€ä¸ªæ¼«åå°„æè´¨, ä»£ç å¦‚ä¸‹:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">earth</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> nx, ny, nn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* texture_data = <span class="built_in">stbi_load</span>(<span class="string">"earthmap.jpg"</span>, &amp;nx, &amp;ny, &amp;nn, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> earth_surface =</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;image_texture&gt;(texture_data, nx, ny));</span><br><span class="line">    <span class="keyword">auto</span> globe = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">2</span>, earth_surface);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hittable_list</span>(globe);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>æˆ‘ä»¬ç°åœ¨å¼€å§‹æ„Ÿå— texture ç±»çš„é­…åŠ›äº†: æˆ‘ä»¬ç°åœ¨å¯ä»¥å°†ä»»æ„ä¸€ç§ç±»çš„çº¹ç†(è´´å›¾, å¤§ç†çŸ³)è¿ç”¨åˆ° lambertian æè´¨ä¸Š, å¹¶ä¸” lambertian æè´¨å¹¶ä¸éœ€è¦å…³å¿ƒå…¶è¾“å…¥çš„æ˜¯å›¾ç‰‡è¿˜æ˜¯å…¶ä»–çš„ä»€ä¹ˆã€‚</p><p>å¦‚æœä½ æƒ³æµ‹è¯•çš„è¯, æˆ‘ä»¬å…ˆåº”ç”¨è¿™ä¸ªçƒ, ç„¶åæš‚æ—¶ä¿®æ”¹<code>ray_color</code>å‡½æ•°, ä½¿å…¶åªè¿”å› attenuation çš„å€¼, ä½ ä¼šå¾—åˆ°ä¸‹é¢çš„ç»“æœ:</p><blockquote><p>We start to see some of the power of all colors being textures â€” we can assign any kind of texture to the lambertian material, and lambertian doesnâ€™t need to be aware of it.</p><p>To test this, throw it into main:</p></blockquote><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.15-earth-sphere.png"></p><h3 id="çŸ©é˜µå’Œå…‰æº"><a href="#çŸ©é˜µå’Œå…‰æº" class="headerlink" title="çŸ©é˜µå’Œå…‰æº"></a>çŸ©é˜µå’Œå…‰æº</h3><blockquote><p>Lighting is a key component of raytracing. Early simple raytracers used abstract light sources, like points in space, or directions. Modern approaches have more physically based lights, which have position and size. To create such light sources, we need to be able to take any regular object and turn it into something that emits light into our scene.</p></blockquote><h4 id="Emissive-Materials"><a href="#Emissive-Materials" class="headerlink" title="Emissive Materials"></a>Emissive Materials</h4><blockquote><p>First, letâ€™s make a light emitting material. We need to add an emitted function (we could also add it to <code>hit_record</code> instead â€” thatâ€™s a matter of design taste). Like the background, it just tells the ray what color it is and performs no reflection. Itâ€™s very simple:</p></blockquote><p>æˆ‘ä»¬é¦–å…ˆæ¥åšä¸€ä¸ªå‘å°„å…‰çº¿çš„æè´¨ã€‚æˆ‘ä»¬éœ€è¦åŠ å…¥ä¸€ä¸ªå‘å°„å‡½æ•°(æˆ‘ä»¬å¯ä»¥æŠŠè¿™éƒ¨åˆ†å†…å®¹åŠ åœ¨<code>hit_record</code>é‡Œ â€”â€” åªæ˜¯è®¾è®¡ä¸Šçš„å“å‘³ä¸åŒç½¢äº†)ã€‚å°±åƒèƒŒæ™¯åŒºåŸŸä¸€æ ·, è¿™ä¸ªæè´¨åªè¦æŒ‡å®šè‡ªå·±å‘å°„çš„å…‰çº¿çš„é¢œè‰², å¹¶ä¸”ä¸ç”¨è€ƒè™‘ä»»ä½•åå°„æŠ˜å°„çš„é—®é¢˜ã€‚æ‰€ä»¥å®ƒå¾ˆç®€å•:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">diffuse_light</span> : <span class="keyword">public</span> material  {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">diffuse_light</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">emit</span>(a) {}</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;texture&gt; emit;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>So that I donâ€™t have to make all the non-emitting materials implement <code>emitted()</code>, I have the base class return black:</p></blockquote><p>ä¸ºäº†ä¸å»ç»™æ¯ä¸ªä¸æ˜¯å…‰æºçš„æè´¨å®ç°<code>emitted()</code>å‡½æ•°, æˆ‘è¿™é‡Œå¹¶ä¸ä½¿ç”¨çº¯è™šå‡½æ•°, å¹¶è®©å‡½æ•°é»˜è®¤è¿”å›é»‘è‰²:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class material {</span><br><span class="line">    public:</span><br><span class="line"><span class="addition">+        virtual vec3 emitted(double u, double v, const vec3&amp; p) const {</span></span><br><span class="line"><span class="addition">+            return vec3(0,0,0);</span></span><br><span class="line"><span class="addition">+        }</span></span><br><span class="line"></span><br><span class="line">        virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span><br><span class="line">        ) const = 0;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Adding-Background-Color-to-the-Ray-Color-Function"><a href="#Adding-Background-Color-to-the-Ray-Color-Function" class="headerlink" title="Adding Background Color to the Ray Color Function"></a>Adding Background Color to the Ray Color Function</h4><blockquote><p>Next, we want a pure black background so the only light in the scene is coming from the emitters. To do this, weâ€™ll add a background color parameter to our <code>ray_color</code> function, and pay attention to the new <code>emitted</code> value.</p></blockquote><p>æ¥ä¸‹æ¥æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªçº¯é»‘çš„èƒŒæ™¯, å¹¶è®©æ‰€æœ‰å…‰çº¿éƒ½æ¥è‡ªäºæˆ‘ä»¬çš„å…‰æºæè´¨ã€‚è¦å®ç°å®ƒ, æˆ‘ä»¬å¾—åœ¨<code>ray_color</code>å‡½æ•°ä¸­åŠ å…¥ä¸€ä¸ªèƒŒæ™¯è‰²çš„å˜é‡, ç„¶åæ³¨æ„ç”±<code>emitted</code>å‡½æ•°äº§ç”Ÿçš„æ–°çš„é¢œè‰²å€¼ã€‚<em>ã€æ€è€ƒä¸€ä¸ªç®€å•åœºæ™¯, é‡Œé¢åªæœ‰å‡ ä¸ªç‰©ä½“å’Œä¸€ä¸ªå…‰æº, æœ‰åŠ©äºç†è§£è¿™æ®µé€’å½’ã€‘</em></p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(const ray&amp; r, const vec3&amp; background, const hittable&amp; world,int depth) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return {0,0,0};</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (world.hit(r,0.001,infinity,rec))</span><br><span class="line"><span class="addition">+       return background;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   {</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        vec3 attenuation;</span><br><span class="line"><span class="addition">+       vec3 emitted = rec.mat_ptr-&gt;emitted(rec.u, rec.v, rec.p);</span></span><br><span class="line">        if (rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered))</span><br><span class="line"><span class="addition">+           return emitted;</span></span><br><span class="line"><span class="deletion">-   }</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   vec3 unit_direction = unit_vector(r.direction());</span></span><br><span class="line"><span class="deletion">-   auto t = 0.5 * (unit_direction.y() + 1.0);</span></span><br><span class="line"><span class="deletion">-   return (1.0 - t) * vec3(1.0,1.0,1.0) + t * vec3(0.5,0.7,1.0);</span></span><br><span class="line"><span class="addition">+	return emitted + attenuation * ray_color(scattered, background, world, depth-1);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    ......</span><br><span class="line"><span class="addition">+   const vec3 background(0,0,0);</span></span><br><span class="line">    ......</span><br><span class="line"><span class="addition">+   	color += ray_color(r, background, world, max_depth);</span></span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Creating-Rectangle-Objects"><a href="#Creating-Rectangle-Objects" class="headerlink" title="Creating Rectangle Objects"></a>Creating Rectangle Objects</h4><blockquote><p>Now, letâ€™s make some rectangles. Rectangles are often convenient for modeling man-made environments. Iâ€™m a fan of doing axis-aligned rectangles because they are easy. (Weâ€™ll get to instancing so we can rotate them later.)</p></blockquote><p>ç°åœ¨æˆ‘ä»¬æ¥åŠ å…¥ä¸€äº›çŸ©å½¢ã€‚åœ¨å»ºæ¨¡äººä¸ºç¯å¢ƒæ—¶ä½¿ç”¨çŸ©å½¢ä¼šå¾ˆæ–¹ä¾¿ã€‚æˆ‘è¶…å–œæ¬¢ç”¨è½´å¯¹é½çš„çŸ©å½¢å› ä¸ºä»–ä»¬å¾ˆç®€å•(æˆ‘ä»¬æ¥ä¸‹æ¥ä¼šåŠ å…¥å®ä¾‹(instance)çš„åŠŸèƒ½, å¾…ä¼šå°±å¯ä»¥æ—‹è½¬è¿™äº›çŸ©å½¢)ã€‚</p><blockquote><p>First, here is a rectangle in an xy plane. Such a plane is defined by its z value. For example, ğ‘§=ğ‘˜. An axis-aligned rectangle is defined by the lines ğ‘¥=ğ‘¥0, ğ‘¥=ğ‘¥1, ğ‘¦=ğ‘¦0, and ğ‘¦=ğ‘¦1.</p></blockquote><p>é¦–å…ˆå°†ä¸€ä¸ªçŸ©å½¢æ”¾åœ¨xyå¹³é¢, é€šå¸¸æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªzå€¼æ¥å®šä¹‰è¿™æ ·çš„å¹³é¢ã€‚ä¸¾ä¾‹æ¥è¯´, $z=k$ã€‚ä¸€ä¸ªè½´å¯¹é½çš„çŸ©å½¢æ˜¯ç”± $x=x_0$, $x=x_1$, $y=y_0$, ä»¥åŠ $y=y_1$ è¿™å››æ¡ç›´çº¿æ„æˆçš„ã€‚</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.05-ray-rect.jpg"></p><blockquote><p>To determine whether a ray hits such a rectangle, we first determine where the ray hits the plane. Recall that a ray <strong>ğ</strong>(ğ‘¡)=<strong>ğ€</strong>+ğ‘¡<strong>ğ›</strong> has its z component defined by $ğ‘ƒ_ğ‘§(ğ‘¡)=ğ´_ğ‘§+ğ‘¡ğ‘_z$. Rearranging those terms we can solve for what the t is where ğ‘§=ğ‘˜.</p></blockquote><p>ä¸ºäº†åˆ¤æ–­å…‰çº¿æ˜¯å¦ä¸è¿™æ ·çš„çŸ©å½¢ç›¸äº¤, æˆ‘ä»¬å…ˆæ¥åˆ¤æ–­å°„çº¿å‡»ä¸­å¹³é¢ä¸Šçš„å“ªä¸ªç‚¹ã€‚å›æƒ³ä¸€ä¸‹å°„çº¿æ–¹ç¨‹ $p(t)=a+t\vec{b}$â€‹, å…¶ä¸­å°„çº¿çš„ z å€¼åˆç”±å¹³é¢ $z(t)=a_z+t \cdot \vec{b_z}$â€‹â€‹ å†³å®šã€‚åˆå¹¶æ•´ç†æˆ‘ä»¬å°†è·å¾—å½“ $z=k$ æ—¶ $t$ çš„å€¼</p><p>$t = \frac{k - a_z}{\vec{b_z}}$</p><blockquote><p>Once we have ğ‘¡, we can plug that into the equations for ğ‘¥ and ğ‘¦:</p></blockquote><p>ä¸€æ—¦æˆ‘ä»¬æ±‚å‡ºt, æˆ‘ä»¬å°±èƒ½å°†å…¶å¸¦å…¥æ±‚è§£ x å’Œ y çš„ç­‰å¼</p><p>$x = a_x + t \cdot \vec{b_x}$</p><p>$y = a_y + t \cdot \vec{b_y}$</p><blockquote><p>It is a hit if $ğ‘¥_0&lt;ğ‘¥&lt;ğ‘¥_1$ and $ğ‘¦_0&lt;ğ‘¦&lt;ğ‘¦_1$.</p><p>Because our rectangles are axis-aligned, their bounding boxes will have an infinitely-thin side. This can be a problem when dividing them up with our axis-aligned bounding volume hierarchy. To counter this, all hittable objects should get a bounding box that has finite width along every dimension. For our rectangles, weâ€™ll just pad the box a bit on the infnitely-thin side.</p></blockquote><p>å¦‚æœ $x_0&lt;x&lt;x_1$â€‹ ä¸ $y_0&lt;y&lt;y_1$â€‹, é‚£ä¹ˆå°„çº¿å°±å‡»ä¸­äº†è¿™ä¸ªçŸ©å½¢ã€‚</p><blockquote><p>The actual <code>xy_rect</code> class is thus:</p></blockquote><p>æˆ‘ä»¬çš„<code>xy_rect</code>ç±»æ˜¯è¿™æ ·çš„ï¼š</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xy_rect</span> : <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xy_rect</span>() {}</span><br><span class="line">    <span class="built_in">xy_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _k, shared_ptr&lt;material&gt; mat)</span><br><span class="line">    : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> </span>{</span><br><span class="line">        <span class="comment">// The bounding box must have non-zero width in each dimension, so pad the Z</span></span><br><span class="line">        <span class="comment">// dimension a small amount.</span></span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">vec3</span>(x0, y0, k - <span class="number">0.0001</span>), <span class="built_in">vec3</span>(x1, y1, k + <span class="number">0.0001</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, y0, y1, k;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the hit function is:</p></blockquote><p>hitå‡½æ•°æ˜¯è¿™æ ·çš„:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xy_rect::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> t = (k-r.<span class="built_in">origin</span>().<span class="built_in">z</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || y &lt; y0 || y &gt; y1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (x-x0)/(x1-x0);</span><br><span class="line">    rec.v = (y-y0)/(y1-y0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Turning-Objects-into-Lights"><a href="#Turning-Objects-into-Lights" class="headerlink" title="Turning Objects into Lights"></a>Turning Objects into Lights</h4><blockquote><p>If we set up a rectangle as a light:</p></blockquote><p>å¦‚æœæˆ‘ä»¬æŠŠä¸€ä¸ªçŸ©å½¢è®¾ç½®ä¸ºå…‰æº:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">simple_light</span><span class="params">()</span> </span>{</span><br><span class="line">        hittable_list objects;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-1000</span>, <span class="number">0</span>), <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>), <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> difflight = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>)));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>), <span class="number">2</span>, difflight));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, difflight));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>è°ƒæ•´ç›¸æœºå‚æ•°ï¼š</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Camera</span></span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">26</span>, <span class="number">3</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="function"><span class="type">const</span> vec3 <span class="title">background</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>æ³¨æ„ç°åœ¨å…‰æ¯”(1,1,1)è¿˜è¦äº®, æ‰€ä»¥è¿™ä¸ªäº®åº¦è¶³å¤Ÿå®ƒå»ç…§äº®å…¶ä»–ä¸œè¥¿äº†ã€‚åŒæ ·çš„æˆ‘ä»¬åœ¨åšä¸€äº›çƒå‹å…‰æºï¼š</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.17-rect-sphere-light.png"></p><h4 id="More-Axis-Aligned-Rectangles"><a href="#More-Axis-Aligned-Rectangles" class="headerlink" title="More Axis-Aligned Rectangles"></a>More Axis-Aligned Rectangles</h4><blockquote><p>Now letâ€™s add the other two axes and the famous Cornell Box.</p><p>This is xz and yz:</p></blockquote><p>ç°åœ¨è®©æˆ‘ä»¬åŠ å…¥å‰©ä¸‹çš„ä¸¤ä¸ªè½´, å¹¶å®Œæˆè‘—åçš„Cornell Boxã€‚</p><p>xz å’Œ yzå¹³é¢æ˜¯è¿™æ ·çš„:<em>ã€å®è¯è¯´è¿™æ ·å†™ä»£ç æœ‰äº›å†—ä½™äº†ã€‘</em></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span>: <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xz_rect</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xz_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k, shared_ptr&lt;material&gt; mat)</span><br><span class="line">            : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) {};</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">        output_box =  <span class="built_in">aabb</span>(<span class="built_in">vec3</span>(x0,k<span class="number">-0.0001</span>,z0), <span class="built_in">vec3</span>(x1, k+<span class="number">0.0001</span>, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, z0, z1, k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yz_rect</span>: <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">yz_rect</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">yz_rect</span>(<span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k, shared_ptr&lt;material&gt; mat)</span><br><span class="line">            : <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) {};</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">        output_box =  <span class="built_in">aabb</span>(<span class="built_in">vec3</span>(k<span class="number">-0.0001</span>, y0, z0), <span class="built_in">vec3</span>(k+<span class="number">0.0001</span>, y1, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> y0, y1, z0, z1, k;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>With unsurprising hit functions:</p></blockquote><p>å½“ç„¶hitå‡½æ•°ä¹Ÿå’Œä¹‹å‰ä¸€æ ·:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xz_rect::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">       <span class="keyword">auto</span> t = (k-r.<span class="built_in">origin</span>().<span class="built_in">y</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">       <span class="keyword">if</span> (t &lt; t0 || t &gt; t1)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">       <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">       <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       rec.u = (x-x0)/(x1-x0);</span><br><span class="line">       rec.v = (z-z0)/(z1-z0);</span><br><span class="line">       rec.t = t;</span><br><span class="line">       vec3 outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">       rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">       rec.mat_ptr = mp;</span><br><span class="line">       rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">yz_rect::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">       <span class="keyword">auto</span> t = (k-r.<span class="built_in">origin</span>().<span class="built_in">x</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">       <span class="keyword">if</span> (t &lt; t0 || t &gt; t1)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">       <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">       <span class="keyword">if</span> (y &lt; y0 || y &gt; y1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       rec.u = (y-y0)/(y1-y0);</span><br><span class="line">       rec.v = (z-z0)/(z1-z0);</span><br><span class="line">       rec.t = t;</span><br><span class="line">       vec3 outward_normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">       rec.mat_ptr = mp;</span><br><span class="line">       rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Creating-an-Empty-â€œCornell-Boxâ€"><a href="#Creating-an-Empty-â€œCornell-Boxâ€" class="headerlink" title="Creating an Empty â€œCornell Boxâ€"></a>Creating an Empty â€œCornell Boxâ€</h4><blockquote><p>The â€œCornell Boxâ€ was introduced in 1984 to model the interaction of light between diffuse surfaces. Letâ€™s make the 5 walls and the light of the box:</p></blockquote><p>è®©æˆ‘ä»¬åšäº”å µå¢™å£, å¹¶ç‚¹äº®è¿™ä¸ªç›’å­:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>{</span><br><span class="line">        hittable_list objects;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.65</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)));</span><br><span class="line">        <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.73</span>, <span class="number">0.73</span>, <span class="number">0.73</span>)));</span><br><span class="line">        <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.12</span>, <span class="number">0.45</span>, <span class="number">0.15</span>)));</span><br><span class="line">        <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>)));</span><br><span class="line"></span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">        <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Add the view and scene info:</p></blockquote><p>ä¸‹é¢æ˜¯æ–°çš„æ‘„åƒæœºçš„å‚æ•°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Camera</span></span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="function"><span class="type">const</span> vec3 <span class="title">background</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>æˆ‘ä»¬ä¼šå¾—åˆ°å¦‚ä¸‹çš„ç»“æœ:</p><p><img data-src="./image/loading.gif" data-original="https://raytracing.github.io/images/img-2.18-cornell-empty.png" alt="img"></p><p>è¿™çœ‹ä¸Šå»éƒ½æ˜¯å™ªç‚¹, å› ä¸ºå…‰å¤ªå°äº†ã€‚æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªé—®é¢˜: ä¸€äº›å¢™å£çš„æœå‘åäº†ã€‚æˆ‘ä»¬è¿˜æ²¡æœ‰è®©æ¼«åå°„æè´¨çš„æ­£åä¸¤é¢æœ‰ç›¸åŒçš„è¡¨ç°ã€‚ä½†cornell boxçš„å†…å¤–éƒ¨æ˜¯ä¸åŒçš„æ¨¡å¼ã€‚ä¸€ä¸ªçŸ©å½¢ç‰©ä½“çš„æ­£é¢å¾€å¾€æ˜¯(1,0,0), (0,1,0), æˆ–è€… (0,0,1) è¿™å‡ ä¸ªæ–¹å‘ã€‚æˆ‘ä»¬éœ€è¦ä¸€ç§ç¿»è½¬çŸ©å½¢æœå‘çš„æ–¹æ³•ã€‚æ‰€ä»¥è®©æˆ‘ä»¬æ¥ä¸€ä¸ªæ–°çš„hittableç±»å§, åˆ«å¾—å•¥éƒ½ä¸å¹², ä¸“é—¨ç”¨æ¥ç¿»è½¬æ­£åé¢ã€‚</p><h3 id="å®ä¾‹"><a href="#å®ä¾‹" class="headerlink" title="å®ä¾‹"></a>å®ä¾‹</h3><blockquote><p>The Cornell Box usually has two blocks in it. These are rotated relative to the walls. First, letâ€™s make an axis-aligned block primitive that holds 6 rectangles:</p></blockquote><p>Cornell Boxé‡Œé¢ä¸€èˆ¬éƒ½æœ‰ä¸¤ä¸ªç›¸å¯¹å¢™é¢æœ‰äº›è§’åº¦çš„é•¿æ–¹ä½“ã€‚é¦–å…ˆæˆ‘ä»¬å…ˆæŠŠè½´å¯¹é½çš„é•¿æ–¹ä½“å›¾å…ƒåšå‡ºæ¥ã€‚æ¯ä¸ªé•¿æ–¹ä½“æ˜¯ç”±6ä¸ªå¹³é¢æ„æˆçš„:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"aarect.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable_list.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">box</span> : <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">box</span>() {}</span><br><span class="line">    <span class="built_in">box</span>(<span class="type">const</span> vec3&amp; p0, <span class="type">const</span> vec3&amp; p1, shared_ptr&lt;material&gt; ptr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(box_min, box_max);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 box_min;</span><br><span class="line">    vec3 box_max;</span><br><span class="line">    hittable_list sides;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">box::<span class="built_in">box</span>(<span class="type">const</span> vec3&amp; p0, <span class="type">const</span> vec3&amp; p1, shared_ptr&lt;material&gt; ptr) {</span><br><span class="line">    box_min = p0;</span><br><span class="line">    box_max = p1;</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p1.<span class="built_in">z</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">y</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">y</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">x</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">x</span>(), ptr));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box::hit</span><span class="params">(<span class="type">const</span> ray &amp;r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record &amp;rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> sides.<span class="built_in">hit</span>(r, t0, t1, rec);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Now we can add two blocks (but not rotated)</p></blockquote><p>ç°åœ¨æˆ‘ä»¬å¯ä»¥åŠ å…¥ä¸¤ä¸ªé•¿æ–¹ä½“äº†(ä½†æ˜¯æ²¡æœ‰æ—‹è½¬çš„è§’åº¦)</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"box.h"</span></span></span><br><span class="line">...</span><br><span class="line">objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>), <span class="built_in">point3</span>(<span class="number">295</span>, <span class="number">165</span>, <span class="number">230</span>), white));</span><br><span class="line">objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>), <span class="built_in">point3</span>(<span class="number">430</span>, <span class="number">330</span>, <span class="number">460</span>), white));</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.19-cornell-blocks.png"></p><blockquote><p>Now that we have boxes, we need to rotate them a bit to have them match the <em>real</em> Cornell box. In ray tracing, this is usually done with an <em>instance</em>. An instance is a geometric primitive that has been moved or rotated somehow. This is especially easy in ray tracing because we donâ€™t move anything; instead we move the rays in the opposite direction. For example, consider a <em>translation</em> (often called a <em>move</em>). We could take the pink box at the origin and add 2 to all its x components, or (as we almost always do in ray tracing) leave the box where it is, but in its hit routine subtract 2 off the x-component of the ray origin.</p></blockquote><p>ç°åœ¨æˆ‘ä»¬æœ‰äº†è¿™ä¸¤ä¸ªé•¿æ–¹ä½“, ä¸ºäº†è®©å®ƒçœ‹ä¸Šå»æ›´åŠ æ¥è¿‘<strong>æ­£å®—</strong>çš„Cornell Box, æˆ‘ä»¬è¿˜éœ€è¦è®©ä»–æ—‹è½¬ä¸€ä¸‹ã€‚åœ¨å…‰çº¿è¿½è¸ªä¸­, æˆ‘ä»¬æ—¶å¸¸ä½¿ç”¨**å®ä¾‹(instance)**æ¥å®Œæˆè¿™ä¸ªå·¥ä½œã€‚å®ä¾‹æ˜¯ä¸€ç§ç»è¿‡æ—‹è½¬è¿‡æˆ–è€…å¹³ç§»ç­‰æ“ä½œçš„å‡ ä½•å›¾å…ƒã€‚åœ¨å…‰çº¿è¿½è¸ªä¸­, è¿™å…¶å®å¾ˆç®€å•ã€‚æˆ‘ä»¬å¹¶ä¸éœ€è¦å»ç§»åŠ¨ä»»ä½•ä¸œè¥¿ã€‚ç›¸å¯¹çš„, æˆ‘ä»¬åªéœ€å°†å°„çº¿ã€‚ä¸¾ä¾‹æ¥è¯´, æƒ³è±¡ä¸€ä¸ª**å¹³ç§»**æ“ä½œ, æˆ‘ä»¬å¯ä»¥å°†ä½äºåŸç‚¹çš„ç²‰çº¢è‰²ç›’å­æ‰€æœ‰çš„ç»„æˆéƒ¨åˆ†çš„çš„xå€¼+2, æˆ–è€…å°±æŠŠç›’å­æ”¾åœ¨é‚£é‡Œ, ç„¶ååœ¨hitå‡½æ•°ä¸­, ç›¸å¯¹çš„å°†å°„çº¿çš„åŸç‚¹-2ã€‚(è¿™ä¹Ÿæ˜¯æˆ‘ä»¬åœ¨ray tracingä¸­æƒ¯ç”¨çš„åšæ³•) <em>ã€è¯‘æ³¨: å°„çº¿åŸç‚¹-2è®¡ç®—å‡ºhit recordå, å¾—åˆ°æ˜¯å·¦è¾¹ç›’å­, æœ€åè¿˜è¦å°†è®¡ç®—ç»“æœ+2, æ‰èƒ½è·å¾—æ­£ç¡®çš„å°„å…¥ç‚¹(å³è¾¹ç›’å­)ã€‘</em></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.06-ray-box.jpg"></p><h4 id="Instance-Translation"><a href="#Instance-Translation" class="headerlink" title="Instance Translation"></a>Instance Translation</h4><blockquote><p>Whether you think of this as a move or a change of coordinates is up to you. The code for this, to move any underlying hittable is a <em>translate</em> instance.</p></blockquote><p>ä½ æŠŠåˆšåˆšçš„è¿™ä¸ªæ“ä½œå½“æˆæ˜¯å¹³ç§»è¿˜æ˜¯åæ ‡ç³»çš„è½¬æ¢éƒ½è¡Œ, éšä½ çš„å–œå¥½ã€‚ç§»åŠ¨hittableç±»çš„translateçš„ä»£ç å¦‚ä¸‹:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">translate</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">translate</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> vec3&amp; displacement)</span><br><span class="line">            : <span class="built_in">ptr</span>(p), <span class="built_in">offset</span>(displacement) {}</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">        vec3 offset;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="function">ray <span class="title">moved_r</span><span class="params">(r.origin() - offset, r.direction(), r.time())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(moved_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    rec.p += offset;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(moved_r, rec.normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">bounding_box</span>(t0, t1, output_box))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        output_box.<span class="built_in">min</span>() + offset,</span><br><span class="line">        output_box.<span class="built_in">max</span>() + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Instance-Rotation"><a href="#Instance-Rotation" class="headerlink" title="Instance Rotation"></a>Instance Rotation</h4><blockquote><p>Rotation isnâ€™t quite as easy to understand or generate the formulas for. A common graphics tactic is to apply all rotations about the x, y, and z axes. These rotations are in some sense axis-aligned. First, letâ€™s rotate by theta about the z-axis. That will be changing only x and y, and in ways that donâ€™t depend on z.</p></blockquote><p>æ—‹è½¬å°±æ²¡æœ‰é‚£ä¹ˆå®¹æ˜“ç†è§£æˆ–åˆ—å‡ºç®—å¼äº†ã€‚ä¸€ä¸ªå¸¸ç”¨çš„å›¾åƒæŠ€å·§æ˜¯å°†æ‰€æœ‰çš„æ—‹è½¬éƒ½å½“æˆæ˜¯ç»•xyzè½´æ—‹è½¬ã€‚é¦–å…ˆ, è®©æˆ‘ä»¬ç»•zè½´æ—‹è½¬ã€‚è¿™æ ·åªä¼šæ”¹å˜xyè€Œä¸ä¼šæ”¹å˜zå€¼ã€‚</p><p><img data-src="./image/loading.gif" data-original="https://raytracing.github.io/images/fig-2.07-rot-z.jpg" alt="img"></p><blockquote><p>This involves some basic trigonometry that uses formulas that I will not cover here. That gives you the correct impression itâ€™s a little involved, but it is straightforward, and you can find it in any graphics text and in many lecture notes. The result for rotating counter-clockwise about z is:</p></blockquote><p>è¿™é‡ŒåŒ…å«äº†ä¸€äº›ä¸‰è§’å‡ ä½•. æˆ‘è¿™é‡Œå°±ä¸å±•å¼€äº†ã€‚ä½ è¦çŸ¥é“è¿™å…¶å®å¾ˆç®€å•, å¹¶ä¸éœ€è¦å¤ªå¤šçš„å‡ ä½•çŸ¥è¯†, ä½ èƒ½åœ¨ä»»ä½•ä¸€æœ¬å›¾å½¢å­¦çš„æ•™ææˆ–è€…è¯¾å ‚ç¬”è®°ä¸­æ‰¾åˆ°å®ƒã€‚ç»•zè½´é€†æ—¶é’ˆæ—‹è½¬çš„å…¬å¼å¦‚ä¸‹:</p><p>$xâ€™ = \cos(\theta) \cdot x - \sin(\theta) \cdot y$</p><p>$yâ€™ = \sin(\theta) \cdot x + \cos(\theta) \cdot y$</p><blockquote><p>The great thing is that it works for any ğœƒ and doesnâ€™t need any cases for quadrants or anything like that. The inverse transform is the opposite geometric operation: rotate by âˆ’ğœƒ. Here, recall that $\cos(ğœƒ)=\cos(âˆ’ğœƒ)$ and $\sin(âˆ’ğœƒ)=âˆ’\sin(ğœƒ)$, so the formulas are very simple.</p></blockquote><p>è¿™ä¸ªå…¬å¼çš„ä¼Ÿå¤§ä¹‹å¤„åœ¨äºå®ƒå¯¹ä»»ä½•Î¸Î¸éƒ½æˆç«‹, ä½ å®Œå…¨ä¸ç”¨å»è€ƒè™‘ä»€ä¹ˆè±¡é™å•Šæˆ–è€…åˆ«çš„ç±»ä¼¼çš„ä¸œè¥¿ã€‚å¦‚æœè¦é¡ºæ—¶é’ˆæ—‹è½¬, åªéœ€æŠŠ Î¸ æ”¹æˆ âˆ’Î¸ å³å¯ã€‚æ¥, å›æƒ³ä¸€ä¸‹$\cos(Î¸)=\cos(âˆ’Î¸)$ å’Œ $\sin(âˆ’Î¸)=âˆ’\sin(Î¸)$, æ‰€ä»¥é€†è¿ç®—çš„å…¬å¼å¾ˆç®€å•ã€‚</p><blockquote><p>Similarly, for rotating about y (as we want to do for the blocks in the box) the formulas are:</p></blockquote><p>ç±»ä¼¼çš„, ç»•yè½´æ—‹è½¬(ä¹Ÿæ­£æ˜¯æˆ‘ä»¬ç›¸å¯¹è¿™ä¸¤ä¸ªé•¿æ–¹ä½“åšçš„äº‹æƒ…)çš„å…¬å¼å¦‚ä¸‹:</p><p>$xâ€™ = \cos(\theta) \cdot x + \sin(\theta) \cdot z$</p><p>$zâ€™ = -\sin(\theta) \cdot x + \cos(\theta) \cdot z$</p><blockquote><p>And about the x-axis:</p></blockquote><p>ç»•xè½´æ—‹è½¬çš„å…¬å¼å¦‚ä¸‹:</p><p>$yâ€™ = \cos(\theta) \cdot y - \sin(\theta) \cdot z$</p><p>$zâ€™ = \sin(\theta) \cdot y + \cos(\theta) \cdot z$â€‹</p><blockquote><p>Unlike the situation with translations, the surface normal vector also changes, so we need to transform directions too if we get a hit. Fortunately for rotations, the same formulas apply. If you add scales, things get more complicated. See the web page <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> for links to that.</p><p>For a y-rotation class we have:</p></blockquote><p>å’Œå¹³ç§»å˜æ¢ä¸åŒ, æ—‹è½¬æ—¶è¡¨é¢æ³•å‘ä¹Ÿå‘ç”Ÿäº†å˜åŒ–ã€‚æ‰€ä»¥åœ¨è®¡ç®—å®Œhitå‡½æ•°åæˆ‘ä»¬è¿˜è¦é‡æ–°è®¡ç®—æ³•å‘é‡ã€‚å¹¸å¥½å¯¹äºæ—‹è½¬æ¥è¯´, æˆ‘ä»¬å¯¹æ³•å‘é‡ä½¿ç”¨ç›¸åŒçš„å…¬å¼å˜æ¢ä¸€ä¸‹å³å¯ã€‚å¦‚æœä½ åŠ å…¥äº†ç¼©æ”¾(Scale), é‚£ä¹ˆè¿™ä¸‹äº‹æƒ…å°±å¤æ‚å¤šäº†ã€‚ç‚¹å‡»æˆ‘ä»¬çš„ç½‘é¡µ <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> äº†è§£è¯¦ç»†ä¿¡æ¯ã€‚</p><p>å¯¹ä¸€ä¸ªç»•yè½´çš„æ—‹è½¬å˜æ¢æ¥è¯´, æˆ‘ä»¬æœ‰:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rotate_y</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">            output_box = bbox;</span><br><span class="line">            <span class="keyword">return</span> hasbox;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">        <span class="type">double</span> sin_theta;</span><br><span class="line">        <span class="type">double</span> cos_theta;</span><br><span class="line">        <span class="type">bool</span> hasbox;</span><br><span class="line">        aabb bbox;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>With constructor:</p></blockquote><p>åŠ ä¸Šæ„é€ å‡½æ•°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">rotate_y::<span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle) : <span class="built_in">ptr</span>(p) {</span><br><span class="line">    <span class="keyword">auto</span> radians = <span class="built_in">degree_to_radians</span>(angle);</span><br><span class="line">    sin_theta = <span class="built_in">sin</span>(radians);</span><br><span class="line">    cos_theta = <span class="built_in">cos</span>(radians);</span><br><span class="line">    hasbox = ptr-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">1</span>, bbox);</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">min</span><span class="params">( infinity,  infinity,  infinity)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">max</span><span class="params">(-infinity, -infinity, -infinity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) {</span><br><span class="line">                <span class="keyword">auto</span> x = i*bbox.<span class="built_in">max</span>().<span class="built_in">x</span>() + (<span class="number">1</span>-i)*bbox.<span class="built_in">min</span>().<span class="built_in">x</span>();</span><br><span class="line">                <span class="keyword">auto</span> y = j*bbox.<span class="built_in">max</span>().<span class="built_in">y</span>() + (<span class="number">1</span>-j)*bbox.<span class="built_in">min</span>().<span class="built_in">y</span>();</span><br><span class="line">                <span class="keyword">auto</span> z = k*bbox.<span class="built_in">max</span>().<span class="built_in">z</span>() + (<span class="number">1</span>-k)*bbox.<span class="built_in">min</span>().<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> newx =  cos_theta*x + sin_theta*z;</span><br><span class="line">                <span class="keyword">auto</span> newz = -sin_theta*x + cos_theta*z;</span><br><span class="line"></span><br><span class="line">                <span class="function">vec3 <span class="title">tester</span><span class="params">(newx, y, newz)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++) {</span><br><span class="line">                    min[c] = <span class="built_in">ffmin</span>(min[c], tester[c]);</span><br><span class="line">                    max[c] = <span class="built_in">ffmax</span>(max[c], tester[c]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    bbox = <span class="built_in">aabb</span>(min, max);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the hit function:</p></blockquote><p>ä»¥åŠhitå‡½æ•°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rotate_y::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    vec3 origin = r.<span class="built_in">origin</span>();</span><br><span class="line">    vec3 direction = r.<span class="built_in">direction</span>();</span><br><span class="line"></span><br><span class="line">    origin[<span class="number">0</span>] = cos_theta*r.<span class="built_in">origin</span>()[<span class="number">0</span>] - sin_theta*r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    origin[<span class="number">2</span>] = sin_theta*r.<span class="built_in">origin</span>()[<span class="number">0</span>] + cos_theta*r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    direction[<span class="number">0</span>] = cos_theta*r.<span class="built_in">direction</span>()[<span class="number">0</span>] - sin_theta*r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line">    direction[<span class="number">2</span>] = sin_theta*r.<span class="built_in">direction</span>()[<span class="number">0</span>] + cos_theta*r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">rotated_r</span><span class="params">(origin, direction, r.time())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(rotated_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    vec3 p = rec.p;</span><br><span class="line">    vec3 normal = rec.normal;</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] =  cos_theta*rec.p[<span class="number">0</span>] + sin_theta*rec.p[<span class="number">2</span>];</span><br><span class="line">    p[<span class="number">2</span>] = -sin_theta*rec.p[<span class="number">0</span>] + cos_theta*rec.p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    normal[<span class="number">0</span>] =  cos_theta*rec.normal[<span class="number">0</span>] + sin_theta*rec.normal[<span class="number">2</span>];</span><br><span class="line">    normal[<span class="number">2</span>] = -sin_theta*rec.normal[<span class="number">0</span>] + cos_theta*rec.normal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    rec.p = p;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(rotated_r, normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the changes to Cornell are:</p></blockquote><p>å¹¶ä¸”ä¿®æ”¹ä¸€ä¸‹ç”Ÿæˆcornell boxçš„Cornellå‡½æ•°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1,  <span class="number">15</span>);</span><br><span class="line">box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>,<span class="number">0</span>,<span class="number">295</span>));</span><br><span class="line">objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">165</span>,<span class="number">165</span>,<span class="number">165</span>), white);</span><br><span class="line">box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>,<span class="number">0</span>,<span class="number">65</span>));</span><br><span class="line">objects.<span class="built_in">add</span>(box2);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which yields:</p></blockquote><p>æœ€åå¾—åˆ°:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.20-cornell-standard.png"></p><h3 id="ä½“ç§¯ä½“"><a href="#ä½“ç§¯ä½“" class="headerlink" title="ä½“ç§¯ä½“"></a>ä½“ç§¯ä½“</h3><blockquote><p>One thing itâ€™s nice to add to a ray tracer is smoke/fog/mist. These are sometimes called <em>volumes</em> or <em>participating media</em>. Another feature that is nice to add is subsurface scattering, which is sort of like dense fog inside an object. This usually adds software architectural mayhem because volumes are a different animal than surfaces, but a cute technique is to make a volume a random surface. A bunch of smoke can be replaced with a surface that probabilistically might or might not be there at every point in the volume. This will make more sense when you see the code.</p></blockquote><p>ç»™å…‰çº¿è¿½è¸ªå™¨åŠ å…¥çƒŸ/é›¾/æ°´æ±½æ˜¯ä¸€ä»¶å¾ˆä¸é”™çš„äº‹æƒ…ã€‚è¿™äº›ä¸œè¥¿å¸¸å¸¸è¢«ç§°ä¸ºä½“ç§¯ä½“(volumes)æˆ–è€…å¯å‚ä¸ä»‹è´¨(participating media)ã€‚æ¬¡è¡¨é¢æ•£å°„(sub surface scatter, SSS)æ˜¯å¦ä¸€ä¸ªä¸é”™çš„ç‰¹æ€§, æœ‰ç‚¹åƒç‰©ä½“å†…éƒ¨çš„æµ“é›¾ã€‚åŠ å…¥è¿™éƒ¨åˆ†å†…å®¹ä¼šå¯¼è‡´ä»£ç ç»“æ„çš„æ··ä¹±ã€‚å› ä¸ºä½“ç§¯ä½“å’Œå¹³é¢è¡¨é¢æ˜¯å®Œå…¨ä¸åŒçš„ä¸¤ç§ä¸œè¥¿ã€‚ä½†æˆ‘ä»¬æœ‰ä¸€ä¸ªå¯çˆ±çš„å°æŠ€å·§: å°†ä½“ç§¯ä½“è¡¨ç¤ºä¸ºä¸€ä¸ªéšæœºè¡¨é¢ã€‚ä¸€å›¢çƒŸé›¾åœ¨å…¶å®å¯ä»¥ç”¨ä¸€ä¸ªæ¦‚ç‡ä¸Šä¸ç¡®å®šåœ¨ä»€ä¹ˆä½ç½®çš„å¹³é¢æ¥ä»£æ›¿ã€‚å½“ä½ çœ‹åˆ°ä»£ç å, ä½ å°±ä¼šæ›´æœ‰æ„Ÿè§‰äº†ã€‚</p><h4 id="Constant-Density-Mediums"><a href="#Constant-Density-Mediums" class="headerlink" title="Constant Density Mediums"></a>Constant Density Mediums</h4><blockquote><p>First, letâ€™s start with a volume of constant density. A ray going through there can either scatter inside the volume, or it can make it all the way through like the middle ray in the figure. More thin transparent volumes, like a light fog, are more likely to have rays like the middle one. How far the ray has to travel through the volume also determines how likely it is for the ray to make it through.</p></blockquote><p>é¦–å…ˆè®©æˆ‘ä»¬æ¥ç”Ÿæˆä¸€ä¸ªå›ºå®šå¯†åº¦çš„ä½“ç§¯ä½“ã€‚å…‰çº¿å¯ä»¥åœ¨ä½“ç§¯ä½“å†…éƒ¨å‘ç”Ÿæ•£å°„, ä¹Ÿå¯ä»¥åƒå›¾ä¸­çš„ä¸­é—´é‚£æ¡å°„çº¿ä¸€æ ·ç›´æ¥ç©¿è¿‡å»ã€‚ä½“ç§¯ä½“è¶Šè–„è¶Šé€æ˜, ç›´æ¥ç©¿è¿‡å»çš„æƒ…å†µå°±è¶Šæœ‰å¯èƒ½ä¼šå‘ç”Ÿã€‚å…‰çº¿åœ¨ä½“ç§¯ä½“ä¸­ç›´çº¿ä¼ æ’­æ‰€ç»è¿‡çš„è·ç¦»ä¹Ÿå†³å®šäº†å…‰çº¿é‡‡ç”¨å›¾ä¸­å“ªç§æ–¹å¼é€šè¿‡ä½“ç§¯ä½“ã€‚</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.08-ray-vol.jpg"></p><blockquote><p>As the ray passes through the volume, it may scatter at any point. The denser the volume, the more likely that is. The probability that the ray scatters in any small distance Î”ğ¿ is:</p></blockquote><p>å½“å…‰çº¿å°„å…¥ä½“ç§¯ä½“æ—¶, å®ƒå¯èƒ½åœ¨ä»»æ„ä¸€ç‚¹å‘ç”Ÿæ•£å°„ã€‚ä½“ç§¯ä½“è¶Šæµ“, è¶Šå¯èƒ½å‘ç”Ÿæ•£å°„ã€‚åœ¨ä»»æ„å¾®å°çš„è·ç¦»å·® $Î”L$ å‘ç”Ÿæ•£å°„çš„æ¦‚ç‡å¦‚ä¸‹:</p><p>$probability = C \cdot \Delta L$</p><blockquote><p>where ğ¶ is proportional to the optical density of the volume. If you go through all the differential equations, for a random number you get a distance where the scattering occurs. If that distance is outside the volume, then there is no â€œhitâ€. For a constant volume we just need the density ğ¶ and the boundary. Iâ€™ll use another hittable for the boundary. The resulting class is:</p></blockquote><p>å…¶ä¸­ C æ˜¯ä½“ç§¯ä½“çš„å…‰å­¦å¯†åº¦æ¯”ä¾‹å¸¸æ•°ã€‚ ç»è¿‡äº†ä¸€ç³»åˆ—ä¸åŒçš„ç­‰å¼è¿ç®—, ä½ å°†ä¼šéšæœºçš„å¾—åˆ°ä¸€ä¸ªå…‰çº¿å‘ç”Ÿæ•£å°„çš„è·ç¦»å€¼ã€‚å¦‚æœæ ¹æ®è¿™ä¸ªè·ç¦»æ¥è¯´, æ•£å°„ç‚¹åœ¨ä½“ç§¯ä½“å¤–, é‚£ä¹ˆæˆ‘ä»¬è®¤ä¸ºæ²¡æœ‰ç›¸äº¤, ä¸è°ƒç”¨<code>hit</code>å‡½æ•°ã€‚å¯¹äºä¸€ä¸ªé™æ€çš„ä½“ç§¯ä½“æ¥è¯´, æˆ‘ä»¬åªéœ€è¦ä»–çš„å¯†åº¦ C å’Œè¾¹ç•Œã€‚æˆ‘ä¼šç”¨å¦ä¸€ä¸ªhittableç‰©ä½“æ¥è¡¨ç¤ºä½“ç§¯ä½“çš„è¾¹ç•Œ:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"material.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constant_medium</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, shared_ptr&lt;texture&gt; a)</span><br><span class="line">            : <span class="built_in">boundary</span>(b), <span class="built_in">neg_inv_density</span>(<span class="number">-1</span>/d)</span><br><span class="line">        {</span><br><span class="line">            phase_function = <span class="built_in">make_shared</span>&lt;isotropic&gt;(a);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> boundary-&gt;<span class="built_in">bounding_box</span>(t0, t1, output_box);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; boundary;</span><br><span class="line">        shared_ptr&lt;material&gt; phase_function;</span><br><span class="line">        <span class="type">double</span> neg_inv_density;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The scattering function of isotropic picks a uniform random direction:</p></blockquote><p>å¯¹äºæ•£å°„çš„æ–¹å‘æ¥è¯´, æˆ‘ä»¬é‡‡ç”¨å„é¡¹åŒæ€§(isotropic)çš„éšæœºå•ä½å‘é‡å¤§æ³•</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">isotropic</span> : <span class="keyword">public</span> material {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">isotropic</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) {}</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="type">const</span>  </span>{</span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">random_in_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">            attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;texture&gt; albedo;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the hit function is:</p></blockquote><p>hitå‡½æ•°å¦‚ä¸‹:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">constant_medium::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="comment">// Print occasional samples when debugging. To enable, set enableDebug true.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableDebug = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> debugging = enableDebug &amp;&amp; <span class="built_in">random_double</span>() &lt; <span class="number">0.00001</span>;</span><br><span class="line"></span><br><span class="line">    hit_record rec1, rec2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, -infinity, infinity, rec1))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, rec1.t+<span class="number">0.0001</span>, infinity, rec2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) std::cerr &lt;&lt; <span class="string">"\nt0="</span> &lt;&lt; rec1.t &lt;&lt; <span class="string">", t1="</span> &lt;&lt; rec2.t &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; t_min) rec1.t = t_min;</span><br><span class="line">    <span class="keyword">if</span> (rec2.t &gt; t_max) rec2.t = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &gt;= rec2.t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; <span class="number">0</span>)</span><br><span class="line">        rec1.t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ray_length = r.<span class="built_in">direction</span>().<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> distance_inside_boundary = (rec2.t - rec1.t) * ray_length;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> hit_distance = neg_inv_density * <span class="built_in">log</span>(<span class="built_in">random_double</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hit_distance &gt; distance_inside_boundary)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    rec.t = rec1.t + hit_distance / ray_length;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"hit_distance = "</span> &lt;&lt;  hit_distance &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">                  &lt;&lt; <span class="string">"rec.t = "</span> &lt;&lt;  rec.t &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">                  &lt;&lt; <span class="string">"rec.p = "</span> &lt;&lt;  rec.p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rec.normal = <span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">// arbitrary</span></span><br><span class="line">    rec.front_face = <span class="literal">true</span>;     <span class="comment">// also arbitrary</span></span><br><span class="line">    rec.mat_ptr = phase_function;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The reason we have to be so careful about the logic around the boundary is we need to make sure this works for ray origins inside the volume. In clouds, things bounce around a lot so that is a common case.</p></blockquote><p>æˆ‘ä»¬ä¸€å®šè¦å°å¿ƒä¸è¾¹ç•Œç›¸å…³çš„é€»è¾‘, å› ä¸ºæˆ‘ä»¬è¦ç¡®ä¿å½“å°„çº¿åŸç‚¹åœ¨ä½“ç§¯ä½“å†…éƒ¨æ—¶, å…‰çº¿ä¾ç„¶ä¼šå‘ç”Ÿæ•£å°„ã€‚åœ¨äº‘ä¸­, å…‰çº¿åå¤å‘ç”Ÿæ•£å°„, è¿™æ˜¯ä¸€ç§å¾ˆå¸¸è§çš„ç°è±¡ã€‚</p><blockquote><p>In addition, the above code assumes that once a ray exits the constant medium boundary, it will continue forever outside the boundary. Put another way, it assumes that the boundary shape is convex. So this particular implementation will work for boundaries like boxes or spheres, but will not work with toruses or shapes that contain voids. Itâ€™s possible to write an implementation that handles arbitrary shapes, but weâ€™ll leave that as an exercise for the reader.</p></blockquote><p>å¦å¤–, ä¸Šè¿°ä»£ç åªèƒ½ç¡®ä¿å°„çº¿åªä¼šå°„å…¥ä½“ç§¯ä½“ä¸€æ¬¡, ä¹‹åå†ä¹Ÿä¸è¿›å…¥ä½“ç§¯ä½“çš„æƒ…å†µã€‚æ¢å¥è¯è¯´, å®ƒå‡å®šä½“ç§¯ä½“çš„è¾¹ç•Œæ˜¯ä¸€ä¸ªå‡¸å‡ ä½•ä½“ã€‚æ‰€ä»¥è¿™ä¸ªç‹­ä¹‰çš„å®ç°åªå¯¹çƒä½“æˆ–è€…é•¿æ–¹ä½“è¿™æ ·çš„ç‰©ä½“ç”Ÿæ•ˆã€‚ä½†æ˜¯å¯¹äºå½“ä¸­æœ‰æ´çš„é‚£ç§å½¢çŠ¶, å¦‚ç”œç”œåœˆå°±ä¸è¡Œäº†ã€‚å†™ä¸€ä¸ªèƒ½å¤„ç†ä»»æ„å½¢çŠ¶çš„å®ç°æ˜¯å®Œå…¨å¯è¡Œçš„, ä½†æˆ‘ä»¬æŠŠè¿™éƒ¨åˆ†å†…å®¹ç•™ç»™æˆ‘ä»¬çš„è¯»è€…ä½œä¸ºç»ƒä¹ ã€‚</p><h4 id="Rendering-a-Cornell-Box-with-Smoke-and-Fog-Boxes"><a href="#Rendering-a-Cornell-Box-with-Smoke-and-Fog-Boxes" class="headerlink" title="Rendering a Cornell Box with Smoke and Fog Boxes"></a>Rendering a Cornell Box with Smoke and Fog Boxes</h4><blockquote><p>If we replace the two blocks with smoke and fog (dark and light particles), and make the light bigger (and dimmer so it doesnâ€™t blow out the scene) for faster convergence:</p></blockquote><p>å¦‚æœæˆ‘ä»¬å°†ä¸¤ä¸ªé•¿æ–¹ä½“æ›¿æ¢ä¸ºçƒŸå’Œé›¾(æ·±è‰²ä¸æµ…è‰²çš„ç²’å­)å¹¶ä½¿ç”¨ä¸€ä¸ªæ›´å¤§çš„ç¯å…‰(åŒæ—¶æ›´åŠ æ˜æš—ä»¥è‡³äºä¸ä¼šç‚¸äº†è¿™ä¸ªåœºæ™¯)è®©åœºæ™¯æ›´å¿«çš„èåˆåœ¨ä¸€èµ·ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"constant_medium.h"</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_smoke</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.65</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.73</span>, <span class="number">0.73</span>, <span class="number">0.73</span>)));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.12</span>, <span class="number">0.45</span>, <span class="number">0.15</span>)));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>)));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">113</span>, <span class="number">443</span>, <span class="number">127</span>, <span class="number">432</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white)));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">165</span>,<span class="number">330</span>,<span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1,  <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>,<span class="number">0</span>,<span class="number">295</span>));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">165</span>,<span class="number">165</span>,<span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>,<span class="number">0</span>,<span class="number">65</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;constant_medium&gt;(box1, <span class="number">0.01</span>, <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))));</span><br><span class="line">    objects.<span class="built_in">add</span>(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;constant_medium&gt;(box2, <span class="number">0.01</span>, <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We get:</p></blockquote><p>æˆ‘ä»¬ä¼šå¾—åˆ°:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.21-cornell-smoke.png"></p><h3 id="æµ‹è¯•åœºæ™¯"><a href="#æµ‹è¯•åœºæ™¯" class="headerlink" title="æµ‹è¯•åœºæ™¯"></a>æµ‹è¯•åœºæ™¯</h3><blockquote><p>Letâ€™s put it all together, with a big thin mist covering everything, and a blue subsurface reflection sphere (we didnâ€™t implement that explicitly, but a volume inside a dielectric is what a subsurface material is). The biggest limitation left in the renderer is no shadow rays, but that is why we get caustics and subsurface for free. Itâ€™s a double-edged design decision.</p></blockquote><p>è®©æˆ‘ä»¬æŠŠæ‰€æœ‰ä¸œè¥¿æ”¾åœ¨ä¸€èµ·å§!ä½¿ç”¨ä¸€ä¸ªè–„é›¾ç›–ä½æ‰€æœ‰ä¸œè¥¿, å¹¶åŠ å…¥ä¸€ä¸ªè“è‰²çš„æ¬¡è¡¨é¢åå°„çƒä½“(è¿™ç§è¯´æ³•ä¸å¤ªæ¸…æ¥š, å®é™…ä¸Šæ¬¡è¡¨é¢æè´¨å°±æ˜¯åœ¨ç”µä»‹è´¨å†…éƒ¨å¡«å……ä½“ç§¯ä½“)ã€‚ç°åœ¨è¿™ä¸ªæ¸²æŸ“å™¨çš„æœ€å¤§å±€é™å°±æ˜¯æ²¡æœ‰é˜´å½±å…‰çº¿ã€‚ä½†æ˜¯å› æ­¤æˆ‘ä»¬èƒ½ä¸èŠ±ä»£ä»·çš„å¾—åˆ°æ•£ç„¦å’Œæ¬¡è¡¨é¢ã€‚è¿™æ˜¯ä¸€æŠŠè®¾è®¡ä¸Šçš„åŒåˆƒå‰‘ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">final_scene</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list boxes1;</span><br><span class="line">    <span class="keyword">auto</span> ground =</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.48</span>, <span class="number">0.83</span>, <span class="number">0.53</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> boxes_per_side = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boxes_per_side; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boxes_per_side; j++) {</span><br><span class="line">            <span class="keyword">auto</span> w = <span class="number">100.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x0 = <span class="number">-1000.0</span> + i*w;</span><br><span class="line">            <span class="keyword">auto</span> z0 = <span class="number">-1000.0</span> + j*w;</span><br><span class="line">            <span class="keyword">auto</span> y0 = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x1 = x0 + w;</span><br><span class="line">            <span class="keyword">auto</span> y1 = <span class="built_in">random_double</span>(<span class="number">1</span>,<span class="number">101</span>);</span><br><span class="line">            <span class="keyword">auto</span> z1 = z0 + w;</span><br><span class="line"></span><br><span class="line">            boxes1.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(x0,y0,z0), <span class="built_in">vec3</span>(x1,y1,z1), ground));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes1, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">123</span>, <span class="number">423</span>, <span class="number">147</span>, <span class="number">412</span>, <span class="number">554</span>, light));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> center1 = <span class="built_in">vec3</span>(<span class="number">400</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">auto</span> center2 = center1 + <span class="built_in">vec3</span>(<span class="number">30</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> moving_sphere_material =</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.1</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;moving_sphere&gt;(center1, center2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, moving_sphere_material));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.9</span>), <span class="number">10.0</span>)</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">70</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(boundary);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(</span><br><span class="line">        boundary, <span class="number">0.2</span>, <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.9</span>))</span><br><span class="line">    ));</span><br><span class="line">    boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5000</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(</span><br><span class="line">        boundary, <span class="number">.0001</span>, <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nx, ny, nn;</span><br><span class="line">    <span class="keyword">auto</span> tex_data = <span class="built_in">stbi_load</span>(<span class="string">"earthmap.jpg"</span>, &amp;nx, &amp;ny, &amp;nn, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> emat = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;image_texture&gt;(tex_data, nx, ny));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">400</span>,<span class="number">200</span>, <span class="number">400</span>), <span class="number">100</span>, emat));</span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">0.1</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">220</span>,<span class="number">280</span>, <span class="number">300</span>), <span class="number">80</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    hittable_list boxes2;</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.73</span>, <span class="number">0.73</span>, <span class="number">0.73</span>)));</span><br><span class="line">    <span class="type">int</span> ns = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ns; j++) {</span><br><span class="line">        boxes2.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(vec3::<span class="built_in">random</span>(<span class="number">0</span>,<span class="number">165</span>), <span class="number">10</span>, white));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;translate&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;rotate_y&gt;(</span><br><span class="line">            <span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes2, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">15</span>),</span><br><span class="line">            <span class="built_in">vec3</span>(<span class="number">-100</span>,<span class="number">270</span>,<span class="number">395</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Running it with 10,000 rays per pixel yields:</p></blockquote><p>æ¯ä¸ªåƒç´ ç‚¹é‡‡æ ·10,000æ¬¡, å¾—åˆ°ä¸‹å›¾çš„ç»“æœ:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final-20210730003326518.jpg"></p><blockquote><p>Now go off and make a really cool image of your own! See <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> for pointers to further reading and features, and feel free to email questions, comments, and cool images to me at <a href="mailto:ptrshrl@gmail.com.">ptrshrl@gmail.com.</a></p></blockquote><p>ç°åœ¨ä½ å¯ä»¥åˆä¸Šè¿™æœ¬ä¹¦, å¼€å§‹ç”Ÿæˆå±äºä½ è‡ªå·±çš„ç‚«é…·å›¾ç‰‡! åœ¨ <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> è·å–åç»­é˜…è¯»å†…å®¹å’Œæ–°ç‰¹æ€§, å¦‚æœä½ åœ¨é˜…è¯»è¿‡ç¨‹ä¸­é‡åˆ°äº†é—®é¢˜, æˆ–å¯¹æœ¬ä¹¦æœ‰ä»€ä¹ˆçœ‹æ³•æˆ–è¯„ä»·, æˆ–è€…æƒ³åˆ†äº«ä½ çš„ç‚«é…·å›¾ç‰‡, æ¬¢è¿å‘é€é‚®ä»¶åˆ° <a href="mailto:ptrshrl@gmail.com">ptrshrl@gmail.com</a></p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/1503bc5d.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 13</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/62048ccb.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 12</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/7d20819.html" rel="prev" title="Triangles and Z-Buffering"><i class="fa fa-chevron-left"></i> Triangles and Z-Buffering</a></div><div class="post-nav-item"><a href="/archives/341aeb83.html" rel="next" title="åºåˆ—æ¨¡å¼">åºåˆ—æ¨¡å¼ <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">å¼•è¨€</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">æ¦‚è¿°</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%A8%A1%E7%B3%8A"><span class="nav-number">3.</span> <span class="nav-text">åŠ¨æ€æ¨¡ç³Š</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduction-of-SpaceTime-Ray-Tracing"><span class="nav-number">3.1.</span> <span class="nav-text">Introduction of SpaceTime Ray Tracing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Updating-the-Camera-to-Simulate-Motion-Blur"><span class="nav-number">3.2.</span> <span class="nav-text">Updating the Camera to Simulate Motion Blur</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adding-Moving-Spheres"><span class="nav-number">3.3.</span> <span class="nav-text">Adding Moving Spheres</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tracking-the-Time-of-Ray-Intersection"><span class="nav-number">3.4.</span> <span class="nav-text">Tracking the Time of Ray Intersection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Putting-Everything-Together"><span class="nav-number">3.5.</span> <span class="nav-text">Putting Everything Together</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E5%8C%85%E5%9B%B4%E7%9B%92"><span class="nav-number">4.</span> <span class="nav-text">å±‚æ¬¡åŒ…å›´ç›’</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Key-Idea"><span class="nav-number">4.1.</span> <span class="nav-text">The Key Idea</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hierarchies-of-Bounding-Volumes"><span class="nav-number">4.2.</span> <span class="nav-text">Hierarchies of Bounding Volumes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Axis-Aligned-Bounding-Boxes-AABBs"><span class="nav-number">4.3.</span> <span class="nav-text">Axis-Aligned Bounding Boxes (AABBs)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ray-Intersection-with-an-AABB"><span class="nav-number">4.4.</span> <span class="nav-text">Ray Intersection with an AABB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#An-Optimized-AABB-Hit-Method"><span class="nav-number">4.5.</span> <span class="nav-text">An Optimized AABB Hit Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructing-Bounding-Boxes-for-Hittables"><span class="nav-number">4.6.</span> <span class="nav-text">Constructing Bounding Boxes for Hittables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-Bounding-Boxes-of-Lists-of-Objects"><span class="nav-number">4.7.</span> <span class="nav-text">Creating Bounding Boxes of Lists of Objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-BVH-Node-Class"><span class="nav-number">4.8.</span> <span class="nav-text">The BVH Node Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Splitting-BVH-Volumes"><span class="nav-number">4.9.</span> <span class="nav-text">Splitting BVH Volumes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Box-Comparison-Functions"><span class="nav-number">4.10.</span> <span class="nav-text">The Box Comparison Functions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">å›ºä½“è´´å›¾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-First-Texture-Class-Constant-Texture"><span class="nav-number">5.1.</span> <span class="nav-text">The First Texture Class: Constant Texture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A-Checker-Texture"><span class="nav-number">5.2.</span> <span class="nav-text">A Checker Texture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rendering-a-Scene-with-a-Checkered-Texture"><span class="nav-number">5.3.</span> <span class="nav-text">Rendering a Scene with a Checkered Texture</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%8F%E6%9E%97%E5%99%AA%E9%9F%B3"><span class="nav-number">6.</span> <span class="nav-text">æŸæ—å™ªéŸ³</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-Blocks-of-Random-Numbers"><span class="nav-number">6.1.</span> <span class="nav-text">Using Blocks of Random Numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Smoothing-out-the-Result"><span class="nav-number">6.2.</span> <span class="nav-text">Smoothing out the Result</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Improvement-with-Hermitian-Smoothing"><span class="nav-number">6.3.</span> <span class="nav-text">Improvement with Hermitian Smoothing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tweaking-The-Frequency"><span class="nav-number">6.4.</span> <span class="nav-text">Tweaking The Frequency</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-Random-Vectors-on-the-Lattice-Points"><span class="nav-number">6.5.</span> <span class="nav-text">Using Random Vectors on the Lattice Points</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Introducing-Turbulence"><span class="nav-number">6.6.</span> <span class="nav-text">Introducing Turbulence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adjusting-the-Phase"><span class="nav-number">6.7.</span> <span class="nav-text">Adjusting the Phase</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84"><span class="nav-number">7.</span> <span class="nav-text">çº¹ç†æ˜ å°„</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Storing-Texture-Image-Data"><span class="nav-number">7.1.</span> <span class="nav-text">Storing Texture Image Data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-an-Image-Texture"><span class="nav-number">7.2.</span> <span class="nav-text">Using an Image Texture</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%92%8C%E5%85%89%E6%BA%90"><span class="nav-number">8.</span> <span class="nav-text">çŸ©é˜µå’Œå…‰æº</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Emissive-Materials"><span class="nav-number">8.1.</span> <span class="nav-text">Emissive Materials</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adding-Background-Color-to-the-Ray-Color-Function"><span class="nav-number">8.2.</span> <span class="nav-text">Adding Background Color to the Ray Color Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-Rectangle-Objects"><span class="nav-number">8.3.</span> <span class="nav-text">Creating Rectangle Objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Turning-Objects-into-Lights"><span class="nav-number">8.4.</span> <span class="nav-text">Turning Objects into Lights</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#More-Axis-Aligned-Rectangles"><span class="nav-number">8.5.</span> <span class="nav-text">More Axis-Aligned Rectangles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-an-Empty-%E2%80%9CCornell-Box%E2%80%9D"><span class="nav-number">8.6.</span> <span class="nav-text">Creating an Empty â€œCornell Boxâ€</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">9.</span> <span class="nav-text">å®ä¾‹</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Instance-Translation"><span class="nav-number">9.1.</span> <span class="nav-text">Instance Translation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Instance-Rotation"><span class="nav-number">9.2.</span> <span class="nav-text">Instance Rotation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%93%E7%A7%AF%E4%BD%93"><span class="nav-number">10.</span> <span class="nav-text">ä½“ç§¯ä½“</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Constant-Density-Mediums"><span class="nav-number">10.1.</span> <span class="nav-text">Constant Density Mediums</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rendering-a-Cornell-Box-with-Smoke-and-Fog-Boxes"><span class="nav-number">10.2.</span> <span class="nav-text">Rendering a Cornell Box with Smoke and Fog Boxes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF"><span class="nav-number">11.</span> <span class="nav-text">æµ‹è¯•åœºæ™¯</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">272</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail â†’ mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub â†’ https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter â†’ https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo â†’ https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam â†’ https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess â†’ https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS â†’ /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><span class="exturl cc-opacity" title="Deploy with Netlify â†’ https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">ç¹/ç®€ï¼š<a id="translateLink" href="javascript:translatePage();">ç¹ä½“</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="ç¹ä½“",msgToSimplifiedChinese="ç®€ä½“",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">æ™‹ICPå¤‡2021009930å· </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/å¤‡æ¡ˆå›¾æ ‡.png" style="display:inline-block"></div><div class="copyright">Â© 2020 â€“ <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4m</span></div><div class="powered-by">ä»Šæ—©é›¾éœ¾è”½æ—¥ï¼Œä½†æ˜¯ä¸è¦å®³æ€•ï¼Œå¤ªé˜³ä¾æ—§åœ¨äº‘ç«¯</div><div class="busuanzi-count"><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//fastly.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//fastly.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//fastly.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}ï¼‰
#åœ¨è¿™åé¢å¯ä»¥åŠ å…¥ç¨‹åºçš„å…¶ä»–ä»£ç   


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script async="" src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script>!function(t,h,e,j){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:2272201,hjsv:6},e=h.getElementsByTagName("head")[0],(j=h.createElement("script")).async=1,j.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,e.appendChild(j)}(window,document)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Ray Tracing: The Next Week             引言《Ray Tracing: The Next Week》（《一周搞定光线追踪》）， 由 Peter Shirley（就是那本图形学虎书的作者）所编写的的软渲光追三部曲第二本，是一本非常好的入门级书籍，当前版本 v3.0。"><meta property="og:type" content="article"><meta property="og:title" content="Ray Tracing the Next Week"><meta property="og:url" content="https://yousazoe.top/archives/30e31a9b.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Ray Tracing: The Next Week             引言《Ray Tracing: The Next Week》（《一周搞定光线追踪》）， 由 Peter Shirley（就是那本图形学虎书的作者）所编写的的软渲光追三部曲第二本，是一本非常好的入门级书籍，当前版本 v3.0。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.01-bouncing-spheres.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.01-bvol-hierarchy.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.02-2d-aabb.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.03-ray-slab.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.04-ray-slab-interval.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.02-checker-ground.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.03-checker-spheres.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.04-white-noise.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.05-white-noise-blurred.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.06-tile-random.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.07-hash-random.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.08-perlin-trilerp.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.09-perlin-trilerp-smooth.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.10-perlin-hifreq.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.11-perlin-shift.png"><meta property="og:image" content="https://raytracing.github.io/images/img-2.12-perlin-turb.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.13-perlin-marble.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/earthmap.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.15-earth-sphere.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.05-ray-rect.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.17-rect-sphere-light.png"><meta property="og:image" content="https://raytracing.github.io/images/img-2.18-cornell-empty.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.19-cornell-blocks.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.06-ray-box.jpg"><meta property="og:image" content="https://raytracing.github.io/images/fig-2.07-rot-z.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.20-cornell-standard.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.08-ray-vol.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.21-cornell-smoke.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final-20210730003326518.jpg"><meta property="article:published_time" content="2021-07-29T16:42:59.000Z"><meta property="article:modified_time" content="2022-09-25T09:42:54.427Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final.jpg"><link rel="canonical" href="https://yousazoe.top/archives/30e31a9b.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Ray Tracing the Next Week | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/30e31a9b.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Ray Tracing the Next Week</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-07-30 00:42:59" itemprop="dateCreated datePublished" datetime="2021-07-30T00:42:59+08:00">2021-07-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">光线追踪 (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>74k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>2:14</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final.jpg"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">Ray Tracing: The Next Week</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">《Ray Tracing: The Next Week》</a>（《一周搞定光线追踪》）， 由 Peter Shirley（就是那本图形学虎书的作者）所编写的的软渲光追三部曲第二本，是一本非常好的入门级书籍，当前版本 v3.0。</p><span id="more"></span><blockquote><p>原文源自 <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">Ray Tracing: The Next Week</a></p><p>本文转载自 <a target="_blank" rel="noopener" href="https://matrix4f.com/Graphic/Ray-tracing-the-next-week/">Ray tracing the next week 中文翻译</a>的翻译，如果您愿意帮助译者改进这个翻译，请直接<strong>发送邮件</strong>到 <a href="mailto:zgxmy@126.com">zgxmy@126.com</a>, 万分感激</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>In Ray Tracing in One Weekend, you built a simple brute force path tracer. In this installment we’ll add textures, volumes (like fog), rectangles, instances, lights, and support for lots of objects using a BVH. When done, you’ll have a “real” ray tracer.</p></blockquote><p>在<a target="_blank" rel="noopener" href="https://raytracing.github.io/books">Ray Tracing in One Weekend</a>中, 你实现了一个暴力的光线路径追踪器。在本部分中, 我们将加入纹理, 体积体(例如烟雾), 矩形, 实例, 光源, 并用BVH来包裹我们的物体。当你完成这些后, 你将拥有一个“真正的”光线追踪器。</p><blockquote><p>A heuristic in ray tracing that many people—including me—believe, is that most optimizations complicate the code without delivering much speedup. What I will do in this mini-book is go with the simplest approach in each design decision I make. Check <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> for readings and references to a more sophisticated approach. However, I strongly encourage you to do no premature optimization; if it doesn’t show up high in the execution time profile, it doesn’t need optimization until all the features are supported!</p></blockquote><p>在光线追踪方面, 具有启发性的一点是, 许多人(包括作者本人)相信大多数用来优化的代码只会让程序更复杂, 而并不会提升太多的运行速度。我在这本迷你书中将采取最简单直接的方式来实现代码。如果你想看复杂的优化版本, 请点击<a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">这里</a>。并且我在这里建议读者不要自己过早的去优化。如果说程序在执行时间上来看并没有太大的变化, 那么它就并不需要你去优化。直到最后所有的功能都被实现前, 你可以一直就这样往里面添加代码。</p><blockquote><p>The two hardest parts of this book are the BVH and the Perlin textures. This is why the title suggests you take a week rather than a weekend for this endeavor. But you can save those for last if you want a weekend project. Order is not very important for the concepts presented in this book, and without BVH and Perlin texture you will still get a Cornell Box!</p></blockquote><p>本书中最难的两部分是BVH和柏林噪声贴图。所以我将标题取名为“一周”而不是像上一本一样的“一个周末”。如果你想一个周末搞定这本书, 那么你可以把这两个部分留到最后。这本书中提到的概念, 各章节的顺序并不是很重要, 没有BVH和柏林噪声贴图你仍然能渲染出属于自己漂亮的Cornell Box!</p><h3 id="动态模糊"><a href="#动态模糊" class="headerlink" title="动态模糊"></a>动态模糊</h3><blockquote><p>When you decided to ray trace, you decided that visual quality was worth more than run-time. In your fuzzy reflection and defocus blur you needed multiple samples per pixel. Once you have taken a step down that road, the good news is that almost all effects can be brute-forced. Motion blur is certainly one of those. In a real camera, the shutter opens and stays open for a time interval, and the camera and objects may move during that time. Its really an average of what the camera sees over that interval that we want.</p><p>We can get a random estimate by sending each ray at some random time when the shutter is open. As long as the objects are where they should be at that time, we can get the right average answer with a ray that is at exactly a single time. This is fundamentally why random ray tracing tends to be simple.</p></blockquote><p>当你在做光线追踪时, 想要更好的出图质量就意味着更多的程序运行时间。例如上一本书中的反射部分和镜头散焦模糊中, 你需要对每个像素进行多重采样。当你决定在这条路上走得更深一些时, 好消息来了: 几乎所有的特效都能这样暴力实现。动态模糊也是属于能这样实现的特效之一。想象一个真实世界的摄像机, 在快门打开的时间间隔中, 摄像机和物体都有可能移动。那拍出来的结果肯定是这个运动过程每一帧的平均值, 或者说, 一团糊了。我们可以用随机的方法在不同时间发射多条射线来模拟快门的打开。只要物体在那个时间处于其正确的位置, 那么我们就能得出这条光线在那个时间点的精确平均值。这就是为什么随机光追看上去很简单的原因。</p><h4 id="Introduction-of-SpaceTime-Ray-Tracing"><a href="#Introduction-of-SpaceTime-Ray-Tracing" class="headerlink" title="Introduction of SpaceTime Ray Tracing"></a>Introduction of SpaceTime Ray Tracing</h4><blockquote><p>The basic idea is to generate rays at random times while the shutter is open and intersect the model at that one time. The way it is usually done is to have the camera move and the objects move, but have each ray exist at exactly one time. This way the “engine” of the ray tracer can just make sure the objects are where they need to be for the ray, and the intersection guts don’t change much.</p></blockquote><p>一个基础的思路是, 在快门打开时, 随着时间变化随机生成光线, 并同时发出射线与模型相交。一般来说我们让摄像机和物体同时运动, 并让每一条射线都拥有自己存在的一个时间点。这样光线追踪器的“引擎”就能确定, 对于指定的某条光线来说, 在该时刻, 物体到底在哪儿。求射线与球相交的部分写法和之前并没有太多区别。</p><blockquote><p>For this we will first need to have a ray store the time it exists at:</p></blockquote><p>为了实现刚刚的思路, 我们首先在 <code>ray.h</code> 中要让每条光线都能储存自己所在的时刻, 就像这样:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class ray {</span><br><span class="line">public:</span><br><span class="line">    ray() {}</span><br><span class="line"><span class="addition">+   ray(const vec3&amp; origin, const vec3&amp; direction, double time = 0)</span></span><br><span class="line"><span class="addition">+       : orig(origin), dir(direction), tm(time){</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    vec3 origin() const { return orig; }</span><br><span class="line">    vec3 direction() const { return dir; }</span><br><span class="line"><span class="addition">+   double time() const { return tm; }</span></span><br><span class="line"></span><br><span class="line">    vec3 at(double t) const {</span><br><span class="line">        return orig + t * dir;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vec3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line"><span class="addition">+   double tm;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Updating-the-Camera-to-Simulate-Motion-Blur"><a href="#Updating-the-Camera-to-Simulate-Motion-Blur" class="headerlink" title="Updating the Camera to Simulate Motion Blur"></a>Updating the Camera to Simulate Motion Blur</h4><blockquote><p>Now we need to modify the camera to generate rays at a random time between <code>time1</code> and <code>time2</code>. Should the camera keep track of <code>time1</code> and <code>time2</code> or should that be up to the user of camera when a ray is created? When in doubt, I like to make constructors complicated if it makes calls simple, so I will make the camera keep track, but that’s a personal preference. Not many changes are needed to camera because for now it is not allowed to move; it just sends out rays over a time period.</p></blockquote><p>现在我们需要让摄像机在<code>time1</code>到<code>time2</code>的时间段中随机生成射线。光线的生成时刻是让camera类自己来运算追踪呢, 还是说可以让用户来自行指定光线在哪个时刻生成比较好呢? 当出现这样的疑问时, 我喜欢让构造函数更加复杂,同时调用起来会更加简单。所以我让camera类来储存着两个变量。但这只是我的个人喜好。camera类并不需要太多修改, 因为现在它不会动, 只会在一个时间段内发出射线。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class camera {</span><br><span class="line">public:</span><br><span class="line">    camera() {</span><br><span class="line">        lower_left_corner = vec3(-2.0,-1.0,-1.0);</span><br><span class="line">        horizontal = vec3(4.0,0.0,0.0);</span><br><span class="line">        vertical = vec3(0.0,2.0,0.0);</span><br><span class="line">        origin = vec3(0.0,0.0,0.0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    camera(vec3 lookfrom, vec3 lookat, vec3 vup,</span><br><span class="line"><span class="addition">+           double vfov, double aspect, double aperture, double focus_dist, double t0 = 0, double t1 = 0) { // top to bottom, in degress</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        lens_radius = aperture / 2;</span><br><span class="line"></span><br><span class="line">        auto theta = degree_to_radians(vfov);</span><br><span class="line">        auto half_height = tan(theta / 2);</span><br><span class="line">        auto half_width = aspect * half_height;</span><br><span class="line"><span class="addition">+       time0 = t0;</span></span><br><span class="line"><span class="addition">+       time1 = t1;</span></span><br><span class="line">        w = unit_vector(lookfrom - lookat);</span><br><span class="line">        u = unit_vector(cross(vup, w));</span><br><span class="line">        v = cross(w, u);</span><br><span class="line"></span><br><span class="line">        lower_left_corner = origin</span><br><span class="line">                          - half_width * focus_dist * u</span><br><span class="line">                          - half_height * focus_dist * v</span><br><span class="line">                          - focus_dist * w;</span><br><span class="line"></span><br><span class="line">        horizontal = 2 * half_width * focus_dist * u;</span><br><span class="line">        vertical = 2 * half_height * focus_dist * v;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ray get_ray(double s, double t) {</span><br><span class="line">        vec3 rd = lens_radius * random_in_unit_disk();</span><br><span class="line">        vec3 offset = u * rd.x() + v * rd.y();</span><br><span class="line"></span><br><span class="line">        return ray(</span><br><span class="line">                origin + offset,</span><br><span class="line">                lower_left_corner + s * horizontal + t * vertical - origin - offset,</span><br><span class="line"><span class="addition">+               random_double(time0, time1)</span></span><br><span class="line">                );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vec3 origin;</span><br><span class="line">    vec3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    double lens_radius;</span><br><span class="line"><span class="addition">+   double time0, time1;  // shutter open/close times</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Adding-Moving-Spheres"><a href="#Adding-Moving-Spheres" class="headerlink" title="Adding Moving Spheres"></a>Adding Moving Spheres</h4><blockquote><p>We also need a moving object. I’ll create a sphere class that has its center move linearly from <code>center0</code> at <code>time0</code> to <code>center1</code> at <code>time1</code>. Outside that time interval it continues on, so those times need not match up with the camera aperture open and close.</p></blockquote><p>我们还需要一个运动中的物体。我建立了一个新的sphere类, 让它的球心在<code>time0</code>到<code>time1</code>的时间段内从<code>center0</code>线性运动到<code>center1</code>。超出这个时间段, 这个球心依然在动, <em>【译注：就是说在做线性插值的时候t可以大于1.0 也可以小于0】</em>, 所以这里的两个时间变量和摄像机快门的开关时刻并不需要一一对应。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">moving_sphere</span> : <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">moving_sphere</span>() {}</span><br><span class="line">    <span class="built_in">moving_sphere</span>(</span><br><span class="line">            vec3 cen0, vec3 cen1, <span class="type">double</span> t0, <span class="type">double</span> t1, <span class="type">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">            : <span class="built_in">center0</span>(cen0), <span class="built_in">center1</span>(cen1), <span class="built_in">time0</span>(t0), <span class="built_in">time1</span>(t1), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 center0, center1;</span><br><span class="line">    <span class="type">double</span> time0, time1;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">moving_sphere::center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> center0 + ((time - time0) / (time1 - time0)) * (center1 - center0);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>An alternative to making a new moving sphere class is to just make them all move, while stationary spheres have the same begin and end position. I’m on the fence about that trade-off between fewer classes and more efficient stationary spheres, so let your design taste guide you.</p><p>The <code>moving_sphere::hit()</code> function is almost identical to the <code>sphere::hit()</code> function: <code>center</code> just needs to become a function <code>center(time)</code>:</p></blockquote><p>另外一种让球随着时间动起来的方法是, 取代先前新建一个动态球类的做法, 只留一个球类, 让所有的球都动起来, 只是那些静止的球起点与终点位置相同。我在第一种方案和第二种方案间反复很跳。所以就请你们自己根据自己的喜好来选择吧。球与光线求交的代码几乎没有改变: 只要把<code>center</code>改成一个插值函数<code>center(time)</code>就行了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">moving_sphere::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>{</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - <span class="built_in">center</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc,r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - <span class="built_in">sqrt</span>(discriminant)) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min){</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">            vec3 outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">            rec.<span class="built_in">set_face_normal</span>(r,outward_normal);</span><br><span class="line">            rec.mat_ptr = mat_ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        temp = (-half_b + root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min){</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">            vec3 outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">            rec.<span class="built_in">set_face_normal</span>(r,outward_normal);</span><br><span class="line">            rec.mat_ptr = mat_ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Tracking-the-Time-of-Ray-Intersection"><a href="#Tracking-the-Time-of-Ray-Intersection" class="headerlink" title="Tracking the Time of Ray Intersection"></a>Tracking the Time of Ray Intersection</h4><blockquote><p>Now that rays have a time property, we need to update the <code>material::scatter()</code> methods to account for the time of intersection:</p></blockquote><p>请确保你的材质在运算光线散射时, 散射光线与入射光线所存在的时间点相同。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class lambertian : public material {</span><br><span class="line">public:</span><br><span class="line">    lambertian(const vec3&amp; a) : albedo(a) {}</span><br><span class="line"></span><br><span class="line">    virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span><br><span class="line">    ) const {</span><br><span class="line">        vec3 scatter_direction = rec.normal + random_unit_vector();</span><br><span class="line"><span class="addition">+       scattered = ray(rec.p, scatter_direction, r_in.time());</span></span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class metal : public material {</span><br><span class="line">		......</span><br><span class="line">    virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span><br><span class="line">    ) const {</span><br><span class="line">        vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);</span><br><span class="line"><span class="addition">+       scattered = ray(rec.p, reflected + fuzz * random_in_sphere(), r_in.time());</span></span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        return (dot(scattered.direction(), rec.normal) &gt; 0);</span><br><span class="line">    }</span><br><span class="line">		......</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class dielectric : public material {</span><br><span class="line">		......</span><br><span class="line">    virtual bool scatter (</span><br><span class="line">    		......</span><br><span class="line"><span class="addition">+       scattered = ray(rec.p, refracted, r_in.time());</span></span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Putting-Everything-Together"><a href="#Putting-Everything-Together" class="headerlink" title="Putting Everything Together"></a>Putting Everything Together</h4><blockquote><p>The code below takes the example diffuse spheres from the scene at the end of the last book, and makes them move during the image render. (Think of a camera with shutter opening at time 0 and closing at time 1.) Each sphere moves from its center <strong>𝐂</strong> at time 𝑡=0 to <strong>𝐂</strong>+(0,𝑟/2,0) at time 𝑡=1, where 𝑟 is a random number in [0,1):</p></blockquote><p>下面的代码是在上本书结尾处最终场景的例子上加以改动, 使其中漫反射材质的球动起来。(想象一下摄像机的快门在 <code>time0</code> 时打开, 在 <code>time1</code> 时关闭)每个球的中心在 <code>time0</code> 到 <code>time1</code> 的时间段内从原始位置 $C$ 线性运动到 $C+(0,r/2,0)$, 其中 $r$ 是[0,1)之间的随机数。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list random_scene() {</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(</span><br><span class="line">            vec3(0,-1000,0), 1000, make_shared&lt;lambertian&gt;(vec3(0.5, 0.5, 0.5))));</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    for (int a = -10; a &lt; 10; a++) {</span><br><span class="line">        for (int b = -10; b &lt; 10; b++) {</span><br><span class="line">            auto choose_mat = random_double();</span><br><span class="line">            vec3 center(a + 0.9*random_double(), 0.2, b + 0.9*random_double());</span><br><span class="line">            if ((center - vec3(4, 0.2, 0)).length() &gt; 0.9) {</span><br><span class="line">                if (choose_mat &lt; 0.8) {</span><br><span class="line">                    // diffuse</span><br><span class="line">                    auto albedo = vec3::random() * vec3::random();</span><br><span class="line"><span class="addition">+                   world.add(make_shared&lt;moving_sphere&gt;(</span></span><br><span class="line"><span class="addition">+                           center, center + vec3(0, random_double(0, 0.5), 0), 0.0, 1.0, 0.2,</span></span><br><span class="line"><span class="addition">+                           make_shared&lt;lambertian&gt;(albedo)));</span></span><br><span class="line"></span><br><span class="line">                } else if (choose_mat &lt; 0.95) {</span><br><span class="line">                    // metal</span><br><span class="line">                    auto albedo = vec3::random(0.5, 1);</span><br><span class="line">                    auto fuzz = random_double(0, 0.5);</span><br><span class="line">                    world.add(</span><br><span class="line">                            make_shared&lt;sphere&gt;(center, 0.2, make_shared&lt;metal&gt;(albedo, fuzz)));</span><br><span class="line">                } else {</span><br><span class="line">                    // glass</span><br><span class="line">                    world.add(make_shared&lt;sphere&gt;(center, 0.2, make_shared&lt;dielectric&gt;(1.5)));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(vec3(0, 1, 0), 1.0, make_shared&lt;dielectric&gt;(1.5)));</span><br><span class="line">    world.add(</span><br><span class="line">            make_shared&lt;sphere&gt;(vec3(-4, 1, 0), 1.0, make_shared&lt;lambertian&gt;(vec3(0.4, 0.2, 0.1))));</span><br><span class="line">    world.add(</span><br><span class="line">            make_shared&lt;sphere&gt;(vec3(4, 1, 0), 1.0, make_shared&lt;metal&gt;(vec3(0.7, 0.6, 0.5), 0.0)));</span><br><span class="line"></span><br><span class="line">    return world;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并使用以下的摄像机参数:</p><p>你将会得到类似下面的结果:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.01-bouncing-spheres.png"></p><h3 id="层次包围盒"><a href="#层次包围盒" class="headerlink" title="层次包围盒"></a>层次包围盒</h3><blockquote><p>This part is by far the most difficult and involved part of the ray tracer we are working on. I am sticking it in this chapter so the code can run faster, and because it refactors <code>hittable</code> a little, and when I add rectangles and boxes we won’t have to go back and refactor them.</p></blockquote><p>这部分是书中最难,也是与我们正在写的光线追踪器关联最深的一部分。我把这部分放在这么前面, 是因为它改写了<code>hittable</code>的部分代码, 程序运行起来更加的快了。而且当我们后面添加三角形和箱子类的时候, 我们也不必回来改写<code>hittable</code>了。</p><blockquote><p>The ray-object intersection is the main time-bottleneck in a ray tracer, and the time is linear with the number of objects. But it’s a repeated search on the same model, so we ought to be able to make it a logarithmic search in the spirit of binary search. Because we are sending millions to billions of rays on the same model, we can do an analog of sorting the model, and then each ray intersection can be a sublinear search. The two most common families of sorting are to 1) divide the space, and 2) divide the objects. The latter is usually much easier to code up and just as fast to run for most models.</p></blockquote><p>光线的求交运算一直是光线追踪器的主要时间瓶颈, 并且运行时间与场景中的物体数量线性相关。使用遍历反复查找同一个模型会有许多多余的计算, 所以我们应该用二叉搜索的方法来加速查找。我们对每个模型都射出了成千上万的射线, 我们可以对模型的排序进行模拟, 每一次光线求交都是一个亚线性(subliner)的查找 <em>【译注:亚线性指参数的指数小于1, 即不到线性, 平衡查找树的时间复杂度为O(log2(n))】</em>。最常见的两种排序方法是 1) 按空间分割 <em>【译注: 如KD树、八叉树】</em> 2) 按物体分割。后者一般来说实现起来更简单并且对大多数模型来说运行速度都不错。</p><h4 id="The-Key-Idea"><a href="#The-Key-Idea" class="headerlink" title="The Key Idea"></a>The Key Idea</h4><blockquote><p>The key idea of a bounding volume over a set of primitives is to find a volume that fully encloses (bounds) all the objects. For example, suppose you computed a bounding sphere of 10 objects. Any ray that misses the bounding sphere definitely misses all ten objects. If the ray hits the bounding sphere, then it might hit one of the ten objects. So the bounding code is always of the form:</p></blockquote><p>包围盒的核心思想是去找到一个能包围所有物体的盒子。举例来说, 假设你计算了一个包围10个物体的大球, 那么任何射不到这个大球的射线, 它都射不到球里面的那10个物体。反之亦然, 如果射线碰到大球了, 那么它和里面那10个物体都有可能发生关系。所以包围盒的代码看上去总是这样的:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ray hits bounding object)</span><br><span class="line">    <span class="keyword">return</span> whether ray hits bounded objects</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>A key thing is we are dividing objects into subsets. We are not dividing the screen or the volume. Any object is in just one bounding volume, but bounding volumes can overlap.</p></blockquote><p>记住, 我们的核心思想是把很多很多物体分割为子集。我们并不划分屏幕或者是空间。每个物体都只在一个包围盒里面, 并且这些包围盒还可以重叠。</p><h4 id="Hierarchies-of-Bounding-Volumes"><a href="#Hierarchies-of-Bounding-Volumes" class="headerlink" title="Hierarchies of Bounding Volumes"></a>Hierarchies of Bounding Volumes</h4><blockquote><p>To make things sub-linear we need to make the bounding volumes hierarchical. For example, if we divided a set of objects into two groups, red and blue, and used rectangular bounding volumes, we’d have:</p></blockquote><p>为了做到每次光线求交都是一个亚线性的查找, 我们需要用包围盒构建出层级(hierarchical)。举个例子, 如果我们把一堆物体分成两队, 红队和蓝队, 并使用方方正正的包围盒来包围他们, 你将看到如下场景:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.01-bvol-hierarchy.jpg"></p><blockquote><p>Note that the blue and red bounding volumes are contained in the purple one, but they might overlap, and they are not ordered — they are just both inside. So the tree shown on the right has no concept of ordering in the left and right children; they are simply inside. The code would be:</p></blockquote><p>注意蓝盒子和红盒子现在都在紫盒子里面, 他们可以重合, 并且无序 —— 他们都平平等等的躺在紫盒子的肚子里。所以图片里右边的那颗树并没有什么左子树右子树的概念 <em>【译注: 作者这里只是想强调他们属于同一层, 地位平等。等待会实际写这个二叉查找树的时候还是会有左子树右子树的】</em>, 这两个分支是同级的。代码看起来是这样的:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hits purple)</span><br><span class="line">    hit0 = hits blue enclosed objects</span><br><span class="line">    hit1 = hits red enclosed objects</span><br><span class="line">    <span class="keyword">if</span>(hit0 <span class="keyword">or</span> hit1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">and</span> info of closer hit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Axis-Aligned-Bounding-Boxes-AABBs"><a href="#Axis-Aligned-Bounding-Boxes-AABBs" class="headerlink" title="Axis-Aligned Bounding Boxes (AABBs)"></a>Axis-Aligned Bounding Boxes (AABBs)</h4><blockquote><p>To get that all to work we need a way to make good divisions, rather than bad ones, and a way to intersect a ray with a bounding volume. A ray bounding volume intersection needs to be fast, and bounding volumes need to be pretty compact. In practice for most models, axis-aligned boxes work better than the alternatives, but this design choice is always something to keep in mind if you encounter unusual types of models.</p></blockquote><p>为了能使上述代码良好的跑起来, 我们需要好好规划一下怎么分堆。还得想想怎么去检测光线和包围盒相交。求交计算一定要高效, 并且包围盒要尽量密集。很对大多数模型来说, 轴对齐的包围盒比其他种类的包围盒效果更好。但是当你遇到更复杂的模型种类时, 你就先别想着用这种方法了。</p><blockquote><p>From now on we will call axis-aligned bounding rectangular parallelepiped (really, that is what they need to be called if precise) axis-aligned bounding boxes, or AABBs. Any method you want to use to intersect a ray with an AABB is fine. And all we need to know is whether or not we hit it; we don’t need hit points or normals or any of that stuff that we need for an object we want to display.</p></blockquote><p>从现在开始, 我们会把轴对齐的包围盒叫成矩形平行管道(讲真的, 这才是他本来该有的精确描述), 或者还是叫他 <strong>AABB</strong>吧 。你想用啥方法去算光线和AABB是否相交都行。我们现在只要能判断我们能不能射中这个AABB就行了。和击中那些会在屏幕上显示出来的物体时不同, 射线与AABB求交并不需要去获取那些法向啊交点啊这些东西, AABB不需要在屏幕上渲染出来。</p><blockquote><p>Most people use the “slab” method. This is based on the observation that an n-dimensional AABB is just the intersection of n axis-aligned intervals, often called “slabs” An interval is just the points between two endpoints, <em>e.g.</em>, 𝑥 such that 3&lt;𝑥&lt;5, or more succinctly 𝑥x in (3,5). In 2D, two intervals overlapping makes a 2D AABB (a rectangle):</p></blockquote><p>大多数人采用一个叫堆叠法(slab)的方法。显然一个n维的AABB盒是由n个平行线所截的区间的重叠拼出来的区域 <em>【译注: 这里看图就行了, 别看字】</em>, 我们管这个叫”slab”。一个区间就是两个端点间的距离。比如对于$x$, 3&lt;x&lt;5, 或者更加简洁的 $x$ 属于 (3,5) 。在二维的情况下, 两段区间重叠的部分就是一个二维的AABB(一个矩形):</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.02-2d-aabb.jpg"></p><blockquote><p>For a ray to hit one interval we first need to figure out whether the ray hits the boundaries. For example, again in 2D, this is the ray parameters 𝑡0 and 𝑡1. (If the ray is parallel to the plane those will be undefined.)</p></blockquote><p>对于检测射线是否射入一段区间来说, 我们首先要看看射线有没有射入这个区间的边界。还是拿二维来举例子, 这是光线变量t0, t1。(在光线和目标平面平行的情况下, 因为并没有交点, 这两个变量将未定义)</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.03-ray-slab.jpg"></p><blockquote><p>In 3D, those boundaries are planes. The equations for the planes are $𝑥=𝑥_0$​, and $𝑥=𝑥_1$. Where does the ray hit that plane? Recall that the ray can be thought of as just a function that given a 𝑡t returns a location <strong>𝐏</strong>(𝑡):</p></blockquote><p>在三维的情况下, 这些射入的边界不再是一条线, 而是一个平面。 这两个边界平面的方程分别是 $x=x0$ 和 $x=x1$​。那么怎样来计算射线和平面相交呢? 让我们回想一下上一本书中我们给出的, 点p关于参数t的方程：</p><p>$P(t) = A + tb$</p><p>这个等式用在三个坐标轴上都行, 比如：</p><p>$x(t)=A_x+t_0⋅B_x$​</p><p>然后我们把这个方程和平面方程 $x=x_0$ 联立, 使得存在一个值 $t$, 满足下面方程:</p><p>$x_0=A_x+t_0⋅B_x$</p><p>我们稍稍变下形:</p><p>$t_0=\frac{x0−A_x}{B_x}$​</p><p>同理, 对于$x_1$的那个平面来说:</p><p>$t_1=\frac{x_1−A_x}{B_x}$</p><blockquote><p>The key observation to turn that 1D math into a hit test is that for a hit, the 𝑡t-intervals need to overlap. For example, in 2D the green and blue overlapping only happens if there is a hit:</p></blockquote><p>把这个1D的等式运用到我们AABB求交运算的关键是, 你需要把n个维度的t区间重叠在一起。举例来说, 在2D情况下, 绿色的t区间和蓝色的t区间发生重叠的情况如下:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.04-ray-slab-interval.jpg"></p><p><em>【译注: 这张图挺好的, 上面的那条射线, 蓝色与绿色部分没有重叠, 很自然的就没有穿过这个AABB矩形, 下面那条射线发生了重叠, 说明射线同时传过了蓝色区域和绿色区域, 即穿过了AABB矩形。注意对每一个维度来说, 这里我们解出来的t0, t1都表示直线上一个固定的点的位置, 所以我们可以自然地按照维度拆分计算, 然后在通过t这个统一的标识进行求交运算】</em></p><h4 id="Ray-Intersection-with-an-AABB"><a href="#Ray-Intersection-with-an-AABB" class="headerlink" title="Ray Intersection with an AABB"></a>Ray Intersection with an AABB</h4><blockquote><p>The following pseudocode determines whether the 𝑡t intervals in the slab overlap:</p></blockquote><p>用代码表示”区间们是否重叠”看上去会是这样:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">compute</span>(tx0,tx1)</span><br><span class="line"><span class="built_in">compute</span>(ty0,ty1)</span><br><span class="line"><span class="keyword">return</span> overlap?( (tx0, tx1), (ty0, ty1))</span><br></pre></td></tr></tbody></table></figure><blockquote><p>That is awesomely simple, and the fact that the 3D version also works is why people love the slab method:</p></blockquote><p>这看上去真是简洁! 而且放到3D的情况下依旧适用, 所以大家都爱堆叠法:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">compute</span>(tx0, tx1)</span><br><span class="line"><span class="built_in">compute</span>(ty0, ty1)</span><br><span class="line"><span class="built_in">compute</span>(tz0, tz1)</span><br><span class="line"><span class="keyword">return</span> overlap?( (tx0, tx1), (ty0, ty1), (tz0, tz1))</span><br></pre></td></tr></tbody></table></figure><blockquote><p>There are some caveats that make this less pretty than it first appears. First, suppose the ray is travelling in the negative 𝑥 direction. The interval $(𝑡_{𝑥0},𝑡_{𝑥1})$ as computed above might be reversed, <em>e.g.</em> something like (7,3). Second, the divide in there could give us infinities. And if the ray origin is on one of the slab boundaries, we can get a <code>NaN</code>. There are many ways these issues are dealt with in various ray tracers’ AABB. (There are also vectorization issues like SIMD which we will not discuss here. Ingo Wald’s papers are a great place to start if you want to go the extra mile in vectorization for speed.) For our purposes, this is unlikely to be a major bottleneck as long as we make it reasonably fast, so let’s go for simplest, which is often fastest anyway! First let’s look at computing the intervals:</p></blockquote><p>当然我们还要对它做一些限制, 这会使它看上去没有一开始那么简洁。首先, 假设射线从xx轴负方向射入, 这样前面<code>compute</code>的这个区间$(t_{x0},t_{x1})$​就会反过来了, e.g. (7,3)。第二, 除数为零时我们会得到无穷, 如果射线的原点就在这个堆叠的边界上, 我们就会得到 <code>NaN</code>。不同的光线追踪器的AABB部分解决上述问题的方法多种多样。(这里还有一些矢量平行加速的方面比如SIMD, 我们本书中不讨论。如果你想走得更远些, 使用这种方法加速的话, <a target="_blank" rel="noopener" href="http://www.sci.utah.edu/~wald/PhD/wald_phd.pdf">Ingo Wald的论文</a>将是个不错的选择)。对我们来说, 这并不是一个运算的主要瓶颈。所以直接让我们用最快捷最简单的方式搞起来吧! 首先我们来看看需要计算的这些区间。</p><p>$t_{x0} = \frac{x_0 - A_x}{B_x}$</p><p>$t_{x1}=\frac{x_1-A_x}{b_x}$</p><blockquote><p>One troublesome thing is that perfectly valid rays will have $𝑏<em>𝑥=0$, causing division by zero. Some of those rays are inside the slab, and some are not. Also, the zero will have a ± sign under IEEE floating point. The good news for $𝑏_𝑥=0$ is that $𝑡</em>{𝑥0}$ and $𝑡_{𝑥1}$ will both be +∞ or both be -∞ if not between $𝑥_0$ and $𝑥_1$. So, using min and max should get us the right answers:</p></blockquote><p>我们的麻烦是一些射线恰好 $b_x=0$, 这样就会有除数为0的错误。一些光线在堆叠的里面, 一些不在。浮点0在 IEEE 工程标准下是有正负号的。好消息是, 在$x_0$到$x_1$区间内, $t_{x0}$与$t_{x1}$要么同为∞要么同为−∞。所以使用 min 与 max 函数就能得到正确的结果:</p><p>$t_{x0}=\min{(\frac{x_0-A_x}{B_x}, \frac{x_1- A_x}{B_x})}$</p><p>$t_{x1} = \max{(\frac{x_0-A_x}{B_x}, \frac{x_1-A_x}{B_x})}$</p><blockquote><p>The remaining troublesome case if we do that is if $𝑏_𝑥=0$​ and either $𝑥_0−𝐴_𝑥=0$​ or $𝑥_1−𝐴_𝑥=0$ so we get a <code>NaN</code>. In that case we can probably accept either hit or no hit answer, but we’ll revisit that later.</p></blockquote><p>现在只剩下分母 $B_x=0$​​ 并且 $x_0−A_x=0$​​ 和$x_1−A_x=0$​​ 这两个分子之一为零的特殊情况了。这样我们会得到一个<code>NaN</code><em>【译注: 0/0 = NaN】</em>。这种情况我们认为他射中了或者没射中这个区域都行。我们过会儿再来解决这个问题。</p><blockquote><p>Now, let’s look at that overlap function. Suppose we can assume the intervals are not reversed (so the first value is less than the second value in the interval) and we want to return true in that case. The boolean overlap that also computes the overlap interval (𝑓,𝐹) of intervals (𝑑,𝐷) and (𝑒,𝐸) would be:</p></blockquote><p>现在让我们先来看看<code>overlap</code>函数, 假设我们能保证区间没有被倒过来(即第一个值比第二个值小), 在这种情况下我们 <code>return true</code>, 那么一个计算 (d,D) 和 (e,E) 的重叠区间 (f,F) 的函数看上去是这样的:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">overlap</span><span class="params">(d, D, e, E, f, F)</span></span></span><br><span class="line"><span class="function">    f </span>= <span class="built_in">max</span>(d, e)</span><br><span class="line">    F = <span class="built_in">min</span>(D, E)</span><br><span class="line">    <span class="built_in">return</span> (f &lt; F)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>If there are any <code>NaN</code>s running around there, the compare will return false so we need to be sure our bounding boxes have a little padding if we care about grazing cases (and we probably should because in a ray tracer all cases come up eventually). With all three dimensions in a loop, and passing in the interval $[𝑡_{𝑚𝑖𝑛}, 𝑡_{𝑚𝑎𝑥}]$, we get:</p></blockquote><p>如果这里出现了任何的 <code>NaN</code>, 比较结果都会 return false, 所有如果考虑到那些擦边的情况, 我们要保证我们的包围盒有一些内间距(而且我们也许理应这么做, 因为在光线追踪中所有的情况最终都会发生)。把三个维度都写在一个循环中并传入时间间隔 $[𝑡_{𝑚𝑖𝑛}, 𝑡_{𝑚𝑎𝑥}]$ 我们得到:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">aabb</span>() {}</span><br><span class="line">        <span class="built_in">aabb</span>(<span class="type">const</span> vec3&amp; a, <span class="type">const</span> vec3&amp; b) { _min = a; _max = b;}</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">min</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> _min; }</span><br><span class="line">        <span class="function">vec3 <span class="title">max</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> _max; }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a++) {</span><br><span class="line">                <span class="keyword">auto</span> t0 = <span class="built_in">ffmin</span>((_min[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a],</span><br><span class="line">                                (_max[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a]);</span><br><span class="line">                <span class="keyword">auto</span> t1 = <span class="built_in">ffmax</span>((_min[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a],</span><br><span class="line">                                (_max[a] - r.<span class="built_in">origin</span>()[a]) / r.<span class="built_in">direction</span>()[a]);</span><br><span class="line">                tmin = <span class="built_in">ffmax</span>(t0, tmin);</span><br><span class="line">                tmax = <span class="built_in">ffmin</span>(t1, tmax);</span><br><span class="line">                <span class="keyword">if</span> (tmax &lt;= tmin)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        vec3 _min;</span><br><span class="line">        vec3 _max;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注意我们把<code>cmath</code>内置的<code>fmax()</code>函数换成了我们自己的<code>ffmax()</code>(在rtweekend中定义)。这样会更快一点， 因为我们自己写的函数并不需要考虑到 <code>NaN</code> 和其他的异常情况。</p><h4 id="An-Optimized-AABB-Hit-Method"><a href="#An-Optimized-AABB-Hit-Method" class="headerlink" title="An Optimized AABB Hit Method"></a>An Optimized AABB Hit Method</h4><blockquote><p>In reviewing this intersection method, Andrew Kensler at Pixar tried some experiments and proposed the following version of the code. It works extremely well on many compilers, and I have adopted it as my go-to method:</p></blockquote><p>来自皮克斯的Andrew Kensler在阅读我的这个求交方法时做了一些试验, 并提出了一个自己的版本。这个版本在大多数编译器上都运行的非常好。所以我采用了这个方法作为我们接下来要使用的方法。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">aabb::hit</span><span class="params">(<span class="type">const</span> ray &amp;r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">        <span class="keyword">auto</span> invD = <span class="number">1.0f</span> / r.<span class="built_in">direction</span>()[i];</span><br><span class="line">        <span class="keyword">auto</span> t0 = (<span class="built_in">min</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">auto</span> t1 = (<span class="built_in">max</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">        tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">        tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">        <span class="keyword">if</span>(tmax &lt;= tmin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Constructing-Bounding-Boxes-for-Hittables"><a href="#Constructing-Bounding-Boxes-for-Hittables" class="headerlink" title="Constructing Bounding Boxes for Hittables"></a>Constructing Bounding Boxes for Hittables</h4><blockquote><p>We now need to add a function to compute the bounding boxes of all the hittables. Then we will make a hierarchy of boxes over all the primitives, and the individual primitives—like spheres—will live at the leaves. That function returns a bool because not all primitives have bounding boxes (<em>e.g.</em>, infinite planes). In addition, moving objects will have a bounding box that encloses the object for the entire time interval [<code>time0</code>,<code>time1</code>].</p></blockquote><p>现在我们需要加入一个函数来计算这些包裹着hittable类的包围盒。然后我们将做一个层次树。在这个层次树中, 所有的图元, 比如球体, 都会在树的最底端(叶子节点)。这个函数返回值是一个 bool 因为不是所有的图元都有包围盒的(e.g 无限延伸的平面)。另外, 物体会动, 所以他还要接收<code>time1</code>和<code>time2</code>, 包围盒会把在这个时间区间内运动的物体完整的包起来。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "ray.h"</span><br><span class="line"><span class="addition">+#include "aabb.h"</span></span><br><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">class hittable {</span><br><span class="line">public:</span><br><span class="line">    virtual bool hit(const ray&amp; r,double  t_min,double  t_max,hit_record&amp; rec) const = 0;</span><br><span class="line"><span class="addition">+   virtual bool bounding_box(double t0, double t1, aabb&amp; output_box) const = 0;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Creating-Bounding-Boxes-of-Lists-of-Objects"><a href="#Creating-Bounding-Boxes-of-Lists-of-Objects" class="headerlink" title="Creating Bounding Boxes of Lists of Objects"></a>Creating Bounding Boxes of Lists of Objects</h4><blockquote><p>For a sphere, that <code>bounding_box</code> function is easy:</p></blockquote><p>对一个<code>sphere</code>类来说, 求包围盒真的太简单了:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"aabb.h"</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        center - <span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + <span class="built_in">vec3</span>(radius, radius, radius));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>For <code>moving sphere</code>, we can take the box of the sphere at $𝑡_0$​, and the box of the sphere at $𝑡_1$​, and compute the box of those two boxes:</p></blockquote><p>对于<code>moving_sphere</code>, 我们先求球体在 $t_0$ 时刻的包围盒, 再求球体在 $t_1$ 时刻的包围盒, 然后再计算这两个盒子的包围盒:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"aabb.h"</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">moving_sphere::bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="function">aabb <span class="title">box0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(t0) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(t0) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="function">aabb <span class="title">box1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(t1) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(t1) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    output_box = <span class="built_in">surrounding_box</span>(box0, box1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>For lists you can store the bounding box at construction, or compute it on the fly. I like doing it the fly because it is only usually called at BVH construction.</p></blockquote><p>对于<code>hittable_list</code>来说, 我们可以在构造函数中就进行包围盒的运算, 或者在程序运行时计算。我喜欢在运行时计算, 因为这些包围盒的计算一般只有在BVH构造时才会被调用。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"aabb.h"</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb &amp;output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    aabb temp_box;</span><br><span class="line">    <span class="type">bool</span> first_box = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) {</span><br><span class="line">        <span class="keyword">if</span> (!object-&gt;<span class="built_in">bounding_box</span>(t0, t1, temp_box))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        output_box = first_box ? temp_box : <span class="built_in">surrounding_box</span>(output_box, temp_box);</span><br><span class="line">        first_box = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This requires the <code>surrounding_box</code> function for <code>aabb</code> which computes the bounding box of two boxes:</p></blockquote><p>我们需要一个<code>surrounding_box</code>函数来计算包围盒的包围盒。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">aabb <span class="title">surrounding_box</span><span class="params">(aabb box0, aabb box1)</span> </span>{</span><br><span class="line">    <span class="function">vec3 <span class="title">small</span><span class="params">(ffmin(box0.min().x(), box1.min().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">               ffmin(box0.min().y(), box1.min().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">               ffmin(box0.min().z(), box1.min().z()))</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">big</span>  <span class="params">(ffmax(box0.max().x(), box1.max().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">               ffmax(box0.max().y(), box1.max().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">               ffmax(box0.max().z(), box1.max().z()))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">aabb</span>(small,big);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="The-BVH-Node-Class"><a href="#The-BVH-Node-Class" class="headerlink" title="The BVH Node Class"></a>The BVH Node Class</h4><blockquote><p>A BVH is also going to be a <code>hittable</code> — just like lists of <code>hittable</code>s. It’s really a container, but it can respond to the query “does this ray hit you?”. One design question is whether we have two classes, one for the tree, and one for the nodes in the tree; or do we have just one class and have the root just be a node we point to. I am a fan of the one class design when feasible. Here is such a class:</p></blockquote><p>BVH也应该是<code>hittable</code>的一员, 就像<code>hittable_list</code>类那样。BVH虽然是个容器, 但也能对于问题“这条光线射中你了么?”做出回答。一个设计上的问题是, 我们是为树和树的节点设计两个不同的类呢, 还是用一个类加上指针来搞定。我是一个类搞定派, 所以这个 <code>bvh.h</code> 类会是这样:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAYTRACING_DEV_BVH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAYTRACING_DEV_BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable_list.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bvh_node</span> : <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bvh_node</span>() {};</span><br><span class="line">    <span class="built_in">bvh_node</span>(hittable_list&amp; list, <span class="type">double</span> time0, <span class="type">double</span> time1)</span><br><span class="line">        : <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>(), time0, time1) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bvh_node</span>(std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; objects,</span><br><span class="line">            <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bouding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; left;</span><br><span class="line">    shared_ptr&lt;hittable&gt; right;</span><br><span class="line">    aabb box;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::bouding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb &amp;output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    output_box = box;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//RAYTRACING_DEV_BVH_H</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Note that the children pointers are to generic hittables. They can be other <code>bvh_nodes</code>, or <code>spheres</code>, or any other <code>hittable</code>.</p><p>The <code>hit</code> function is pretty straightforward: check whether the box for the node is hit, and if so, check the children and sort out any details:</p></blockquote><p>注意我们的子节点指针是<code>hittable*</code>, 所以这个指针可以指向所有的<code>hittable</code>类。例如节点<code>bvh_node</code>， 或者是<code>sphere</code>, 或者是其他各种各样的图元。</p><p><code>hit</code> 函数也是十分的直接明了: 检查这个节点的box是否被击中, 如果是的话, 那就对这个节点的子节点进行判断。<em>【译注: 对于二叉树来说, 这样的递归结构相信大家并不陌生】</em></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::hit</span><span class="params">(<span class="type">const</span> ray &amp;r, <span class="type">double</span> tmin, <span class="type">double</span> tmax, hit_record &amp;rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, tmin, tmax))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, tmin, tmax, rec);</span><br><span class="line">    <span class="type">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, tmin, hit_left ? rec.t : tmax, rec);</span><br><span class="line">    <span class="keyword">return</span> hit_left || hit_right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Splitting-BVH-Volumes"><a href="#Splitting-BVH-Volumes" class="headerlink" title="Splitting BVH Volumes"></a>Splitting BVH Volumes</h4><blockquote><p>The most complicated part of any efficiency structure, including the BVH, is building it. We do this in the constructor. A cool thing about BVHs is that as long as the list of objects in a <code>bvh_node</code> gets divided into two sub-lists, the hit function will work. It will work best if the division is done well, so that the two children have smaller bounding boxes than their parent’s bounding box, but that is for speed not correctness. I’ll choose the middle ground, and at each node split the list along one axis. I’ll go for simplicity:</p><ol><li>randomly choose an axis</li><li>sort the primitives (<code>using std::sort</code>)</li><li>put half in each subtree</li></ol><p>When the list coming in is two elements, I put one in each subtree and end the recursion. The traversal algorithm should be smooth and not have to check for null pointers, so if I just have one element I duplicate it in each subtree. Checking explicitly for three elements and just following one recursion would probably help a little, but I figure the whole method will get optimized later. This yields:</p></blockquote><p>任何高效的数据结构, 例如BVH, 最复杂的部分就是如何去构建他。我们会在构造函数里完成。 对于BVH来说, 很酷的一点是当你不断地把<code>bvh_node</code>中的物体分割成两个子集的同时, hit函数也会跟着执行。如果说你分割的算法很好, 两个孩子的包围盒都比其父节点的包围盒要小, 那么自然hit函数也会运行的很好。但是这样只是快, 并不正确, 我将在正确和快直接做取舍, 在每次分割时我沿着一个轴把物体列表分成两半。我将采用最简单直接的分割原则:</p><p>1.随机选取一个轴来分割<br>2.使用库函数<code>sort()</code>对图元进行排序<br>3.对半分, 每个子树分一半的物体</p><p>物体分割过程递归执行, 当数组传入时只剩下两个元素时, 我在两个子树节点各放一个, 并结束递归。为了使遍历算法平滑, 并且不去检查空指针, 当只有一个元素时, 我将其重复的放在每一个子树里。想象一下有三个元素, 然后仔细的一步步递归一遍有助你理解算法, 但我这里先提一下, 之后我们会优化整个算法。现在代码是这样的:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">bvh_node::<span class="built_in">bvh_node</span>(</span><br><span class="line">    std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; objects,</span><br><span class="line">    <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1</span><br><span class="line">) {</span><br><span class="line">    <span class="type">int</span> axis = <span class="built_in">random_int</span>(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis == <span class="number">0</span>) ? box_x_compare</span><br><span class="line">                    : (axis == <span class="number">1</span>) ? box_y_compare</span><br><span class="line">                                  : box_z_compare;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> object_span = end - start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object_span == <span class="number">1</span>) {</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (object_span == <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comparator</span>(objects[start], objects[start+<span class="number">1</span>])) {</span><br><span class="line">            left = objects[start];</span><br><span class="line">            right = objects[start+<span class="number">1</span>];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            left = objects[start+<span class="number">1</span>];</span><br><span class="line">            right = objects[start];</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>() + start, objects.<span class="built_in">begin</span>() + end, comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span/<span class="number">2</span>;</span><br><span class="line">        left = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid, time0, time1);</span><br><span class="line">        right = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end, time0, time1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    aabb box_left, box_right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (  !left-&gt;<span class="built_in">bounding_box</span> (time0, time1, box_left)</span><br><span class="line">       || !right-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_right)</span><br><span class="line">    )</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"No bounding box in bvh_node constructor.\n"</span>;</span><br><span class="line"></span><br><span class="line">    box = <span class="built_in">surrounding_box</span>(box_left, box_right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里暂时有报错也不要着急，后面会把这些未声明函数补上去。</p><blockquote><p>This uses a new function: <code>random_int()</code>:</p></blockquote><p>在 <code>rtweekend.h</code> 中添加函数 <code>random_int()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">random_int</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>{</span><br><span class="line">    <span class="comment">// Returns a random integer in [min,max].</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">random_double</span>(min, max+<span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The check for whether there is a bounding box at all is in case you sent in something like an infinite plane that doesn’t have a bounding box. We don’t have any of those primitives, so it shouldn’t happen until you add such a thing.</p></blockquote><p>这边做了一个物体是否有包围盒的检查, 是为了防止你把一些如无限延伸的平面这样没有包围盒的东西传进去当参数。我们现在并没有这样的图元, 所以在你手动添加这样的图元之前, 这个<code>std::cerr</code>并不会被执行。</p><h4 id="The-Box-Comparison-Functions"><a href="#The-Box-Comparison-Functions" class="headerlink" title="The Box Comparison Functions"></a>The Box Comparison Functions</h4><blockquote><p>Now we need to implement the box comparison functions, used by <code>std::sort()</code>. To do this, create a generic comparator returns true if the first argument is less than the second, given an additional axis index argument. Then define axis-specific comparison functions that use the generic comparison function.</p></blockquote><p>现在我们需要实现<code>std::sort()</code>使用的比较函数。我们先判断是哪个轴, 然后对应的为我们的比较器赋值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">box_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b, <span class="type">int</span> axis)</span> </span>{</span><br><span class="line">    aabb box_a;</span><br><span class="line">    aabb box_b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>,<span class="number">0</span>, box_a) || !b-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>,<span class="number">0</span>, box_b))</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"No bounding box in bvh_node constructor.\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> box_a.<span class="built_in">min</span>().e[axis] &lt; box_b.<span class="built_in">min</span>().e[axis];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_x_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_y_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_z_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em>【译注: 使用方法：在 <code>random_scene()</code>函数最后<code>return static_cast&lt;hittable_list&gt;(make_shared&lt;bvh_node&gt;(world,0,1));</code>】</em></p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list random_scene() {</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="addition">+	return static_cast&lt;hittable_list&gt;(make_shared&lt;bvh_node&gt;(world,0,1));</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="固体贴图"><a href="#固体贴图" class="headerlink" title="固体贴图"></a>固体贴图</h3><blockquote><p>A texture in graphics usually means a function that makes the colors on a surface procedural. This procedure can be synthesis code, or it could be an image lookup, or a combination of both. We will first make all colors a texture. Most programs keep constant rgb colors and textures in different classes, so feel free to do something different, but I am a big believer in this architecture because being able to make any color a texture is great.</p></blockquote><p>在图形学中, 纹理贴图常常意味着一个将颜色赋予物题表面的一个过程。这个过程可以是纹理生成代码, 或者是一张图片, 或者是两者的结合。我们首先来使用颜色作为贴图。大多数程序员把静态rgb颜色和贴图写成两个不同的类, 以此来区分两者, 但我更加喜欢下面的做法, 因为这样就可以把任何颜色弄成一张贴图, 十分的great。</p><h4 id="The-First-Texture-Class-Constant-Texture"><a href="#The-First-Texture-Class-Constant-Texture" class="headerlink" title="The First Texture Class: Constant Texture"></a>The First Texture Class: Constant Texture</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">texture</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constant_texture</span> : <span class="keyword">public</span> texture {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">constant_texture</span>() {}</span><br><span class="line">    <span class="built_in">constant_texture</span>(vec3 c) : <span class="built_in">color</span>(c) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 color;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We’ll need to update the <code>hit_record</code> structure to store the U,V surface coordinates of the ray-object hit point.</p></blockquote><p>我们需要更新<code>hit_record</code>结构体来储存击中点的uv信息:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">struct hit_record {</span><br><span class="line">    vec3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">    double t;</span><br><span class="line"><span class="addition">+   double u;</span></span><br><span class="line"><span class="addition">+   double v;</span></span><br><span class="line">    bool front_face;</span><br><span class="line">	......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Now we can make textured materials by replacing the <code>const color&amp; a</code> with a texture pointer:</p></blockquote><p>把vec3的颜色换成一个纹理指针, 你将得到一个纹理材质。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+#include "texture.h"</span></span><br><span class="line"></span><br><span class="line">class lambertian : public material {</span><br><span class="line">public:</span><br><span class="line"><span class="deletion">-   lambertian(const vec3&amp; a) : albedo(a) {}</span></span><br><span class="line"><span class="addition">+   lambertian(shared_ptr&lt;texture&gt; a) : albedo(a) {}</span></span><br><span class="line"><span class="addition">+   lambertian(const vec3&amp; a) : albedo(make_shared&lt;constant_texture&gt;(a)) {}</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">class lambertian : public material {</span><br><span class="line">public:</span><br><span class="line">    lambertian(const vec3&amp; a) : albedo(a) {}</span><br><span class="line"></span><br><span class="line">    virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span><br><span class="line">    ) const {</span><br><span class="line">        vec3 scatter_direction = rec.normal + random_unit_vector();</span><br><span class="line">        scattered = ray(rec.p, scatter_direction, r_in.time());</span><br><span class="line"><span class="deletion">-       attenuation = albedo;</span></span><br><span class="line"><span class="addition">+		attenuation = albedo-&gt;value(rec.u, rec.v, rec.p);</span></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">public:</span><br><span class="line"><span class="deletion">-   vec3 albedo;</span></span><br><span class="line"><span class="addition">+	shared_ptr&lt;texture&gt; albedo;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在之前一个lambert材质是这样的:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">...<span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))</span><br></pre></td></tr></tbody></table></figure><p>现在我们把<code>vec3(...)</code>换成<code>make_shared&lt;constant_texture&gt;(vec3(...))</code></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">...<span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)))</span><br></pre></td></tr></tbody></table></figure><h4 id="A-Checker-Texture"><a href="#A-Checker-Texture" class="headerlink" title="A Checker Texture"></a>A Checker Texture</h4><blockquote><p>We can create a checker texture by noting that the sign of sine and cosine just alternates in a regular way, and if we multiply trig functions in all three dimensions, the sign of that product forms a 3D checker pattern.</p></blockquote><p>我们可以使用sine和cosine函数周期性的变化来做一个棋盘格纹理。如果我们在三个维度都乘上这个周期函数, 就会形成一个3D的棋盘格模型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">constant_texture</span> : <span class="keyword">public</span> texture {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">constant_texture</span>() {}</span><br><span class="line">    <span class="built_in">constant_texture</span>(vec3 c) : <span class="built_in">color</span>(c) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 color;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">checker_texture</span> : <span class="keyword">public</span> texture {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">checker_texture</span>() {}</span><br><span class="line">    <span class="built_in">checker_texture</span>(shared_ptr&lt;texture&gt; t0, shared_ptr&lt;texture&gt; t1) : <span class="built_in">odd</span>(t0), <span class="built_in">even</span>(t1) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> sines = <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">x</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">y</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="keyword">if</span> (sines &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> odd-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> even-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; odd;</span><br><span class="line">    shared_ptr&lt;texture&gt; even;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Those checker odd/even pointers can be to a constant texture or to some other procedural texture. This is in the spirit of shader networks introduced by Pat Hanrahan back in the 1980s.</p><p>If we add this to our <code>random_scene()</code> function’s base sphere:</p></blockquote><p>这些奇偶格的指针可以指向一个静态纹理, 也可以指向一些程序生成的纹理。这就是Pat Hanrahan在1980年代提出的着色器网络的核心思想。</p><p>如果我们把这个纹理贴在我们<code>random_scene()</code>函数里底下那个大球上:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list random_scene() {</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   world.add(make_shared&lt;sphere&gt;(</span></span><br><span class="line"><span class="deletion">-           vec3(0,-1000,0), 1000, make_shared&lt;lambertian&gt;(vec3(0.5, 0.5, 0.5))));</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto checker = make_shared&lt;checker_texture&gt;(</span></span><br><span class="line"><span class="addition">+           make_shared&lt;constant_texture&gt;(vec3(0.2, 0.3, 0.1)),</span></span><br><span class="line"><span class="addition">+           make_shared&lt;constant_texture&gt;(vec3(0.9, 0.9, 0.9))</span></span><br><span class="line"><span class="addition">+   );</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   world.add(make_shared&lt;sphere&gt;(vec3(0, -1000, 0), 1000, make_shared&lt;lambertian&gt;(checker)));</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We get:</p></blockquote><p>我们将得到:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.02-checker-ground.png"></p><h4 id="Rendering-a-Scene-with-a-Checkered-Texture"><a href="#Rendering-a-Scene-with-a-Checkered-Texture" class="headerlink" title="Rendering a Scene with a Checkered Texture"></a>Rendering a Scene with a Checkered Texture</h4><blockquote><p>We’re going to add a second scene to our program, and will add more scenes after that as we progress through this book. To help with this, we’ll set up a hard-coded switch statement to select the desired scene for a given run. Clearly, this is a crude approach, but we’re trying to keep things dead simple and focus on the raytracing. You may want to use a different approach in your own raytracer.</p><p>Here’s the scene construction function:</p></blockquote><p>如果我们添加一个新场景:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">two_spheres</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>)),</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用以下的摄像机参数:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// World</span></span><br><span class="line"><span class="comment">//auto world = random_scene();</span></span><br><span class="line"><span class="keyword">auto</span> world = <span class="built_in">two_spheres</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Camera</span></span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We get this result:</p></blockquote><p>我们将得到:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.03-checker-spheres.png"></p><h3 id="柏林噪音"><a href="#柏林噪音" class="headerlink" title="柏林噪音"></a>柏林噪音</h3><blockquote><p>To get cool looking solid textures most people use some form of Perlin noise. These are named after their inventor Ken Perlin. Perlin texture doesn’t return white noise like this:</p></blockquote><p>为了得到一个看上去很cool的纹理, 大部分人使用柏林噪声(Perlin noise)。柏林噪声是以它的发明者Ken Perlin命名的。柏林噪声并不会得到以下的白噪声:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.04-white-noise.jpg"></p><blockquote><p>Instead it returns something similar to blurred white noise:</p></blockquote><p>取而代之的是一些类似模糊后的白噪声:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.05-white-noise-blurred.jpg"></p><blockquote><p>A key part of Perlin noise is that it is repeatable: it takes a 3D point as input and always returns the same randomish number. Nearby points return similar numbers. Another important part of Perlin noise is that it be simple and fast, so it’s usually done as a hack. I’ll build that hack up incrementally based on Andrew Kensler’s description.</p></blockquote><p>柏林噪声的关键特点是可复现性。如果输入的是同一个三维空间中的点, 他的输出值总是相同的。柏林噪声的另一个特点是它实现起来简单快捷。所以通常来说我们拿柏林噪声来做一些hack的事情。我会在Andrew Kensler的描述下逐步的实现这些hack的事情。</p><h4 id="Using-Blocks-of-Random-Numbers"><a href="#Using-Blocks-of-Random-Numbers" class="headerlink" title="Using Blocks of Random Numbers"></a>Using Blocks of Random Numbers</h4><blockquote><p>We could just tile all of space with a 3D array of random numbers and use them in blocks. You get something blocky where the repeating is clear:</p></blockquote><p>我们可以用一个随机生成的三维数组铺满(tile)整个空间, 你会得到明显重复的区块:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.06-tile-random.jpg"></p><blockquote><p>Let’s just use some sort of hashing to scramble this, instead of tiling. This has a bit of support code to make it all happen:</p></blockquote><p>不使用瓷砖贴图的方法, 让我们用哈希表去完成他, 代码如下:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">perlin</span>() {</span><br><span class="line">            ranfloat = <span class="keyword">new</span> <span class="type">double</span>[point_count];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) {</span><br><span class="line">                ranfloat[i] = <span class="built_in">random_double</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">            perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">            perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">perlin</span>() {</span><br><span class="line">            <span class="keyword">delete</span>[] ranfloat;</span><br><span class="line">            <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">            <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">            <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">            <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">            <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>*p.<span class="built_in">x</span>()) &amp; <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>*p.<span class="built_in">y</span>()) &amp; <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>*p.<span class="built_in">z</span>()) &amp; <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ranfloat[perm_x[i] ^ perm_y[j] ^ perm_z[k]];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">        <span class="type">double</span>* ranfloat;</span><br><span class="line">        <span class="type">int</span>* perm_x;</span><br><span class="line">        <span class="type">int</span>* perm_y;</span><br><span class="line">        <span class="type">int</span>* perm_z;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">                p[i] = i;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">                <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">                <span class="type">int</span> tmp = p[i];</span><br><span class="line">                p[i] = p[target];</span><br><span class="line">                p[target] = tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Now if we create an actual texture that takes these floats between 0 and 1 and creates grey colors:</p></blockquote><p>现在让我们来生成一个纹理, 使用范围为0到1的一个float变量来制造灰度图:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+#include "perlin.h"</span></span><br><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="addition">+class nosie_texture : public texture {</span></span><br><span class="line"><span class="addition">+public:</span></span><br><span class="line"><span class="addition">+   nosie_texture() {}</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   virtual vec3 value(double u, double v, const vec3&amp; p) const {</span></span><br><span class="line"><span class="addition">+       return vec3(1, 1, 1) * noise.noise(p);</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+public:</span></span><br><span class="line"><span class="addition">+   perlin noise;</span></span><br><span class="line"><span class="addition">+};</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can use that texture on some spheres:</p></blockquote><p>我们可以把纹理运用在一些球上:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list objects;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> pertex = <span class="built_in">make_shared</span>&lt;nosie_texture&gt;();</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertex)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertex)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并使用和之前相同的摄像机参数:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="built_in">double</span>(image_width) / image_height;</span><br><span class="line">...</span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Add the hashing does scramble as hoped:</p></blockquote><p>如我们所愿, 我们成功的使用哈希生成了下面的图案:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.07-hash-random.png"></p><h4 id="Smoothing-out-the-Result"><a href="#Smoothing-out-the-Result" class="headerlink" title="Smoothing out the Result"></a>Smoothing out the Result</h4><blockquote><p>To make it smooth, we can linearly interpolate:</p></blockquote><p>为了让它看上去更加平滑, 我们可以采用线性插值:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+inline double trilinear_interp(double c[2][2][2], double u, double v, double w) {</span></span><br><span class="line"><span class="addition">+   auto accum = 0.0;</span></span><br><span class="line"><span class="addition">+   for (int i = 0; i &lt; 2; ++i) {</span></span><br><span class="line"><span class="addition">+       for (int j = 0; j &lt; 2; ++j) {</span></span><br><span class="line"><span class="addition">+           for (int k = 0; k &lt; 2; ++k) {</span></span><br><span class="line"><span class="addition">+               accum += (i * u + (1 - i) * (1 - u)) *</span></span><br><span class="line"><span class="addition">+                        (j * v + (1 - j) * (1 - v)) *</span></span><br><span class="line"><span class="addition">+                        (k * w + (1 - k) * (1 - w)) * c[i][j][k];</span></span><br><span class="line"><span class="addition">+           }</span></span><br><span class="line"><span class="addition">+       }</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">    </span><br><span class="line"><span class="addition">+   return accum;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">class perlin {</span><br><span class="line">public:</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    double noise(const vec3&amp; p) const {</span><br><span class="line">        auto u = p.x() - floor(p.x());</span><br><span class="line">        auto v = p.y() - floor(p.y());</span><br><span class="line">        auto w = p.z() - floor(p.z());</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="addition">+		int i = floor(p.x());</span></span><br><span class="line"><span class="addition">+       int j = floor(p.y());</span></span><br><span class="line"><span class="addition">+       int k = floor(p.z());</span></span><br><span class="line"><span class="addition">+       double c[2][2][2];</span></span><br><span class="line"><span class="deletion">-       auto i = static_cast&lt;int&gt;(4 * p.x()) &amp; 255;</span></span><br><span class="line"><span class="deletion">-       auto j = static_cast&lt;int&gt;(4 * p.y()) &amp; 255;</span></span><br><span class="line"><span class="deletion">-       auto k = static_cast&lt;int&gt;(4 * p.z()) &amp; 255;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+       return trilinear_interp(c, u, v, w);</span></span><br><span class="line"><span class="deletion">-       return ranfloat[perm_x[i] ^ perm_y[j] ^ perm_z[k]];</span></span><br><span class="line">    }</span><br><span class="line">	......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And we get:</p></blockquote><p>我们会得到:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.08-perlin-trilerp.png"></p><h4 id="Improvement-with-Hermitian-Smoothing"><a href="#Improvement-with-Hermitian-Smoothing" class="headerlink" title="Improvement with Hermitian Smoothing"></a>Improvement with Hermitian Smoothing</h4><blockquote><p>Smoothing yields an improved result, but there are obvious grid features in there. Some of it is Mach bands, a known perceptual artifact of linear interpolation of color. A standard trick is to use a Hermite cubic to round off the interpolation:</p></blockquote><p>嗯, 现在看上去更好了, 但是还是能明显的看出来有格子的痕迹。其中的一部分是马赫带(Mach bands), 是由线性变化的颜色构成的有名的视觉感知效果。这里我们使用一个标准的解法：用hermite cube来平滑差值。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">    double noise(const vec3&amp; p) const {</span><br><span class="line">        auto u = p.x() - floor(p.x());</span><br><span class="line">        auto v = p.y() - floor(p.y());</span><br><span class="line">        auto w = p.z() - floor(p.z());</span><br><span class="line"></span><br><span class="line"><span class="addition">+       u = u * u * (3 - 2 * u);</span></span><br><span class="line"><span class="addition">+       v = v * v * (3 - 2 * v);</span></span><br><span class="line"><span class="addition">+       w = w * w * (3 - 2 * w);</span></span><br><span class="line">        </span><br><span class="line">        int i = floor(p.x());</span><br><span class="line">        int j = floor(p.y());</span><br><span class="line">        int k = floor(p.z());</span><br><span class="line">        double c[2][2][2];</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This gives a smoother looking image:</p></blockquote><p>这样看起来就更加平滑了:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.09-perlin-trilerp-smooth.png"></p><h4 id="Tweaking-The-Frequency"><a href="#Tweaking-The-Frequency" class="headerlink" title="Tweaking The Frequency"></a>Tweaking The Frequency</h4><blockquote><p>It is also a bit low frequency. We can scale the input point to make it vary more quickly:</p></blockquote><p>现在这个球看上去变化的频率太低了, 没什么花纹, 我们加入一个<code>scale</code>变量让它更快的发生变化:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class nosie_texture : public texture {</span><br><span class="line">public:</span><br><span class="line">    nosie_texture() {}</span><br><span class="line"><span class="addition">+   nosie_texture(double sc) : scale(sc) {}</span></span><br><span class="line"></span><br><span class="line">    virtual vec3 value(double u, double v, const vec3&amp; p) const {</span><br><span class="line"><span class="addition">+       return vec3(1, 1, 1) * noise.noise(scale * p);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    perlin noise;</span><br><span class="line"><span class="addition">+   double scale;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We then add that scale to the <code>two_perlin_spheres()</code> scene description:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list two_perlin_spheres() {</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto pertex = make_shared&lt;nosie_texture&gt;(4);</span></span><br><span class="line">    objects.add(make_shared&lt;sphere&gt;(vec3(0, -1000, 0), 1000, make_shared&lt;lambertian&gt;(pertex)));</span><br><span class="line">    objects.add(make_shared&lt;sphere&gt;(vec3(0, 2, 0), 2, make_shared&lt;lambertian&gt;(pertex)));</span><br><span class="line"></span><br><span class="line">    return objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.10-perlin-hifreq.png"></p><h4 id="Using-Random-Vectors-on-the-Lattice-Points"><a href="#Using-Random-Vectors-on-the-Lattice-Points" class="headerlink" title="Using Random Vectors on the Lattice Points"></a>Using Random Vectors on the Lattice Points</h4><blockquote><p>This is still a bit blocky looking, probably because the min and max of the pattern always lands exactly on the integer x/y/z. Ken Perlin’s very clever trick was to instead put random unit vectors (instead of just floats) on the lattice points, and use a dot product to move the min and max off the lattice. So, first we need to change the random floats to random vectors. These vectors are any reasonable set of irregular directions, and I won’t bother to make them exactly uniform:</p></blockquote><p>现在看上去还是有一点格子的感觉, 也许是因为这方法的最大值和最小值总是精确地落在了整数的x/y/z上, Ken Perlin有一个十分聪明的trick, 在网格点使用随机的单位向量替代float(即梯度向量), 用点乘将min和max值推离网格点, 所以我们首先要把random floats改成random vectors。这些梯度向量可以是任意合理的不规则方向的集合, 所以我干脆使用单位向量作为梯度向量:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#ifndef RAYTRACING_DEV_PERLIN_H</span><br><span class="line">#define RAYTRACING_DEV_PERLIN_H</span><br><span class="line"></span><br><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">class perlin {</span><br><span class="line">public:</span><br><span class="line">    perlin() {</span><br><span class="line"><span class="deletion">-       ranfloat = new double[point_count];</span></span><br><span class="line"><span class="addition">+       ranvec = new vec3[point_count];</span></span><br><span class="line">        for (int i = 0; i &lt; point_count; ++i) {</span><br><span class="line"><span class="deletion">-           ranfloat[i] = random_double();</span></span><br><span class="line"><span class="addition">+           ranvec[i] = unit_vector(vec3::random(-1, 1));</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        perm_x = perlin_generate_perm();</span><br><span class="line">        perm_y = perlin_generate_perm();</span><br><span class="line">        perm_z = perlin_generate_perm();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~perlin() {</span><br><span class="line"><span class="deletion">-       delete[] ranfloat;</span></span><br><span class="line"><span class="addition">+       delete[] ranvec;</span></span><br><span class="line">        delete[] perm_x;</span><br><span class="line">        delete[] perm_y;</span><br><span class="line">        delete[] perm_z;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    static const int point_count = 256;</span><br><span class="line"><span class="deletion">-   double* ranfloat;</span></span><br><span class="line">    int* perm_x;</span><br><span class="line">    int* perm_y;</span><br><span class="line">    int* perm_z;</span><br><span class="line"><span class="addition">+   vec3* ranvec;</span></span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">#endif //RAYTRACING_DEV_PERLIN_H</span><br></pre></td></tr></tbody></table></figure><p>现在的<code>Perlin</code>类如下:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class perlin {</span><br><span class="line">public:</span><br><span class="line">    double noise(const vec3&amp; p) const {</span><br><span class="line">        auto u = p.x() - floor(p.x());</span><br><span class="line">        auto v = p.y() - floor(p.y());</span><br><span class="line">        auto w = p.z() - floor(p.z());</span><br><span class="line"></span><br><span class="line">        u = u * u * (3 - 2 * u);</span><br><span class="line">        v = v * v * (3 - 2 * v);</span><br><span class="line">        w = w * w * (3 - 2 * w);</span><br><span class="line"></span><br><span class="line">        int i = floor(p.x());</span><br><span class="line">        int j = floor(p.y());</span><br><span class="line">        int k = floor(p.z());</span><br><span class="line"><span class="deletion">-       double c[2][2][2];</span></span><br><span class="line"><span class="addition">+		vec3 c[2][2][2];</span></span><br><span class="line"></span><br><span class="line">        for (int di = 0; di &lt; 2; ++di) {</span><br><span class="line">            for (int dj = 0; dj &lt; 2; ++dj) {</span><br><span class="line">                for (int dk = 0; dk &lt; 2; ++dk) {</span><br><span class="line"><span class="deletion">-                    c[di][dj][dk] = ranfloat[</span></span><br><span class="line"><span class="addition">+                    c[di][dj][dk] = ranvec[</span></span><br><span class="line">                            perm_x[(i + di) &amp; 255] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; 255] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; 255]];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="deletion">-       return trilinear_interp(c, u, v, w);</span></span><br><span class="line"><span class="addition">+       return perlin_interp(c, u, v, w);</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the interpolation becomes a bit more complicated:</p></blockquote><p>插值部分的代码看上去比之前复杂了一些:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">perlin_interp</span><span class="params">(vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>{</span><br><span class="line">            <span class="keyword">auto</span> uu = u*u*(<span class="number">3</span><span class="number">-2</span>*u);</span><br><span class="line">            <span class="keyword">auto</span> vv = v*v*(<span class="number">3</span><span class="number">-2</span>*v);</span><br><span class="line">            <span class="keyword">auto</span> ww = w*w*(<span class="number">3</span><span class="number">-2</span>*w);</span><br><span class="line">            <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k &lt; <span class="number">2</span>; k++) {</span><br><span class="line">                        <span class="function">vec3 <span class="title">weight_v</span><span class="params">(u-i, v-j, w-k)</span></span>;</span><br><span class="line">                        accum += (i*uu + (<span class="number">1</span>-i)*(<span class="number">1</span>-uu))</span><br><span class="line">                               * (j*vv + (<span class="number">1</span>-j)*(<span class="number">1</span>-vv))</span><br><span class="line">                               * (k*ww + (<span class="number">1</span>-k)*(<span class="number">1</span>-ww))</span><br><span class="line">                               * <span class="built_in">dot</span>(c[i][j][k], weight_v);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> accum;</span><br><span class="line">        }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The output of the perlin interpretation can return negative values. These negative values will be passed to the <code>sqrt()</code> function of our gamma function and get turned into <code>NaN</code>s. We will cast the perlin output back to between 0 and 1.</p></blockquote><p>柏林插值的输出结果有可能是负数, 这些负数在伽马校正时经过开平方跟<code>sqrt()</code>会变成NaN。我们将输出结果映射到0与1之间。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class nosie_texture : public texture {</span><br><span class="line">public:</span><br><span class="line">    nosie_texture() {}</span><br><span class="line">    nosie_texture(double sc) : scale(sc) {}</span><br><span class="line"></span><br><span class="line">    virtual vec3 value(double u, double v, const vec3&amp; p) const {</span><br><span class="line"><span class="addition">+       return vec3(1, 1, 1) * 0.5 * (1.0 + noise.noise(scale * p));</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    perlin noise;</span><br><span class="line">    double scale;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This finally gives something more reasonable looking:</p></blockquote><p>最终我们得到一个让人满意的结果:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.11-perlin-shift.png"></p><h4 id="Introducing-Turbulence"><a href="#Introducing-Turbulence" class="headerlink" title="Introducing Turbulence"></a>Introducing Turbulence</h4><blockquote><p>Very often, a composite noise that has multiple summed frequencies is used. This is usually called turbulence, and is a sum of repeated calls to noise:</p></blockquote><p>使用多个频率相加得到复合噪声是一种很常见的做法, 我们常常称之为扰动(turbulence), 是一种由多次噪声运算的结果相加得到的产物。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">turb</span><span class="params">(<span class="type">const</span> vec3&amp; p, <span class="type">int</span> depth=<span class="number">7</span>)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">            vec3 temp_p = p;</span><br><span class="line">            <span class="keyword">auto</span> weight = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) {</span><br><span class="line">                accum += weight*<span class="built_in">noise</span>(temp_p);</span><br><span class="line">                weight *= <span class="number">0.5</span>;</span><br><span class="line">                temp_p *= <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>(accum);</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Here <code>fabs()</code> is the absolute value function defined in <code>&lt;cmath&gt;</code>.</p></blockquote><p>这里的<code>fabs()</code>是<code>math.h</code>里的求绝对值的函数。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class noise_texture : public texture {</span><br><span class="line">    public:</span><br><span class="line">        noise_texture() {}</span><br><span class="line">        noise_texture(double sc) : scale(sc) {}</span><br><span class="line"></span><br><span class="line">        virtual color value(double u, double v, const point3&amp; p) const override {</span><br><span class="line"><span class="addition">+           return color(1,1,1) * noise.turb(scale * p);</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        perlin noise;</span><br><span class="line">        double scale;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Used directly, turbulence gives a sort of camouflage netting appearance:</p></blockquote><p>直接使用turb函数来产生纹理, 会得到一个看上去像伪装网一样的东西:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://raytracing.github.io/images/img-2.12-perlin-turb.png"></p><h4 id="Adjusting-the-Phase"><a href="#Adjusting-the-Phase" class="headerlink" title="Adjusting the Phase"></a>Adjusting the Phase</h4><blockquote><p>However, usually turbulence is used indirectly. For example, the “hello world” of procedural solid textures is a simple marble-like texture. The basic idea is to make color proportional to something like a sine function, and use turbulence to adjust the phase (so it shifts 𝑥 in sin(𝑥)) which makes the stripes undulate. Commenting out straight noise and turbulence, and giving a marble-like effect is:</p></blockquote><p>然而扰动函数通常是间接使用的, 在程序生成纹理这方面的”hello world”是一个类似大理石的纹理。基本思路是让颜色与sine函数的值成比例, 并使用扰动函数去调整相位(平移了sin(x)中的x), 使得带状条纹起伏波荡。修正我们直接使用扰动turb或者噪声noise给颜色赋值的方法， 我们会得到一个类似大理石的纹理:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class noise_texture : public texture {</span><br><span class="line">    public:</span><br><span class="line">        noise_texture() {}</span><br><span class="line">        noise_texture(double sc) : scale(sc) {}</span><br><span class="line"></span><br><span class="line">        virtual vec3 value(double u, double v, const vec3&amp; p) const {</span><br><span class="line"><span class="addition">+            return vec3(1,1,1) * 0.5 * (1 + sin(scale*p.z() + 10*noise.turb(p)));</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        perlin noise;</span><br><span class="line">        double scale;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which yields:</p></blockquote><p>最终得到:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.13-perlin-marble.png"></p><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><blockquote><p>From the hitpoint <strong>𝐏</strong>, we compute the surface coordinates (𝑢,𝑣). We then use these to index into our procedural solid texture (like marble). We can also read in an image and use the 2D (𝑢,𝑣) texture coordinate to index into the image.</p><p>A direct way to use scaled (𝑢,𝑣) in an image is to round the 𝑢 and 𝑣 to integers, and use that as (𝑖,𝑗) pixels. This is awkward, because we don’t want to have to change the code when we change image resolution. So instead, one of the the most universal unofficial standards in graphics is to use texture coordinates instead of image pixel coordinates. These are just some form of fractional position in the image. For example, for pixel (𝑖,𝑗) in an $𝑁_𝑥$ by $𝑁_𝑦$​ image, the image texture position is:</p></blockquote><p>我们之前使用射入点p来映射(原文to index)类似大理石那样程序生成的纹理。我们也能读取一张图片, 并将一个2D(u,v)的坐标系映射在图片上。</p><p>使用(u,v)坐标的一个直接的想法是将u与v调整比例后取整, 然后将其对应到像素坐标(i,j)上, 这很糟糕, 因为这样每次图片分辨率发生变化时, 我们都要修改代码。所以相对的, 图形学界中广泛认可的非官方标准之一是采用纹理坐标系代替图像坐标系。即使用[0,1]的小数来表示图像中的位置。举例来说, 对于一张宽度为 $N_x$ 高度为 $N_y$ 的图像中的像素(i,j) , 其像素坐标系下的坐标为:</p><p>$u = \frac{i}{N_x-1}$</p><p>$v = \frac{j}{N_y - 1}$</p><p>对于一个<code>hittable</code>来说, 我们还需要在<code>hit record</code>中加入 u 和 v 的记录。对于椭圆来说, uv的计算是基于经度和纬度的的, 换句话说, 是基于球面坐标的。所以当我们有一个球面坐标(θ,ϕ)， 我们只需要按比例转化一下就能得到uv坐标。如果θ是朝下距离极轴的角度, ϕ是绕极轴旋转的角度, 将其映射到[0,1]的过程为:</p><p>$u = \frac{\phi}{2\pi}$</p><p>$v = \frac{\phi}{\pi}$</p><p>为了计算 θ 和 ϕ, 对于任意给出的球面上的射入点, 将球面坐标系转化为直角坐标系的方程为:</p><p>$x = \cos(\phi)\cos(\theta)$</p><p>$y=\sin(\phi)\cos(\theta)$</p><p>$z = \sin(\theta)$</p><blockquote><p>We need to invert these equations to solve for 𝜃 and 𝜙. Because of the lovely <code>&lt;cmath&gt;</code> function <code>atan2()</code>, which takes any pair of numbers proportional to sine and cosine and returns the angle, we can pass in 𝑥 and 𝑧 (the sin(𝜃) cancel) to solve for 𝜙:</p></blockquote><p>我们现在只要把它倒过来就行, 因为我们可爱的<code>&lt;cmath&gt;</code>库函数<code>atan2()</code>的关系, 给出任意一个角度的 sine 和 cosine 值, 我们就能得到这个角的角度值。 所以我们可以像这样传入x, y的值 sin(θ) 与 cos(θ) 相除抵消得到 tan⁡(θ):</p><p>$\phi = \atan2(y, x)$</p><blockquote><p><code>atan2()</code> returns values in the range −𝜋 to 𝜋, but they go from 0 to 𝜋, then flip to −𝜋 and proceed back to zero. While this is mathematically correct, we want 𝑢 to range from 0 to 1, not from 0 to 1/2 and then from −1/2 to 0. Fortunately,</p></blockquote><p>$\atan2$ 函数的返回值范围为 −π 到 π <em>【译注:即返回弧度(radius)】</em>所以我们这里还要小心一下。相对的, 求角 θ 更为简单直接:</p><p>$\theta = \asin(z)$</p><blockquote><p>So for a sphere, the (𝑢,𝑣) coord computation is accomplished by a utility function that takes points on the unit sphere centered at the origin, and computes 𝑢 and 𝑣:</p></blockquote><p>所以对于一个球体来说, (u,v)(u,v) 坐标的计算是由一个工具函数完成的, 该函数假定输入参数为单位圆上的点, 所以我们传入参数时需要注意一下:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_sphere_uv</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span> </span>{</span><br><span class="line">            <span class="comment">// p: a given point on the sphere of radius one, centered at the origin.</span></span><br><span class="line">            <span class="comment">// u: returned value [0,1] of angle around the Y axis from X=-1.</span></span><br><span class="line">            <span class="comment">// v: returned value [0,1] of angle from Y=-1 to Y=+1.</span></span><br><span class="line">            <span class="comment">//     &lt;1 0 0&gt; yields &lt;0.50 0.50&gt;       &lt;-1  0  0&gt; yields &lt;0.00 0.50&gt;</span></span><br><span class="line">            <span class="comment">//     &lt;0 1 0&gt; yields &lt;0.50 1.00&gt;       &lt; 0 -1  0&gt; yields &lt;0.50 0.00&gt;</span></span><br><span class="line">            <span class="comment">//     &lt;0 0 1&gt; yields &lt;0.25 0.50&gt;       &lt; 0  0 -1&gt; yields &lt;0.75 0.50&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">            <span class="keyword">auto</span> phi = <span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(), p.<span class="built_in">x</span>()) + pi;</span><br><span class="line"></span><br><span class="line">            u = phi / (<span class="number">2</span>*pi);</span><br><span class="line">            v = theta / pi;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Update the <code>sphere::hit()</code> function to use this function to update the hit record UV coordinates.</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(...)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="built_in">get_sphere_uv</span>(outward_normal, rec.u, rec.v);</span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Storing-Texture-Image-Data"><a href="#Storing-Texture-Image-Data" class="headerlink" title="Storing Texture Image Data"></a>Storing Texture Image Data</h4><blockquote><p>The representation of a packed array in that order is pretty standard. Thankfully, the <a target="_blank" rel="noopener" href="https://github.com/nothings/stb">stb_image</a> package makes that super simple — just write a header called <code>rtw_stb_image.h</code> that also deals with some compiler warnings:</p></blockquote><p>现在我们还需要新建一个texture类来存放图片。我现在将使用我最喜欢的图像工具库<a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h"><code>stb_image.h</code></a>(点击下载)。它将图片信息读入一个无符号字符类型(unsigned char)的大数组中。unsigned char(8bit, 0<del>255)的值即为RGBs中表示明暗的0</del>255。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"texture.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image_texture</span> : <span class="keyword">public</span> texture {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">image_texture</span>() {}</span><br><span class="line">        <span class="built_in">image_texture</span>(<span class="type">unsigned</span> <span class="type">char</span> *pixels, <span class="type">int</span> A, <span class="type">int</span> B)</span><br><span class="line">            : <span class="built_in">data</span>(pixels), <span class="built_in">nx</span>(A), <span class="built_in">ny</span>(B) {}</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">image_texture</span>() {</span><br><span class="line">            <span class="keyword">delete</span> data;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="comment">// If we have no texture data, then always emit cyan (as a debugging aid).</span></span><br><span class="line">            <span class="keyword">if</span> (data == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((  u)*nx);</span><br><span class="line">            <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((<span class="number">1</span>-v)*ny<span class="number">-0.001</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; nx<span class="number">-1</span>) i = nx<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; ny<span class="number">-1</span>) j = ny<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data[<span class="number">3</span>*i + <span class="number">3</span>*nx*j+<span class="number">0</span>]) / <span class="number">255.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data[<span class="number">3</span>*i + <span class="number">3</span>*nx*j+<span class="number">1</span>]) / <span class="number">255.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data[<span class="number">3</span>*i + <span class="number">3</span>*nx*j+<span class="number">2</span>]) / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vec3</span>(r, g, b);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *data;</span><br><span class="line">        <span class="type">int</span> nx, ny;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>使用这样的数组来储存图像十分的基础。感谢<a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h"><code>stb_image.h</code></a>, 导入图片变得异常简单, 只需在<code>main.cpp</code>中包含函数头<code>stb_image.h</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stb_image.h"</span></span></span><br></pre></td></tr></tbody></table></figure><p>我们earthmap.jpg中从读取数据(这张图是我从网上随便找的 – 这里你使用任何图片都行, 最好符合球体的投影标准), 并将它部署给一个漫反射材质, 代码如下:</p><h4 id="Using-an-Image-Texture"><a href="#Using-an-Image-Texture" class="headerlink" title="Using an Image Texture"></a>Using an Image Texture</h4><blockquote><p>I just grabbed a random earth map from the web — any standard projection will do for our purposes.</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/earthmap.jpg"></p><blockquote><p>Here’s the code to read an image from a file and then assign it to a diffuse material:</p></blockquote><p>我们 earthmap.jpg 中从读取数据(这张图是我从网上随便找的 – 这里你使用任何图片都行, 最好符合球体的投影标准), 并将它部署给一个漫反射材质, 代码如下:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">earth</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> nx, ny, nn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* texture_data = <span class="built_in">stbi_load</span>(<span class="string">"earthmap.jpg"</span>, &amp;nx, &amp;ny, &amp;nn, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> earth_surface =</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;image_texture&gt;(texture_data, nx, ny));</span><br><span class="line">    <span class="keyword">auto</span> globe = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">2</span>, earth_surface);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hittable_list</span>(globe);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们现在开始感受 texture 类的魅力了: 我们现在可以将任意一种类的纹理(贴图, 大理石)运用到 lambertian 材质上, 并且 lambertian 材质并不需要关心其输入的是图片还是其他的什么。</p><p>如果你想测试的话, 我们先应用这个球, 然后暂时修改<code>ray_color</code>函数, 使其只返回 attenuation 的值, 你会得到下面的结果:</p><blockquote><p>We start to see some of the power of all colors being textures — we can assign any kind of texture to the lambertian material, and lambertian doesn’t need to be aware of it.</p><p>To test this, throw it into main:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.15-earth-sphere.png"></p><h3 id="矩阵和光源"><a href="#矩阵和光源" class="headerlink" title="矩阵和光源"></a>矩阵和光源</h3><blockquote><p>Lighting is a key component of raytracing. Early simple raytracers used abstract light sources, like points in space, or directions. Modern approaches have more physically based lights, which have position and size. To create such light sources, we need to be able to take any regular object and turn it into something that emits light into our scene.</p></blockquote><h4 id="Emissive-Materials"><a href="#Emissive-Materials" class="headerlink" title="Emissive Materials"></a>Emissive Materials</h4><blockquote><p>First, let’s make a light emitting material. We need to add an emitted function (we could also add it to <code>hit_record</code> instead — that’s a matter of design taste). Like the background, it just tells the ray what color it is and performs no reflection. It’s very simple:</p></blockquote><p>我们首先来做一个发射光线的材质。我们需要加入一个发射函数(我们可以把这部分内容加在<code>hit_record</code>里 —— 只是设计上的品味不同罢了)。就像背景区域一样, 这个材质只要指定自己发射的光线的颜色, 并且不用考虑任何反射折射的问题。所以它很简单:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">diffuse_light</span> : <span class="keyword">public</span> material  {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">diffuse_light</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">emit</span>(a) {}</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;texture&gt; emit;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>So that I don’t have to make all the non-emitting materials implement <code>emitted()</code>, I have the base class return black:</p></blockquote><p>为了不去给每个不是光源的材质实现<code>emitted()</code>函数, 我这里并不使用纯虚函数, 并让函数默认返回黑色:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class material {</span><br><span class="line">    public:</span><br><span class="line"><span class="addition">+        virtual vec3 emitted(double u, double v, const vec3&amp; p) const {</span></span><br><span class="line"><span class="addition">+            return vec3(0,0,0);</span></span><br><span class="line"><span class="addition">+        }</span></span><br><span class="line"></span><br><span class="line">        virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span><br><span class="line">        ) const = 0;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Adding-Background-Color-to-the-Ray-Color-Function"><a href="#Adding-Background-Color-to-the-Ray-Color-Function" class="headerlink" title="Adding Background Color to the Ray Color Function"></a>Adding Background Color to the Ray Color Function</h4><blockquote><p>Next, we want a pure black background so the only light in the scene is coming from the emitters. To do this, we’ll add a background color parameter to our <code>ray_color</code> function, and pay attention to the new <code>emitted</code> value.</p></blockquote><p>接下来我们想要一个纯黑的背景, 并让所有光线都来自于我们的光源材质。要实现它, 我们得在<code>ray_color</code>函数中加入一个背景色的变量, 然后注意由<code>emitted</code>函数产生的新的颜色值。<em>【思考一个简单场景, 里面只有几个物体和一个光源, 有助于理解这段递归】</em></p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(const ray&amp; r, const vec3&amp; background, const hittable&amp; world,int depth) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return {0,0,0};</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (world.hit(r,0.001,infinity,rec))</span><br><span class="line"><span class="addition">+       return background;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   {</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        vec3 attenuation;</span><br><span class="line"><span class="addition">+       vec3 emitted = rec.mat_ptr-&gt;emitted(rec.u, rec.v, rec.p);</span></span><br><span class="line">        if (rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered))</span><br><span class="line"><span class="addition">+           return emitted;</span></span><br><span class="line"><span class="deletion">-   }</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   vec3 unit_direction = unit_vector(r.direction());</span></span><br><span class="line"><span class="deletion">-   auto t = 0.5 * (unit_direction.y() + 1.0);</span></span><br><span class="line"><span class="deletion">-   return (1.0 - t) * vec3(1.0,1.0,1.0) + t * vec3(0.5,0.7,1.0);</span></span><br><span class="line"><span class="addition">+	return emitted + attenuation * ray_color(scattered, background, world, depth-1);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    ......</span><br><span class="line"><span class="addition">+   const vec3 background(0,0,0);</span></span><br><span class="line">    ......</span><br><span class="line"><span class="addition">+   	color += ray_color(r, background, world, max_depth);</span></span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Creating-Rectangle-Objects"><a href="#Creating-Rectangle-Objects" class="headerlink" title="Creating Rectangle Objects"></a>Creating Rectangle Objects</h4><blockquote><p>Now, let’s make some rectangles. Rectangles are often convenient for modeling man-made environments. I’m a fan of doing axis-aligned rectangles because they are easy. (We’ll get to instancing so we can rotate them later.)</p></blockquote><p>现在我们来加入一些矩形。在建模人为环境时使用矩形会很方便。我超喜欢用轴对齐的矩形因为他们很简单(我们接下来会加入实例(instance)的功能, 待会就可以旋转这些矩形)。</p><blockquote><p>First, here is a rectangle in an xy plane. Such a plane is defined by its z value. For example, 𝑧=𝑘. An axis-aligned rectangle is defined by the lines 𝑥=𝑥0, 𝑥=𝑥1, 𝑦=𝑦0, and 𝑦=𝑦1.</p></blockquote><p>首先将一个矩形放在xy平面, 通常我们使用一个z值来定义这样的平面。举例来说, $z=k$。一个轴对齐的矩形是由 $x=x_0$, $x=x_1$, $y=y_0$, 以及 $y=y_1$ 这四条直线构成的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.05-ray-rect.jpg"></p><blockquote><p>To determine whether a ray hits such a rectangle, we first determine where the ray hits the plane. Recall that a ray <strong>𝐏</strong>(𝑡)=<strong>𝐀</strong>+𝑡<strong>𝐛</strong> has its z component defined by $𝑃_𝑧(𝑡)=𝐴_𝑧+𝑡𝑏_z$. Rearranging those terms we can solve for what the t is where 𝑧=𝑘.</p></blockquote><p>为了判断光线是否与这样的矩形相交, 我们先来判断射线击中平面上的哪个点。回想一下射线方程 $p(t)=a+t\vec{b}$​, 其中射线的 z 值又由平面 $z(t)=a_z+t \cdot \vec{b_z}$​​ 决定。合并整理我们将获得当 $z=k$ 时 $t$ 的值</p><p>$t = \frac{k - a_z}{\vec{b_z}}$</p><blockquote><p>Once we have 𝑡, we can plug that into the equations for 𝑥 and 𝑦:</p></blockquote><p>一旦我们求出t, 我们就能将其带入求解 x 和 y 的等式</p><p>$x = a_x + t \cdot \vec{b_x}$</p><p>$y = a_y + t \cdot \vec{b_y}$</p><blockquote><p>It is a hit if $𝑥_0&lt;𝑥&lt;𝑥_1$ and $𝑦_0&lt;𝑦&lt;𝑦_1$.</p><p>Because our rectangles are axis-aligned, their bounding boxes will have an infinitely-thin side. This can be a problem when dividing them up with our axis-aligned bounding volume hierarchy. To counter this, all hittable objects should get a bounding box that has finite width along every dimension. For our rectangles, we’ll just pad the box a bit on the infnitely-thin side.</p></blockquote><p>如果 $x_0&lt;x&lt;x_1$​ 与 $y_0&lt;y&lt;y_1$​, 那么射线就击中了这个矩形。</p><blockquote><p>The actual <code>xy_rect</code> class is thus:</p></blockquote><p>我们的<code>xy_rect</code>类是这样的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xy_rect</span> : <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xy_rect</span>() {}</span><br><span class="line">    <span class="built_in">xy_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _k, shared_ptr&lt;material&gt; mat)</span><br><span class="line">    : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> </span>{</span><br><span class="line">        <span class="comment">// The bounding box must have non-zero width in each dimension, so pad the Z</span></span><br><span class="line">        <span class="comment">// dimension a small amount.</span></span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">vec3</span>(x0, y0, k - <span class="number">0.0001</span>), <span class="built_in">vec3</span>(x1, y1, k + <span class="number">0.0001</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, y0, y1, k;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the hit function is:</p></blockquote><p>hit函数是这样的:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xy_rect::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> t = (k-r.<span class="built_in">origin</span>().<span class="built_in">z</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || y &lt; y0 || y &gt; y1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (x-x0)/(x1-x0);</span><br><span class="line">    rec.v = (y-y0)/(y1-y0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Turning-Objects-into-Lights"><a href="#Turning-Objects-into-Lights" class="headerlink" title="Turning Objects into Lights"></a>Turning Objects into Lights</h4><blockquote><p>If we set up a rectangle as a light:</p></blockquote><p>如果我们把一个矩形设置为光源:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">simple_light</span><span class="params">()</span> </span>{</span><br><span class="line">        hittable_list objects;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-1000</span>, <span class="number">0</span>), <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>), <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> difflight = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>)));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>), <span class="number">2</span>, difflight));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, difflight));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调整相机参数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Camera</span></span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">26</span>, <span class="number">3</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="function"><span class="type">const</span> vec3 <span class="title">background</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>注意现在光比(1,1,1)还要亮, 所以这个亮度足够它去照亮其他东西了。同样的我们在做一些球型光源：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.17-rect-sphere-light.png"></p><h4 id="More-Axis-Aligned-Rectangles"><a href="#More-Axis-Aligned-Rectangles" class="headerlink" title="More Axis-Aligned Rectangles"></a>More Axis-Aligned Rectangles</h4><blockquote><p>Now let’s add the other two axes and the famous Cornell Box.</p><p>This is xz and yz:</p></blockquote><p>现在让我们加入剩下的两个轴, 并完成著名的Cornell Box。</p><p>xz 和 yz平面是这样的:<em>【实话说这样写代码有些冗余了】</em></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span>: <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xz_rect</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xz_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k, shared_ptr&lt;material&gt; mat)</span><br><span class="line">            : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) {};</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">        output_box =  <span class="built_in">aabb</span>(<span class="built_in">vec3</span>(x0,k<span class="number">-0.0001</span>,z0), <span class="built_in">vec3</span>(x1, k+<span class="number">0.0001</span>, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, z0, z1, k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yz_rect</span>: <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">yz_rect</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">yz_rect</span>(<span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k, shared_ptr&lt;material&gt; mat)</span><br><span class="line">            : <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) {};</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">        output_box =  <span class="built_in">aabb</span>(<span class="built_in">vec3</span>(k<span class="number">-0.0001</span>, y0, z0), <span class="built_in">vec3</span>(k+<span class="number">0.0001</span>, y1, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> y0, y1, z0, z1, k;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>With unsurprising hit functions:</p></blockquote><p>当然hit函数也和之前一样:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xz_rect::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">       <span class="keyword">auto</span> t = (k-r.<span class="built_in">origin</span>().<span class="built_in">y</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">       <span class="keyword">if</span> (t &lt; t0 || t &gt; t1)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">       <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">       <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       rec.u = (x-x0)/(x1-x0);</span><br><span class="line">       rec.v = (z-z0)/(z1-z0);</span><br><span class="line">       rec.t = t;</span><br><span class="line">       vec3 outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">       rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">       rec.mat_ptr = mp;</span><br><span class="line">       rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">yz_rect::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">       <span class="keyword">auto</span> t = (k-r.<span class="built_in">origin</span>().<span class="built_in">x</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">       <span class="keyword">if</span> (t &lt; t0 || t &gt; t1)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">       <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t*r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">       <span class="keyword">if</span> (y &lt; y0 || y &gt; y1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       rec.u = (y-y0)/(y1-y0);</span><br><span class="line">       rec.v = (z-z0)/(z1-z0);</span><br><span class="line">       rec.t = t;</span><br><span class="line">       vec3 outward_normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">       rec.mat_ptr = mp;</span><br><span class="line">       rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Creating-an-Empty-“Cornell-Box”"><a href="#Creating-an-Empty-“Cornell-Box”" class="headerlink" title="Creating an Empty “Cornell Box”"></a>Creating an Empty “Cornell Box”</h4><blockquote><p>The “Cornell Box” was introduced in 1984 to model the interaction of light between diffuse surfaces. Let’s make the 5 walls and the light of the box:</p></blockquote><p>让我们做五堵墙壁, 并点亮这个盒子:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>{</span><br><span class="line">        hittable_list objects;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.65</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)));</span><br><span class="line">        <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.73</span>, <span class="number">0.73</span>, <span class="number">0.73</span>)));</span><br><span class="line">        <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.12</span>, <span class="number">0.45</span>, <span class="number">0.15</span>)));</span><br><span class="line">        <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>)));</span><br><span class="line"></span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">        <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Add the view and scene info:</p></blockquote><p>下面是新的摄像机的参数:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Camera</span></span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="function"><span class="type">const</span> vec3 <span class="title">background</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>我们会得到如下的结果:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://raytracing.github.io/images/img-2.18-cornell-empty.png" alt="img"></p><p>这看上去都是噪点, 因为光太小了。我们还有一个问题: 一些墙壁的朝向反了。我们还没有让漫反射材质的正反两面有相同的表现。但cornell box的内外部是不同的模式。一个矩形物体的正面往往是(1,0,0), (0,1,0), 或者 (0,0,1) 这几个方向。我们需要一种翻转矩形朝向的方法。所以让我们来一个新的hittable类吧, 别得啥都不干, 专门用来翻转正反面。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote><p>The Cornell Box usually has two blocks in it. These are rotated relative to the walls. First, let’s make an axis-aligned block primitive that holds 6 rectangles:</p></blockquote><p>Cornell Box里面一般都有两个相对墙面有些角度的长方体。首先我们先把轴对齐的长方体图元做出来。每个长方体是由6个平面构成的:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"aarect.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable_list.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">box</span> : <span class="keyword">public</span> hittable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">box</span>() {}</span><br><span class="line">    <span class="built_in">box</span>(<span class="type">const</span> vec3&amp; p0, <span class="type">const</span> vec3&amp; p1, shared_ptr&lt;material&gt; ptr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(box_min, box_max);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 box_min;</span><br><span class="line">    vec3 box_max;</span><br><span class="line">    hittable_list sides;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">box::<span class="built_in">box</span>(<span class="type">const</span> vec3&amp; p0, <span class="type">const</span> vec3&amp; p1, shared_ptr&lt;material&gt; ptr) {</span><br><span class="line">    box_min = p0;</span><br><span class="line">    box_max = p1;</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p1.<span class="built_in">z</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">y</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">y</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">x</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">x</span>(), ptr));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box::hit</span><span class="params">(<span class="type">const</span> ray &amp;r, <span class="type">double</span> t0, <span class="type">double</span> t1, hit_record &amp;rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> sides.<span class="built_in">hit</span>(r, t0, t1, rec);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Now we can add two blocks (but not rotated)</p></blockquote><p>现在我们可以加入两个长方体了(但是没有旋转的角度)</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"box.h"</span></span></span><br><span class="line">...</span><br><span class="line">objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>), <span class="built_in">point3</span>(<span class="number">295</span>, <span class="number">165</span>, <span class="number">230</span>), white));</span><br><span class="line">objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>), <span class="built_in">point3</span>(<span class="number">430</span>, <span class="number">330</span>, <span class="number">460</span>), white));</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.19-cornell-blocks.png"></p><blockquote><p>Now that we have boxes, we need to rotate them a bit to have them match the <em>real</em> Cornell box. In ray tracing, this is usually done with an <em>instance</em>. An instance is a geometric primitive that has been moved or rotated somehow. This is especially easy in ray tracing because we don’t move anything; instead we move the rays in the opposite direction. For example, consider a <em>translation</em> (often called a <em>move</em>). We could take the pink box at the origin and add 2 to all its x components, or (as we almost always do in ray tracing) leave the box where it is, but in its hit routine subtract 2 off the x-component of the ray origin.</p></blockquote><p>现在我们有了这两个长方体, 为了让它看上去更加接近<strong>正宗</strong>的Cornell Box, 我们还需要让他旋转一下。在光线追踪中, 我们时常使用**实例(instance)**来完成这个工作。实例是一种经过旋转过或者平移等操作的几何图元。在光线追踪中, 这其实很简单。我们并不需要去移动任何东西。相对的, 我们只需将射线。举例来说, 想象一个**平移**操作, 我们可以将位于原点的粉红色盒子所有的组成部分的的x值+2, 或者就把盒子放在那里, 然后在hit函数中, 相对的将射线的原点-2。(这也是我们在ray tracing中惯用的做法) <em>【译注: 射线原点-2计算出hit record后, 得到是左边盒子, 最后还要将计算结果+2, 才能获得正确的射入点(右边盒子)】</em></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.06-ray-box.jpg"></p><h4 id="Instance-Translation"><a href="#Instance-Translation" class="headerlink" title="Instance Translation"></a>Instance Translation</h4><blockquote><p>Whether you think of this as a move or a change of coordinates is up to you. The code for this, to move any underlying hittable is a <em>translate</em> instance.</p></blockquote><p>你把刚刚的这个操作当成是平移还是坐标系的转换都行, 随你的喜好。移动hittable类的translate的代码如下:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">translate</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">translate</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> vec3&amp; displacement)</span><br><span class="line">            : <span class="built_in">ptr</span>(p), <span class="built_in">offset</span>(displacement) {}</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">        vec3 offset;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="function">ray <span class="title">moved_r</span><span class="params">(r.origin() - offset, r.direction(), r.time())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(moved_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    rec.p += offset;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(moved_r, rec.normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">bounding_box</span>(t0, t1, output_box))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        output_box.<span class="built_in">min</span>() + offset,</span><br><span class="line">        output_box.<span class="built_in">max</span>() + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Instance-Rotation"><a href="#Instance-Rotation" class="headerlink" title="Instance Rotation"></a>Instance Rotation</h4><blockquote><p>Rotation isn’t quite as easy to understand or generate the formulas for. A common graphics tactic is to apply all rotations about the x, y, and z axes. These rotations are in some sense axis-aligned. First, let’s rotate by theta about the z-axis. That will be changing only x and y, and in ways that don’t depend on z.</p></blockquote><p>旋转就没有那么容易理解或列出算式了。一个常用的图像技巧是将所有的旋转都当成是绕xyz轴旋转。首先, 让我们绕z轴旋转。这样只会改变xy而不会改变z值。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://raytracing.github.io/images/fig-2.07-rot-z.jpg" alt="img"></p><blockquote><p>This involves some basic trigonometry that uses formulas that I will not cover here. That gives you the correct impression it’s a little involved, but it is straightforward, and you can find it in any graphics text and in many lecture notes. The result for rotating counter-clockwise about z is:</p></blockquote><p>这里包含了一些三角几何. 我这里就不展开了。你要知道这其实很简单, 并不需要太多的几何知识, 你能在任何一本图形学的教材或者课堂笔记中找到它。绕z轴逆时针旋转的公式如下:</p><p>$x’ = \cos(\theta) \cdot x - \sin(\theta) \cdot y$</p><p>$y’ = \sin(\theta) \cdot x + \cos(\theta) \cdot y$</p><blockquote><p>The great thing is that it works for any 𝜃 and doesn’t need any cases for quadrants or anything like that. The inverse transform is the opposite geometric operation: rotate by −𝜃. Here, recall that $\cos(𝜃)=\cos(−𝜃)$ and $\sin(−𝜃)=−\sin(𝜃)$, so the formulas are very simple.</p></blockquote><p>这个公式的伟大之处在于它对任何θθ都成立, 你完全不用去考虑什么象限啊或者别的类似的东西。如果要顺时针旋转, 只需把 θ 改成 −θ 即可。来, 回想一下$\cos(θ)=\cos(−θ)$ 和 $\sin(−θ)=−\sin(θ)$, 所以逆运算的公式很简单。</p><blockquote><p>Similarly, for rotating about y (as we want to do for the blocks in the box) the formulas are:</p></blockquote><p>类似的, 绕y轴旋转(也正是我们相对这两个长方体做的事情)的公式如下:</p><p>$x’ = \cos(\theta) \cdot x + \sin(\theta) \cdot z$</p><p>$z’ = -\sin(\theta) \cdot x + \cos(\theta) \cdot z$</p><blockquote><p>And about the x-axis:</p></blockquote><p>绕x轴旋转的公式如下:</p><p>$y’ = \cos(\theta) \cdot y - \sin(\theta) \cdot z$</p><p>$z’ = \sin(\theta) \cdot y + \cos(\theta) \cdot z$​</p><blockquote><p>Unlike the situation with translations, the surface normal vector also changes, so we need to transform directions too if we get a hit. Fortunately for rotations, the same formulas apply. If you add scales, things get more complicated. See the web page <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> for links to that.</p><p>For a y-rotation class we have:</p></blockquote><p>和平移变换不同, 旋转时表面法向也发生了变化。所以在计算完hit函数后我们还要重新计算法向量。幸好对于旋转来说, 我们对法向量使用相同的公式变换一下即可。如果你加入了缩放(Scale), 那么这下事情就复杂多了。点击我们的网页 <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> 了解详细信息。</p><p>对一个绕y轴的旋转变换来说, 我们有:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rotate_y</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">            output_box = bbox;</span><br><span class="line">            <span class="keyword">return</span> hasbox;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">        <span class="type">double</span> sin_theta;</span><br><span class="line">        <span class="type">double</span> cos_theta;</span><br><span class="line">        <span class="type">bool</span> hasbox;</span><br><span class="line">        aabb bbox;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>With constructor:</p></blockquote><p>加上构造函数:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">rotate_y::<span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle) : <span class="built_in">ptr</span>(p) {</span><br><span class="line">    <span class="keyword">auto</span> radians = <span class="built_in">degree_to_radians</span>(angle);</span><br><span class="line">    sin_theta = <span class="built_in">sin</span>(radians);</span><br><span class="line">    cos_theta = <span class="built_in">cos</span>(radians);</span><br><span class="line">    hasbox = ptr-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">1</span>, bbox);</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">min</span><span class="params">( infinity,  infinity,  infinity)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">max</span><span class="params">(-infinity, -infinity, -infinity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) {</span><br><span class="line">                <span class="keyword">auto</span> x = i*bbox.<span class="built_in">max</span>().<span class="built_in">x</span>() + (<span class="number">1</span>-i)*bbox.<span class="built_in">min</span>().<span class="built_in">x</span>();</span><br><span class="line">                <span class="keyword">auto</span> y = j*bbox.<span class="built_in">max</span>().<span class="built_in">y</span>() + (<span class="number">1</span>-j)*bbox.<span class="built_in">min</span>().<span class="built_in">y</span>();</span><br><span class="line">                <span class="keyword">auto</span> z = k*bbox.<span class="built_in">max</span>().<span class="built_in">z</span>() + (<span class="number">1</span>-k)*bbox.<span class="built_in">min</span>().<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> newx =  cos_theta*x + sin_theta*z;</span><br><span class="line">                <span class="keyword">auto</span> newz = -sin_theta*x + cos_theta*z;</span><br><span class="line"></span><br><span class="line">                <span class="function">vec3 <span class="title">tester</span><span class="params">(newx, y, newz)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++) {</span><br><span class="line">                    min[c] = <span class="built_in">ffmin</span>(min[c], tester[c]);</span><br><span class="line">                    max[c] = <span class="built_in">ffmax</span>(max[c], tester[c]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    bbox = <span class="built_in">aabb</span>(min, max);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the hit function:</p></blockquote><p>以及hit函数:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rotate_y::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    vec3 origin = r.<span class="built_in">origin</span>();</span><br><span class="line">    vec3 direction = r.<span class="built_in">direction</span>();</span><br><span class="line"></span><br><span class="line">    origin[<span class="number">0</span>] = cos_theta*r.<span class="built_in">origin</span>()[<span class="number">0</span>] - sin_theta*r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    origin[<span class="number">2</span>] = sin_theta*r.<span class="built_in">origin</span>()[<span class="number">0</span>] + cos_theta*r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    direction[<span class="number">0</span>] = cos_theta*r.<span class="built_in">direction</span>()[<span class="number">0</span>] - sin_theta*r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line">    direction[<span class="number">2</span>] = sin_theta*r.<span class="built_in">direction</span>()[<span class="number">0</span>] + cos_theta*r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">rotated_r</span><span class="params">(origin, direction, r.time())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(rotated_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    vec3 p = rec.p;</span><br><span class="line">    vec3 normal = rec.normal;</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] =  cos_theta*rec.p[<span class="number">0</span>] + sin_theta*rec.p[<span class="number">2</span>];</span><br><span class="line">    p[<span class="number">2</span>] = -sin_theta*rec.p[<span class="number">0</span>] + cos_theta*rec.p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    normal[<span class="number">0</span>] =  cos_theta*rec.normal[<span class="number">0</span>] + sin_theta*rec.normal[<span class="number">2</span>];</span><br><span class="line">    normal[<span class="number">2</span>] = -sin_theta*rec.normal[<span class="number">0</span>] + cos_theta*rec.normal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    rec.p = p;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(rotated_r, normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the changes to Cornell are:</p></blockquote><p>并且修改一下生成cornell box的Cornell函数:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1,  <span class="number">15</span>);</span><br><span class="line">box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>,<span class="number">0</span>,<span class="number">295</span>));</span><br><span class="line">objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">165</span>,<span class="number">165</span>,<span class="number">165</span>), white);</span><br><span class="line">box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>,<span class="number">0</span>,<span class="number">65</span>));</span><br><span class="line">objects.<span class="built_in">add</span>(box2);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which yields:</p></blockquote><p>最后得到:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.20-cornell-standard.png"></p><h3 id="体积体"><a href="#体积体" class="headerlink" title="体积体"></a>体积体</h3><blockquote><p>One thing it’s nice to add to a ray tracer is smoke/fog/mist. These are sometimes called <em>volumes</em> or <em>participating media</em>. Another feature that is nice to add is subsurface scattering, which is sort of like dense fog inside an object. This usually adds software architectural mayhem because volumes are a different animal than surfaces, but a cute technique is to make a volume a random surface. A bunch of smoke can be replaced with a surface that probabilistically might or might not be there at every point in the volume. This will make more sense when you see the code.</p></blockquote><p>给光线追踪器加入烟/雾/水汽是一件很不错的事情。这些东西常常被称为体积体(volumes)或者可参与介质(participating media)。次表面散射(sub surface scatter, SSS)是另一个不错的特性, 有点像物体内部的浓雾。加入这部分内容会导致代码结构的混乱。因为体积体和平面表面是完全不同的两种东西。但我们有一个可爱的小技巧: 将体积体表示为一个随机表面。一团烟雾在其实可以用一个概率上不确定在什么位置的平面来代替。当你看到代码后, 你就会更有感觉了。</p><h4 id="Constant-Density-Mediums"><a href="#Constant-Density-Mediums" class="headerlink" title="Constant Density Mediums"></a>Constant Density Mediums</h4><blockquote><p>First, let’s start with a volume of constant density. A ray going through there can either scatter inside the volume, or it can make it all the way through like the middle ray in the figure. More thin transparent volumes, like a light fog, are more likely to have rays like the middle one. How far the ray has to travel through the volume also determines how likely it is for the ray to make it through.</p></blockquote><p>首先让我们来生成一个固定密度的体积体。光线可以在体积体内部发生散射, 也可以像图中的中间那条射线一样直接穿过去。体积体越薄越透明, 直接穿过去的情况就越有可能会发生。光线在体积体中直线传播所经过的距离也决定了光线采用图中哪种方式通过体积体。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-2.08-ray-vol.jpg"></p><blockquote><p>As the ray passes through the volume, it may scatter at any point. The denser the volume, the more likely that is. The probability that the ray scatters in any small distance Δ𝐿 is:</p></blockquote><p>当光线射入体积体时, 它可能在任意一点发生散射。体积体越浓, 越可能发生散射。在任意微小的距离差 $ΔL$ 发生散射的概率如下:</p><p>$probability = C \cdot \Delta L$</p><blockquote><p>where 𝐶 is proportional to the optical density of the volume. If you go through all the differential equations, for a random number you get a distance where the scattering occurs. If that distance is outside the volume, then there is no “hit”. For a constant volume we just need the density 𝐶 and the boundary. I’ll use another hittable for the boundary. The resulting class is:</p></blockquote><p>其中 C 是体积体的光学密度比例常数。 经过了一系列不同的等式运算, 你将会随机的得到一个光线发生散射的距离值。如果根据这个距离来说, 散射点在体积体外, 那么我们认为没有相交, 不调用<code>hit</code>函数。对于一个静态的体积体来说, 我们只需要他的密度 C 和边界。我会用另一个hittable物体来表示体积体的边界:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hittable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"material.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constant_medium</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, shared_ptr&lt;texture&gt; a)</span><br><span class="line">            : <span class="built_in">boundary</span>(b), <span class="built_in">neg_inv_density</span>(<span class="number">-1</span>/d)</span><br><span class="line">        {</span><br><span class="line">            phase_function = <span class="built_in">make_shared</span>&lt;isotropic&gt;(a);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> t0, <span class="type">double</span> t1, aabb&amp; output_box)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> boundary-&gt;<span class="built_in">bounding_box</span>(t0, t1, output_box);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; boundary;</span><br><span class="line">        shared_ptr&lt;material&gt; phase_function;</span><br><span class="line">        <span class="type">double</span> neg_inv_density;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The scattering function of isotropic picks a uniform random direction:</p></blockquote><p>对于散射的方向来说, 我们采用各项同性(isotropic)的随机单位向量大法</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">isotropic</span> : <span class="keyword">public</span> material {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">isotropic</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) {}</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="type">const</span>  </span>{</span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">random_in_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">            attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;texture&gt; albedo;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the hit function is:</p></blockquote><p>hit函数如下:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">constant_medium::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="comment">// Print occasional samples when debugging. To enable, set enableDebug true.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableDebug = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> debugging = enableDebug &amp;&amp; <span class="built_in">random_double</span>() &lt; <span class="number">0.00001</span>;</span><br><span class="line"></span><br><span class="line">    hit_record rec1, rec2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, -infinity, infinity, rec1))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, rec1.t+<span class="number">0.0001</span>, infinity, rec2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) std::cerr &lt;&lt; <span class="string">"\nt0="</span> &lt;&lt; rec1.t &lt;&lt; <span class="string">", t1="</span> &lt;&lt; rec2.t &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; t_min) rec1.t = t_min;</span><br><span class="line">    <span class="keyword">if</span> (rec2.t &gt; t_max) rec2.t = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &gt;= rec2.t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; <span class="number">0</span>)</span><br><span class="line">        rec1.t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ray_length = r.<span class="built_in">direction</span>().<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> distance_inside_boundary = (rec2.t - rec1.t) * ray_length;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> hit_distance = neg_inv_density * <span class="built_in">log</span>(<span class="built_in">random_double</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hit_distance &gt; distance_inside_boundary)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    rec.t = rec1.t + hit_distance / ray_length;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"hit_distance = "</span> &lt;&lt;  hit_distance &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">                  &lt;&lt; <span class="string">"rec.t = "</span> &lt;&lt;  rec.t &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">                  &lt;&lt; <span class="string">"rec.p = "</span> &lt;&lt;  rec.p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rec.normal = <span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">// arbitrary</span></span><br><span class="line">    rec.front_face = <span class="literal">true</span>;     <span class="comment">// also arbitrary</span></span><br><span class="line">    rec.mat_ptr = phase_function;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The reason we have to be so careful about the logic around the boundary is we need to make sure this works for ray origins inside the volume. In clouds, things bounce around a lot so that is a common case.</p></blockquote><p>我们一定要小心与边界相关的逻辑, 因为我们要确保当射线原点在体积体内部时, 光线依然会发生散射。在云中, 光线反复发生散射, 这是一种很常见的现象。</p><blockquote><p>In addition, the above code assumes that once a ray exits the constant medium boundary, it will continue forever outside the boundary. Put another way, it assumes that the boundary shape is convex. So this particular implementation will work for boundaries like boxes or spheres, but will not work with toruses or shapes that contain voids. It’s possible to write an implementation that handles arbitrary shapes, but we’ll leave that as an exercise for the reader.</p></blockquote><p>另外, 上述代码只能确保射线只会射入体积体一次, 之后再也不进入体积体的情况。换句话说, 它假定体积体的边界是一个凸几何体。所以这个狭义的实现只对球体或者长方体这样的物体生效。但是对于当中有洞的那种形状, 如甜甜圈就不行了。写一个能处理任意形状的实现是完全可行的, 但我们把这部分内容留给我们的读者作为练习。</p><h4 id="Rendering-a-Cornell-Box-with-Smoke-and-Fog-Boxes"><a href="#Rendering-a-Cornell-Box-with-Smoke-and-Fog-Boxes" class="headerlink" title="Rendering a Cornell Box with Smoke and Fog Boxes"></a>Rendering a Cornell Box with Smoke and Fog Boxes</h4><blockquote><p>If we replace the two blocks with smoke and fog (dark and light particles), and make the light bigger (and dimmer so it doesn’t blow out the scene) for faster convergence:</p></blockquote><p>如果我们将两个长方体替换为烟和雾(深色与浅色的粒子)并使用一个更大的灯光(同时更加昏暗以至于不会炸了这个场景)让场景更快的融合在一起。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"constant_medium.h"</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_smoke</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.65</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.73</span>, <span class="number">0.73</span>, <span class="number">0.73</span>)));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.12</span>, <span class="number">0.45</span>, <span class="number">0.15</span>)));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>)));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">113</span>, <span class="number">443</span>, <span class="number">127</span>, <span class="number">432</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white)));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">165</span>,<span class="number">330</span>,<span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1,  <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>,<span class="number">0</span>,<span class="number">295</span>));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">165</span>,<span class="number">165</span>,<span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>,<span class="number">0</span>,<span class="number">65</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;constant_medium&gt;(box1, <span class="number">0.01</span>, <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))));</span><br><span class="line">    objects.<span class="built_in">add</span>(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;constant_medium&gt;(box2, <span class="number">0.01</span>, <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We get:</p></blockquote><p>我们会得到:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.21-cornell-smoke.png"></p><h3 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h3><blockquote><p>Let’s put it all together, with a big thin mist covering everything, and a blue subsurface reflection sphere (we didn’t implement that explicitly, but a volume inside a dielectric is what a subsurface material is). The biggest limitation left in the renderer is no shadow rays, but that is why we get caustics and subsurface for free. It’s a double-edged design decision.</p></blockquote><p>让我们把所有东西放在一起吧!使用一个薄雾盖住所有东西, 并加入一个蓝色的次表面反射球体(这种说法不太清楚, 实际上次表面材质就是在电介质内部填充体积体)。现在这个渲染器的最大局限就是没有阴影光线。但是因此我们能不花代价的得到散焦和次表面。这是一把设计上的双刃剑。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">final_scene</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list boxes1;</span><br><span class="line">    <span class="keyword">auto</span> ground =</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.48</span>, <span class="number">0.83</span>, <span class="number">0.53</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> boxes_per_side = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boxes_per_side; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boxes_per_side; j++) {</span><br><span class="line">            <span class="keyword">auto</span> w = <span class="number">100.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x0 = <span class="number">-1000.0</span> + i*w;</span><br><span class="line">            <span class="keyword">auto</span> z0 = <span class="number">-1000.0</span> + j*w;</span><br><span class="line">            <span class="keyword">auto</span> y0 = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x1 = x0 + w;</span><br><span class="line">            <span class="keyword">auto</span> y1 = <span class="built_in">random_double</span>(<span class="number">1</span>,<span class="number">101</span>);</span><br><span class="line">            <span class="keyword">auto</span> z1 = z0 + w;</span><br><span class="line"></span><br><span class="line">            boxes1.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">vec3</span>(x0,y0,z0), <span class="built_in">vec3</span>(x1,y1,z1), ground));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes1, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">123</span>, <span class="number">423</span>, <span class="number">147</span>, <span class="number">412</span>, <span class="number">554</span>, light));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> center1 = <span class="built_in">vec3</span>(<span class="number">400</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">auto</span> center2 = center1 + <span class="built_in">vec3</span>(<span class="number">30</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> moving_sphere_material =</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.1</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;moving_sphere&gt;(center1, center2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, moving_sphere_material));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.9</span>), <span class="number">10.0</span>)</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">70</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(boundary);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(</span><br><span class="line">        boundary, <span class="number">0.2</span>, <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.9</span>))</span><br><span class="line">    ));</span><br><span class="line">    boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5000</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(</span><br><span class="line">        boundary, <span class="number">.0001</span>, <span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nx, ny, nn;</span><br><span class="line">    <span class="keyword">auto</span> tex_data = <span class="built_in">stbi_load</span>(<span class="string">"earthmap.jpg"</span>, &amp;nx, &amp;ny, &amp;nn, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> emat = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;image_texture&gt;(tex_data, nx, ny));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">400</span>,<span class="number">200</span>, <span class="number">400</span>), <span class="number">100</span>, emat));</span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">0.1</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">220</span>,<span class="number">280</span>, <span class="number">300</span>), <span class="number">80</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    hittable_list boxes2;</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(<span class="built_in">vec3</span>(<span class="number">0.73</span>, <span class="number">0.73</span>, <span class="number">0.73</span>)));</span><br><span class="line">    <span class="type">int</span> ns = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ns; j++) {</span><br><span class="line">        boxes2.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(vec3::<span class="built_in">random</span>(<span class="number">0</span>,<span class="number">165</span>), <span class="number">10</span>, white));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;translate&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;rotate_y&gt;(</span><br><span class="line">            <span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes2, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">15</span>),</span><br><span class="line">            <span class="built_in">vec3</span>(<span class="number">-100</span>,<span class="number">270</span>,<span class="number">395</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Running it with 10,000 rays per pixel yields:</p></blockquote><p>每个像素点采样10,000次, 得到下图的结果:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-2.22-book2-final-20210730003326518.jpg"></p><blockquote><p>Now go off and make a really cool image of your own! See <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> for pointers to further reading and features, and feel free to email questions, comments, and cool images to me at <a href="mailto:ptrshrl@gmail.com.">ptrshrl@gmail.com.</a></p></blockquote><p>现在你可以合上这本书, 开始生成属于你自己的炫酷图片! 在 <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> 获取后续阅读内容和新特性, 如果你在阅读过程中遇到了问题, 或对本书有什么看法或评价, 或者想分享你的炫酷图片, 欢迎发送邮件到 <a href="mailto:ptrshrl@gmail.com">ptrshrl@gmail.com</a></p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/7dbe30e4.html" rel="bookmark">Blockwise Multi-Order Feature Regression for Real-Time Path Tracing Reconstruction</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/971404c0.html" rel="bookmark">Rendering Course by Wangningbei</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/7d20819.html" rel="prev" title="Triangles and Z-Buffering"><i class="fa fa-chevron-left"></i> Triangles and Z-Buffering</a></div><div class="post-nav-item"><a href="/archives/341aeb83.html" rel="next" title="序列模式">序列模式 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%A8%A1%E7%B3%8A"><span class="nav-number">3.</span> <span class="nav-text">动态模糊</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduction-of-SpaceTime-Ray-Tracing"><span class="nav-number">3.1.</span> <span class="nav-text">Introduction of SpaceTime Ray Tracing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Updating-the-Camera-to-Simulate-Motion-Blur"><span class="nav-number">3.2.</span> <span class="nav-text">Updating the Camera to Simulate Motion Blur</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adding-Moving-Spheres"><span class="nav-number">3.3.</span> <span class="nav-text">Adding Moving Spheres</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tracking-the-Time-of-Ray-Intersection"><span class="nav-number">3.4.</span> <span class="nav-text">Tracking the Time of Ray Intersection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Putting-Everything-Together"><span class="nav-number">3.5.</span> <span class="nav-text">Putting Everything Together</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E5%8C%85%E5%9B%B4%E7%9B%92"><span class="nav-number">4.</span> <span class="nav-text">层次包围盒</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Key-Idea"><span class="nav-number">4.1.</span> <span class="nav-text">The Key Idea</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hierarchies-of-Bounding-Volumes"><span class="nav-number">4.2.</span> <span class="nav-text">Hierarchies of Bounding Volumes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Axis-Aligned-Bounding-Boxes-AABBs"><span class="nav-number">4.3.</span> <span class="nav-text">Axis-Aligned Bounding Boxes (AABBs)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ray-Intersection-with-an-AABB"><span class="nav-number">4.4.</span> <span class="nav-text">Ray Intersection with an AABB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#An-Optimized-AABB-Hit-Method"><span class="nav-number">4.5.</span> <span class="nav-text">An Optimized AABB Hit Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructing-Bounding-Boxes-for-Hittables"><span class="nav-number">4.6.</span> <span class="nav-text">Constructing Bounding Boxes for Hittables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-Bounding-Boxes-of-Lists-of-Objects"><span class="nav-number">4.7.</span> <span class="nav-text">Creating Bounding Boxes of Lists of Objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-BVH-Node-Class"><span class="nav-number">4.8.</span> <span class="nav-text">The BVH Node Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Splitting-BVH-Volumes"><span class="nav-number">4.9.</span> <span class="nav-text">Splitting BVH Volumes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Box-Comparison-Functions"><span class="nav-number">4.10.</span> <span class="nav-text">The Box Comparison Functions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">固体贴图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-First-Texture-Class-Constant-Texture"><span class="nav-number">5.1.</span> <span class="nav-text">The First Texture Class: Constant Texture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A-Checker-Texture"><span class="nav-number">5.2.</span> <span class="nav-text">A Checker Texture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rendering-a-Scene-with-a-Checkered-Texture"><span class="nav-number">5.3.</span> <span class="nav-text">Rendering a Scene with a Checkered Texture</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%8F%E6%9E%97%E5%99%AA%E9%9F%B3"><span class="nav-number">6.</span> <span class="nav-text">柏林噪音</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-Blocks-of-Random-Numbers"><span class="nav-number">6.1.</span> <span class="nav-text">Using Blocks of Random Numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Smoothing-out-the-Result"><span class="nav-number">6.2.</span> <span class="nav-text">Smoothing out the Result</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Improvement-with-Hermitian-Smoothing"><span class="nav-number">6.3.</span> <span class="nav-text">Improvement with Hermitian Smoothing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tweaking-The-Frequency"><span class="nav-number">6.4.</span> <span class="nav-text">Tweaking The Frequency</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-Random-Vectors-on-the-Lattice-Points"><span class="nav-number">6.5.</span> <span class="nav-text">Using Random Vectors on the Lattice Points</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Introducing-Turbulence"><span class="nav-number">6.6.</span> <span class="nav-text">Introducing Turbulence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adjusting-the-Phase"><span class="nav-number">6.7.</span> <span class="nav-text">Adjusting the Phase</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84"><span class="nav-number">7.</span> <span class="nav-text">纹理映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Storing-Texture-Image-Data"><span class="nav-number">7.1.</span> <span class="nav-text">Storing Texture Image Data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-an-Image-Texture"><span class="nav-number">7.2.</span> <span class="nav-text">Using an Image Texture</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%92%8C%E5%85%89%E6%BA%90"><span class="nav-number">8.</span> <span class="nav-text">矩阵和光源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Emissive-Materials"><span class="nav-number">8.1.</span> <span class="nav-text">Emissive Materials</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adding-Background-Color-to-the-Ray-Color-Function"><span class="nav-number">8.2.</span> <span class="nav-text">Adding Background Color to the Ray Color Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-Rectangle-Objects"><span class="nav-number">8.3.</span> <span class="nav-text">Creating Rectangle Objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Turning-Objects-into-Lights"><span class="nav-number">8.4.</span> <span class="nav-text">Turning Objects into Lights</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#More-Axis-Aligned-Rectangles"><span class="nav-number">8.5.</span> <span class="nav-text">More Axis-Aligned Rectangles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-an-Empty-%E2%80%9CCornell-Box%E2%80%9D"><span class="nav-number">8.6.</span> <span class="nav-text">Creating an Empty “Cornell Box”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">9.</span> <span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Instance-Translation"><span class="nav-number">9.1.</span> <span class="nav-text">Instance Translation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Instance-Rotation"><span class="nav-number">9.2.</span> <span class="nav-text">Instance Rotation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%93%E7%A7%AF%E4%BD%93"><span class="nav-number">10.</span> <span class="nav-text">体积体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Constant-Density-Mediums"><span class="nav-number">10.1.</span> <span class="nav-text">Constant Density Mediums</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rendering-a-Cornell-Box-with-Smoke-and-Fog-Boxes"><span class="nav-number">10.2.</span> <span class="nav-text">Rendering a Cornell Box with Smoke and Fog Boxes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF"><span class="nav-number">11.</span> <span class="nav-text">测试场景</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">296</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">47</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.5m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
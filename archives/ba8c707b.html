<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Keyclack posters by        Mohamed Chahin               引言力扣提供海量题库，帮助你高效提升编程技能，轻松拿下世界 IT 名企 Dream Offer。本文作为博主的LeetCode刷题记录，包含基于C++的解题思路与完整代码以供参考学习。"><meta property="og:type" content="article"><meta property="og:title" content="LeetCode刷题记录"><meta property="og:url" content="https://yousazoe.top/archives/ba8c707b.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Keyclack posters by        Mohamed Chahin               引言力扣提供海量题库，帮助你高效提升编程技能，轻松拿下世界 IT 名企 Dream Offer。本文作为博主的LeetCode刷题记录，包含基于C++的解题思路与完整代码以供参考学习。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/beb27864152259.5ac8b75847ad9-20210303093009942.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/addtwonumber1.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/question_11.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/remove_ex1.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p3.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/d502a4ee32fc8b7e7dbaadb3c3378b4a48507295bce12768cb2b6c82a3671c2e-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rainwatertrap.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/6db1fe9019dfbf4d5c2e472112c5cd227925d4b5a99ac48cd2a2779d2535b6ce-Snipaste_2019-05-11_18-02-16.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1617673689-HwNHJA-80.gif"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/histogram.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/histogram-1-20211230215250929.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev2ex2.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist_test2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist_test3.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist-20211217215034089.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist_test2-20211217215118016.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist_test3-20211217215152769.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/jianzhi_II_022_fig1-20211217215410978.png"><meta property="og:image" content="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png"><meta property="og:image" content="https://pic.leetcode-cn.com/1626420320-YUiulT-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1634694986-QSFMuX-aa.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_statement-20211218222551745.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_1_1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_2-20211218222840916.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_3-20211218222946270.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123481-fdeApj-image-20211218222217465.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123467-zeofGx-image-20211218222141874.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123497-pwIiFq-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629516721-xcbSKy-2bdd85f029f86f2e9708a61edccdc1a-20220107162514225.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev1ex1.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev1ex2.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/20211220163756.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/pal2linked-list.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/237_example.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/3579a496897df5321c110bf1301872b6e10c342f5e400ce45d2db0348d00d715-file_1555866623326.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/902dc5d3f8c44d3cbc0b6e837711cad2eefc021fd2b9de8dfabc6d478bc779b1-file_1555866680932.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626332422-wUpUHT-image-20211216174726957.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628949136-zQFMmB-e740f25c4850f72eae2482bb42cfc36.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628949854-YEDxST-5424205ebc953c73cf8381aa53f7bc2.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/TIM%E6%88%AA%E5%9B%BE20200518232849-3.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png-20211231183823285.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png-20211221123721524.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/multilevellinkedlist.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/multilevellinkedlistflattened.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1-20211220193435939.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626420025-fZfzMX-image-20211218224204036.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree1-20220107161653527.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree2-20220107161730654.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629516028-QgimFe-2ec6bf9d0c6a8c23ba023583bfeacf6-20220107161930201.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629514102-NbQgoB-477afe8550c13a4e1e3c0e726bdf67a-20220102233928707.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628958996-hWmHxz-10139da0979df36b9067b22886a0890.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/example_1_before_65p-20211220220147609.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/example_1_after_65p-20211220220218531.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629345113-XXdGKZ-f1dbb5feb6708bc5ec400d978eea73a-20211226205629348.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/a24107cefeff7239068268099db90671254c2d357857232f19dc21bdaace5774-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629473154-gKRqvU-ce27c552f3c1d653d97978cf52b4b0d-20220102232041162.jpg"><meta property="article:published_time" content="2021-02-26T05:16:45.000Z"><meta property="article:modified_time" content="2022-09-29T01:17:36.455Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="LeetCode"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Online Judge"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/beb27864152259.5ac8b75847ad9-20210303093009942.jpg"><link rel="canonical" href="https://yousazoe.top/archives/ba8c707b.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>LeetCode刷题记录 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/ba8c707b.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">LeetCode刷题记录</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-02-26 13:16:45" itemprop="dateCreated datePublished" datetime="2021-02-26T13:16:45+08:00">2021-02-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/LeetCode%E9%A2%98%E8%A7%A3-LeetCode-Solution/" itemprop="url" rel="index"><span itemprop="name">LeetCode题解 (LeetCode Solution)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>66k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>2:01</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/beb27864152259.5ac8b75847ad9-20210303093009942.jpg"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://www.behance.net/gallery/64152259/Keyclack-posters">Keyclack posters</a> by <a target="_blank" rel="noopener" href="https://www.behance.net/MChahin">Mohamed Chahin</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>力扣提供海量题库，帮助你高效提升编程技能，轻松拿下世界 IT 名企 Dream Offer。本文作为博主的LeetCode刷题记录，包含基于C++的解题思路与完整代码以供参考学习。</p><span id="more"></span><blockquote><p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/">https://leetcode-cn.com</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="两数之和-1"><a href="#两数之和-1" class="headerlink" title="两数之和[1]"></a>两数之和[1]</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ul><li>2 &lt;= nums.length &lt;= 103</li><li>$-10^9$ &lt;= nums[i] &lt;= $10^9$</li><li>$-10^9$ &lt;= target &lt;= $10^9$</li><li>只会存在一个有效答案</li></ul><h4 id="默认模板"><a href="#默认模板" class="headerlink" title="默认模板"></a>默认模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h5><p>这道题很像AOJ中的一道题，那时候我就用的这种二次循环的遍历方式枚举每一种情况。需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++){</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target){</span><br><span class="line">                    v[<span class="number">0</span>] = i;</span><br><span class="line">                    v[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="两数相加-2"><a href="#两数相加-2" class="headerlink" title="两数相加[2]"></a>两数相加[2]</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/addtwonumber1.jpg"></p><br><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>这道题涉及到了链表的知识。我一开始的想法是先把链表遍历导出到比较方便访问的数据结构比如<code>vector</code>然后再倒置最后相加，后面开始写伪代码的时候困难重重，比较难实现所以就放弃了这个思路。</p><p>之后参考了精选解题的思路，对于两个链表节点个数不同的情况我们可以选择将节点数较小的那个表补零，比如<code>l1=[2,0,4,3]</code>、<code>l2=[5,6,8]</code>，此时<code>l2</code>少一个节点，那么我们就可以对<code>l2</code>补零为<code>[5,6,8,0]</code>使之节点数相同。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> len1 = <span class="number">0</span>,len2 = <span class="number">0</span>;</span><br><span class="line">ListNode* p = l1;</span><br><span class="line">ListNode* q = l2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">  len1++;</span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">  len2++;</span><br><span class="line">  q = q-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ListNode* zero = len1 &gt; len2 ? q : p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len1 - len2;i++){</span><br><span class="line">  zero-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">  zero = zero-&gt;next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>l1</code>与<code>l2</code>位数相同后该考虑的就是相加的问题，这个其实就简单很多了，设置一个用于进位的<code>carry</code>负责下一位的进制，而对于输出的链表<code>l3</code>而言<code>sum%10</code>就是它在该位置上的值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> len1 = <span class="number">0</span>,len2 = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = l1;</span><br><span class="line">        ListNode* q = l2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">            len1++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">            len2++;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ListNode* zero = len1 &gt; len2 ? q : p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len1 - len2;i++){</span><br><span class="line">            zero-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            zero = zero-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        p = l1;</span><br><span class="line">        q = l2;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">        ListNode* l3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* r = l3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>){</span><br><span class="line">            sum = carry + p-&gt;val + q-&gt;val;</span><br><span class="line">            r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            carry = sum &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l3;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然而满怀欣喜的提交后倒在了<strong>1138</strong> 样例中，大家不妨先不往下翻，先带入该样例看看哪里出了问题。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2,4,9]</span><br><span class="line">[5,6,4,9]</span><br><span class="line">输出：</span><br><span class="line">[7,0,4,1]</span><br><span class="line">预期：</span><br><span class="line">[7,0,4,0,1]</span><br></pre></td></tr></tbody></table></figure><p>一检查源码问题可太多了：</p><ul><li>补零没有使用绝对值函数<code>abs()</code>，导致如果<code>len1&lt;len2</code>不会补零而实际上我们需要补零</li><li>没有考虑最后一位的情况，如果还有进制会导致结果出错（少一个最高位位的1）</li><li>结果输出实际上是从<code>l3-&gt;next</code>开始的，最初始的节点并没有派上用场</li></ul><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) {}</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) {}</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {</span><br><span class="line">        int len1 = 0,len2 = 0;</span><br><span class="line">        ListNode* p = l1;</span><br><span class="line">        ListNode* q = l2;</span><br><span class="line">        </span><br><span class="line">        while(p-&gt;next != NULL){</span><br><span class="line">            len1++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        while(q-&gt;next != NULL){</span><br><span class="line">            len2++;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ListNode* zero = len1 &gt; len2 ? q : p;</span><br><span class="line"><span class="deletion">-       for(int i = 0;i &lt; len1 - len2;i++){</span></span><br><span class="line"><span class="addition">+       for(int i = 0;i &lt; abs(len1 - len2);i++){</span></span><br><span class="line">            zero-&gt;next = new ListNode(0);</span><br><span class="line">            zero = zero-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        p = l1;</span><br><span class="line">        q = l2;</span><br><span class="line">        int carry = 0,sum = 0;</span><br><span class="line">        ListNode* l3 = new ListNode(0);</span><br><span class="line">        ListNode* r = l3;</span><br><span class="line"></span><br><span class="line">        while(p != NULL &amp;&amp; q != NULL){</span><br><span class="line">            sum = carry + p-&gt;val + q-&gt;val;</span><br><span class="line">            r-&gt;next = new ListNode(sum%10);</span><br><span class="line">            carry = sum &gt;= 10 ? 1 : 0;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        }</span><br><span class="line"><span class="addition">+        if(carry){</span></span><br><span class="line"><span class="addition">+            r-&gt;next = new ListNode(1);</span></span><br><span class="line"><span class="addition">+            r = r-&gt;next;</span></span><br><span class="line"><span class="addition">+        }</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-        return l3;</span></span><br><span class="line"><span class="addition">+        return l3-&gt;next;</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="无重复字符的最长子串-3"><a href="#无重复字符的最长子串-3" class="headerlink" title="无重复字符的最长子串[3]"></a>无重复字符的最长子串[3]</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "abcabcbb"</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "bbbbb"</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "pwwkew"</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = ""</span><br><span class="line">输出: 0</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><ul><li>0 &lt;= s.length &lt;= $5 * 10^4$</li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h4 id="默认模板-1"><a href="#默认模板-1" class="headerlink" title="默认模板"></a>默认模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>本题属于典型的滑动窗口问题，这类问题的逻辑基本上是这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()){</span><br><span class="line">  window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">  right++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(window needs shrink){</span><br><span class="line">    window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">    left++;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为左右指针只遍历字符串一次，所以时间复杂度为$O(N)$，比字符串暴力算法要高效的多。对上面的逻辑再加以整理，labuladong总结出一套滑动算法的代码框架：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span></span>{</span><br><span class="line">  unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; window;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()){</span><br><span class="line">    <span class="type">char</span> c = s[right];</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(window needs shrink){</span><br><span class="line">      <span class="type">char</span> d = s[left];</span><br><span class="line">      left++;</span><br><span class="line">      </span><br><span class="line">      ......</span><br><span class="line">    }  </span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中两处<code>...</code>表示更新窗口数据的地方，我们只需要在这里填入具体的窗口数据更新的逻辑即可，而且右移和左移的操作是完全对称的。</p><p>回到本题，很显然当<code>window[c]</code>的值大于1时窗口存在重复的字符，不满足题目要求，移动<code>left</code>缩小窗口。比较难理解的是<code>res = max(res,right - left);</code>，我们可以理解为一种另类的求最大值，虽然指针在不断滑动，但<code>res</code>与<code>right-left</code>求最大值保证了之前的最大值与现在可能超过的长度进行比较从而得出我们需要的最长子串。如果还有疑问或者不理解可以带入下面的求解过程体会：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(a)bcabcbb</span><br><span class="line">(ab)cabcbb</span><br><span class="line">(abc)abcbb</span><br><span class="line">abc(a)bcbb</span><br><span class="line">abc(ab)cbb</span><br><span class="line">abc(abc)bb</span><br><span class="line">abcabc(b)b</span><br><span class="line">abcabcb(b)</span><br></pre></td></tr></tbody></table></figure><p>最后完整源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; window;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="type">char</span> c = s[right++];</span><br><span class="line">            window[c]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>){</span><br><span class="line">                <span class="type">char</span> d = s[left++];</span><br><span class="line">                window[d]--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res,right - left);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="未解决-寻找两个正序数组的中位数-4"><a href="#未解决-寻找两个正序数组的中位数-4" class="headerlink" title="[未解决]寻找两个正序数组的中位数[4]"></a>[未解决]寻找两个正序数组的中位数[4]</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><h4 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-3"><a href="#示例-3-3" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums1 = [0,0], nums2 = [0,0]</span><br><span class="line">输出：0.00000</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-4-1"><a href="#示例-4-1" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums1 = [], nums2 = [1]</span><br><span class="line">输出：1.00000</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums1 = [2], nums2 = []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li>0 &lt;= m &lt;= 1000</li><li>0 &lt;= n &lt;= 1000</li><li>1 &lt;= m + n &lt;= 2000</li><li>$-10^6$ &lt;= nums1[i], nums2[i] &lt;= $10^6$</li></ul><p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p><h4 id="默认模板-2"><a href="#默认模板-2" class="headerlink" title="默认模板"></a>默认模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><h3 id="最长回文子串-5"><a href="#最长回文子串-5" class="headerlink" title="最长回文子串[5]"></a>最长回文子串[5]</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h4 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "babad"</span><br><span class="line">输出："bab"</span><br><span class="line">解释："aba" 同样是符合题意的答案。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "cbbd"</span><br><span class="line">输出："bb"</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-4"><a href="#示例-3-4" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "a"</span><br><span class="line">输出："a"</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-4-2"><a href="#示例-4-2" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "ac"</span><br><span class="line">输出："a"</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= s.length &lt;= 1000</li><li>s 仅由数字和英文字母（大写和/或小写）组成</li></ul><h4 id="默认模板-3"><a href="#默认模板-3" class="headerlink" title="默认模板"></a>默认模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>本题要求我们求出字符串中回文子串中长度最长的一个子串。</p><p>我们可以举两个回文串<code>aa</code>、<code>babab</code>来理解题目，首先回文串有<code>a</code>、<code>b</code>、<code>aa</code>、<code>bab</code>、<code>aba</code>、<code>babab</code>，可以观察到回文串有奇数和偶数两种情况，并且由于回文串对称的特性，我们应该不断判断字符串左右是否相同以保持这个对称的特性。</p><p>基于此我们可以先写出这个判断函数，内容就是以某个点为中心向左右两边发散，判断是否为回文串并返回最小的回文子串：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">traceMid2Side</span><span class="params">(string s,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>{</span><br><span class="line">  <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= s.<span class="built_in">length</span>() - <span class="number">1</span> &amp;&amp; s[left] == s[right]){</span><br><span class="line">				left--;</span><br><span class="line">        right++;</span><br><span class="line">  }</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(left + <span class="number">1</span>,right - left - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>命令第一个元素为最后返回的结果<code>res</code>，如果没有第一个元素返回空字符串。之后遍历字符串，按刚才依次从中间向左右寻找是否有回文子串以临时变量<code>tmp</code>储存，并比较与<code>res</code>的长度。</p><p>两次调用<code>traceMid2Side()</code>是考虑到之前提到的奇偶问题，奇数情况左右都是<code>i</code>，偶数情况左边是<code>i</code>右边是<code>i+1</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        string res = s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= len - <span class="number">2</span>;i++){</span><br><span class="line">            string tmp = <span class="built_in">traceMid2Side</span>(s,i,i);</span><br><span class="line">            <span class="keyword">if</span>(tmp.<span class="built_in">length</span>() &gt; res.<span class="built_in">length</span>())</span><br><span class="line">                res = tmp;</span><br><span class="line"></span><br><span class="line">            tmp = <span class="built_in">traceMid2Side</span>(s,i,i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp.<span class="built_in">length</span>() &gt; res.<span class="built_in">length</span>())</span><br><span class="line">                res = tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">traceMid2Side</span><span class="params">(string s,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= s.<span class="built_in">length</span>() - <span class="number">1</span> &amp;&amp; s[left] == s[right]){</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left + <span class="number">1</span>,right - left - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="Z-字形变换-6"><a href="#Z-字形变换-6" class="headerlink" title="Z 字形变换[6]"></a>Z 字形变换[6]</h3><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>"PAYPALISHIRING"</code> 行数为 <code>3</code> 时，排列如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></tbody></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>"PAHNAPLSIIGYIR"</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "PAYPALISHIRING", numRows = 3</span><br><span class="line">输出："PAHNAPLSIIGYIR"</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-5"><a href="#示例-2-5" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "PAYPALISHIRING", numRows = 4</span><br><span class="line">输出："PINALSIGYAHRPI"</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-5"><a href="#示例-3-5" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "A", numRows = 1</span><br><span class="line">输出："A"</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= s.length &lt;= 100</li><li><code>s</code> 由英文字母（小写和大写）、<code>','</code> 和 <code>'.'</code> 组成</li><li>1 &lt;= numRows &lt;= 1000</li></ul><h4 id="默认模板-4"><a href="#默认模板-4" class="headerlink" title="默认模板"></a>默认模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>本题是一个找规律的题，首先我们先观察给出样例的Z形排列中下标的变化，可以发现行数的变化是周期性的：0-1-2-1-0-……：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">PAYPALISHIRING</span><br><span class="line"></span><br><span class="line">0: P(0)      A(4)      H(8)        N(12)</span><br><span class="line">1: A(1) P(3) L(5) S(7) I(9)  I(11) G(13)</span><br><span class="line">2: Y(2)      I(6)      R(10)</span><br><span class="line"></span><br><span class="line">PAHKAPLSIIGYIR</span><br></pre></td></tr></tbody></table></figure><p>所以我们就以行数的周期反复为突破点，用字符串数组分别存储每行的字符串。在遍历字符串<code>s</code>时根据行数由<code>0</code>到<code>numRows</code>再到<code>0</code>，最后以<code>+</code>合并进<code>res</code>字符串即可：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        string res,z[numRows];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>()){</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numRows &amp;&amp; i &lt; s.<span class="built_in">length</span>(); ++j) {</span><br><span class="line">                z[j] += s[i++];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = numRows - <span class="number">2</span>; k &gt; <span class="number">0</span> &amp;&amp; i &lt; s.<span class="built_in">length</span>(); --k) {</span><br><span class="line">                z[k] += s[i++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numRows; ++j) {</span><br><span class="line">            res += z[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="整数反转-7"><a href="#整数反转-7" class="headerlink" title="整数反转[7]"></a>整数反转[7]</h3><p>给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 $[−2^{31}, 2^{31} − 1]$ ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><h4 id="示例-1-5"><a href="#示例-1-5" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-6"><a href="#示例-2-6" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：x = -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-6"><a href="#示例-3-6" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：x = 120</span><br><span class="line">输出：21</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-4-3"><a href="#示例-4-3" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：x = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h4><ul><li>$-2^{31}$ &lt;= x &lt;= $2^{31} - 1$</li></ul><h4 id="默认模板-5"><a href="#默认模板-5" class="headerlink" title="默认模板"></a>默认模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>本题考查的是C++字符串转换，主要使用了两个库函数：</p><ul><li><code>reverse()</code></li><li><code>stoll()</code></li></ul><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p><code>reverse()</code>函数功能是逆序（或反转），多用于字符串、数组、容器，头文件是<code>#include &lt;algorithm&gt;</code>。<code>reverse()</code>函数用于反转在<code>[first,last)</code>范围内的顺序（包括<code>first</code>指向的元素，不包括<code>last</code>指向的元素），<code>reverse()</code>函数无返回值。</p><p>举个例子来体会一下这个函数的用法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string str=<span class="string">"hello world , hi"</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//str结果为 ih , dlrow olleh</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>};</span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());<span class="comment">//容器v的值变为1,2,3,4,5</span></span><br></pre></td></tr></tbody></table></figure><h4 id="stoll"><a href="#stoll" class="headerlink" title="stoll"></a>stoll</h4><p><code>stoll()</code>函数功能是将字符串转换为<code>long long</code>，也就是解析<code>str</code>将其内容解释为指定基数的整数，并将其作为<code>long long</code>类型的值返回。如果<code>idx</code>不是空指针，则该函数还将<code>idx</code>的值设置为数字后str中第一个字符的位置。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">stoll</span> <span class="params">(<span class="type">const</span> string&amp;  str, <span class="type">size_t</span>* idx = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">stoll</span> <span class="params">(<span class="type">const</span> wstring&amp; str, <span class="type">size_t</span>* idx = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>完整源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>){</span><br><span class="line">            std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + <span class="number">1</span>,s.<span class="built_in">end</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> tmp = <span class="built_in">stoll</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>) - <span class="number">1</span> || tmp &lt; -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="未解决-字符串转换整数-atoi-8"><a href="#未解决-字符串转换整数-atoi-8" class="headerlink" title="[未解决]字符串转换整数 (atoi)[8]"></a>[未解决]字符串转换整数 (atoi)[8]</h3><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ul><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li><li>返回整数作为最终结果。</li></ul><p><strong>注意：</strong></p><ul><li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li><li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li></ul><h4 id="示例-1-6"><a href="#示例-1-6" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "42"</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步："42"（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）</span><br><span class="line">         ^</span><br><span class="line">第 3 步："42"（读入 "42"）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-7"><a href="#示例-2-7" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "   -42"</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步："   -42"（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步："   -42"（读入 "42"）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-7"><a href="#示例-3-7" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "4193 with words"</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）</span><br><span class="line">         ^</span><br><span class="line">第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-4-4"><a href="#示例-4-4" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "words and 987"</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）</span><br><span class="line">         ^</span><br><span class="line">第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）</span><br><span class="line">         ^</span><br><span class="line">解析得到整数 0 ，因为没有读入任何数字。</span><br><span class="line">由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-5-1"><a href="#示例-5-1" class="headerlink" title="示例 5"></a>示例 5</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "-91283472332"</span><br><span class="line">输出：-2147483648</span><br><span class="line">解释：</span><br><span class="line">第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）</span><br><span class="line">          ^</span><br><span class="line">第 3 步："-91283472332"（读入 "91283472332"）</span><br><span class="line">                     ^</span><br><span class="line">解析得到整数 -91283472332 。</span><br><span class="line">由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h4><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li></ul><h4 id="默认模板-6"><a href="#默认模板-6" class="headerlink" title="默认模板"></a>默认模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="盛最多水的容器-11"><a href="#盛最多水的容器-11" class="headerlink" title="盛最多水的容器[11]"></a>盛最多水的容器[11]</h3><p>给你 <code>n</code> 个非负整数 <code>a1</code>，<code>a2</code>，…，<code>an</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器。</p><h4 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/question_11.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure><h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：height = [4,3,2,1,4]</span><br><span class="line">输出：16</span><br></pre></td></tr></tbody></table></figure><h4 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：height = [1,2,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h4><ul><li><code>n</code> = <code>height.length</code></li><li>2 &lt;= <code>n</code> &lt;= 3 * $10^4$</li><li>0 &lt;= <code>height[i]</code> &lt;= 3 * $10^4$</li></ul><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">      </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h4><p>指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 <strong>对应的数字较小的那个指针</strong> 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) {</span><br><span class="line">            <span class="keyword">if</span>(height[i + <span class="number">1</span>] &gt; height[i])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span>(height[j - <span class="number">1</span>] &gt; height[j])</span><br><span class="line">                j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (j - i) * <span class="built_in">min</span>(height[i], height[j]);   </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="三数之和-15"><a href="#三数之和-15" class="headerlink" title="三数之和[15]"></a>三数之和[15]</h3><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 <em>a + b + c = 0</em> ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><h4 id="示例-1-7"><a href="#示例-1-7" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-8"><a href="#示例-2-8" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-8"><a href="#示例-3-8" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h4><ul><li>0 &lt;= <code>nums.length</code> &lt;= 3000</li><li>$-10^5$ &lt;= <code>nums[i]</code> &lt;= $10^5$</li></ul><h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h4><p>枚举第一个数，然后用双指针确定另外两个数。注意去重：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) {</span><br><span class="line">            <span class="type">int</span> i = k + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) {</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) {</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[k], nums[i], nums[j]});</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) i++;</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) j--;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) {</span><br><span class="line">                    i++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    j--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="删除链表的倒数第-N-个结点-19"><a href="#删除链表的倒数第-N-个结点-19" class="headerlink" title="删除链表的倒数第 N 个结点[19]"></a>删除链表的倒数第 N 个结点[19]</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h4 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/remove_ex1.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-9"><a href="#示例-2-9" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h4><ul><li>链表中结点的数目为 <code>sz</code></li><li>1 &lt;= <code>sz</code> &lt;= 30</li><li>0 &lt;= <code>Node.val</code> &lt;= 100</li><li>1 &lt;= <code>n</code> &lt;= <code>sz</code></li></ul><h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h4><p>正数第n到末尾的距离和倒数第n到开始的距离相同<br>a指针从第n到末尾停止，b指针同时从开始遍历，停止就到倒数第n<br>需要注意的是使用了空头，所给链表是没有的，需要自己从空头开始。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p3.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast) {</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="有效的括号-20"><a href="#有效的括号-20" class="headerlink" title="有效的括号[20]"></a>有效的括号[20]</h3><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合</li><li>左括号必须以正确的顺序闭合</li></ol><h4 id="示例-1-8"><a href="#示例-1-8" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "()"</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-10"><a href="#示例-2-10" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "()[]{}"</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-9"><a href="#示例-3-9" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "(]"</span><br><span class="line">输出：false</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-4-5"><a href="#示例-4-5" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "([)]"</span><br><span class="line">输出：false</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-5-2"><a href="#示例-5-2" class="headerlink" title="示例 5"></a>示例 5</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "{[]}"</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li></ul><h4 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h4><p>不能忘了扫描过的左括号，它们等着被匹配，用一个容器暂存——为什么是栈？</p><ul><li>当遇到右括号时，我们期待它匹配「<strong>最近出现</strong>的左括号」，于是容器中的「最近出现的左括号」不用等待匹配了，可以离开容器。它是「后进」的，现在「先出」，所以是栈。</li></ul><p>像“对对碰”，匹配了就拿掉，如果最后清空了栈，则有效。如果栈中还剩左括号未匹配，则无效。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/d502a4ee32fc8b7e7dbaadb3c3378b4a48507295bce12768cb2b6c82a3671c2e-image.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) {</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">                st.<span class="built_in">push</span>(ch);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'('</span> || ch == <span class="string">'{'</span> || ch == <span class="string">'['</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(ch);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">char</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ((top == <span class="string">'('</span> &amp;&amp; ch == <span class="string">')'</span>) || (top == <span class="string">'['</span> &amp;&amp; ch == <span class="string">']'</span>) || (top == <span class="string">'{'</span> &amp;&amp; ch == <span class="string">'}'</span>))</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="删除有序数组中的重复项-26"><a href="#删除有序数组中的重复项-26" class="headerlink" title="删除有序数组中的重复项[26]"></a>删除有序数组中的重复项[26]</h3><p>给你一个有序数组 <code>nums</code> ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong>原地</strong> <strong>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">removeDuplicates</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h4><ul><li>0 &lt;= <code>nums.length</code> &lt;= 3 * $10^4$</li><li>$-10^4$​ &lt;= <code>nums[i]</code> &lt;= $10^4$</li><li><code>nums</code> 已按升序排列</li></ul><h4 id="模板-5"><a href="#模板-5" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h4><p>此题要求我们删除重复字符，要注意的是去重之后元素的相对位置不能改变，比如 <code>[1, 2, 2, 3]</code> 去重后是 <code>[1, 2, 3]</code>，而不能是 <code>[1, 3, 2]</code>。既然输入数组是排好序的，那么对于每段重复元素，他们必定是相连的，我们只需要记录头元素即可，然后依次记录下那些互不重合的元素，就能解决此题了。这种需要依次记录下所需要元素的问题，就能完全使用同向指针的套路来解决，以下是解题步骤和代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="comment">// initialize</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums.<span class="built_in">size</span>()) {</span><br><span class="line">            <span class="comment">// if not duplicate, keep it, otherwise skip it</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[j] != nums[i - <span class="number">1</span>])</span><br><span class="line">                nums[i++] = nums[j++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i is now at the length of the new array, [0, i) is what we want</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>简单来说，<code>[0 ~ i)</code> 区间的元素是我们决定留下来的元素，<code>i</code> 指向的位置需要放入的是下一个不重复元素，<code>j</code> 指针是用来遍历整个数组的。在遍历过程中，如果 <code>array[j]</code> 和 <code>array[i – 1]</code> 不同，代表出现了一个新的不重复元素，那么就将新元素赋给 <code>array[i]</code>，否则向右移动 <code>j</code> 指针，直到 <code>j</code> 指针遍历完整个数组为止。</p><h3 id="接雨水-42"><a href="#接雨水-42" class="headerlink" title="接雨水[42]"></a>接雨水[42]</h3><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h4 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rainwatertrap.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-13"><a href="#提示-13" class="headerlink" title="提示"></a>提示</h4><ul><li><code>n</code> == <code>height.length</code></li><li>0 &lt;= <code>n</code> &lt;= 3 * $10^4$</li><li>0 &lt;= <code>height[i]</code> &lt;= $10^5$</li></ul><h4 id="模板-6"><a href="#模板-6" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h4><p>这道题真正难点在于: 在一个位置能容下的雨水量等于它左右两边柱子最大高度的最小值减去它的高度.比如下图所示,</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/6db1fe9019dfbf4d5c2e472112c5cd227925d4b5a99ac48cd2a2779d2535b6ce-Snipaste_2019-05-11_18-02-16.png"></p><p>位置 <code>i</code> 能容下雨水量:<code>min(3,1) - 0 = 1</code></p><p>所以，问题就变成了：如何找所有位置的左右两边的柱子的最大值？</p><p>这里我们沿用11题盛最多水容器的思路，用双指针遍历数组一次即可：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> area = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            left = <span class="built_in">max</span>(left, height[i]);</span><br><span class="line">            right = <span class="built_in">max</span>(right, height[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) {</span><br><span class="line">                area += left - height[i];</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                area += right - height[j];</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="字母异位词分组-49"><a href="#字母异位词分组-49" class="headerlink" title="字母异位词分组[49]"></a>字母异位词分组[49]</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><h4 id="示例-1-9"><a href="#示例-1-9" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]</span><br><span class="line">输出: [["bat"],["nat","tan"],["ate","eat","tea"]]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-11"><a href="#示例-2-11" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: strs = [""]</span><br><span class="line">输出: [[""]]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-10"><a href="#示例-3-10" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: strs = ["a"]</span><br><span class="line">输出: [["a"]]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-14"><a href="#提示-14" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= strs.length &lt;= 10^4</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h4 id="模板-7"><a href="#模板-7" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) {</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h4><p>遍历字符串，将每个字符串按照字符字典序排序后得到一个新的字符串，将相同的新字符串放在哈希表的同一个 key 对应 value 列表中。</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td><code>"aet"</code></td><td><code>["eat", "tea", "ate"]</code></td></tr><tr><td><code>"ant"</code></td><td><code>["tan", "nat"]</code></td></tr><tr><td><code>"abt"</code></td><td><code>["bat"]</code></td></tr></tbody></table><p>最后返回哈希表的 value 列表即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) {</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; <span class="built_in">hash</span>(strs.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs) {</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            hash[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = hash.<span class="built_in">begin</span>(); it != hash.<span class="built_in">end</span>(); it++) {</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="二进制求和-67"><a href="#二进制求和-67" class="headerlink" title="二进制求和[67]"></a>二进制求和[67]</h3><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 非空 字符串且只包含数字 1 和 0。</p><h4 id="示例-1-10"><a href="#示例-1-10" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: a = "11", b = "1"</span><br><span class="line">输出: "100"</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-12"><a href="#示例-2-12" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: a = "1010", b = "1011"</span><br><span class="line">输出: "10101"</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-15"><a href="#提示-15" class="headerlink" title="提示"></a>提示</h4><ul><li>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成</li><li>1 &lt;= a.length, b.length &lt;= 10^4</li><li>字符串如果不是 “0” ，就都不含前导零</li></ul><h4 id="模板-8"><a href="#模板-8" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h4><p>模拟笔算加法的过程，注意进位：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>{</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> digitA = i &gt;= <span class="number">0</span> ? a.<span class="built_in">at</span>(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> digitB = j &gt;= <span class="number">0</span> ? b.<span class="built_in">at</span>(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = digitA + digitB + carry;</span><br><span class="line">            carry = sum &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            sum = sum &gt;= <span class="number">2</span> ? sum - <span class="number">2</span> : sum;</span><br><span class="line">            res += <span class="built_in">to_string</span>(sum);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) res.<span class="built_in">push_back</span>(<span class="string">'1'</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="删除有序数组中的重复项-II-80"><a href="#删除有序数组中的重复项-II-80" class="headerlink" title="删除有序数组中的重复项 II[80]"></a>删除有序数组中的重复项 II[80]</h3><p>给你一个有序数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong>原地</strong> <strong>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a><strong>说明</strong></h4><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">removeDuplicates</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">&nbsp; &nbsp; <span class="built_in">print</span>(nums[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-1-11"><a href="#示例-1-11" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-13"><a href="#示例-2-13" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-16"><a href="#提示-16" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= <code>nums.length</code> &lt;= 3 * $10^4$</li><li>$-10^4$ &lt;= <code>nums[i]</code> &lt;= $10^4$</li><li><code>nums</code> 已按升序排列</li></ul><h4 id="模板-9"><a href="#模板-9" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h4><p>题目大意：一个有序数组中，让每个数字最多出现两次，返回一个 n ，使得数组的前 n 个元素就是结果。需要在输入数组上原地修改。</p><p>今天这个题目是 26. 删除有序数组中的重复项 的进阶，可以先做一下 26 题。</p><p>注意是原地修改，那么肯定就需要一个指针指向当前即将放置元素的位置，需要另外一个指针向后遍历所有元素，所以「双指针」解法就呼之欲出了。如果能想到双指针解法，后面的分析也就顺理成章。</p><ul><li><strong>慢指针 slow</strong> : 指向当前即将放置元素的位置；则 slow - 1 是刚才已经放置了元素的位置。</li><li><strong>快指针 fast</strong> : 向后遍历所有元素；</li></ul><p>因为最多允许两个重复元素，并且 <code>slow - 2</code> 位置是上上次放置了元素的位置，所以让 <code>nums[fast]</code> 跟 <code>nums[slow - 2]</code> 进行比较。每次都是只允许最多两个元素出现重复，这两个元素的位置在 <code>slow - 1</code> 和 <code>slow - 2</code>.</p><p>请看下面的动图展示，一图胜千言。图中红色表示已经放置了正确元素的位置，绿色表示当前元素被修改了。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1617673689-HwNHJA-80.gif"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.<span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != nums[i - <span class="number">2</span>]) {</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="柱状图中最大的矩形-84"><a href="#柱状图中最大的矩形-84" class="headerlink" title="柱状图中最大的矩形[84]"></a>柱状图中最大的矩形[84]</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><h4 id="示例-1-12"><a href="#示例-1-12" class="headerlink" title="示例 1"></a>示例 1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/histogram.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-14"><a href="#示例-2-14" class="headerlink" title="示例 2"></a>示例 2</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/histogram-1-20211230215250929.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-17"><a href="#提示-17" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= heights.length &lt;=10^5</code></li><li><code>0 &lt;= heights[i] &lt;= 10^4</code></li></ul><h4 id="模板-10"><a href="#模板-10" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h4><p>我们可以遍历每根柱子，以当前柱子 i 的高度作为矩形的高，那么矩形的宽度边界即为向左找到第一个高度小于当前柱体 i 的柱体，向右找到第一个高度小于当前柱体 i 的柱体。</p><p>对于每个柱子我们都如上计算一遍以当前柱子作为高的矩形面积，最终比较出最大的矩形面积即可。</p><p>我们遍历每个柱体，若当前的柱体高度大于等于栈顶柱体的高度，就直接将当前柱体入栈，否则若当前的柱体高度小于栈顶柱体的高度，说明当前栈顶柱体找到了右边的第一个小于自身的柱体，那么就可以将栈顶柱体出栈来计算以其为高的矩形的面积了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>{</span><br><span class="line">        <span class="type">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[s.<span class="built_in">top</span>()]) {</span><br><span class="line">                <span class="type">int</span> h = heights[s.<span class="built_in">top</span>()];</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                maxarea = <span class="built_in">max</span>(maxarea, h * (i - s.<span class="built_in">top</span>() - <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="反转链表-II-92"><a href="#反转链表-II-92" class="headerlink" title="反转链表 II[92]"></a>反转链表 II[92]</h3><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left</code> &lt;= <code>right</code> 。请你反转从位置 left 到位置 right 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p><h4 id="示例1-5"><a href="#示例1-5" class="headerlink" title="示例1"></a>示例1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev2ex2.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例2-3"><a href="#示例2-3" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [5], left = 1, right = 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-18"><a href="#提示-18" class="headerlink" title="提示"></a>提示</h4><ul><li>链表中节点数目为 <code>n</code></li><li>1 &lt;= <code>n</code> &lt;= 500</li><li>-500 &lt;= <code>Node.val</code> &lt;= 500</li><li>1 &lt;= <code>left</code> &lt;= <code>right</code> &lt;= <code>n</code></li></ul><h4 id="模板-11"><a href="#模板-11" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="keyword">if</span>(pos == right || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos &lt; left) {</span><br><span class="line">            head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, left, right);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            ListNode* res = <span class="built_in">reverseBetween</span>(head-&gt;next, left, right);</span><br><span class="line">            ListNode* tmp = head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = head;</span><br><span class="line">            head-&gt;next = tmp;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="只出现一次的数字-II-137"><a href="#只出现一次的数字-II-137" class="headerlink" title="只出现一次的数字 II[137]"></a>只出现一次的数字 II[137]</h3><p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><h4 id="示例-1-13"><a href="#示例-1-13" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-15"><a href="#示例-2-15" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,1,0,1,99]</span><br><span class="line">输出：99</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-19"><a href="#提示-19" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= <code>nums.length</code> &lt;= 3 * $10^4$</li><li>$-2^{31}$ &lt;= <code>nums[i]</code> &lt;= $2^{31}$ - 1</li><li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li></ul><p><strong>进阶</strong>：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><h4 id="模板-12"><a href="#模板-12" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h4><p>统计所有数字每个位中 1 出现的次数，对于某个位，1 出现的次数一定是 3 的倍数 +1 或 0。对这个数 %3 得到的结果就是那个出现一次的数字在该位上的值：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bit</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">                bit[i] += (num &gt;&gt; (<span class="number">31</span> - i)) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) + bit[i] % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="环形链表-141"><a href="#环形链表-141" class="headerlink" title="环形链表[141]"></a>环形链表[141]</h3><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 <code>0</code> 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>进阶：</strong></p><p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p><h4 id="示例1-6"><a href="#示例1-6" class="headerlink" title="示例1"></a>示例1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例2-4"><a href="#示例2-4" class="headerlink" title="示例2"></a>示例2</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist_test2.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例3-2"><a href="#示例3-2" class="headerlink" title="示例3"></a>示例3</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist_test3.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-20"><a href="#提示-20" class="headerlink" title="提示"></a>提示</h4><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li>$-10^5$ &lt;= <code>Node.val</code> &lt;= $10^5$</li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong></li></ul><h4 id="模板-13"><a href="#模板-13" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h4><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode* i = head, *j = head;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="literal">nullptr</span> &amp;&amp; j-&gt;next != <span class="literal">nullptr</span>) {</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            j = j-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="环形链表-II-142"><a href="#环形链表-II-142" class="headerlink" title="环形链表 II[142]"></a>环形链表 II[142]</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><h4 id="示例-1-14"><a href="#示例-1-14" class="headerlink" title="示例 1"></a>示例 1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist-20211217215034089.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-16"><a href="#示例-2-16" class="headerlink" title="示例 2"></a>示例 2</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist_test2-20211217215118016.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-11"><a href="#示例-3-11" class="headerlink" title="示例 3"></a>示例 3</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/circularlinkedlist_test3-20211217215152769.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-21"><a href="#提示-21" class="headerlink" title="提示"></a>提示</h4><ul><li>链表中节点的数目范围在范围 <code>[0, 10^4]</code> 内</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h4 id="模板-14"><a href="#模板-14" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h4><p>先利用快慢指针判断链表是否有环，没有环则直接返回 <code>null</code>。</p><p>若链表有环，我们分析快慢相遇时走过的距离：<br>$$<br>a + n(b + c) + b = a + (n + 1)b + c \\<br>a + (n + 1)b + c = 2(a + b) \to a = c + (n - 1)(b + c)<br>$$<br><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/jianzhi_II_022_fig1-20211217215410978.png"></p><p>我们会发现：从相遇点到入环点的距离加上 $n-1$ 圈的环长，恰好等于从链表头部到入环点的距离。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) {</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="重排链表-143"><a href="#重排链表-143" class="headerlink" title="重排链表[143]"></a>重排链表[143]</h3><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code>，单链表 <code>L</code> 表示为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></tbody></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></tbody></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><h4 id="示例-1-15"><a href="#示例-1-15" class="headerlink" title="示例 1"></a>示例 1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[1,4,2,3]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-17"><a href="#示例-2-17" class="headerlink" title="示例 2"></a>示例 2</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://pic.leetcode-cn.com/1626420320-YUiulT-image.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[1,5,2,4,3]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-22"><a href="#提示-22" class="headerlink" title="提示"></a>提示</h4><ul><li>链表的长度范围为 <code>[1, 5 * 104]</code></li><li><code>1 &lt;= node.val &lt;= 1000</code></li></ul><h4 id="模板-15"><a href="#模板-15" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h4><p>相当于这 3 道问题，只需要 5 行代码将它们组合：</p><ul><li>[链表的中间结点](<a target="_blank" rel="noopener" href="https://doocs.github.io/leetcode/#/solution/0800-0899/0876.Middle">https://doocs.github.io/leetcode/#/solution/0800-0899/0876.Middle</a> of the Linked List/README)</li><li>[反转链表](<a target="_blank" rel="noopener" href="https://doocs.github.io/leetcode/#/solution/0200-0299/0206.Reverse">https://doocs.github.io/leetcode/#/solution/0200-0299/0206.Reverse</a> Linked List/README)</li><li>合并两个链表</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummy;</span><br><span class="line">        ListNode* fast = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) {</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        }        </span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummy-&gt;next;</span><br><span class="line">        ListNode* mid = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        mid = <span class="built_in">reverseList</span>(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mid) {</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = mid;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* succ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            succ = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = succ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="逆波兰表达式求值-150"><a href="#逆波兰表达式求值-150" class="headerlink" title="逆波兰表达式求值[150]"></a>逆波兰表达式求值[150]</h3><p>根据<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求表达式的值。</p><p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><h4 id="示例-1-16"><a href="#示例-1-16" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：tokens = ["2","1","+","3","*"]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-18"><a href="#示例-2-18" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：tokens = ["4","13","5","/","+"]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-12"><a href="#示例-3-12" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]</span><br><span class="line">输出：22</span><br><span class="line">解释：</span><br><span class="line">该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-23"><a href="#提示-23" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= tokens.length &lt;= 10^4</code></li><li><code>tokens[i]</code> 要么是一个算符（<code>"+"</code>、<code>"-"</code>、<code>"*"</code> 或 <code>"/"</code>），要么是一个在范围 <code>[-200, 200]</code> 内的整数</li></ul><p><strong>逆波兰表达式</strong>：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code></li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code></li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code> 也可以依据次序计算出正确结果</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><h4 id="模板-16"><a href="#模板-16" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h4><p>利用栈存储运算数，每次遇到符号，对栈顶两个元素进行运算。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1634694986-QSFMuX-aa.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>{</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (string&amp; t: tokens) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isNumber</span>(t)) {</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(t));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">int</span> a = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">                    s.<span class="built_in">push</span>(a + b);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">                    s.<span class="built_in">push</span>(b - a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'*'</span>)</span><br><span class="line">                    s.<span class="built_in">push</span>(a * b);</span><br><span class="line">                <span class="keyword">else</span>            </span><br><span class="line">                    s.<span class="built_in">push</span>(b / a);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span> || (s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;=<span class="string">'9'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="最小栈-155"><a href="#最小栈-155" class="headerlink" title="最小栈[155]"></a>最小栈[155]</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中</li><li><code>pop()</code> —— 删除栈顶的元素</li><li><code>top()</code> —— 获取栈顶元素</li><li><code>getMin()</code> —— 检索栈中的最小元素</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">["MinStack","push","push","push","getMin","pop","top","getMin"]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-24"><a href="#提示-24" class="headerlink" title="提示"></a>提示</h4><ul><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li></ul><h4 id="模板-17"><a href="#模板-17" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h4><p>此题要求写一个栈，与普通栈不同的是多出了一个获取最小值的方法。由于栈比较简单，这里就不多说了，主要还是说说怎么以 O(1) 的时间复杂度查找栈中的最小值。</p><ol><li>使用一个变量 min 记录每次栈中的最小值，每次有元素进栈都对 min 进行更新。<br>这个方法存在一个问题，没有考虑出栈时，怎么对 min 进行更新。</li><li>为了解决出栈对最小值的更新，可以设定一个辅助栈，栈顶表示当前数据栈中的最小值，每次有元素入栈，就将当前最小值入辅助栈。出栈时，辅助栈也要将栈顶元素出栈，这就解决了出栈时的最小值更新问题。</li></ol><p><strong>push</strong>：将数据入栈的同时，更新最小值。如果入栈元素大于辅助栈顶元素（也就是元素入栈前，数据栈中的最小值），则最小值依旧是数据栈原来的最小值，否则将元素入辅助栈。</p><p>![](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628245226-xNbNUW-GIF">https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628245226-xNbNUW-GIF</a> 2021-8-6 18-17-13.gif)</p><p><strong>pop</strong>：将数据栈和辅助栈的栈顶元素同时出栈，保持辅助栈的栈顶元素是数据栈中的最小值。</p><p>![](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628245428-cWDvKW-GIF">https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628245428-cWDvKW-GIF</a> 2021-8-6 18-23-10.gif)</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> {</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; dataStack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() {</span><br><span class="line">        <span class="keyword">while</span>(!dataStack.<span class="built_in">empty</span>())</span><br><span class="line">            dataStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!minStack.<span class="built_in">empty</span>())</span><br><span class="line">            minStack.<span class="built_in">pop</span>();</span><br><span class="line">        minStack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        dataStack.<span class="built_in">push</span>(x);</span><br><span class="line">        minStack.<span class="built_in">push</span>(std::<span class="built_in">min</span>(x, minStack.<span class="built_in">top</span>()));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        dataStack.<span class="built_in">pop</span>();</span><br><span class="line">        minStack.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> dataStack.<span class="built_in">top</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> minStack.<span class="built_in">top</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="相交链表-160"><a href="#相交链表-160" class="headerlink" title="相交链表[160]"></a>相交链表[160]</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_statement-20211218222551745.png"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测</strong>：</p><p><strong>评测系统</strong> 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 `0``</li><li>``listA` - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><h4 id="示例-1-17"><a href="#示例-1-17" class="headerlink" title="示例 1"></a>示例 1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_1_1.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at '8'</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-19"><a href="#示例-2-19" class="headerlink" title="示例 2"></a>示例 2</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_2-20211218222840916.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：intersectVal&nbsp;= 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at '2'</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例3-3"><a href="#示例3-3" class="headerlink" title="示例3"></a>示例3</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_3-20211218222946270.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-25"><a href="#提示-25" class="headerlink" title="提示"></a>提示</h4><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 10^4</code></li><li><code>1 &lt;= Node.val &lt;= 10^5</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 0</li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h4 id="模板-18"><a href="#模板-18" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h4><p>使用<strong>双指针</strong>，细想就会发现很简单很巧妙。</p><p>A 和 B 两个链表长度可能不同，但是 A + B 和 B + A 的长度是相同的，所以遍历 A + B 和遍历 B + A 一定是同时结束：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123481-fdeApj-image-20211218222217465.png"></p><ul><li><p>如果 A、B 相交的话 A 和 B 有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123467-zeofGx-image-20211218222141874.png"></p></li><li><p>如果 A、B 不相交的话两个指针就会同时到达 A + B（B + A）的尾节点（然后同时变成<code>nullptr</code>）</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123497-pwIiFq-image.png"></p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        ListNode* pa = headA;</span><br><span class="line">        ListNode* pb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pa != pb) {</span><br><span class="line">            pa = pa? pa-&gt;next: headB;</span><br><span class="line">            pb = pb? pb-&gt;next: headA;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="两数之和-II-输入有序数组-167"><a href="#两数之和-II-输入有序数组-167" class="headerlink" title="两数之和 II - 输入有序数组[167]"></a>两数之和 II - 输入有序数组[167]</h3><p>给定一个已按照 <strong>非递减顺序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p><p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值。numbers 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 不可以 重复使用相同的元素。</p><h4 id="示例-1-18"><a href="#示例-1-18" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numbers = [2,7,11,15], target = 9</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-20"><a href="#示例-2-20" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numbers = [2,3,4], target = 6</span><br><span class="line">输出：[1,3]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-13"><a href="#示例-3-13" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numbers = [-1,0], target = -1</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-26"><a href="#提示-26" class="headerlink" title="提示"></a>提示</h4><ul><li>2 &lt;= numbers.length &lt;= 3 * $10^4$</li><li>-1000 &lt;= numbers[i] &lt;= 1000</li><li>numbers 按 <strong>非递减顺序</strong> 排列</li><li>-1000 &lt;= target &lt;= 1000</li><li><strong>仅存在一个有效答案</strong></li></ul><h4 id="模板-19"><a href="#模板-19" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h4><p>双指针：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; numbers[i] + numbers[j] != target) {</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;        </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="二叉树的右视图-199"><a href="#二叉树的右视图-199" class="headerlink" title="二叉树的右视图[199]"></a>二叉树的右视图[199]</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h4 id="示例-1-19"><a href="#示例-1-19" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-21"><a href="#示例-2-21" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-14"><a href="#示例-3-14" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-27"><a href="#提示-27" class="headerlink" title="提示"></a>提示</h4><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="模板-20"><a href="#模板-20" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h4><p>只需将保存每一层最左端的节点值，改为保存每一层最右端的节点值并保存即可。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629516721-xcbSKy-2bdd85f029f86f2e9708a61edccdc1a-20220107162514225.jpg"></p><p>代码如下，注意空根节点的判断。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="反转链表-206"><a href="#反转链表-206" class="headerlink" title="反转链表[206]"></a>反转链表[206]</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><h4 id="示例-1-20"><a href="#示例-1-20" class="headerlink" title="示例 1"></a>示例 1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev1ex1.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-22"><a href="#示例-2-22" class="headerlink" title="示例 2"></a>示例 2</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev1ex2.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例3-4"><a href="#示例3-4" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-28"><a href="#提示-28" class="headerlink" title="提示"></a>提示</h4><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li>-5000 &lt;= <code>Node.val</code> &lt;= 5000</li></ul><h4 id="模板-21"><a href="#模板-21" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>考虑使用递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 <code>next</code> 引用指向。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            ListNode* res = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">            ListNode* tmp = head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = head;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><p>非递归方法我选择直接背诵了，可以看到几个等式成一个环状收尾相连：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">succ--cur-&gt;next--pre--cur--succ</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* succ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            succ = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = succ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="长度最小的子数组-209"><a href="#长度最小的子数组-209" class="headerlink" title="长度最小的子数组[209]"></a>长度最小的子数组[209]</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><h4 id="示例-1-21"><a href="#示例-1-21" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-23"><a href="#示例-2-23" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-15"><a href="#示例-3-15" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-29"><a href="#提示-29" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= target &lt;= 10^9</code></li><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><p><strong>进阶</strong>：如果你已经实现 $O(n)$ 时间复杂度的解法, 请尝试设计一个 $O(n log(n))$ 时间复杂度的解法。</p><h4 id="模板-22"><a href="#模板-22" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h4><p>同向双指针，注意边界条件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> minlen = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) {</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; sum &gt;= target) {</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minlen == INT_MAX? <span class="number">0</span>: minlen;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="回文链表-234"><a href="#回文链表-234" class="headerlink" title="回文链表[234]"></a>回文链表[234]</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><h4 id="示例1-7"><a href="#示例1-7" class="headerlink" title="示例1"></a>示例1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/20211220163756.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure><h4 id="示例2-5"><a href="#示例2-5" class="headerlink" title="示例2"></a>示例2</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/pal2linked-list.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-30"><a href="#提示-30" class="headerlink" title="提示"></a>提示</h4><ul><li>链表中节点数目在范围 <code>[1, 10^5]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p><strong>进阶</strong>：你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><h4 id="模板-23"><a href="#模板-23" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h4><p>先用快慢指针找到链表的中点，接着反转右半部分的链表。然后同时遍历前后两段链表，若前后两段链表节点对应的值不等，说明不是回文链表，否则说明是回文链表。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummy;</span><br><span class="line">        ListNode* fast = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) {</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummy-&gt;next;</span><br><span class="line">        ListNode* mid = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        mid = <span class="built_in">reverseList</span>(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mid) {</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val != mid-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* succ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            succ = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = succ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="删除链表中的节点-237"><a href="#删除链表中的节点-237" class="headerlink" title="删除链表中的节点[237]"></a>删除链表中的节点[237]</h3><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <strong>要被删除的节点</strong> 。</p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/237_example.png"></p><h4 id="示例-1-22"><a href="#示例-1-22" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [4,5,1,9], node = 5</span><br><span class="line">输出：[4,1,9]</span><br><span class="line">解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-24"><a href="#示例-2-24" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [4,5,1,9], node = 1</span><br><span class="line">输出：[4,5,9]</span><br><span class="line">解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-31"><a href="#提示-31" class="headerlink" title="提示"></a>提示</h4><ul><li>链表至少包含两个节点</li><li>链表中所有节点的值都是唯一的</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点</li><li>不要从你的函数中返回任何结果</li></ul><h4 id="模板-24"><a href="#模板-24" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h4><p><strong>方法：与下一个节点交换</strong></p><p>从链表里删除一个节点 <code>node</code> 的最常见方法是修改之前节点的 <code>next</code> 指针，使其指向之后的节点。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/3579a496897df5321c110bf1301872b6e10c342f5e400ce45d2db0348d00d715-file_1555866623326.png"></p><p>因为，我们无法访问我们想要删除的节点 <strong>之前</strong> 的节点，我们始终不能修改该节点的 <code>next</code> 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/902dc5d3f8c44d3cbc0b6e837711cad2eefc021fd2b9de8dfabc6d478bc779b1-file_1555866680932.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>{</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>要说明的是这道题在我看来并不是一道好题，忽略了诸如内存泄漏，删除指针，释放内存这些 C++ 中非常常见的实际问题。</p><h3 id="有效的字母异位词-242"><a href="#有效的字母异位词-242" class="headerlink" title="有效的字母异位词[242]"></a>有效的字母异位词[242]</h3><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><h4 id="示例-1-23"><a href="#示例-1-23" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "anagram", t = "nagaram"</span><br><span class="line">输出: true</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-25"><a href="#示例-2-25" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "rat", t = "car"</span><br><span class="line">输出: false</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-32"><a href="#提示-32" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 10^4</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶</strong>: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h4 id="模板-25"><a href="#模板-25" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">    	</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h4><p>数组或哈希表累加 s 中每个字符出现的次数，再减去 t 中对应的每个字符出现的次数。遍历结束后，若字符中出现次数不为 0 的情况，返回 false，否则返回 true。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">zero</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[t[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            hash[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash == zero)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="移动零-283"><a href="#移动零-283" class="headerlink" title="移动零[283]"></a>移动零[283]</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></tbody></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h4 id="模板-26"><a href="#模板-26" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h4><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>注意到以下性质：</p><ol><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。</li></ol><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.<span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">if</span>(nums[j]) {</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="二维区域和检索-矩阵不可变-304"><a href="#二维区域和检索-矩阵不可变-304" class="headerlink" title="二维区域和检索 - 矩阵不可变[304]"></a>二维区域和检索 - 矩阵不可变[304]</h3><p>给定一个二维矩阵 <code>matrix</code>，以下类型的多个请求：</p><p>计算其子矩形范围内元素的总和，该子矩阵的 <strong>左上角</strong> 为 <code>(row1, col1)</code> ，<strong>右下角</strong> 为 <code>(row2, col2)</code>。</p><p>实现 <code>NumMatrix</code> 类：</p><ul><li><code>NumMatrix(int[][] matrix)</code> 给定整数矩阵 <code>matrix</code> 进行初始化</li><li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> 返回 <strong>左上角</strong> <code>(row1, col1)</code> 、<strong>右下角</strong> <code>(row2, col2)</code> 所描述的子矩阵的元素 <strong>总和</strong> 。</li></ul><h4 id="示例-1-24"><a href="#示例-1-24" class="headerlink" title="示例 1"></a>示例 1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626332422-wUpUHT-image-20211216174726957.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">["NumMatrix","sumRegion","sumRegion","sumRegion"]</span><br><span class="line">[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]</span><br><span class="line">输出: </span><br><span class="line">[null, 8, 11, 12]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);</span><br><span class="line">numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)</span><br><span class="line">numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)</span><br><span class="line">numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-33"><a href="#提示-33" class="headerlink" title="提示"></a>提示</h4><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-10^5 &lt;= matrix[i][j] &lt;= 10^5</code></li><li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li><li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li><li>最多调用 <code>10^4</code> 次 <code>sumRegion</code> 方法</li></ul><h4 id="模板-27"><a href="#模板-27" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix* obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h4><p>动态规划-二维前缀和。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628949136-zQFMmB-e740f25c4850f72eae2482bb42cfc36.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628949854-YEDxST-5424205ebc953c73cf8381aa53f7bc2.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; presum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">size</span>() || !matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        presum.<span class="built_in">resize</span>(matrix.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(matrix[<span class="number">0</span>].<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> rowsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j++) {</span><br><span class="line">                rowsum += matrix[i][j];</span><br><span class="line">                presum[i + <span class="number">1</span>][j + <span class="number">1</span>] = presum[i][j + <span class="number">1</span>] + rowsum;</span><br><span class="line">            }</span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> presum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - presum[row1][col2 + <span class="number">1</span>]</span><br><span class="line">                                          - presum[row2 + <span class="number">1</span>][col1]</span><br><span class="line">                                          + presum[row1][col1];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix* obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="最大单词长度乘积-318"><a href="#最大单词长度乘积-318" class="headerlink" title="最大单词长度乘积[318]"></a>最大单词长度乘积[318]</h3><p>给定一个字符串数组 <code>words</code>，找到 <code>length(word[i]) * length(word[j])</code> 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><h4 id="示例-1-25"><a href="#示例-1-25" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: ["abcw","baz","foo","bar","xtfn","abcdef"]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 "abcw", "xtfn"。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-26"><a href="#示例-2-26" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: ["a","ab","abc","d","cd","bcd","abcd"]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 这两个单词为 "ab", "cd"。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-16"><a href="#示例-3-16" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: ["a","aa","aaa","aaaa"]</span><br><span class="line">输出: 0 </span><br><span class="line">解释: 不存在这样的两个单词。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-34"><a href="#提示-34" class="headerlink" title="提示"></a>提示</h4><ul><li>2 &lt;= <code>words.length</code> &lt;= 1000</li><li>1 &lt;= <code>words[i].length</code> &lt;= 1000</li><li><code>words[i]</code> 仅包含小写字母</li></ul><h4 id="模板-28"><a href="#模板-28" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h4><p>因为只有 26 个小写字符，所以可以用一个哈希表存储字符的出现情况，然后枚举最大乘积：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>{</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">hash</span>(words.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">26</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c: words[i])</span><br><span class="line">                hash[i][c - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; words.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; <span class="number">26</span>; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (hash[i][k] &amp;&amp; hash[j][k])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">26</span>) {</span><br><span class="line">                    <span class="type">int</span> prod = words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>();</span><br><span class="line">                    res = <span class="built_in">max</span>(res, prod);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="比特位计数-338"><a href="#比特位计数-338" class="headerlink" title="比特位计数[338]"></a>比特位计数[338]</h3><p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><h4 id="示例-1-26"><a href="#示例-1-26" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：[0,1,1]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-27"><a href="#示例-2-27" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：[0,1,1,2,1,2]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-35"><a href="#提示-35" class="headerlink" title="提示"></a>提示</h4><ul><li>0 &lt;= n &lt;= $10^5$</li></ul><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><ul><li>很容易就能实现时间复杂度为 $O(n log n)$ 的解决方案，你可以在线性时间复杂度 $O(n)$ 内用一趟扫描解决此问题吗？</li><li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 <code>__builtin_popcount</code> ）</li></ul><h4 id="模板-29"><a href="#模板-29" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h4><p>最直观的做法是对从 $0$ 到 $n$ 的每个整数直接计算「一比特数」。每个 $\texttt{int}$ 型的数都可以用 32 位二进制数表示，只要遍历其二进制表示的每一位即可得到 1 的数目。</p><p>利用 $\text{Brian Kernighan}$ 算法，可以在一定程度上进一步提升计算速度。$\text{Brian Kernighan}$ 算法的原理是：对于任意整数 $x$，令 $x=x<del>&amp;</del>(x-1)$，该运算将 $x$ 的二进制表示的最后一个 1 变成 0。因此，对 $x$ 重复该操作，直到 $x$ 变成 $0$，则操作次数即为 $x$ 的「一比特数」。</p><p>对于给定的 $n$，计算从 $0$ 到 $n$ 的每个整数的「一比特数」的时间都不会超过 $O(\log n)$，因此总时间复杂度为 $O(n \log n)$。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            res[i] = res[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="反转字符串-344"><a href="#反转字符串-344" class="headerlink" title="反转字符串[344]"></a>反转字符串[344]</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><h4 id="示例-1-27"><a href="#示例-1-27" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：["h","e","l","l","o"]</span><br><span class="line">输出：["o","l","l","e","h"]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-28"><a href="#示例-2-28" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：["H","a","n","n","a","h"]</span><br><span class="line">输出：["h","a","n","n","a","H"]</span><br></pre></td></tr></tbody></table></figure><h4 id="默认模板-7"><a href="#默认模板-7" class="headerlink" title="默认模板"></a>默认模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">      </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h4><p>这是一道很经典的字符串反转问题，如果可以使用上文的双指针套路，那么应该采取同向还是反向呢？根据观察调换字符串的规律，我们发现只要从外往里，不断调换头部和尾部的元素就能颠倒一个字符串，那很明显和我们提到的反向双指针相关。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/TIM%E6%88%AA%E5%9B%BE20200518232849-3.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">      	<span class="comment">// initialize</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) {</span><br><span class="line">          	<span class="comment">// swap str[i] and str[j]</span></span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="数据流中的移动平均值-346"><a href="#数据流中的移动平均值-346" class="headerlink" title="数据流中的移动平均值[346]"></a>数据流中的移动平均值[346]</h3><p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算其所有整数的移动平均值。</p><p>实现 <code>MovingAverage</code> 类：</p><ul><li><code>MovingAverage(int size)</code> 用窗口大小 <code>size</code> 初始化对象。</li><li><code>double next(int val)</code> 计算并返回数据流中最后 <code>size</code> 个值的移动平均值。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">["MovingAverage", "next", "next", "next", "next"]</span><br><span class="line">[[3], [1], [10], [3], [5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1.0, 5.5, 4.66667, 6.0]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MovingAverage movingAverage = new MovingAverage(3);</span><br><span class="line">movingAverage.next(1); // 返回 1.0 = 1 / 1</span><br><span class="line">movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2</span><br><span class="line">movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3</span><br><span class="line">movingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-36"><a href="#提示-36" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= size &lt;= 1000</code></li><li><code>-10^5 &lt;= val &lt;= 10^5</code></li><li>最多调用 <code>next</code> 方法 <code>10^4</code> 次</li></ul><h4 id="模板-30"><a href="#模板-30" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MovingAverage</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MovingAverage</span>(<span class="type">int</span> size) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">next</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage* obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj-&gt;next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png-20211231183823285.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MovingAverage</span> {</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MovingAverage</span>(<span class="type">int</span> size) {</span><br><span class="line">        capacity = size;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">next</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        sum += val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; capacity) {</span><br><span class="line">            sum -= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">double</span>(sum)/ q.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage* obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj-&gt;next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="O-1-时间插入、删除和获取随机元素-380"><a href="#O-1-时间插入、删除和获取随机元素-380" class="headerlink" title="O(1) 时间插入、删除和获取随机元素[380]"></a>O(1) 时间插入、删除和获取随机元素[380]</h3><p>实现 <code>RandomizedSet</code> 类：</p><ul><li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code> 对象</li><li><code>bool insert(int val)</code> 当元素 <code>val</code> 不存在时，向集合中插入该项，并返回 <code>true</code>；否则，返回 <code>false</code></li><li><code>bool remove(int val)</code> 当元素 <code>val</code> 存在时，从集合中移除该项，并返回 <code>true</code>；否则，返回 <code>false</code></li><li><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 <strong>相同的概率</strong> 被返回</li></ul><p>你必须实现类的所有函数，并满足每个函数的 <strong>平均</strong> 时间复杂度为 O(1)</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。</span><br><span class="line">randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-37"><a href="#提示-37" class="headerlink" title="提示"></a>提示</h4><ul><li>-2^31 &lt;= val &lt;= 2^31 - 1</li><li>最多调用 <code>insert</code>、<code>remove</code> 和 <code>getRandom</code> 函数 2 * 10^5 次</li><li>在调用 <code>getRandom</code> 方法时，数据结构中 <strong>至少存在一个</strong> 元素。</li></ul><h4 id="模板-31"><a href="#模板-31" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet* obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h4><p>由于题目要求删除和插入的时间复杂度为 O(1)，能够满足要求的只有哈希表，显然此处需要使用哈希表。</p><p>但是使用哈希表无法等概率返回其中的每个数值。若这些数值是保存在数组内，则可以轻松解决。但若只使用数组，那么删除和插入一个值时，都需遍历一遍数组找到数值对应的下标，则会使时间复杂度为 O(n)。</p><p>故可将哈希表和数组结合，数组内存数值实现 <code>getRandom</code>，哈希内存数值和下标的映射实现 <code>insert</code> 和 <code>remove</code> 的索引查找的时间复杂度为 O(1)，之后在数组内操作数值的插入和删除。具体来看操作就是：</p><ol><li><strong>插入</strong></li></ol><p>每次添加新数值时，先使用哈希表判断该数值是否存在，存在则直接返回 false。不存在则进行插入操作，只要将该数值添加到数组尾部即可，并将该数值和其下标的映射存入哈希表。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png.png"></p><ol start="2"><li><strong>删除</strong></li></ol><p>删除同样需使用哈希表判断是否存在，若不存在则返回 false。存在则进行删除操作，在哈希表中删除时间复杂度为 O(1)，但是在数值中删除比较麻烦。若只是直接删除，则为了保证数组内存连续性需将删除数值后面的数值均前移一位，时间复杂度为 O(n)。比较好的处理方式是，用数组的最后一个数值去填充需要删除的数值的内存，其他数值在数组中的位置保持不变，并将这个拿来填充的数值的下标更新即可，最后只要删除数组最后一个数值，同样可以保证时间复杂度为 O(1)。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png-20211221123721524.png"></p><ol start="3"><li><strong>随机返回</strong></li></ol><p>只要随机生成数组下标范围内一个随机下标值，返回该数组下标内的数值即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> {</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        mp[val] = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> removeIndex = mp[val];</span><br><span class="line">        nums[removeIndex] = nums.<span class="built_in">back</span>();</span><br><span class="line">        mp[nums.<span class="built_in">back</span>()] = removeIndex;</span><br><span class="line">        </span><br><span class="line">        mp.<span class="built_in">erase</span>(val);</span><br><span class="line">        nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">rand</span>() % nums.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet* obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="扁平化多级双向链表-430"><a href="#扁平化多级双向链表-430" class="headerlink" title="扁平化多级双向链表[430]"></a>扁平化多级双向链表[430]</h3><p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p><p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p><h4 id="示例-1-28"><a href="#示例-1-28" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">输出：[1,2,3,7,8,11,12,9,10,4,5,6]</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/multilevellinkedlist.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/multilevellinkedlistflattened.png"></p><h4 id="示例-2-29"><a href="#示例-2-29" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,null,3]</span><br><span class="line">输出：[1,3,2]</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">输入的多级列表如下图所示：</span><br><span class="line"></span><br><span class="line">  1---2---NULL</span><br><span class="line">  |</span><br><span class="line">  3---NULL</span><br></pre></td></tr></tbody></table></figure><h5 id="示例-3-17"><a href="#示例-3-17" class="headerlink" title="示例 3"></a>示例 3</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>如何表示测试用例中的多级链表？</strong></p><p>以 <strong>示例</strong> 1 为例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1---2---3---4---5---6--NULL</span><br><span class="line">        |</span><br><span class="line">        7---8---9---10--NULL</span><br><span class="line">            |</span><br><span class="line">            11--12--NULL</span><br></pre></td></tr></tbody></table></figure><p>序列化其中的每一级之后：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[7,8,9,10,null]</span><br><span class="line">[11,12,null]</span><br></pre></td></tr></tbody></table></figure><p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[null,null,7,8,9,10,null]</span><br><span class="line">[null,11,12,null]</span><br></pre></td></tr></tbody></table></figure><p>合并所有序列化结果，并去除末尾的 null 。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-38"><a href="#提示-38" class="headerlink" title="提示"></a>提示</h4><ul><li>节点数目不超过 1000</li><li><code>1 &lt;= Node.val &lt;= 10^5</code></li></ul><h4 id="模板-32"><a href="#模板-32" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h4><p>仔细观察一下这个结构，不难发现其实就是前序遍历二叉树：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1-20211220193435939.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>{</span><br><span class="line">        <span class="built_in">flattenGetTail</span>(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">flattenGetTail</span><span class="params">(Node* head)</span> </span>{</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        Node* tail = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            Node* next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;child) {</span><br><span class="line">                Node* child = cur-&gt;child;</span><br><span class="line">                Node* childTail = <span class="built_in">flattenGetTail</span>(cur-&gt;child);</span><br><span class="line"></span><br><span class="line">                cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                cur-&gt;next = child;</span><br><span class="line">                child-&gt;prev = cur;</span><br><span class="line">                childTail-&gt;next = next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next)</span><br><span class="line">                    next-&gt;prev = childTail;</span><br><span class="line">                tail = childTail;</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                tail = cur;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cur = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="找到字符串中所有字母异位词-438"><a href="#找到字符串中所有字母异位词-438" class="headerlink" title="找到字符串中所有字母异位词[438]"></a>找到字符串中所有字母异位词[438]</h3><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><h4 id="示例-1-29"><a href="#示例-1-29" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "cbaebabacd", p = "abc"</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-30"><a href="#示例-2-30" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "abab", p = "ab"</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-39"><a href="#提示-39" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><h4 id="模板-33"><a href="#模板-33" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h4><p>滑动窗口。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">zero</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[p[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            hash[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash == zero)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = p.<span class="built_in">size</span>(); i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">            hash[s[i - p.<span class="built_in">size</span>()] - <span class="string">'a'</span>]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hash == zero)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i - p.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="两数相加-II-445"><a href="#两数相加-II-445" class="headerlink" title="两数相加 II[445]"></a>两数相加 II[445]</h3><p>给定两个 <strong>非空链表</strong> <code>l1</code>和 <code>l2</code> 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><h4 id="示例1-8"><a href="#示例1-8" class="headerlink" title="示例1"></a>示例1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626420025-fZfzMX-image-20211218224204036.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,8,0,7]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例2-6"><a href="#示例2-6" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[8,0,7]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例3-5"><a href="#示例3-5" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-40"><a href="#提示-40" class="headerlink" title="提示"></a>提示</h4><ul><li>链表的长度范围为<code>[1, 100]</code></li><li><code>0 &lt;= node.val &lt;= 9</code></li><li>输入数据保证链表代表的数字无前导 0</li></ul><p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p><h4 id="模板-34"><a href="#模板-34" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h4><ul><li>对链表进行翻转</li><li>设置一个空节点 <code>dummy</code>，也就是末尾节点，和一个进位数 <code>carry</code></li><li>遍历链表 <code>l1</code>、<code>l2</code>，条件是链表1，2不为空和进位数大于 0</li><li>求出当前位数，生成节点</li><li>对当前节点的 <code>next</code> 指向上一个节点（逆序）和求进位到下一个的数</li><li>三目运算符对链表进行下一个指向判断</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        l1 = <span class="built_in">reverse</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverse</span>(l2);</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* l = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) {</span><br><span class="line">            <span class="type">int</span> sum = (l1? l1-&gt;val: <span class="number">0</span>) + (l2? l2-&gt;val: <span class="number">0</span>) + carry;</span><br><span class="line">            carry = sum &gt;= <span class="number">10</span>? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">            sum = sum &gt;= <span class="number">10</span>? sum - <span class="number">10</span>: sum;</span><br><span class="line">            </span><br><span class="line">            l-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            </span><br><span class="line">            l1 = l1? l1-&gt;next: <span class="literal">nullptr</span>;</span><br><span class="line">            l2 = l2? l2-&gt;next: <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            l-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(dummy-&gt;next);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* succ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            succ = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = succ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="找树左下角的值-513"><a href="#找树左下角的值-513" class="headerlink" title="找树左下角的值[513]"></a>找树左下角的值[513]</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><h4 id="示例-1-30"><a href="#示例-1-30" class="headerlink" title="示例 1"></a>示例 1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree1-20220107161653527.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-31"><a href="#示例-2-31" class="headerlink" title="示例 2"></a>示例 2</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree2-20220107161730654.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-41"><a href="#提示-41" class="headerlink" title="提示:"></a>提示:</h4><ul><li>二叉树的节点个数的范围是 <code>[1,10^4]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h4 id="模板-35"><a href="#模板-35" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h4><p>若每次都记录当前层的最左端值，那么等遍历完二叉树，记录的当前层的最左端节点值就是最底层的最左端节点值，如图所示。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629516028-QgimFe-2ec6bf9d0c6a8c23ba023583bfeacf6-20220107161930201.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bottomLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    bottomLeft = node-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bottomLeft;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="在每个树行中找最大值-515"><a href="#在每个树行中找最大值-515" class="headerlink" title="在每个树行中找最大值[515]"></a>在每个树行中找最大值[515]</h3><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><h4 id="示例1-9"><a href="#示例1-9" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [1,3,2,5,3,null,9]</span><br><span class="line">输出: [1,3,9]</span><br><span class="line">解释:</span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        3   2</span><br><span class="line">       / \   \  </span><br><span class="line">      5   3   9 </span><br></pre></td></tr></tbody></table></figure><h4 id="示例2-7"><a href="#示例2-7" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [1,2,3]</span><br><span class="line">输出: [1,3]</span><br><span class="line">解释:</span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br></pre></td></tr></tbody></table></figure><h4 id="示例3-6"><a href="#示例3-6" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [1]</span><br><span class="line">输出: [1]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例4-1"><a href="#示例4-1" class="headerlink" title="示例4"></a>示例4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [1,null,2]</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释:      </span><br><span class="line">           1 </span><br><span class="line">            \</span><br><span class="line">             2     </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = []</span><br><span class="line">输出: []</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-42"><a href="#提示-42" class="headerlink" title="提示"></a>提示</h4><ul><li>二叉树的节点个数的范围是 <code>[0,10^4]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h4 id="模板-36"><a href="#模板-36" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629514102-NbQgoB-477afe8550c13a4e1e3c0e726bdf67a-20220102233928707.jpg"></p><p>“BFS 层次遍历”实现。</p><p>因为要求解二叉树每一层的最大值，所以使用二叉树的层次遍历是最适合不过的。但是因为需要求二叉树的每一层的最大值，所以需要确定哪些节点属于同一层。一种简单的方式就是，在遍历完当前层的最后一个节点之后，队列中所保存的节点数就是下一层的节点数。如图所示，红色节点为当前层的最后一个节点，绿色为处于队列中的下一层的所有节点。因为队列的初始状态是只有一个不为空的根节点，所以第一层就是一个节点，第二次就是遍历完根节点之后的队列中的节点，以此类推。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max = INT_MIN;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root) {</span><br><span class="line">            q.<span class="built_in">push</span>(root);</span><br><span class="line">            cur = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            cur--;</span><br><span class="line">            max = std::<span class="built_in">max</span>(max, node-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) {</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                next++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) {</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                next++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) {</span><br><span class="line">                res.<span class="built_in">push_back</span>(max);</span><br><span class="line">                max = INT_MIN;</span><br><span class="line"></span><br><span class="line">                cur = next;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="连续数组-525"><a href="#连续数组-525" class="headerlink" title="连续数组[525]"></a>连续数组[525]</h3><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</p><h4 id="示例-1-31"><a href="#示例-1-31" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-32"><a href="#示例-2-32" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-43"><a href="#提示-43" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>nums[i] 不是 0 就是 1</li></ul><h4 id="模板-37"><a href="#模板-37" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h4><p>前缀和加哈希表，把 0 当作 -1 处理，题目变成求和为 0 的子数组：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            presum += nums[i] == <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(presum) != mp.<span class="built_in">end</span>())</span><br><span class="line">                maxlen = <span class="built_in">max</span>(maxlen, i - mp[presum]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mp[presum] = i;    </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="最小时间差-539"><a href="#最小时间差-539" class="headerlink" title="最小时间差[539]"></a>最小时间差[539]</h3><p>给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p><h4 id="示例-1-32"><a href="#示例-1-32" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：timePoints = ["23:59","00:00"]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-33"><a href="#示例-2-33" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：timePoints = ["00:00","23:59","00:00"]</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-44"><a href="#提示-44" class="headerlink" title="提示"></a>提示</h4><ul><li><code>2 &lt;= timePoints &lt;= 2 * 10^4</code></li><li><code>timePoints[i]</code> 格式为 “<strong>HH:MM</strong>“</li></ul><h4 id="模板-38"><a href="#模板-38" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt;&amp; timePoints)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h4><p>首先，遍历时间列表，将其转换为“分钟制”列表 <code>mins</code>，比如，对于时间点 <code>13:14</code>，将其转换为 <code>13 * 60 + 14</code>。</p><p>接着将“分钟制”列表按升序排列，然后将此列表的最小时间 <code>mins[0]</code> 加上 <code>24 * 60</code> 追加至列表尾部，用于处理最大值、最小值的差值这种特殊情况。</p><p>最后遍历“分钟制”列表，找出相邻两个时间的最小值即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt; &amp;timePoints)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (timePoints.<span class="built_in">size</span>() &gt; <span class="number">24</span> * <span class="number">60</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mins;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : timePoints)</span><br><span class="line">            mins.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(t.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>)) * <span class="number">60</span> + <span class="built_in">stoi</span>(t.<span class="built_in">substr</span>(<span class="number">3</span>)));</span><br><span class="line">        <span class="built_in">sort</span>(mins.<span class="built_in">begin</span>(), mins.<span class="built_in">end</span>());</span><br><span class="line">        mins.<span class="built_in">push_back</span>(mins[<span class="number">0</span>] + <span class="number">24</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; mins.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            res = <span class="built_in">min</span>(res, mins[i] - mins[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="和为-K-的子数组-560"><a href="#和为-K-的子数组-560" class="headerlink" title="和为 K 的子数组[560]"></a>和为 K 的子数组[560]</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p><h4 id="示例-1-33"><a href="#示例-1-33" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-34"><a href="#示例-2-34" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-45"><a href="#提示-45" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= nums.length &lt;= 2 * 10^4</li><li>-1000 &lt;= nums[i] &lt;= 1000</li><li>-10^7 &lt;= k &lt;= 10^7</li></ul><h4 id="模板-39"><a href="#模板-39" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-47"><a href="#题解-47" class="headerlink" title="题解"></a>题解</h4><p>数组中既有正数又有负数，无法使用双指针。可以利用前缀和思想，快速判断子数组的和。前缀和思想。遍历数组求前缀和，把前缀和以及这个和出现的次数作为键值对存入哈希表中。</p><p>举例理解：数组的前 i 个数字之和记为 sum，如果存在一个 j（j &lt; i），数组的前 j 个数字之和为sum - k，那么数组中从第 j + 1个数字开始到第 i 个数字结束的子数组之和为 k。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) {</span><br><span class="line">            presum += nums[right];</span><br><span class="line">            count += mp[presum - k];</span><br><span class="line">            mp[presum]++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串中的变位词-567"><a href="#字符串中的变位词-567" class="headerlink" title="字符串中的变位词[567]"></a>字符串中的变位词[567]</h3><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的某个变位词。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p><h4 id="示例-1-34"><a href="#示例-1-34" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s1 = "ab" s2 = "eidbaooo"</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 ("ba").</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-35"><a href="#示例-2-35" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s1= "ab" s2 = "eidboaoo"</span><br><span class="line">输出: False</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-46"><a href="#提示-46" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 104</code></li><li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li></ul><blockquote><p>注意：本题与主站 567 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">https://leetcode-cn.com/problems/permutation-in-string/</a></p></blockquote><h4 id="模板-40"><a href="#模板-40" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-48"><a href="#题解-48" class="headerlink" title="题解"></a>题解</h4><ol><li>记录 s1 的哈希数组</li><li>确定左右指针的初始位置，并将当前所夹的子数组的字符出现情况与 s1 的哈希表进行比较</li><li>同时右移左右指针，左指针右移导致 ‘c’ 不在所夹的子数组中，所以将比较后的哈希数组中 ‘c’ 对应的值加 1，右指针右移导致 ‘b’ 进入所夹的子数组中，所以将比较后的哈希数组中 ‘b’ 对应的值减 1</li><li>重复步骤 3，直至找到答案或者遍历完 s2 均未找到答案</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628958996-hWmHxz-10139da0979df36b9067b22886a0890.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">zero</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[s1[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            hash[s2[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash == zero)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s1.<span class="built_in">size</span>(); i &lt; s2.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[s2[i] - <span class="string">'a'</span>]--;</span><br><span class="line">            hash[s2[i - s1.<span class="built_in">size</span>()] - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (hash == zero) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="循环有序列表的插入-708"><a href="#循环有序列表的插入-708" class="headerlink" title="循环有序列表的插入[708]"></a>循环有序列表的插入[708]</h3><p>给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 <code>insertVal</code>，使这个列表仍然是循环非降序的。</p><p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p><p>如果有多个满足条件的插入位置，你可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p><p>如果列表为空（给定的节点是 <code>null</code>），你需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p><h4 id="示例-1-35"><a href="#示例-1-35" class="headerlink" title="示例 1"></a>示例 1</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/example_1_before_65p-20211220220147609.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [3,4,1], insertVal = 2</span><br><span class="line">输出：[3,4,1,2]</span><br><span class="line">解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/example_1_after_65p-20211220220218531.jpg"></p><h4 id="示例-2-36"><a href="#示例-2-36" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [], insertVal = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-18"><a href="#示例-3-18" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1], insertVal = 0</span><br><span class="line">输出：[1,0]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-47"><a href="#提示-47" class="headerlink" title="提示"></a>提示</h4><ul><li><code>0 &lt;= Number of Nodes &lt;= 5 * 104</code></li><li><code>-10^6 &lt;= Node.val, insertVal &lt;= 10^6</code></li></ul><h4 id="模板-41"><a href="#模板-41" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="type">int</span> insertVal)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-49"><a href="#题解-49" class="headerlink" title="题解"></a>题解</h4><ol><li>头节点如果为空或仅为一个，直接返回 <code>head</code>或连成环</li><li>如果 <code>insertVal</code> 在链表的最小值和最大值之间，找到合适的位置插入</li><li>如果 <code>insertVal</code> 小于链表的最小值或大于链表的最大值，则在头节点和尾节点之间插入</li></ol><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="type">int</span> insertVal)</span> </span>{</span><br><span class="line">        Node* insert = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) {</span><br><span class="line">            head = insert;</span><br><span class="line">            head-&gt;next = head;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) {</span><br><span class="line">            head-&gt;next = insert;</span><br><span class="line">            insert-&gt;next = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">insertCore</span>(head, insert);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertCore</span><span class="params">(Node* head, Node* insert)</span> </span>{</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        Node* maxNode = head;</span><br><span class="line">        Node* next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!(cur-&gt;val &lt;= insert-&gt;val &amp;&amp; insert-&gt;val &lt;= next-&gt;val) &amp;&amp; next != head) {</span><br><span class="line">            cur = next;</span><br><span class="line">            next = next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt;= maxNode-&gt;val)</span><br><span class="line">                maxNode = cur;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt;= insert-&gt;val &amp;&amp; insert-&gt;val &lt;= next-&gt;val) {</span><br><span class="line">            insert-&gt;next = next;</span><br><span class="line">            cur-&gt;next = insert;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            insert-&gt;next = maxNode-&gt;next;</span><br><span class="line">            maxNode-&gt;next = insert;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="乘积小于K的子数组-713"><a href="#乘积小于K的子数组-713" class="headerlink" title="乘积小于K的子数组[713]"></a>乘积小于K的子数组[713]</h3><p>给定一个正整数数组 nums和整数 k 。</p><p>请找出该数组内乘积小于 k 的连续的子数组的个数。</p><h4 id="示例-1-36"><a href="#示例-1-36" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [10,5,2,6], k = 100</span><br><span class="line">输出: 8</span><br><span class="line">解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br><span class="line">需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-37"><a href="#示例-2-37" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3], k = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-48"><a href="#提示-48" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= nums.length &lt;= 3 * 10^4</li><li>1 &lt;= nums[i] &lt;= 1000</li><li>0 &lt;= k &lt;= 10^6</li></ul><h4 id="模板-42"><a href="#模板-42" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-50"><a href="#题解-50" class="headerlink" title="题解"></a>题解</h4><p>利用滑动窗口，我们能求出每个不同 <code>right</code> 结尾的合法子数组的个数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right;</span><br><span class="line">        <span class="type">long</span> mul = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) {</span><br><span class="line">            mul *= nums[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; mul &gt;= k) {</span><br><span class="line">                mul /= nums[left++];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            count += right &gt;= left? right - left + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="寻找数组的中心下标-724"><a href="#寻找数组的中心下标-724" class="headerlink" title="寻找数组的中心下标[724]"></a>寻找数组的中心下标[724]</h3><p>给你一个整数数组 nums ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code>，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 -1 。</p><h4 id="示例-1-37"><a href="#示例-1-37" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-38"><a href="#示例-2-38" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心下标。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-19"><a href="#示例-3-19" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [2, 1, -1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">中心下标是 0 。</span><br><span class="line">左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），</span><br><span class="line">右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-49"><a href="#提示-49" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= nums.length &lt;= 10^4</li><li>-1000 &lt;= nums[i] &lt;= 1000</li></ul><blockquote><p>注意：本题与主站 1991 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-middle-index-in-array/">https://leetcode-cn.com/problems/find-the-middle-index-in-array/</a></p></blockquote><h4 id="模板-43"><a href="#模板-43" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-51"><a href="#题解-51" class="headerlink" title="题解"></a>题解</h4><p>用前缀和进行预处理，避免重复计算：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            total += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (total - nums[i] == sum - total)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="行星碰撞-735"><a href="#行星碰撞-735" class="headerlink" title="行星碰撞[735]"></a>行星碰撞[735]</h3><p>给定一个整数数组 <code>asteroids</code>，表示在同一行的行星。</p><p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p><p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p><h4 id="示例-1-38"><a href="#示例-1-38" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：asteroids = [5,10,-5]</span><br><span class="line">输出：[5,10]</span><br><span class="line">解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-39"><a href="#示例-2-39" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：asteroids = [8,-8]</span><br><span class="line">输出：[]</span><br><span class="line">解释：8 和 -8 碰撞后，两者都发生爆炸。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-20"><a href="#示例-3-20" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：asteroids = [10,2,-5]</span><br><span class="line">输出：[10]</span><br><span class="line">解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-4-6"><a href="#示例-4-6" class="headerlink" title="示例 4"></a>示例 4</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：asteroids = [-2,-1,1,2]</span><br><span class="line">输出：[-2,-1,1,2]</span><br><span class="line">解释：-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 </span><br></pre></td></tr></tbody></table></figure><h4 id="提示-50"><a href="#提示-50" class="headerlink" title="提示"></a>提示</h4><ul><li><code>2 &lt;= asteroids.length &lt;= 10^4</code></li><li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li><li><code>asteroids[i] != 0</code></li></ul><h4 id="模板-44"><a href="#模板-44" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">asteroidCollision</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; asteroids)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-52"><a href="#题解-52" class="headerlink" title="题解"></a>题解</h4><p>可以类比成左右括号匹配：</p><ul><li>向右移动的小行星（左括号）：不会引发碰撞，直接入栈</li><li>向左移动的小行星（右括号）：可能会和之前向右移动的小行星发生碰撞，特殊处理</li></ul><p>因为答案需要碰撞后剩下的所有小行星，相当于栈里最后剩下的元素，所以可以直接用数组表示栈。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629345113-XXdGKZ-f1dbb5feb6708bc5ec400d978eea73a-20211226205629348.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">asteroidCollision</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; asteroids)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a: asteroids) {</span><br><span class="line">            <span class="keyword">if</span> (a &gt; <span class="number">0</span>) {</span><br><span class="line">                res.<span class="built_in">push_back</span>(a);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">while</span> (!res.<span class="built_in">empty</span>() &amp;&amp; res.<span class="built_in">back</span>() &gt; <span class="number">0</span> &amp;&amp; res.<span class="built_in">back</span>() &lt; -a)</span><br><span class="line">                    res.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() &amp;&amp; res.<span class="built_in">back</span>() == -a)</span><br><span class="line">                    res.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="built_in">empty</span>() || res.<span class="built_in">back</span>() &lt; -a)    </span><br><span class="line">                    res.<span class="built_in">push_back</span>(a);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="每日温度-739"><a href="#每日温度-739" class="headerlink" title="每日温度[739]"></a>每日温度[739]</h3><p>请根据每日 <code>气温</code> 列表 <code>temperatures</code> ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><h4 id="示例1-10"><a href="#示例1-10" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例2-8"><a href="#示例2-8" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例3-7"><a href="#示例3-7" class="headerlink" title="示例3"></a>示例3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-51"><a href="#提示-51" class="headerlink" title="提示"></a>提示</h4><ul><li>1 &lt;= <code>temperatures.length</code> &lt;= $10^5$</li><li>30 &lt;= <code>temperatures[i]</code> &lt;= 100</li></ul><h4 id="模板-45"><a href="#模板-45" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-53"><a href="#题解-53" class="headerlink" title="题解"></a>题解</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/a24107cefeff7239068268099db90671254c2d357857232f19dc21bdaace5774-image.png"></p><ul><li>如果当前元素比栈顶大，则让小项逐个出栈，直到当前元素比栈顶小，停止出栈</li><li>此时的栈顶元素就是当前项右边的第一个比自己大的元素索引，计算距离</li><li>当前项入栈</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt;= temperatures[s.<span class="built_in">top</span>()])</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i] = s.<span class="built_in">top</span>() - i;     </span><br><span class="line">            </span><br><span class="line">            s.<span class="built_in">push</span>(i);   </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="链表的中间结点-876"><a href="#链表的中间结点-876" class="headerlink" title="链表的中间结点[876]"></a>链表的中间结点[876]</h3><p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><h4 id="示例-1-39"><a href="#示例-1-39" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-40"><a href="#示例-2-40" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-52"><a href="#提示-52" class="headerlink" title="提示"></a>提示</h4><ul><li>给定链表的结点数介于 1 和 100 之间。</li></ul><h4 id="模板-46"><a href="#模板-46" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-54"><a href="#题解-54" class="headerlink" title="题解"></a>题解</h4><p>用两个指针 <code>slow</code> 与 <code>fast</code> 一起遍历链表。<code>slow</code> 一次走一步，<code>fast</code> 一次走两步。那么当 <code>fast</code> 到达链表的末尾时，<code>slow</code> 必然位于中间。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) {</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="完全二叉树插入器-919"><a href="#完全二叉树插入器-919" class="headerlink" title="完全二叉树插入器[919]"></a>完全二叉树插入器[919]</h3><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p><p>设计一个用完全二叉树初始化的数据结构 <code>CBTInserter</code>，它支持以下几种操作：</p><ul><li><code>CBTInserter(TreeNode root)</code> 使用头节点为 <code>root</code> 的给定树初始化该数据结构；</li><li><code>CBTInserter.insert(int v)</code> 向树中插入一个新节点，节点类型为 <code>TreeNode</code>，值为 <code>v</code> 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；</li><li><code>CBTInserter.get_root()</code> 将返回树的头节点。</li></ul><h4 id="示例-1-40"><a href="#示例-1-40" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]]</span><br><span class="line">输出：[null,1,[1,2]]</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-41"><a href="#示例-2-41" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]</span><br><span class="line">输出：[null,3,4,[1,2,3,4,5,6,7,8]]</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-53"><a href="#提示-53" class="headerlink" title="提示"></a>提示</h4><ul><li>最初给定的树是完全二叉树，且包含 1 到 1000 个节点。</li><li>每个测试用例最多调用 <code>CBTInserter.insert</code> 操作 10000 次。</li><li>给定节点或插入节点的每个值都在 0 到 5000 之间。</li></ul><h4 id="模板-47"><a href="#模板-47" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBTInserter</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CBTInserter</span>(TreeNode* root) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">get_root</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CBTInserter* obj = new CBTInserter(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * TreeNode* param_2 = obj-&gt;get_root();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="题解-55"><a href="#题解-55" class="headerlink" title="题解"></a>题解</h4><p>完全二叉树只有最后一层是不满的，通过层序遍历就能找到应该插入的节点位置的父节点，然后将新节点插到该父节点下面即可。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629473154-gKRqvU-ce27c552f3c1d653d97978cf52b4b0d-20220102232041162.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBTInserter</span> {</span><br><span class="line">    TreeNode* rt;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CBTInserter</span>(TreeNode* root) {</span><br><span class="line">        rt = root;</span><br><span class="line">        q.<span class="built_in">push</span>(rt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">front</span>()-&gt;left &amp;&amp; q.<span class="built_in">front</span>()-&gt;right) {</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            </span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        TreeNode* parent = q.<span class="built_in">front</span>();</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;left == <span class="literal">nullptr</span>) {</span><br><span class="line">            parent-&gt;left = node;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent-&gt;right = node;</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(parent-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(parent-&gt;right);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parent-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">get_root</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CBTInserter* obj = new CBTInserter(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * TreeNode* param_2 = obj-&gt;get_root();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="最近的请求次数-933"><a href="#最近的请求次数-933" class="headerlink" title="最近的请求次数[933]"></a>最近的请求次数[933]</h3><p>写一个 <code>RecentCounter</code> 类来计算特定时间范围内最近的请求。</p><p>请你实现 <code>RecentCounter</code> 类：</p><ul><li><code>RecentCounter()</code> 初始化计数器，请求数为 0</li><li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li></ul><p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">["RecentCounter", "ping", "ping", "ping", "ping"]</span><br><span class="line">[[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">RecentCounter recentCounter = new RecentCounter();</span><br><span class="line">recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1</span><br><span class="line">recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2</span><br><span class="line">recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3</span><br><span class="line">recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-54"><a href="#提示-54" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= t &lt;= 10^9</code></li><li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 严格递增</li><li>至多调用 <code>ping</code> 方法 <code>10^4</code> 次</li></ul><h4 id="模板-48"><a href="#模板-48" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RecentCounter</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ping</span><span class="params">(<span class="type">int</span> t)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="题解-56"><a href="#题解-56" class="headerlink" title="题解"></a>题解</h4><p>在第 1、100、3001、3002 这四个时间点分别进行了 ping 请求， 在 3001 秒的时候， 它前面的 3000 秒指的是区间 <code>[1,3001]</code>， 所以一共是有 <code>1、100、3001</code> 三个请求， t = 3002 的前 3000 秒指的是区间 <code>[2,3002]</code>, 所以有 <code>100、3001、3002</code> 三次请求。</p><p>可以用队列实现。每次将 t 进入队尾，同时从队头开始依次移除小于 <code>t-3000</code> 的元素。然后返回队列的大小 <code>q.size()</code> 即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> {</span><br><span class="line">    queue&lt;<span class="type">long</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RecentCounter</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ping</span><span class="params">(<span class="type">int</span> t)</span> </span>{</span><br><span class="line">        q.<span class="built_in">push</span>(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">front</span>() + <span class="number">3000</span> &lt; t) {</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="验证外星语词典-953"><a href="#验证外星语词典-953" class="headerlink" title="验证外星语词典[953]"></a>验证外星语词典[953]</h3><p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p><p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p><h4 id="示例-1-41"><a href="#示例-1-41" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"</span><br><span class="line">输出：true</span><br><span class="line">解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2-42"><a href="#示例-2-42" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"</span><br><span class="line">输出：false</span><br><span class="line">解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-3-21"><a href="#示例-3-21" class="headerlink" title="示例 3"></a>示例 3</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"</span><br><span class="line">输出：false</span><br><span class="line">解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" &gt; "app"，因为 'l' &gt; '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。</span><br></pre></td></tr></tbody></table></figure><h4 id="提示-55"><a href="#提示-55" class="headerlink" title="提示"></a>提示</h4><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 20</code></li><li><code>order.length == 26</code></li><li>在 <code>words[i]</code> 和 <code>order</code> 中的所有字符都是英文小写字母。</li></ul><h4 id="模板-49"><a href="#模板-49" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAlienSorted</span><span class="params">(vector&lt;string&gt;&amp; words, string order)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="题解-57"><a href="#题解-57" class="headerlink" title="题解"></a>题解</h4><p>用数组或哈希表存放字母顺序。依次遍历单词列表，检测相邻两单词是否满足字典序。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAlienSorted</span><span class="params">(vector&lt;string&gt;&amp; words, string order)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>() - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isOrdered</span>(words[i], words[i +<span class="number">1</span>], order))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isOrdered</span><span class="params">(string word1, string word2, string order)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            hash[order[i] - <span class="string">'a'</span>] = i;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>() &amp;&amp; i &lt; word2.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">char</span> ch1 = word1[i];</span><br><span class="line">            <span class="type">char</span> ch2 = word2[i];</span><br><span class="line">            <span class="keyword">if</span> (hash[ch1 - <span class="string">'a'</span>] &lt; hash[ch2 - <span class="string">'a'</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (hash[ch1 - <span class="string">'a'</span>] &gt; hash[ch2 - <span class="string">'a'</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;      </span><br><span class="line">        }    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i == word1.<span class="built_in">size</span>();  </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8add02f4.html" rel="bookmark">剑指Offer(专项突破版)</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/dd921d98.html" rel="bookmark">剑指Offer</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8069546e.html" rel="bookmark">Stack</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Cpp/" rel="tag"># Cpp</a> <a href="/tags/LeetCode/" rel="tag"># LeetCode</a> <a href="/tags/Algorithm/" rel="tag"># Algorithm</a> <a href="/tags/Online-Judge/" rel="tag"># Online Judge</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/8fa1c6be.html" rel="prev" title="编译原理绪论"><i class="fa fa-chevron-left"></i> 编译原理绪论</a></div><div class="post-nav-item"><a href="/archives/d10a3b2.html" rel="next" title="游戏开发导论">游戏开发导论 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-1"><span class="nav-number">2.</span> <span class="nav-text">两数之和[1]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">2.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">2.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA"><span class="nav-number">2.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.5.</span> <span class="nav-text">默认模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3"><span class="nav-number">2.6.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE"><span class="nav-number">2.6.1.</span> <span class="nav-text">暴力枚举</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-2"><span class="nav-number">3.</span> <span class="nav-text">两数相加[2]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="nav-number">3.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-1"><span class="nav-number">3.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-1"><span class="nav-number">3.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-1"><span class="nav-number">3.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-1"><span class="nav-number">3.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-3"><span class="nav-number">4.</span> <span class="nav-text">无重复字符的最长子串[3]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-1"><span class="nav-number">4.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-2"><span class="nav-number">4.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-2"><span class="nav-number">4.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">4.4.</span> <span class="nav-text">示例 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-2"><span class="nav-number">4.5.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF-1"><span class="nav-number">4.6.</span> <span class="nav-text">默认模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-2"><span class="nav-number">4.7.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E8%A7%A3%E5%86%B3-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-4"><span class="nav-number">5.</span> <span class="nav-text">[未解决]寻找两个正序数组的中位数[4]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-2"><span class="nav-number">5.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-3"><span class="nav-number">5.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-3"><span class="nav-number">5.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4-1"><span class="nav-number">5.4.</span> <span class="nav-text">示例 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="nav-number">5.5.</span> <span class="nav-text">示例 5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-3"><span class="nav-number">5.6.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF-2"><span class="nav-number">5.7.</span> <span class="nav-text">默认模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-3"><span class="nav-number">5.8.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-5"><span class="nav-number">6.</span> <span class="nav-text">最长回文子串[5]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-3"><span class="nav-number">6.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-4"><span class="nav-number">6.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-4"><span class="nav-number">6.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4-2"><span class="nav-number">6.4.</span> <span class="nav-text">示例 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-4"><span class="nav-number">6.5.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF-3"><span class="nav-number">6.6.</span> <span class="nav-text">默认模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-4"><span class="nav-number">6.7.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2-6"><span class="nav-number">7.</span> <span class="nav-text">Z 字形变换[6]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-4"><span class="nav-number">7.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-5"><span class="nav-number">7.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-5"><span class="nav-number">7.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-5"><span class="nav-number">7.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF-4"><span class="nav-number">7.5.</span> <span class="nav-text">默认模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-5"><span class="nav-number">7.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-7"><span class="nav-number">8.</span> <span class="nav-text">整数反转[7]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-5"><span class="nav-number">8.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-6"><span class="nav-number">8.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-6"><span class="nav-number">8.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4-3"><span class="nav-number">8.4.</span> <span class="nav-text">示例 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-6"><span class="nav-number">8.5.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF-5"><span class="nav-number">8.6.</span> <span class="nav-text">默认模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-6"><span class="nav-number">8.7.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reverse"><span class="nav-number">8.8.</span> <span class="nav-text">reverse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stoll"><span class="nav-number">8.9.</span> <span class="nav-text">stoll</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E8%A7%A3%E5%86%B3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi-8"><span class="nav-number">9.</span> <span class="nav-text">[未解决]字符串转换整数 (atoi)[8]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-6"><span class="nav-number">9.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-7"><span class="nav-number">9.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-7"><span class="nav-number">9.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4-4"><span class="nav-number">9.4.</span> <span class="nav-text">示例 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-5-1"><span class="nav-number">9.5.</span> <span class="nav-text">示例 5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-7"><span class="nav-number">9.6.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF-6"><span class="nav-number">9.7.</span> <span class="nav-text">默认模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-7"><span class="nav-number">9.8.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-11"><span class="nav-number">10.</span> <span class="nav-text">盛最多水的容器[11]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-1"><span class="nav-number">10.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="nav-number">10.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3"><span class="nav-number">10.3.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B4"><span class="nav-number">10.4.</span> <span class="nav-text">示例4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-8"><span class="nav-number">10.5.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-1"><span class="nav-number">10.6.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-8"><span class="nav-number">10.7.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-15"><span class="nav-number">11.</span> <span class="nav-text">三数之和[15]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-7"><span class="nav-number">11.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-8"><span class="nav-number">11.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-8"><span class="nav-number">11.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-9"><span class="nav-number">11.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-2"><span class="nav-number">11.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-9"><span class="nav-number">11.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9-19"><span class="nav-number">12.</span> <span class="nav-text">删除链表的倒数第 N 个结点[19]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-2"><span class="nav-number">12.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-9"><span class="nav-number">12.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3-1"><span class="nav-number">12.3.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-10"><span class="nav-number">12.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-3"><span class="nav-number">12.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-10"><span class="nav-number">12.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-20"><span class="nav-number">13.</span> <span class="nav-text">有效的括号[20]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-8"><span class="nav-number">13.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-10"><span class="nav-number">13.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-9"><span class="nav-number">13.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4-5"><span class="nav-number">13.4.</span> <span class="nav-text">示例 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-5-2"><span class="nav-number">13.5.</span> <span class="nav-text">示例 5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-11"><span class="nav-number">13.6.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-4"><span class="nav-number">13.7.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-11"><span class="nav-number">13.8.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-26"><span class="nav-number">14.</span> <span class="nav-text">删除有序数组中的重复项[26]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">14.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-3"><span class="nav-number">14.2.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-1"><span class="nav-number">14.3.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-12"><span class="nav-number">14.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-5"><span class="nav-number">14.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-12"><span class="nav-number">14.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4-42"><span class="nav-number">15.</span> <span class="nav-text">接雨水[42]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-4"><span class="nav-number">15.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-2"><span class="nav-number">15.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-13"><span class="nav-number">15.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-6"><span class="nav-number">15.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-13"><span class="nav-number">15.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-49"><span class="nav-number">16.</span> <span class="nav-text">字母异位词分组[49]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-9"><span class="nav-number">16.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-11"><span class="nav-number">16.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-10"><span class="nav-number">16.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-14"><span class="nav-number">16.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-7"><span class="nav-number">16.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-14"><span class="nav-number">16.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C-67"><span class="nav-number">17.</span> <span class="nav-text">二进制求和[67]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-10"><span class="nav-number">17.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-12"><span class="nav-number">17.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-15"><span class="nav-number">17.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-8"><span class="nav-number">17.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-15"><span class="nav-number">17.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II-80"><span class="nav-number">18.</span> <span class="nav-text">删除有序数组中的重复项 II[80]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-1"><span class="nav-number">18.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-11"><span class="nav-number">18.2.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-13"><span class="nav-number">18.3.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-16"><span class="nav-number">18.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-9"><span class="nav-number">18.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-16"><span class="nav-number">18.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-84"><span class="nav-number">19.</span> <span class="nav-text">柱状图中最大的矩形[84]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-12"><span class="nav-number">19.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-14"><span class="nav-number">19.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-17"><span class="nav-number">19.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-10"><span class="nav-number">19.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-17"><span class="nav-number">19.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-92"><span class="nav-number">20.</span> <span class="nav-text">反转链表 II[92]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-5"><span class="nav-number">20.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-3"><span class="nav-number">20.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-18"><span class="nav-number">20.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-11"><span class="nav-number">20.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-18"><span class="nav-number">20.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II-137"><span class="nav-number">21.</span> <span class="nav-text">只出现一次的数字 II[137]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-13"><span class="nav-number">21.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-15"><span class="nav-number">21.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-19"><span class="nav-number">21.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-12"><span class="nav-number">21.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-19"><span class="nav-number">21.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141"><span class="nav-number">22.</span> <span class="nav-text">环形链表[141]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-6"><span class="nav-number">22.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-4"><span class="nav-number">22.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3-2"><span class="nav-number">22.3.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-20"><span class="nav-number">22.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-13"><span class="nav-number">22.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-20"><span class="nav-number">22.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II-142"><span class="nav-number">23.</span> <span class="nav-text">环形链表 II[142]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-14"><span class="nav-number">23.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-16"><span class="nav-number">23.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-11"><span class="nav-number">23.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-21"><span class="nav-number">23.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-14"><span class="nav-number">23.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-21"><span class="nav-number">23.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-143"><span class="nav-number">24.</span> <span class="nav-text">重排链表[143]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-15"><span class="nav-number">24.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-17"><span class="nav-number">24.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-22"><span class="nav-number">24.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-15"><span class="nav-number">24.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-22"><span class="nav-number">24.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-150"><span class="nav-number">25.</span> <span class="nav-text">逆波兰表达式求值[150]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-16"><span class="nav-number">25.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-18"><span class="nav-number">25.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-12"><span class="nav-number">25.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-23"><span class="nav-number">25.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-16"><span class="nav-number">25.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-23"><span class="nav-number">25.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88-155"><span class="nav-number">26.</span> <span class="nav-text">最小栈[155]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">26.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-24"><span class="nav-number">26.2.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-17"><span class="nav-number">26.3.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-24"><span class="nav-number">26.4.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-160"><span class="nav-number">27.</span> <span class="nav-text">相交链表[160]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-17"><span class="nav-number">27.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-19"><span class="nav-number">27.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3-3"><span class="nav-number">27.3.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-25"><span class="nav-number">27.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-18"><span class="nav-number">27.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-25"><span class="nav-number">27.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-167"><span class="nav-number">28.</span> <span class="nav-text">两数之和 II - 输入有序数组[167]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-18"><span class="nav-number">28.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-20"><span class="nav-number">28.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-13"><span class="nav-number">28.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-26"><span class="nav-number">28.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-19"><span class="nav-number">28.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-26"><span class="nav-number">28.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-199"><span class="nav-number">29.</span> <span class="nav-text">二叉树的右视图[199]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-19"><span class="nav-number">29.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-21"><span class="nav-number">29.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-14"><span class="nav-number">29.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-27"><span class="nav-number">29.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-20"><span class="nav-number">29.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-27"><span class="nav-number">29.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-206"><span class="nav-number">30.</span> <span class="nav-text">反转链表[206]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-20"><span class="nav-number">30.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-22"><span class="nav-number">30.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3-4"><span class="nav-number">30.3.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-28"><span class="nav-number">30.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-21"><span class="nav-number">30.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-28"><span class="nav-number">30.6.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">30.6.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-number">30.6.2.</span> <span class="nav-text">非递归</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-209"><span class="nav-number">31.</span> <span class="nav-text">长度最小的子数组[209]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-21"><span class="nav-number">31.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-23"><span class="nav-number">31.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-15"><span class="nav-number">31.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-29"><span class="nav-number">31.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-22"><span class="nav-number">31.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-29"><span class="nav-number">31.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-234"><span class="nav-number">32.</span> <span class="nav-text">回文链表[234]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-7"><span class="nav-number">32.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-5"><span class="nav-number">32.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-30"><span class="nav-number">32.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-23"><span class="nav-number">32.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-30"><span class="nav-number">32.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-237"><span class="nav-number">33.</span> <span class="nav-text">删除链表中的节点[237]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-22"><span class="nav-number">33.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-24"><span class="nav-number">33.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-31"><span class="nav-number">33.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-24"><span class="nav-number">33.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-31"><span class="nav-number">33.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-242"><span class="nav-number">34.</span> <span class="nav-text">有效的字母异位词[242]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-23"><span class="nav-number">34.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-25"><span class="nav-number">34.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-32"><span class="nav-number">34.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-25"><span class="nav-number">34.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-32"><span class="nav-number">34.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6-283"><span class="nav-number">35.</span> <span class="nav-text">移动零[283]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">35.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-2"><span class="nav-number">35.2.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-26"><span class="nav-number">35.3.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-33"><span class="nav-number">35.4.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98-304"><span class="nav-number">36.</span> <span class="nav-text">二维区域和检索 - 矩阵不可变[304]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-24"><span class="nav-number">36.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-33"><span class="nav-number">36.2.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-27"><span class="nav-number">36.3.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-34"><span class="nav-number">36.4.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF-318"><span class="nav-number">37.</span> <span class="nav-text">最大单词长度乘积[318]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-25"><span class="nav-number">37.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-26"><span class="nav-number">37.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-16"><span class="nav-number">37.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-34"><span class="nav-number">37.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-28"><span class="nav-number">37.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-35"><span class="nav-number">37.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0-338"><span class="nav-number">38.</span> <span class="nav-text">比特位计数[338]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-26"><span class="nav-number">38.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-27"><span class="nav-number">38.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-35"><span class="nav-number">38.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6"><span class="nav-number">38.4.</span> <span class="nav-text">进阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-29"><span class="nav-number">38.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-36"><span class="nav-number">38.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344"><span class="nav-number">39.</span> <span class="nav-text">反转字符串[344]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-27"><span class="nav-number">39.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-28"><span class="nav-number">39.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF-7"><span class="nav-number">39.3.</span> <span class="nav-text">默认模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-37"><span class="nav-number">39.4.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E5%80%BC-346"><span class="nav-number">40.</span> <span class="nav-text">数据流中的移动平均值[346]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">40.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-36"><span class="nav-number">40.2.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-30"><span class="nav-number">40.3.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-38"><span class="nav-number">40.4.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-380"><span class="nav-number">41.</span> <span class="nav-text">O(1) 时间插入、删除和获取随机元素[380]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">41.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-37"><span class="nav-number">41.2.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-31"><span class="nav-number">41.3.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-39"><span class="nav-number">41.4.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-430"><span class="nav-number">42.</span> <span class="nav-text">扁平化多级双向链表[430]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-28"><span class="nav-number">42.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-29"><span class="nav-number">42.2.</span> <span class="nav-text">示例 2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-17"><span class="nav-number">42.2.1.</span> <span class="nav-text">示例 3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-38"><span class="nav-number">42.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-32"><span class="nav-number">42.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-40"><span class="nav-number">42.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-438"><span class="nav-number">43.</span> <span class="nav-text">找到字符串中所有字母异位词[438]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-29"><span class="nav-number">43.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-30"><span class="nav-number">43.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-39"><span class="nav-number">43.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-33"><span class="nav-number">43.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-41"><span class="nav-number">43.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II-445"><span class="nav-number">44.</span> <span class="nav-text">两数相加 II[445]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-8"><span class="nav-number">44.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-6"><span class="nav-number">44.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3-5"><span class="nav-number">44.3.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-40"><span class="nav-number">44.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-34"><span class="nav-number">44.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-42"><span class="nav-number">44.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC-513"><span class="nav-number">45.</span> <span class="nav-text">找树左下角的值[513]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-30"><span class="nav-number">45.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-31"><span class="nav-number">45.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-41"><span class="nav-number">45.3.</span> <span class="nav-text">提示:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-35"><span class="nav-number">45.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-43"><span class="nav-number">45.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC-515"><span class="nav-number">46.</span> <span class="nav-text">在每个树行中找最大值[515]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-9"><span class="nav-number">46.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-7"><span class="nav-number">46.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3-6"><span class="nav-number">46.3.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B4-1"><span class="nav-number">46.4.</span> <span class="nav-text">示例4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B5"><span class="nav-number">46.5.</span> <span class="nav-text">示例5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-42"><span class="nav-number">46.6.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-36"><span class="nav-number">46.7.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-44"><span class="nav-number">46.8.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84-525"><span class="nav-number">47.</span> <span class="nav-text">连续数组[525]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-31"><span class="nav-number">47.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-32"><span class="nav-number">47.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-43"><span class="nav-number">47.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-37"><span class="nav-number">47.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-45"><span class="nav-number">47.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE-539"><span class="nav-number">48.</span> <span class="nav-text">最小时间差[539]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-32"><span class="nav-number">48.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-33"><span class="nav-number">48.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-44"><span class="nav-number">48.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-38"><span class="nav-number">48.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-46"><span class="nav-number">48.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-560"><span class="nav-number">49.</span> <span class="nav-text">和为 K 的子数组[560]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-33"><span class="nav-number">49.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-34"><span class="nav-number">49.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-45"><span class="nav-number">49.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-39"><span class="nav-number">49.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-47"><span class="nav-number">49.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D-567"><span class="nav-number">50.</span> <span class="nav-text">字符串中的变位词[567]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-34"><span class="nav-number">50.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-35"><span class="nav-number">50.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-46"><span class="nav-number">50.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-40"><span class="nav-number">50.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-48"><span class="nav-number">50.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5-708"><span class="nav-number">51.</span> <span class="nav-text">循环有序列表的插入[708]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-35"><span class="nav-number">51.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-36"><span class="nav-number">51.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-18"><span class="nav-number">51.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-47"><span class="nav-number">51.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-41"><span class="nav-number">51.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-49"><span class="nav-number">51.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-713"><span class="nav-number">52.</span> <span class="nav-text">乘积小于K的子数组[713]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-36"><span class="nav-number">52.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-37"><span class="nav-number">52.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-48"><span class="nav-number">52.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-42"><span class="nav-number">52.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-50"><span class="nav-number">52.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87-724"><span class="nav-number">53.</span> <span class="nav-text">寻找数组的中心下标[724]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-37"><span class="nav-number">53.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-38"><span class="nav-number">53.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-19"><span class="nav-number">53.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-49"><span class="nav-number">53.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-43"><span class="nav-number">53.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-51"><span class="nav-number">53.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E-735"><span class="nav-number">54.</span> <span class="nav-text">行星碰撞[735]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-38"><span class="nav-number">54.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-39"><span class="nav-number">54.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-20"><span class="nav-number">54.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4-6"><span class="nav-number">54.4.</span> <span class="nav-text">示例 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-50"><span class="nav-number">54.5.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-44"><span class="nav-number">54.6.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-52"><span class="nav-number">54.7.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-739"><span class="nav-number">55.</span> <span class="nav-text">每日温度[739]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-10"><span class="nav-number">55.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-8"><span class="nav-number">55.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3-7"><span class="nav-number">55.3.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-51"><span class="nav-number">55.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-45"><span class="nav-number">55.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-53"><span class="nav-number">55.6.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9-876"><span class="nav-number">56.</span> <span class="nav-text">链表的中间结点[876]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-39"><span class="nav-number">56.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-40"><span class="nav-number">56.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-52"><span class="nav-number">56.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-46"><span class="nav-number">56.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-54"><span class="nav-number">56.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8-919"><span class="nav-number">57.</span> <span class="nav-text">完全二叉树插入器[919]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-40"><span class="nav-number">57.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-41"><span class="nav-number">57.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-53"><span class="nav-number">57.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-47"><span class="nav-number">57.4.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-55"><span class="nav-number">57.5.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0-933"><span class="nav-number">58.</span> <span class="nav-text">最近的请求次数[933]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">58.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-54"><span class="nav-number">58.2.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-48"><span class="nav-number">58.3.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-56"><span class="nav-number">58.4.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8-953"><span class="nav-number">59.</span> <span class="nav-text">验证外星语词典[953]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1-41"><span class="nav-number">59.1.</span> <span class="nav-text">示例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2-42"><span class="nav-number">59.2.</span> <span class="nav-text">示例 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3-21"><span class="nav-number">59.3.</span> <span class="nav-text">示例 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-55"><span class="nav-number">59.4.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-49"><span class="nav-number">59.5.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-57"><span class="nav-number">59.6.</span> <span class="nav-text">题解</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">296</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">47</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.5m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
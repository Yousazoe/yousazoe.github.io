<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言《Ray Tracing: The Rest of Your Life》（《用余生研究光线追踪》）， 由 Peter Shirley（就是那本图形学虎书的作者）所编写的的软渲光追三部曲第三本。在本卷中，我假设你将追求与光线追踪相关的职业，我们将深入创建一个非常严肃的光线追踪器的数学。当你完成的时候，你应该准备好开始与电影和产品设计行业的许多严肃的商业射线追踪器打交道。"><meta property="og:type" content="article"><meta property="og:title" content="Ray Tracing the Rest of Your Life"><meta property="og:url" content="https://yousazoe.top/archives/e2b2b0f4.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言《Ray Tracing: The Rest of Your Life》（《用余生研究光线追踪》）， 由 Peter Shirley（就是那本图形学虎书的作者）所编写的的软渲光追三部曲第三本。在本卷中，我假设你将追求与光线追踪相关的职业，我们将深入创建一个非常严肃的光线追踪器的数学。当你完成的时候，你应该准备好开始与电影和产品设计行业的许多严肃的商业射线追踪器打交道。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.01-circ-square.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.02-jitter.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.03-histogram.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.04-linear-pdf.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.05-solid-angle.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.01-cornell-refactor1.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.02-cornell-refactor2.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.06-rand-pts-sphere.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.03-cornell-ortho.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.07-shape-onto-pdf.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.04-cornell-sample-light.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.05-cornell-lightdown.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.06-cornell-cos-pdf.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.07-hittable-light.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.08-cosine-and-light.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.09-arbitrary-pdf.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.08-sphere-enclosing-cone.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.10-cornell-glass-sphere.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light-20210816114843095.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.12-book3-final.jpg"><meta property="article:published_time" content="2021-08-14T02:16:55.000Z"><meta property="article:modified_time" content="2022-07-23T09:43:01.139Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light.jpg"><link rel="canonical" href="https://yousazoe.top/archives/e2b2b0f4.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Ray Tracing the Rest of Your Life | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/e2b2b0f4.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Ray Tracing the Rest of Your Life</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-08-14 10:16:55" itemprop="dateCreated datePublished" datetime="2021-08-14T10:16:55+08:00">2021-08-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">光线追踪 (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>69k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>2:06</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html">《Ray Tracing: The Rest of Your Life》</a>（《用余生研究光线追踪》）， 由 Peter Shirley（就是那本图形学虎书的作者）所编写的的软渲光追三部曲第三本。在本卷中，我假设你将追求与光线追踪相关的职业，我们将深入创建一个非常严肃的光线追踪器的数学。当你完成的时候，你应该准备好开始与电影和产品设计行业的许多严肃的商业射线追踪器打交道。</p><span id="more"></span><blockquote><p>原文源自 <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html">《Ray Tracing: The Rest of Your Life》</a></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>In <em>Ray Tracing in One Weekend</em> and <em>Ray Tracing: the Next Week</em>, you built a “real” ray tracer.</p></blockquote><p>在Ray Tracing In One Weekend和Ray Tracing: the Next Week中，你构建了一个“真正的”Ray Tracing。</p><blockquote><p>In this volume, I assume you will be pursuing a career related to ray tracing, and we will dive into the math of creating a very serious ray tracer. When you are done you should be ready to start messing with the many serious commercial ray tracers underlying the movie and product design industries. There are many many things I do not cover in this short volume; I dive into only one of many ways to write a Monte Carlo rendering program. I don’t do shadow rays (instead I make rays more likely to go toward lights), bidirectional methods, Metropolis methods, or photon mapping. What I do is speak in the language of the field that studies those methods. I think of this book as a deep exposure that can be your first of many, and it will equip you with some of the concepts, math, and terms you will need to study the others.</p></blockquote><p>在本卷中，我假设你将追求与光线追踪相关的职业，我们将深入创建一个非常严肃的光线追踪器的数学。当你完成的时候，你应该准备好开始与电影和产品设计行业的许多严肃的商业射线追踪器打交道。在这一小卷书中，有许多事情我没有涉及；我只研究了许多编写蒙特卡罗渲染程序的方法中的一种。我不做阴影射线(相反，我让射线更有可能朝向光)，双向方法，大都市方法，或光子映射。我所做的就是用研究这些方法的领域的语言说话。我认为这本书是你的第一次深入接触，它会装备你一些概念，数学和术语，你将需要学习其他。</p><blockquote><p>As before, <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> will have further readings and references.</p><p>Thanks to everyone who lent a hand on this project. You can find them in the <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#acknowledgments">acknowledgments</a> section at the end of this book.</p></blockquote><p>和之前一样，<a href="https://link.zhihu.com/?target=https://in1weekend.blogspot.com/%E5%B0%86%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99%E5%92%8C%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E3%80%82">https://in1weekend.blogspot.com/将提供更多的阅读材料和参考资料。</a></p><p>感谢每一个为这个项目提供帮助的人。你可以在本书末尾的致谢部分找到它们。</p><h3 id="一个简单的蒙特卡罗程序"><a href="#一个简单的蒙特卡罗程序" class="headerlink" title="一个简单的蒙特卡罗程序"></a>一个简单的蒙特卡罗程序</h3><blockquote><p>Let’s start with one of the simplest Monte Carlo (MC) programs. MC programs give a statistical estimate of an answer, and this estimate gets more and more accurate the longer you run it. This basic characteristic of simple programs producing noisy but ever-better answers is what MC is all about, and it is especially good for applications like graphics where great accuracy is not needed.</p></blockquote><p>让我们从一个最简单的蒙特卡洛(Monte Carlo, MC)程序开始。MC程序对一个答案给出一个统计估计，并且这个估计会随着你运行时间的延长而变得越来越准确。这种简单程序产生嘈杂但更好的答案的基本特征就是MC的全部，它尤其适用于不需要很高精确度的图形等应用程序。</p><h4 id="Estimating-Pi"><a href="#Estimating-Pi" class="headerlink" title="Estimating Pi"></a>Estimating Pi</h4><blockquote><p>As an example, let’s estimate 𝜋. There are many ways to do this, with the Buffon Needle problem being a classic case study. We’ll do a variation inspired by that. Suppose you have a circle inscribed inside a square:</p></blockquote><p>作为一个例子，让我们估算 pi。有很多方法可以做到这一点，布丰针问题就是一个经典的案例研究。我们会受启发做一个变奏。假设在一个正方形中有一个内圆:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.01-circ-square.jpg"></p><blockquote><p>Now, suppose you pick random points inside the square. The fraction of those random points that end up inside the circle should be proportional to the area of the circle. The exact fraction should in fact be the ratio of the circle area to the square area. Fraction:</p></blockquote><p>现在，假设你在正方形中随机选取点。这些随机点在圆内的比例应该与圆的面积成正比。确切的分数实际上应该是圆面积和平方面积的比值。分数:</p><p>$\frac{\pi r^2}{(2r)^2} = \frac{\pi}{4}$</p><blockquote><p>Since the 𝑟 cancels out, we can pick whatever is computationally convenient. Let’s go with 𝑟=1, centered at the origin:</p></blockquote><p>因为 r 消掉了，我们可以选择计算上方便的值。让我们使用 r=1 ，在原点居中:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimatePI</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> inside_circle = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> runs = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    runs++;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>)</span><br><span class="line">        inside_circle++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runs % <span class="number">100000</span> == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Estimate of Pi = "</span></span><br><span class="line">        &lt;&lt; <span class="number">4</span> * <span class="built_in">double</span>(inside_circle) / runs</span><br><span class="line">        &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The answer of 𝜋π found will vary from computer to computer based on the initial random seed. On my computer, this gives me the answer <code>Estimate of Pi = 3.0880000000</code></p></blockquote><p>所找到的 <em>π</em> 的答案将根据初始的随机种子而因计算机而异。在我的电脑上，我的答案估计 <code>Estimate of Pi = 3.0880000000</code></p><h4 id="Showing-Convergence"><a href="#Showing-Convergence" class="headerlink" title="Showing Convergence"></a>Showing Convergence</h4><blockquote><p>If we change the program to run forever and just print out a running estimate:</p></blockquote><p>如果我们将程序更改为永远运行，并打印出一个运行估计:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void estimatePI() {</span><br><span class="line">    int inside_circle = 0;</span><br><span class="line">    int runs = 0;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   while (true) {</span></span><br><span class="line">        runs++;</span><br><span class="line">        auto x = random_double(-1, 1);</span><br><span class="line">        auto y = random_double(-1, 1);</span><br><span class="line"></span><br><span class="line">        if (x * x + y * y &lt; 1)</span><br><span class="line">            inside_circle++;</span><br><span class="line"></span><br><span class="line">        if (runs % 100000 == 0)</span><br><span class="line">            std::cout &lt;&lt; "Estimate of Pi = "</span><br><span class="line">                      &lt;&lt; 4 * double(inside_circle) / runs</span><br><span class="line">                      &lt;&lt; '\n';</span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Stratified-Samples-Jittering"><a href="#Stratified-Samples-Jittering" class="headerlink" title="Stratified Samples (Jittering)"></a>Stratified Samples (Jittering)</h4><blockquote><p>We get very quickly near 𝜋, and then more slowly zero in on it. This is an example of the <em>Law of Diminishing Returns</em>, where each sample helps less than the last. This is the worst part of MC. We can mitigate this diminishing return by <em>stratifying</em> the samples (often called <em>jittering</em>), where instead of taking random samples, we take a grid and take one sample within each:</p></blockquote><p>我们很快地接近 $\pi$，然后慢慢地瞄准它。这是收益递减定律的一个例子，每个样本的帮助都小于前一个样本。这是MC中最糟糕的部分。我们可以通过分层样本(通常称为抖动)来缓解这种递减的收益，这里我们不是随机抽取样本，而是取一个网格，在每个网格中抽取一个样本:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.02-jitter.jpg"></p><blockquote><p>This changes the sample generation, but we need to know how many samples we are taking in advance because we need to know the grid. Let’s take a hundred million and try it both ways:</p></blockquote><p>这改变了样本生成，但我们需要提前知道我们取了多少样本，因为我们需要知道网格。让我们以1亿为例，两种方法都试一下:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimatePI</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> inside_circle = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> inside_circle_stratified = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sqrt_N = <span class="number">10000</span>;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sqrt_N; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sqrt_N; ++j) {</span><br><span class="line">            <span class="keyword">auto</span> x = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">auto</span> y = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>)</span><br><span class="line">                inside_circle++;</span><br><span class="line"></span><br><span class="line">            x = <span class="number">2</span> * ((i + <span class="built_in">random_double</span>()) / sqrt_N) - <span class="number">1</span>;</span><br><span class="line">            y = <span class="number">2</span> * ((j + <span class="built_in">random_double</span>()) / sqrt_N) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>)</span><br><span class="line">                inside_circle_stratified++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> N = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(sqrt_N) * sqrt_N;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout</span><br><span class="line">            &lt;&lt; <span class="string">"Regular    Estimate of Pi = "</span></span><br><span class="line">            &lt;&lt; <span class="number">4</span>*<span class="built_in">double</span>(inside_circle) / (sqrt_N*sqrt_N) &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"Stratified Estimate of Pi = "</span></span><br><span class="line">            &lt;&lt; <span class="number">4</span>*<span class="built_in">double</span>(inside_circle_stratified) / (sqrt_N*sqrt_N) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>On my computer, I get:</p></blockquote><p>在我的电脑上，我得到了：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Regular    Estimate of Pi = 3.14151480</span><br><span class="line">Stratified Estimate of Pi = 3.14158948</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Interestingly, the stratified method is not only better, it converges with a better asymptotic rate! Unfortunately, this advantage decreases with the dimension of the problem (so for example, with the 3D sphere volume version the gap would be less). This is called the <em>Curse of Dimensionality</em>. We are going to be very high dimensional (each reflection adds two dimensions), so I won’t stratify in this book, but if you are ever doing single-reflection or shadowing or some strictly 2D problem, you definitely want to stratify.</p></blockquote><p>有趣的是，分层方法不仅更好，而且它具有更好的渐近收敛率！不幸的是，这种优势会随着问题的大小而减小(例如，在3D球体体积版本中，差距会更小)。这被称为维度诅咒。我们将会是非常高维的(每个反射都增加两个维度)，所以我不会在这本书中分层，但如果你做过单反射或阴影或一些严格的二维问题，你肯定想分层。</p><h3 id="一维MC集成"><a href="#一维MC集成" class="headerlink" title="一维MC集成"></a>一维MC集成</h3><blockquote><p>Integration is all about computing areas and volumes, so we could have framed chapter <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#toc2">2</a> in an integral form if we wanted to make it maximally confusing. But sometimes integration is the most natural and clean way to formulate things. Rendering is often such a problem.</p></blockquote><p>积分是关于计算面积和体积的，我们想让它更混乱的话，可以把第二章框定为一个积分形式。但有时候，积分是最自然、最干净的表述方式。渲染通常就是这样一个问题。</p><h4 id="Integrating-x²"><a href="#Integrating-x²" class="headerlink" title="Integrating x²"></a>Integrating x²</h4><blockquote><p>Let’s look at a classic integral:</p></blockquote><p>我们来看一个经典的积分:</p><p>$I = \int^2_0{x^2dx}$</p><blockquote><p>In computer sciency notation, we might write this as:</p></blockquote><p>在计算机科学符号中，我们可以这样写:</p><p>$I = area{(x^2, 0, 2)}$</p><blockquote><p>We could also write it as:</p></blockquote><p>我们也可以这样写:</p><p>$I = 2 \cdot average(x^2, 0, 2)$</p><blockquote><p>This suggests a MC approach:</p></blockquote><p>这就提出了MC方法:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        <span class="keyword">auto</span> x = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        sum += x * x;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"I = "</span> &lt;&lt; <span class="number">2</span> * sum / N &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This, as expected, produces approximately the exact answer we get with algebra, 𝐼=8/3. We could also do it for functions that we can’t analytically integrate like $\log(\sin(𝑥))$. In graphics, we often have functions we can evaluate but can’t write down explicitly, or functions we can only probabilistically evaluate. That is in fact what the ray tracing <code>ray_color()</code> function of the last two books is — we don’t know what color is seen in every direction, but we can statistically estimate it in any given dimension.</p></blockquote><p>正如预期的那样，这产生了我们用代数得到的大致准确答案，I = 8/3。对于不能解析积分的函数也可以这样做，比如$\log(\sin(x))$。在图形学中，我们经常有可以求值但不能显式地写出来的函数，或者只能按概率求值的函数。这实际上是射线追踪的 <code>ray_color()</code> 函数的最后两本书-我们不知道在每个方向上看到什么颜色，但我们可以统计估计它在任何给定的维度。</p><blockquote><p>One problem with the random program we wrote in the first two books is that small light sources create too much noise. This is because our uniform sampling doesn’t sample these light sources often enough. Light sources are only sampled if a ray scatters toward them, but this can be unlikely for a small light, or a light that is far away. We could lessen this problem if we sent more random samples toward this light, but this will cause the scene to be inaccurately bright. We can remove this inaccuracy by downweighting these samples to adjust for the over-sampling. How we do that adjustment? To do that, we will need the concept of a <em>probability density function</em>.</p></blockquote><p>我们在前两本书中所写的随机程序的一个问题是，小的光源会产生太多的噪音。这是因为我们的均匀采样并没有对这些光源进行足够频繁的采样。只有当光线向光源散射时，才会对光源进行采样，但对于较小的光或距离较远的光来说，这是不可能的。我们可以减少这个问题，如果我们向这个光发送更多的随机样本，但这会导致场景的亮度不准确。我们可以通过降低这些样本的权重来调整过度采样来消除这种不准确性。我们如何进行调整?要做到这一点，我们需要概率密度函数的概念。</p><h4 id="Density-Functions"><a href="#Density-Functions" class="headerlink" title="Density Functions"></a>Density Functions</h4><blockquote><p>First, what is a <em>density function</em>? It’s just a continuous form of a histogram. Here’s an example from the histogram Wikipedia page:</p></blockquote><p>首先，什么是密度函数?它是直方图的连续形式。以下是来自维基百科直方图页面的一个例子:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.03-histogram.jpg"></p><blockquote><p>If we added data for more trees, the histogram would get taller. If we divided the data into more bins, it would get shorter. A discrete density function differs from a histogram in that it normalizes the frequency y-axis to a fraction or percentage (just a fraction times 100). A continuous histogram, where we take the number of bins to infinity, can’t be a fraction because the height of all the bins would drop to zero. A density function is one where we take the bins and adjust them so they don’t get shorter as we add more bins. For the case of the tree histogram above we might try:</p></blockquote><p>如果我们为更多的树添加数据，直方图会变得更高。如果我们把数据分成更多的箱子，它就会变短。离散密度函数不同于直方图，它将频率y轴归一化为一个分数或百分比(只是分数乘以100)。一个连续的直方图，我们把箱子的数量取到无穷大，不可能是一个分数，因为所有箱子的高度会降为零。密度函数是指我们对箱子进行调整使它们不会随着箱子的增加而变短。对于上面的树直方图，我们可以尝试:</p><p>$bin-height = \frac{(Fraction \space of \space tree \space between \space height \space H \space and \space H’)}{(H-H’)}$​</p><blockquote><p>That would work! We could interpret that as a statistical predictor of a tree’s height:</p></blockquote><p>这是可行的!我们可以将其解释为一棵树高度的统计预测指标:</p><p>$Probability \space a \space random \space tree \space is \space between \space H \space and \space H’ = bin-height \cdot (H - H’)$</p><blockquote><p>If we wanted to know about the chances of being in a span of multiple bins, we would sum.</p><p>A <em>probability density function</em>, henceforth <em>PDF</em>, is that fractional histogram made continuous.</p></blockquote><p>如果我们想知道在多个箱子张成的空间里的概率，我们要求和。</p><p>概率密度函数，即以后的PDF，是使分数直方图连续的。</p><h4 id="Constructing-a-PDF"><a href="#Constructing-a-PDF" class="headerlink" title="Constructing a PDF"></a>Constructing a PDF</h4><blockquote><p>Let’s make a <em>PDF</em> and use it a bit to understand it more. Suppose I want a random number 𝑟 between 0 and 2 whose probability is proportional to itself: 𝑟. We would expect the PDF 𝑝(𝑟) to look something like the figure below, but how high should it be?</p></blockquote><p>让我们制作一个PDF，并使用它来更好地理解它。假设我想要一个0到2之间的随机数 $r$，其概率与自身成正比: $r$。我们希望PDF $p(r)$看起来像下面的数字，但它应该有多高?</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.04-linear-pdf.jpg"></p><blockquote><p>The height is just 𝑝(2). What should that be? We could reasonably make it anything by convention, and we should pick something that is convenient. Just as with histograms we can sum up (integrate) the region to figure out the probability that 𝑟 is in some interval (𝑥0,𝑥1):</p></blockquote><p>高度就是 $p(2)$。应该是什么呢?我们可以按照惯例把它写成任何形式，我们应该选一个方便的形式。就像用直方图一样，我们可以对区域求和(积分)来计算出 $r$ 在某个区间内的概率(x0,x1):</p><p>$Probability \space 𝑥_0 &lt; 𝑟 &lt; 𝑥_1 = 𝐶⋅area(𝑝(𝑟),𝑥_0,𝑥_1)$</p><blockquote><p>where 𝐶 is a scaling constant. We may as well make 𝐶=1 for cleanliness, and that is exactly what is done in probability. We also know the probability 𝑟 has the value 1 somewhere, so for this case</p></blockquote><p>其中 C 是缩放常数。我们也可以用 C = 1 来表示整洁，这正是概率所做的。我们也知道概率 r 在某个地方的值是1，所以在这种情况下：</p><p>$area(p(r), 0, 2) = 1$</p><blockquote><p>Since 𝑝(𝑟) is proportional to 𝑟r, <em>i.e.</em>, 𝑝=𝐶′⋅𝑟 for some other constant 𝐶′</p></blockquote><p>$area(C’,r,0,2) = \int^2_0{C’rdr} = \frac{C’r^2}{2}|^{r=2}_{r=0} = \frac{C’ \cdot 2^2}{2} - \frac{C’ \cdot 0^2}{2} = 2C’$</p><blockquote><p>So 𝑝(𝑟)=𝑟/2.</p></blockquote><p>所以 $p(r) = r / 2$</p><blockquote><p>How do we generate a random number with that PDF $𝑝(𝑟)$? For that we will need some more machinery. Don’t worry this doesn’t go on forever!</p><p>Given a random number from <code>d = random_double()</code> that is uniform and between 0 and 1, we should be able to find some function $𝑓(𝑑)$ that gives us what we want. Suppose $𝑒=𝑓(𝑑)=𝑑^2$. This is no longer a uniform PDF. The PDF of $𝑒$ will be bigger near 1 than it is near 0 (squaring a number between 0 and 1 makes it smaller). To convert this general observation to a function, we need the cumulative probability distribution function $𝑃(𝑥)$:</p></blockquote><p>我们如何生成一个随机数与 PDF $p(r)$?为此，我们需要更多的机器。别担心，这不会永远持续下去!</p><p>给定 <code>d = random_double()</code> 中的一个均匀且介于 0 和 1 之间的随机数，我们应该能够找到一些函数(f(d))，从而得到我们想要的结果。假设 $e = f(d) = d^2$。这不再是一个统一的PDF文件。PDF的 $e$ 在接近1时会比接近 0 时更大(将 0 和 1 之间的数字平方会使它更小)。为了将这个一般的观察结果转化为一个函数，我们需要累积概率分布函数 $P(x)$:</p><p>$P(x) = area(p, -\infin, x)$</p><blockquote><p>Note that for 𝑥 where we didn’t define 𝑝(𝑥), 𝑝(𝑥)=0, i.e., the probability of an 𝑥 there is zero. For our example PDF 𝑝(𝑟)=𝑟/2, the 𝑃(𝑥) is:</p></blockquote><p>注意，对于没有定义的 $p(x)$，$p(x) = 0$，即存在一个 $x$ 的概率为 0。对于我们的示例PDF $p (r) = r / 2$, $P(x)$ 是:</p><p>$P(x) = 0:x &lt; 0$​</p><p>$P(x) = \frac{x^2}{4}: 0 &lt; x &lt; 2$</p><p>$P(x) = 1 : x &gt; 2$</p><blockquote><p>One question is, what’s up with 𝑥 versus 𝑟? They are dummy variables — analogous to the function arguments in a program. If we evaluate 𝑃 at 𝑥=1.0, we get:</p></blockquote><p>一个问题是，x 和 r 是什么关系?它们是虚拟变量—类似于程序中的函数参数。如果在 x = 1.0 处求 P 值，则得到:</p><p>$P(1.0) = \frac{1}{4}$​</p><blockquote><p>This says <em>the probability that a random variable with our PDF is less than one is 25%</em>. This gives rise to a clever observation that underlies many methods to generate non-uniform random numbers.</p></blockquote><p>也就是说，PDF值小于1的随机变量的概率是25%这就产生了一个聪明的观察结果：</p><p>$f(P(x)) = x$</p><blockquote><p>That means 𝑓 just undoes whatever 𝑃 does. So,</p></blockquote><p>这意味着函数 <strong>f</strong> 只是撤消函数 <strong>P</strong> 所做的任何事情。所以,</p><p>$f(x) = P^{-1}(x)$</p><blockquote><p>The −1 means “inverse function”. Ugly notation, but standard. For our purposes, if we have PDF $𝑝()$ and cumulative distribution function $𝑃()$, we can use this “inverse function” with a random number to get what we want:</p></blockquote><p>−1表示“逆函数”。很难看的符号，但很标准。对于我们的目的，如果我们有PDF $p()$ 和累积分布函数 $P()$，我们可以使用这个“逆函数”与一个随机数来得到我们想要的:</p><p>$e = P^{-1}(random_double())$</p><blockquote><p>For our PDF 𝑝(𝑥)=𝑥/2, and corresponding 𝑃(𝑥), we need to compute the inverse of 𝑃. If we have</p></blockquote><p>对于我们的 <strong>PDFp(x)=x/2</strong>，以及相应的P(x)，我们需要计算<strong>P</strong>的逆。如果我们有</p><p>$y = \frac{x^2}{4}$</p><blockquote><p>we get the inverse by solving for 𝑥 in terms of 𝑦:</p></blockquote><p>我们通过用 $y$ 求出 $x$ 来求逆:</p><p>$x = \sqrt{4y}$</p><blockquote><p>Thus our random number with density 𝑝 is found with:</p></blockquote><p>因此，密度为的随机数是:</p><p>$e = \sqrt{4 \cdot random_double()}$</p><blockquote><p>Note that this ranges from 0 to 2 as hoped, and if we check our work by replacing <code>random_double()</code> with $\frac{1}{4}$ we get 1 as expected.</p><p>We can now sample our old integral</p></blockquote><p>注意，这个范围如预期的从 0 到 2，如果我们用 1/4 替换 <code>random_double()</code> 来检查我们的工作，我们会得到预期的1。</p><p>我们可以对旧的积分进行抽样</p><p>$I = \int_0^2x^2$</p><blockquote><p>We need to account for the non-uniformity of the PDF of 𝑥. Where we sample too much we should down-weight. The PDF is a perfect measure of how much or little sampling is being done. So the weighting function should be proportional to 1/𝑝𝑑𝑓. In fact it is exactly 1/𝑝𝑑𝑓:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">inline double pdf(double x) {</span><br><span class="line">    return 0.5*x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int N = 100000;</span><br><span class="line">    auto sum = 0.0;</span><br><span class="line">    for (int i = 0; i &lt; N; ++i) {</span><br><span class="line"><span class="deletion">-       auto x = random_double(0, 2);</span></span><br><span class="line"><span class="deletion">-       sum += x * x;</span></span><br><span class="line"><span class="addition">+       auto x = sqrt(random_double(0,4));</span></span><br><span class="line"><span class="addition">+       sum += x*x / pdf(x);</span></span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12);</span><br><span class="line">    std::cout &lt;&lt; "I = " &lt;&lt; 2 * sum / N &lt;&lt; '\n';</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="Importance-Sampling"><a href="#Importance-Sampling" class="headerlink" title="Importance Sampling"></a>Importance Sampling</h4><blockquote><p>Since we are sampling more where the integrand is big, we might expect less noise and thus faster convergence. In effect, we are steering our samples toward the parts of the distribution that are more <em>important</em>. This is why using a carefully chosen non-uniform PDF is usually called <em>importance sampling</em>.</p></blockquote><p>由于我们在被积函数较大的地方进行更多采样，我们可能会期望更少的噪声，从而更快地收敛。实际上，我们正在将样本转向分布中更重要的部分。这就是为什么使用精心选择的非均匀PDF通常被称为重要抽样。</p><blockquote><p>If we take that same code with uniform samples so the PDF = 1/2 over the range [0,2] we can use the machinery to get <code>x = random_double(0,2)</code>, and the code is:</p></blockquote><p>如果我们使用统一样本的相同代码，那么在[0,2]范围内的PDF = 1/2 ，我们可以使用 <code>x = random_double(0,2)</code> 获得，代码是:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+inline double pdf(double x) {</span></span><br><span class="line"><span class="addition">+   return 0.5;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int N = 1000000;</span><br><span class="line">    auto sum = 0.0;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) {</span><br><span class="line"><span class="addition">+       auto x = random_double(0,2);</span></span><br><span class="line">        sum += x*x / pdf(x);</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12);</span><br><span class="line">    std::cout &lt;&lt; "I = " &lt;&lt; sum/N &lt;&lt; '\n';</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Note that we don’t need that 2 in the <code>2*sum/N</code> anymore — that is handled by the PDF, which is 2 when you divide by it. You’ll note that importance sampling helps a little, but not a ton. We could make the PDF follow the integrand exactly:</p></blockquote><p>注意，我们不再需要 <code>2*sum/N</code> 中的 2，它是由PDF处理的，当你除以它时，它是 2。您会注意到，重要抽样的作用不大。我们可以让PDF完全遵循被积函数:</p><p>$p(x) = \frac{3}{8}x^2$</p><blockquote><p>And we get the corresponding</p></blockquote><p>我们得到相应的：</p><p>$P(x) = \frac{x^3}{8}$</p><blockquote><p>and</p></blockquote><p>和：</p><p>$P^{-1}(x) = 8x^{\frac{1}{3}}$</p><blockquote><p>This perfect importance sampling is only possible when we already know the answer (we got 𝑃 by integrating 𝑝 analytically), but it’s a good exercise to make sure our code works. For just 1 sample we get:</p></blockquote><p>只有当我们已经知道答案时(我们通过对 $P$ 进行分析来得到 $p$)，这个完美的重要抽样才可能实现，但这是确保代码工作的一个很好的练习。对于一个样本，我们得到:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+inline double pdf(double x) {</span></span><br><span class="line"><span class="addition">+   return 3*x*x/8;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line"><span class="addition">+   int N = 1;</span></span><br><span class="line">    auto sum = 0.0;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) {</span><br><span class="line"><span class="addition">+       auto x = pow(random_double(0,8), 1./3.);</span></span><br><span class="line">        sum += x*x / pdf(x);</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12);</span><br><span class="line">    std::cout &lt;&lt; "I = " &lt;&lt; sum/N &lt;&lt; '\n';</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which always returns the exact answer.</p><p>Let’s review now because that was most of the concepts that underlie MC ray tracers.</p><ol><li>You have an integral of 𝑓(𝑥) over some domain [𝑎,𝑏]</li><li>You pick a PDF 𝑝 that is non-zero over [𝑎,𝑏]</li><li>You average a whole ton of $\frac{𝑓(𝑟)}{𝑝(𝑟)}$ where 𝑟r is a random number with PDF 𝑝.</li></ol><p>Any choice of PDF 𝑝 will always converge to the right answer, but the closer that 𝑝p approximates 𝑓, the faster that it will converge.</p></blockquote><p>它总是返回准确的答案。</p><p>现在让我们回顾一下，因为这是MC射线示踪仪的基本概念。</p><ol><li>你有一个f(x)在某个定义域 [a,b] 上的积分</li><li>你选择一个非0 [a,b] 的 PDF(p)</li><li>你平均一整吨的 f(r)/p(r)，其中 r 是PDF(p)的一个随机数。</li></ol><p>任何 PDF(p) 的选择总是收敛到正确的答案，但是，p 与 f的近距越近，它收敛的速度就越快<em>。</em></p><h3 id="方向球上的MC集成"><a href="#方向球上的MC集成" class="headerlink" title="方向球上的MC集成"></a>方向球上的MC集成</h3><blockquote><p>In our ray tracer we pick random directions, and directions can be represented as points on the unit sphere. The same methodology as before applies, but now we need to have a PDF defined over 2D.</p><p>Suppose we have this integral over all directions:</p></blockquote><p>在我们的射线追踪器中，我们选择随机的方向，方向可以用单位球上的点表示。与之前的方法相同，但是现在我们需要一个在2D上定义的PDF。</p><p>假设我们在所有方向上积分</p><p>$\int{\cos^2(\theta)}$</p><blockquote><p>By MC integration, we should just be able to sample $\cos^2(𝜃)/𝑝(direction)$, but what is <em>direction</em> in that context? We could make it based on polar coordinates, so 𝑝 would be in terms of $(𝜃,𝜙)$. However you do it, remember that a PDF has to integrate to 1 and represent the relative probability of that direction being sampled. Recall that we have vec3 functions to take uniform random samples in (<code>random_in_unit_sphere()</code>) or on (<code>random_unit_vector()</code>) a unit sphere.</p></blockquote><p>通过MC积分，我们应该能够采样 $\cos^2(theta) / p(direction)$，但方向在这种情况下是什么?我们可以让它基于极坐标，所以 p 是用 (theta, phi) 表示的。不管你怎么做，记住PDF必须积分到1，并表示该方向被采样的相对概率。回想一下，我们使用vec3函数在(<code>random_in_unit_sphere()</code>)或(<code>random_unit_vector()</code>)单位球体上进行均匀随机采样。</p><blockquote><p>Now what is the PDF of these uniform points? As a density on the unit sphere, it is 1/area of the sphere or 1/(4𝜋). If the integrand is $cos^2(𝜃)$, and 𝜃 is the angle with the z axis:</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"vec3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">pdf</span><span class="params">(<span class="type">const</span> vec3&amp; p)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">4</span>*pi);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        vec3 d = <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="keyword">auto</span> cosine_squared = d.<span class="built_in">z</span>()*d.<span class="built_in">z</span>();</span><br><span class="line">        sum += cosine_squared / <span class="built_in">pdf</span>(d);</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"I = "</span> &lt;&lt; sum/N &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The analytic answer (if you remember enough advanced calc, check me!) is $\frac{4}{3}𝜋$, and the code above produces that. Next, we are ready to apply that in ray tracing!</p><p>The key point here is that all the integrals and probability and all that are over the unit sphere. The area on the unit sphere is how you measure the directions. Call it direction, solid angle, or area — it’s all the same thing. Solid angle is the term usually used. If you are comfortable with that, great! If not, do what I do and imagine the area on the unit sphere that a set of directions goes through. The solid angle 𝜔 and the projected area 𝐴 on the unit sphere are the same thing.</p></blockquote><p>解析答案（如果你还记得足够的高级计算，请检查我!）是 $\frac{4}{3} \pi$，上面的代码产生了这个结果。接下来，我们准备在光线追踪中应用它!</p><p>这里的关键点是所有的积分和概率，所有的都在单位球上。单位球上的面积就是测量方向的方法。叫它方向，立体角，或者面积，都是一样的。立体角是常用的术语。如果你觉得没问题，那太好了!如果没有，就像我做的一样，想象单位球上一系列方向经过的面积。实心角omega 和单位球上的投影面积 A 是一样的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.05-solid-angle.jpg"></p><h3 id="光散射"><a href="#光散射" class="headerlink" title="光散射"></a>光散射</h3><blockquote><p>In this chapter we won’t actually program anything. We will set up for a big lighting change in the next chapter.</p></blockquote><p>在本章中，我们不会实际编写任何程序。我们将在下一章设置一个大的照明变化。</p><h4 id="Albedo"><a href="#Albedo" class="headerlink" title="Albedo"></a>Albedo</h4><blockquote><p>Our program from the last books already scatters rays from a surface or volume. This is the commonly used model for light interacting with a surface. One natural way to model this is with probability. First, is the light absorbed?</p></blockquote><p>上一本书中的程序已经将光线从表面或体积上散射。这是光与表面相互作用的常用模型。一个很自然的建模方法是用概率。首先，光线被吸收了吗?</p><blockquote><p>Probability of light scattering: 𝐴</p><p>Probability of light being absorbed: 1−𝐴</p></blockquote><p>光散射概率: A</p><p>光被吸收的概率: 1-A</p><blockquote><p>Here 𝐴 stands for <em>albedo</em> (latin for <em>whiteness</em>). Albedo is a precise technical term in some disciplines, but in all cases it is used to define some form of <em>fractional reflectance</em>. This <em>fractional reflectance</em> (or albedo) will vary with color and (as we implemented for our glass in book one) can vary with incident direction.</p></blockquote><p>这里 A 代表反照率(拉丁语中白色的意思)。反照率在某些学科中是一个精确的技术术语，但在所有情况下，它被用来定义某种形式的分数反射率。这部分反射率(或反照率)会随着颜色的变化而变化(正如我们在书一中为我们的玻璃实现的那样)，可以随着入射方向而变化。</p><h4 id="Scattering"><a href="#Scattering" class="headerlink" title="Scattering"></a>Scattering</h4><blockquote><p>In most physically based renderers, we would use a set of wavelengths for the light color rather than RGB. We can extend our intuition by thinking of R, G, and B as specific algebraic mixtures of long, medium, and short wavelengths.</p></blockquote><p>在大多数基于物理的渲染器中，我们会使用一组波长的光颜色，而不是RGB。我们可以扩展我们的直觉，把R、G和B看作是长、中、短波长的特殊代数混合物。</p><blockquote><p>If the light does scatter, it will have a directional distribution that we can describe as a PDF over solid angle. I will refer to this as its <em>scattering PDF</em>: 𝑠(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛). The scattering PDF can also vary with <em>incident direction</em>, which is the direction of the incoming ray. You can see this varying with incident direction when you look at reflections off a road — they become mirror-like as your viewing angle (incident angle) approaches grazing.</p></blockquote><p>如果光散射，它将有一个方向分布，我们可以描述为PDF立体角。我将把它称为散射PDF: s(direction)。散射PDF也可以随入射方向而变化，入射方向是入射射线的方向。当你观察道路上的反射时，你可以看到这随着入射方向的变化而变化——当你的视角(入射角)接近入射时，它们变成了镜子一样。</p><blockquote><p>The color of a surface in terms of these quantities is:</p></blockquote><p>用这些量表示的表面颜色是:</p><p>$Color = \int{A \cdot s(direction) \cdot color(direction)}$</p><blockquote><p>Note that 𝐴 and 𝑠() may depend on the view direction or the scattering position (position on a surface or position within a volume). Therefore, the output color may also vary with view direction or scattering position.</p></blockquote><p>注意 A 和 s()可能取决于视图方向或散射位置(表面上的位置或体积内的位置)。因此，输出颜色也可能随着视图方向或散射位置的变化而变化。</p><h4 id="The-Scattering-PDF"><a href="#The-Scattering-PDF" class="headerlink" title="The Scattering PDF"></a>The Scattering PDF</h4><blockquote><p>If we apply the MC basic formula we get the following statistical estimate:</p></blockquote><p>如果我们应用MC基本公式，我们得到以下统计估计:</p><p>$Color = \frac{A \cdot s(direction) \cdot color(direction)}{p(direction)}$</p><blockquote><p>where 𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛) is the PDF of whatever direction we randomly generate.</p></blockquote><p>其中p(direction)是我们随机生成的任意方向的PDF。</p><blockquote><p>For a Lambertian surface we already implicitly implemented this formula for the special case where 𝑝() is a cosine density. The 𝑠() of a Lambertian surface is proportional to cos(𝜃), where 𝜃 is the angle relative to the surface normal. Remember that all PDF need to integrate to one. For cos(𝜃)&lt;0 we have 𝑠(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=0, and the integral of cos over the hemisphere is 𝜋.</p></blockquote><p>对于朗伯曲面，我们已经隐式地实现了这种特殊情况下的公式，其中 $p()$​ 是一个余弦密度。朗伯曲面的 $s()$​ 正比于 $cos(\theta)$​，其中 $\theta$​ 是相对于曲面法线的角度。记住，所有的PDF都需要集成到一个。对于$cos(\theta) &lt; 0$​ 我们有 $s(direction) = 0$， cos在半球上的积分是 $\pi$</p><blockquote><p>To see that, remember that in spherical coordinates:</p></blockquote><p>记住，在球坐标下</p><p>$dA = \sin(\theta)d\theta d\phi$</p><blockquote><p>So:</p></blockquote><p>所以:</p><p>$Area = \int_0^{2\pi}\int_0^{\pi/2}{\cos{\theta} \sin{\theta} d\theta d\phi} = 2 \pi \frac{1}{2} = \pi$</p><blockquote><p>So for a Lambertian surface the scattering PDF is:</p></blockquote><p>所以对于朗伯曲面散射PDF是:</p><p>$s(direction) = \frac{\cos{\theta}}{\pi}$</p><blockquote><p>If we sample using a PDF that equals the scattering PDF:</p></blockquote><p>如果我们使用一个等于散射PDF的PDF进行采样:</p><p>$p(direction) = s(direction) = \frac{\cos{\theta}}{\pi}$</p><blockquote><p>The numerator and denominator cancel out, and we get:</p></blockquote><p>分子分母约掉了，得到</p><p>$Color = A \cdot color(direction)$​</p><blockquote><p>This is exactly what we had in our original <code>ray_color()</code> function! However, we need to generalize so we can send extra rays in important directions, such as toward the lights.</p></blockquote><p>这正是我们在原来的ray_color()函数中所使用的！然而，我们需要一般化，这样我们才能在重要的方向发送额外的光线，比如向光的方向。</p><blockquote><p>The treatment above is slightly non-standard because I want the same math to work for surfaces and volumes. To do otherwise will make some ugly code.</p></blockquote><p>上面的处理有点不标准，因为我想用同样的数学方法来处理表面和体积。否则将会产生一些丑陋的代码。</p><blockquote><p>If you read the literature, you’ll see reflection described by the bidirectional reflectance distribution function (BRDF). It relates pretty simply to our terms:</p></blockquote><p>如果你阅读文献，你会看到反射是由双向反射分布函数(BRDF)描述的。它与我们的术语非常简单:</p><p>$BRDF = \frac{A \cdot s(direction)}{\cos{\theta}}$</p><blockquote><p>So for a Lambertian surface for example, 𝐵𝑅𝐷𝐹=𝐴/𝜋. Translation between our terms and BRDF is easy.</p></blockquote><p>以朗伯曲面为例，BRDF=A/π 我们的术语和BRDF之间的转换很容易。</p><blockquote><p>For participation media (volumes), our albedo is usually called <em>scattering albedo</em>, and our scattering PDF is usually called <em>phase function</em>.</p></blockquote><p>对于参与介质(体积)，我们的反照率通常称为散射反照率，我们的散射PDF通常称为相位函数。</p><h3 id="重要采样材质"><a href="#重要采样材质" class="headerlink" title="重要采样材质"></a>重要采样材质</h3><blockquote><p>Our goal over the next two chapters is to instrument our program to send a bunch of extra rays toward light sources so that our picture is less noisy. Let’s assume we can send a bunch of rays toward the light source using a PDF 𝑝𝐿𝑖𝑔ℎ𝑡(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛). Let’s also assume we have a PDF related to 𝑠, and let’s call that 𝑝𝑆𝑢𝑟𝑓𝑎𝑐𝑒(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛). A great thing about PDFs is that you can just use linear mixtures of them to form mixture densities that are also PDFs. For example, the simplest would be:</p></blockquote><p>我们的目标在接下来的两章是仪器我们的程序发送一束额外的射线到光源，使我们的图片噪音更小。让我们假设我们可以使用PDF (光照(方向)) 向光源发送一束光线。我们还假设有一个与 $s$​ 相关的 PDF，并将其命名为 *pSurface(direction)*。关于pdf 的一个很棒的地方是你可以使用它们的线性混合来形成混合密度也是 pdf。例如，最简单的是:</p><p>$p(direction) = \frac{1}{2}\cdot Light(direction) + \frac{1}{2} \cdot pSurface(dirction)$</p><blockquote><p>As long as the weights are positive and add up to one, any such mixture of PDFs is a PDF. Remember, we can use any PDF: <em>all PDFs eventually converge to the correct answer</em>. So, the game is to figure out how to make the PDF larger where the product 𝑠(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)⋅𝑐𝑜𝑙𝑜𝑟(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛) is large. For diffuse surfaces, this is mainly a matter of guessing where 𝑐𝑜𝑙𝑜𝑟(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛) is high.</p></blockquote><p>只要权值是正的并且加起来是1，任何这样的 PDF 混合都是 PDF。记住，我们可以使用任何 PDF: 所有的 PDF 最终都会收敛到正确的答案。所以，游戏是要找出如何使 PDF 更大的产品 <em>s(direction)⋅ color(direction)</em> 是大。对于漫反射表面，这主要是猜测哪里 <em>color(direction)</em> 高的问题。</p><blockquote><p>For a mirror, 𝑠() is huge only near one direction, so it matters a lot more. Most renderers in fact make mirrors a special case, and just make the 𝑠/𝑝 implicit — our code currently does that.</p></blockquote><p>对于镜子来说，只在一个方向上，$s()$ 是巨大的，所以它更重要。事实上，大多数渲染器都将镜像作为一种特殊情况，并且只隐式地使用 <em>s/p</em>——我们的代码目前就是这样做的。</p><h4 id="Returning-to-the-Cornell-Box"><a href="#Returning-to-the-Cornell-Box" class="headerlink" title="Returning to the Cornell Box"></a>Returning to the Cornell Box</h4><blockquote><p>Let’s do a simple refactoring and temporarily remove all materials that aren’t Lambertian. We can use our Cornell Box scene again, and let’s generate the camera in the function that generates the model.</p></blockquote><p>让我们做一个简单的重构，暂时删除所有不属于 Lambertian 的材料。我们可以再次使用 Cornell Box 场景，让我们在生成模型的函数中生成摄像机。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(...)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red   = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>,<span class="number">330</span>,<span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>,<span class="number">0</span>,<span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>,<span class="number">165</span>,<span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>,<span class="number">0</span>,<span class="number">65</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">1.0</span> / <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">600</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">cornell_box</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">color <span class="title">background</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> time0 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> time1 = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, time0, time1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"P3\n"</span> &lt;&lt; image_width &lt;&lt; <span class="string">' '</span> &lt;&lt; image_height &lt;&lt; <span class="string">"\n255\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) {</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>At 500×500 my code produces this image in 10min on 1 core of my Macbook:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.01-cornell-refactor1.jpg"></p><blockquote><p>Reducing that noise is our goal. We’ll do that by constructing a PDF that sends more rays to the light.</p></blockquote><p>减少噪音是我们的目标。我们将通过构建一个向光线发射更多射线的PDF来实现这一点。</p><blockquote><p>First, let’s instrument the code so that it explicitly samples some PDF and then normalizes for that. Remember MC basics: $∫𝑓(𝑥)≈𝑓(𝑟)/𝑝(𝑟)$​​. For the Lambertian material, let’s sample like we do now: $𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=\cos(𝜃)/𝜋$​.</p></blockquote><p>首先，让我们对代码进行测试，以便它显式地对一些PDF进行采样，然后对其进行规范化。记住MC基础知识：$∫𝑓(𝑥)≈𝑓(𝑟)/𝑝(𝑟)$​。对于朗伯材料，让我们像现在一样采样: $p(direction)=\cos(θ)/π$​​。</p><blockquote><p>We modify the base-class <code>material</code> to enable this importance sampling:</p></blockquote><p>我们修改基类 <code>material</code> 来启用这个重要抽样:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class material {</span><br><span class="line">    public:</span><br><span class="line"></span><br><span class="line">        virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, color&amp; albedo, ray&amp; scattered, double&amp; pdf</span><br><span class="line"><span class="addition">+       ) const {</span></span><br><span class="line"><span class="addition">+           return false;</span></span><br><span class="line"><span class="addition">+       }</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+       virtual double scattering_pdf(</span></span><br><span class="line"><span class="addition">+           const ray&amp; r_in, const hit_record&amp; rec, const ray&amp; scattered</span></span><br><span class="line"><span class="addition">+       ) const {</span></span><br><span class="line"><span class="addition">+           return 0;</span></span><br><span class="line"><span class="addition">+       }</span></span><br><span class="line"></span><br><span class="line">        virtual vec3 emitted(double u, double v, const point3&amp; p) const {</span><br><span class="line">            return vec3(0,0,0);</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And <em>Lambertian</em> material becomes:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class material {</span><br><span class="line">public:</span><br><span class="line">    virtual vec3 emitted(double u, double v, const vec3&amp; p) const {</span><br><span class="line">        return vec3(0, 0, 0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in,const hit_record&amp; rec,vec3&amp; attenuation,ray&amp; scattered, double&amp; pdf</span><br><span class="line"><span class="addition">+           ) const {</span></span><br><span class="line"><span class="addition">+       return false;</span></span><br><span class="line"><span class="addition">+   };</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   virtual double scattering_pdf (</span></span><br><span class="line"><span class="addition">+           const ray&amp; r_in, const hit_record&amp; rec, const ray&amp; scattered</span></span><br><span class="line"><span class="addition">+           ) const {</span></span><br><span class="line"><span class="addition">+       return 0;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the <code>ray_color</code> function gets a minor modification:</p></blockquote><p><code>ray_color</code> 函数得到了一个小修改:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(const ray&amp; r, const color&amp; background, const hittable&amp; world, int depth) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return color(0,0,0);</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (!world.hit(r, 0.001, infinity, rec))</span><br><span class="line">        return background;</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    vec3 attenuation;</span><br><span class="line">    vec3 emitted = rec.mat_ptr-&gt;emitted(rec.u, rec.v, rec.p);</span><br><span class="line"><span class="addition">+   double pdf;</span></span><br><span class="line"><span class="addition">+   vec3 albedo;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf))</span></span><br><span class="line"><span class="addition">+       return emitted;</span></span><br><span class="line"></span><br><span class="line">    return emitted</span><br><span class="line"><span class="addition">+        + albedo * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span></span><br><span class="line"><span class="addition">+                 * ray_color(scattered, background, world, depth-1) / pdf;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>You should get exactly the same picture.</p></blockquote><h4 id="Random-Hemisphere-Sampling"><a href="#Random-Hemisphere-Sampling" class="headerlink" title="Random Hemisphere Sampling"></a>Random Hemisphere Sampling</h4><blockquote><p>Now, just for the experience, try a different sampling strategy. As in the first book, Let’s choose randomly from the hemisphere above the surface. This would be $𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=\frac{1}{2𝜋}$.</p></blockquote><p>现在，为了体验，尝试一个不同的抽样策略。和第一本书一样，让我们从表面上的半球中随机选择。这将是 $p(direction)=1/2π$</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; alb, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">unit_vector</span>(direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">    alb = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    pdf = <span class="number">0.5</span> / pi;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And again I <em>should</em> get the same picture except with different variance, but I don’t!</p></blockquote><p>同样，我应该得到相同的图像除了不同的方差，但我没有!</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.02-cornell-refactor2.jpg"></p><blockquote><p>It’s pretty close to our old picture, but there are differences that are not noise. The front of the tall box is much more uniform in color. So I have the most difficult kind of bug to find in a Monte Carlo program — a bug that produces a reasonable looking image. I also don’t know if the bug is the first version of the program, or the second, or both!</p><p>Let’s build some infrastructure to address this.</p></blockquote><p>它和我们的旧图片很接近，但是有一些区别不是噪音。高盒子的正面颜色更加统一。所以我有一个在蒙特卡罗程序中最难找到的错误——一个产生合理外观图像的错误。我也不知道这个bug是程序的第一个版本，还是第二个版本，或者两者都有!</p><p>让我们构建一些基础设施来解决这个问题。</p><h3 id="生成随机方向"><a href="#生成随机方向" class="headerlink" title="生成随机方向"></a>生成随机方向</h3><blockquote><p>In this and the next two chapters, let’s harden our understanding and tools and figure out which Cornell Box is right.</p></blockquote><p>在这两章和接下来的两章中，让我们加强我们的理解和工具，并找出哪个Cornell Box是正确的。</p><h4 id="Random-Directions-Relative-to-the-Z-Axis"><a href="#Random-Directions-Relative-to-the-Z-Axis" class="headerlink" title="Random Directions Relative to the Z Axis"></a>Random Directions Relative to the Z Axis</h4><blockquote><p>Let’s first figure out how to generate random directions. To simplify things, let’s assume the z-axis is the surface normal, and $𝜃$ is the angle from the normal. We’ll get them oriented to the surface normal vector in the next chapter. We will only deal with distributions that are rotationally symmetric about $𝑧$. So $𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=𝑓(𝜃)$. If you have had advanced calculus, you may recall that on the sphere in spherical coordinates $𝑑𝐴=sin(𝜃)⋅𝑑𝜃⋅𝑑𝜙$. If you haven’t, you’ll have to take my word for the next step, but you’ll get it when you take advanced calculus.</p></blockquote><p>让我们先弄清楚如何生成随机方向。为了简化，我们假设z轴是表面法线，而 $θ$ 是与法线的角度。我们将在下一章中让它们指向曲面法向量。我们只讨论关于 z 旋转对称的分布。所以 $p(direction)=f(θ)$ 如果你学过高等微积分，你可能会记得，在球坐标下 $dA=sin(θ)⋅dθ⋅dϕ$。如果你还没学过，下一步你就得听我的了，但等你上高等微积分的时候你就会明白了。</p><blockquote><p>Given a directional PDF, $𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=𝑓(𝜃)$ on the sphere, the 1D PDFs on $𝜃$ and $𝜙$ are:</p></blockquote><p>给定一个定向PDF，$p(direction) = f(θ)$ 在球体上，在 $\theta$ 和 $\phi$ 上的1D PDF是:</p><p>$a(\phi) = \frac{1}{2\pi}$</p><blockquote><p>(uniform)</p></blockquote><p>$b(\theta) = 2 \pi f(\theta)\sin(\theta)$</p><blockquote><p>For uniform random numbers $𝑟_1$ and $𝑟_2$, the material presented in the <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#onedimensionalmcintegration">One Dimensional MC Integration</a> chapter leads to:</p></blockquote><p>对于统一随机数 $r_1$ 和 $r_2$，一维MC集成一章的内容如下:</p><p>$r_1 = \int_0^{\phi}{\frac{1}{2\pi}dt} = \frac{\phi}{2\pi}$</p><blockquote><p>Solving for $𝜙$ we get:</p></blockquote><p>求解 $\phi$ 我们得到:</p><p>$\phi = 2\pi \cdot r_1$</p><blockquote><p>For $𝜃$ we have:</p></blockquote><p>对于 $θ$ 我们有:</p><p>$r_2 = \int_0^{\theta}2\pi f(t)\sin(t)dt$</p><blockquote><p>Here, $𝑡$ is a dummy variable. Let’s try some different functions for $𝑓()$. Let’s first try a uniform density on the sphere. The area of the unit sphere is $4𝜋$, so a uniform $𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=\frac{1}{4𝜋}$ on the unit sphere.</p></blockquote><p>这里，$t$ 是一个哑变量。让我们尝试一些不同的 $f()$ 函数。首先让我们在球体上尝试均匀密度。单位球的面积是 $4π$​，所以单位球上的一个均匀的$p(direction)=\frac{1}{4π}$。<br>$$<br>r_2 = \int_0^{\theta}{2\pi \frac{1}{4 \pi} \sin(t)dt} \newline<br>= \int_0^{\theta}{\frac{1}{2} \sin(t)dt} \newline<br>= \frac{-\cos(\theta)}{2} - \frac{-\cos(0)}{2} \newline<br>= \frac{1 - \cos(\theta)}{2}<br>$$</p><blockquote><p>Solving for $\cos(𝜃)$ gives:</p></blockquote><p>求解 $\cos(θ)$ 给出:</p><p>$\cos(\theta) = 1 - 2r_2$</p><blockquote><p>We don’t solve for theta because we probably only need to know $\cos(𝜃)$ anyway, and don’t want needless $\arccos()$ calls running around.</p></blockquote><p>我们不求解，因为我们可能只需要知道 $\cos(θ)$，而不希望不必要的 $\arccos()$ 调用到处运行。</p><blockquote><p>To generate a unit vector direction toward $(𝜃,𝜙)$ we convert to Cartesian coordinates:</p></blockquote><p>为了生成指向 $(θ,ϕ)$ 的单位矢量，我们转换为笛卡尔坐标:<br>$$<br>x = \cos(\phi) \cdot \sin(\theta)	\space<br>y = \sin(\theta) \cdot \sin(\theta)	\space<br>z = \cos(\theta)<br>$$</p><blockquote><p>And using the identity that $\cos^2+\sin^2=1$, we get the following in terms of random $(𝑟_1,𝑟_2)$:</p></blockquote><p>使用恒等式 $\cos^2 + \sin^2 = 1$，我们得到以下随机的 $(r_1,r_2)$:<br>$$<br>x = \cos(2\pi \cdot r_1) \sqrt{1 - (1 - 2r_2)^2} \space<br>y = \sin(2\pi \cdot r_1) \sqrt{1 - (1 - 2r_2)^2} \space<br>z = 1 - 2r_2<br>$$</p><blockquote><p>Simplifying a little, $(1−2𝑟_2)^2=1−4𝑟_2+4𝑟_2^2$, so:</p></blockquote><p>简化一下，$(1−2𝑟_2)^2=1−4𝑟_2+4𝑟_2^2$​，所以：<br>$$<br>x = \cos(2\pi r_1) \cdot 2\sqrt{r_2(1-r_2)} \space<br>y - \sin(2\pi r_1) \cdot 2\sqrt{r_2(1-r_2)} \space<br>z = 1 - 2r_2<br>$$</p><blockquote><p>We can output some of these:</p></blockquote><p>我们可以输出其中一些:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) {</span><br><span class="line">        <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">        <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">        <span class="keyword">auto</span> x = <span class="built_in">cos</span>(<span class="number">2</span>*pi*r1)*<span class="number">2</span>*<span class="built_in">sqrt</span>(r2*(<span class="number">1</span>-r2));</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">sin</span>(<span class="number">2</span>*pi*r1)*<span class="number">2</span>*<span class="built_in">sqrt</span>(r2*(<span class="number">1</span>-r2));</span><br><span class="line">        <span class="keyword">auto</span> z = <span class="number">1</span> - <span class="number">2</span>*r2;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="string">" "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And plot them for free on plot.ly (a great site with 3D scatterplot support):</p></blockquote><p>然后在地图上免费标出它们。ly(一个很棒的网站，支持3D散点图):</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.06-rand-pts-sphere.jpg"></p><blockquote><p>On the plot.ly website you can rotate that around and see that it appears uniform.</p></blockquote><p>你可以旋转它，看到它看起来是一致的。</p><h4 id="Uniform-Sampling-a-Hemisphere"><a href="#Uniform-Sampling-a-Hemisphere" class="headerlink" title="Uniform Sampling a Hemisphere"></a>Uniform Sampling a Hemisphere</h4><blockquote><p>Now let’s derive uniform on the hemisphere. The density being uniform on the hemisphere means $𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=\frac{1}{2𝜋}$​. Just changing the constant in the theta equations yields:</p></blockquote><p>现在我们来推导半球上的均匀性。密度在半球上是均匀的，意味着 $p(direction)= \frac{1}{2\pi}$​。只要改变方程中的常数就能得到:<br>$$<br>\cos(\theta) = 1 - r^2<br>$$</p><blockquote><p>It is comforting that $\cos(𝜃)$ will vary from 1 to 0, and thus theta will vary from 0 to 𝜋/2. Rather than plot it, let’s do a 2D integral with a known solution. Let’s integrate cosine cubed over the hemisphere (just picking something arbitrary with a known solution). First let’s do it by hand:</p></blockquote><p>$$<br>\int{\cos^3(\theta)dA} = \int_0^{2\pi} \int_0^{\pi/2}{\cos^3(\theta) \sin(\theta)d\theta d\phi} = 2\pi \int_0^{\pi/2}{\cos^3(\theta})\sin(\theta) = \frac{\pi}{2}<br>$$</p><blockquote><p>Now for integration with importance sampling. $𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=\frac{1}{2𝜋}$, so we average $𝑓/𝑝$ which is $cos^3(𝜃)/(1/2𝜋)$, and we can test this:</p></blockquote><p>下面是重要抽样的集成。$p(direction)=\frac{1}{2π}$，所以我们取 $f/p$ 的平均值，即 $cos^3(𝜃)/(1/2𝜋)$，我们可以测试这个:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">        <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">        <span class="keyword">auto</span> x = <span class="built_in">cos</span>(<span class="number">2</span>*pi*r1)*<span class="number">2</span>*<span class="built_in">sqrt</span>(r2*(<span class="number">1</span>-r2));</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">sin</span>(<span class="number">2</span>*pi*r1)*<span class="number">2</span>*<span class="built_in">sqrt</span>(r2*(<span class="number">1</span>-r2));</span><br><span class="line">        <span class="keyword">auto</span> z = <span class="number">1</span> - r2;</span><br><span class="line">        sum += z*z*z / (<span class="number">1.0</span>/(<span class="number">2.0</span>*pi));</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Pi/2     = "</span> &lt;&lt; pi/<span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Estimate = "</span> &lt;&lt; sum/N &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Now let’s generate directions with 𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛𝑠)=cos(𝜃)/𝜋.</p></blockquote><p>现在让我们用 p(directions)=cos(θ)/π 来生成方向。<br>$$<br>r_2 = \int_0^{\theta}{2\pi \frac{\cos(t)}{\pi} \sin(t) = 1 - \cos^2(\theta)}<br>$$</p><blockquote><p>So,</p></blockquote><p>$$<br>\cos(\theta) = \sqrt{1 - r_2}<br>$$</p><blockquote><p>We can save a little algebra on specific cases by noting</p></blockquote><p>通过标注，我们可以在特定情况下节省一些代数运算<br>$$<br>z = \cos(\theta) = \sqrt{1 - r_2}<br>$$</p><p>$$<br>x = \cos(\phi)\sin(\theta) = \cos(2\pi r_1)\sqrt{1 - z^2} = \cos(2\pi r_1)\sqrt{r_2}<br>$$</p><p>$$<br>y = \sin(\phi)\sin(\theta) = \sin(2\pi r_1)\sqrt{1 - z^2} = \sin(2 \pi r_2)<br>$$</p><blockquote><p>Let’s also start generating them as random vectors:</p></blockquote><p>让我们开始以随机向量的形式生成它们:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_cosine_direction</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">sqrt</span>(<span class="number">1</span>-r2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="number">2</span>*pi*r1;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi)*<span class="built_in">sqrt</span>(r2);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi)*<span class="built_in">sqrt</span>(r2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">random_cosine_direction</span>();</span><br><span class="line">        sum += v.<span class="built_in">z</span>()*v.<span class="built_in">z</span>()*v.<span class="built_in">z</span>() / (v.<span class="built_in">z</span>()/pi);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Pi/2     = "</span> &lt;&lt; pi/<span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Estimate = "</span> &lt;&lt; sum/N &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can generate other densities later as we need them. In the next chapter we’ll get them aligned to the surface normal vector.</p></blockquote><p>我们可以在以后需要时生成其他密度。在下一章中，我们将让它们与表面法向量对齐。</p><h3 id="标准正交基"><a href="#标准正交基" class="headerlink" title="标准正交基"></a>标准正交基</h3><blockquote><p>In the last chapter we developed methods to generate random directions relative to the Z-axis. We’d like to be able to do that relative to a surface normal vector.</p></blockquote><p>在最后一章中，我们开发了生成相对于z轴的随机方向的方法。我们希望能够相对于曲面法向量来做这个。</p><h4 id="Relative-Coordinates"><a href="#Relative-Coordinates" class="headerlink" title="Relative Coordinates"></a>Relative Coordinates</h4><blockquote><p>An orthonormal basis (ONB) is a collection of three mutually orthogonal unit vectors. The Cartesian XYZ axes are one such ONB, and I sometimes forget that it has to sit in some real place with real orientation to have meaning in the real world, and some virtual place and orientation in the virtual world. A picture is a result of the relative positions/orientations of the camera and scene, so as long as the camera and scene are described in the same coordinate system, all is well.</p></blockquote><p>一个标准正交基(ONB)是三个相互正交的单位向量的集合。笛卡尔的XYZ轴就是这样一个ONB，我有时会忘记它必须位于真实的位置，具有真实的方向，才能在现实世界中有意义，在虚拟世界中也有虚拟的位置和方向。图片是相机和场景的相对位置/方向的结果，所以只要相机和场景在同一个坐标系中描述，一切都好。</p><blockquote><p>Suppose we have an origin <strong>𝐎</strong> and cartesian unit vectors <strong>𝐱</strong>, <strong>𝐲</strong>, and <strong>𝐳</strong>. When we say a location is (3,-2,7), we really are saying:</p></blockquote><p>假设我们有一个原点 <strong>O</strong> 和笛卡子单位向量 <strong>x</strong>、 <strong>y</strong> 和 <strong>z</strong>。当我们说一个位置是(3，-2,7)时，我们实际上是在说:<br>$$<br>Location \space is \space O + 3x - 2y + 7z<br>$$</p><blockquote><p>If we want to measure coordinates in another coordinate system with origin <strong>𝐎</strong>′ and basis vectors <strong>𝐮</strong>, <strong>𝐯</strong>, and <strong>𝐰</strong>, we can just find the numbers (𝑢,𝑣,𝑤) such that:</p></blockquote><p>如果我们想测量另一个以原点 $\mathbf{O}’$ 和基向量 $\mathbf{u}$、$\mathbf{v}$ 和 $\mathbf{w}$ 为原点的坐标系中的坐标，我们可以找到数字 $(u,v,w)$，这样:<br>$$<br>Location \space is \space O’ + 𝑢\mathbf{u} + v\mathbf{v} + w\mathbf{w}<br>$$</p><h4 id="Generating-an-Orthonormal-Basis"><a href="#Generating-an-Orthonormal-Basis" class="headerlink" title="Generating an Orthonormal Basis"></a>Generating an Orthonormal Basis</h4><blockquote><p>If you take an intro graphics course, there will be a lot of time spent on coordinate systems and 4×4 coordinate transformation matrices. Pay attention, it’s important stuff in graphics! But we won’t need it. What we need to is generate random directions with a set distribution relative to <strong>𝐧</strong>. We don’t need an origin because a direction is relative to no specified origin. We do need two cotangent vectors that are mutually perpendicular to <strong>𝐧</strong> and to each other.</p></blockquote><p>如果你上了一门图形入门课程，你会花很多时间学习坐标系统和 4×4 坐标变换矩阵。注意了，这是图像中的重要内容!但我们不需要它。我们需要的是用相对于 $\mathbf{n}$ 的集合分布生成随机方向。我们不需要原点，因为方向相对于没有特定的原点。我们确实需要两个余切向量，它们相互垂直于 $\mathbf{n}$ 并且彼此垂直。</p><blockquote><p>Some models will come with one or more cotangent vectors. If our model has only one cotangent vector, then the process of making an ONB is a nontrivial one. Suppose we have any vector <strong>𝐚</strong> that is of nonzero length and not parallel to <strong>𝐧</strong>. We can get vectors <strong>𝐬</strong> and <strong>𝐭</strong>t perpendicular to <strong>𝐧</strong> by using the property of the cross product that <strong>𝐜</strong>×<strong>𝐝</strong>c×d is perpendicular to both <strong>𝐜</strong> and <strong>𝐝</strong>:</p></blockquote><p>有些模型会带有一个或多个余切向量。如果我们的模型只有一个余切向量，那么生成ONB的过程就不是简单的了。假设有任何长度非零且不平行于 $\mathbf{n}$ 的向量 $\mathbf{a}$。通过使用 $\mathbf{c}$ 乘以 $\mathbf{d}$ 同时垂直于 $\mathbf{c}$ 和 $\mathbf{d}$​ 的叉积属性，我们可以得到垂直于 $\mathbf{s}$ 和 $\mathbf{t}$ 的向量:<br>$$<br>\mathbf{t} = unit_vector(\mathbf a \times \mathbf n)<br>$$</p><p>$$<br>\mathbf{s} = \mathbf{t} \times \mathbf{n}<br>$$</p><blockquote><p>This is all well and good, but the catch is that we may not be given an <strong>𝐚</strong> when we load a model, and we don’t have an <strong>𝐚</strong> with our existing program. If we went ahead and picked an arbitrary <strong>𝐚</strong> to use as our initial vector we may get an <strong>𝐚</strong>a that is parallel to <strong>𝐧</strong>. A common method is to use an if-statement to determine whether <strong>𝐧</strong> is a particular axis, and if not, use that axis.</p></blockquote><p>这一切都很好，但问题是，在加载模型时，可能不会给我们一个 <strong>a</strong>，而且在现有的程序中也没有 <strong>a</strong>。如果我们继续并选择一个任意的 <strong>a</strong> 作为初始向量，我们可能会得到一个与 <strong>n</strong> 并行的 <strong>a</strong>。一个常见的方法是使用if语句来确定 <strong>n</strong> 是否是一个特定的轴，如果不是，就使用这个轴。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">absolute</span><span class="params">(n.x &gt; <span class="number">0.9</span>)</span></span></span><br><span class="line"><span class="function">    a ← <span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span></span></span><br><span class="line"><span class="function">    a ← <span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Once we have an ONB of <strong>𝐬</strong>, <strong>𝐭</strong>, and <strong>𝐧</strong>, and we have a 𝑟𝑎𝑛𝑑𝑜𝑚(𝑥,𝑦,𝑧) relative to the Z-axis, we can get the vector relative to <strong>𝐧</strong> as:</p></blockquote><p>一旦我们有了一个 <strong>s</strong>， <strong>t</strong>，和 <strong>n</strong> 的ONB，并且有了一个相对于z轴的random(x,y,z)，我们就可以得到相对于 <strong>n</strong> 的向量:<br>$$<br>Random \space vector = x\mathbf s + y\mathbf t + z\mathbf n<br>$$</p><blockquote><p>You may notice we used similar math to get rays from a camera. That could be viewed as a change to the camera’s natural coordinate system.</p></blockquote><p>你可能会注意到，我们用类似的数学方法从相机中获取光线。这可以看作是相机自然坐标系统的改变。</p><h4 id="The-ONB-Class"><a href="#The-ONB-Class" class="headerlink" title="The ONB Class"></a>The ONB Class</h4><blockquote><p>Should we make a class for ONBs, or are utility functions enough? I’m not sure, but let’s make a class because it won’t really be more complicated than utility functions:</p></blockquote><p>我们应该为onb创建一个类，还是实用函数就足够了?我不确定，但让我们创建一个类，因为它不会比实用函数更复杂:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONB_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">onb</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">onb</span>() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">inline</span> vec3 <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> { <span class="keyword">return</span> axis[i]; }</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">u</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> axis[<span class="number">0</span>]; }</span><br><span class="line">        <span class="function">vec3 <span class="title">v</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> axis[<span class="number">1</span>]; }</span><br><span class="line">        <span class="function">vec3 <span class="title">w</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> axis[<span class="number">2</span>]; }</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> a*<span class="built_in">u</span>() + b*<span class="built_in">v</span>() + c*<span class="built_in">w</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">const</span> vec3&amp; a)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> a.<span class="built_in">x</span>()*<span class="built_in">u</span>() + a.<span class="built_in">y</span>()*<span class="built_in">v</span>() + a.<span class="built_in">z</span>()*<span class="built_in">w</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 axis[<span class="number">3</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onb::build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp; n)</span> </span>{</span><br><span class="line">    axis[<span class="number">2</span>] = <span class="built_in">unit_vector</span>(n);</span><br><span class="line">    vec3 a = (<span class="built_in">fabs</span>(<span class="built_in">w</span>().<span class="built_in">x</span>()) &gt; <span class="number">0.9</span>) ? <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>) : <span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    axis[<span class="number">1</span>] = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(<span class="built_in">w</span>(), a));</span><br><span class="line">    axis[<span class="number">0</span>] = <span class="built_in">cross</span>(<span class="built_in">w</span>(), <span class="built_in">v</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can rewrite our Lambertian material using this to get:</p></blockquote><p>我们可以用这个改写朗伯公式得到</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">virtual bool scatter(</span><br><span class="line">    const ray&amp; r_in, const hit_record&amp; rec, color&amp; alb, ray&amp; scattered, double&amp; pdf</span><br><span class="line">) const override {</span><br><span class="line"><span class="addition">+   onb uvw;</span></span><br><span class="line"><span class="addition">+   uvw.build_from_w(rec.normal);</span></span><br><span class="line"><span class="addition">+   auto direction = uvw.local(random_cosine_direction());</span></span><br><span class="line">    scattered = ray(rec.p, unit_vector(direction), r_in.time());</span><br><span class="line">    alb = albedo-&gt;value(rec.u, rec.v, rec.p);</span><br><span class="line"><span class="addition">+   pdf = dot(uvw.w(), scattered.direction()) / pi;</span></span><br><span class="line">    return true;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which produces:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.03-cornell-ortho.jpg"></p><blockquote><p>Is that right? We still don’t know for sure. Tracking down bugs is hard in the absence of reliable reference solutions. Let’s table that for now and get rid of some of that noise.</p></blockquote><p>是这样吗?我们还不确定。在缺乏可靠的参考解决方案的情况下，追踪bug是很困难的。我们先把它放在桌子上，去掉一些杂音。</p><h3 id="直接光源采样"><a href="#直接光源采样" class="headerlink" title="直接光源采样"></a>直接光源采样</h3><blockquote><p>The problem with sampling almost uniformly over directions is that lights are not sampled any more than unimportant directions. We could use shadow rays and separate out direct lighting. Instead, I’ll just send more rays to the light. We can then use that later to send more rays in whatever direction we want.</p><p>It’s really easy to pick a random direction toward the light; just pick a random point on the light and send a ray in that direction. We also need to know the PDF, 𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛). What is that?</p></blockquote><p>对方向进行几乎一致的采样的问题是，光的采样并不比不重要的方向多。我们可以使用阴影光线来分离直接照明。相反，我将向光发射更多的射线。然后我们可以用它向任何我们想要的方向发送更多的射线。</p><p>我们很容易选择一个随机的朝向光的方向;在光上随便选一个点，然后往那个方向发送一条射线。我们还需要知道PDF， $p(direction)$。那是什么?</p><h4 id="Getting-the-PDF-of-a-Light"><a href="#Getting-the-PDF-of-a-Light" class="headerlink" title="Getting the PDF of a Light"></a>Getting the PDF of a Light</h4><blockquote><p>For a light of area 𝐴, if we sample uniformly on that light, the PDF on the surface of the light is $\frac{1}{𝐴}$. What is it on the area of the unit sphere that defines directions? Fortunately, there is a simple correspondence, as outlined in the diagram:</p></blockquote><p>对于一个区域(a)的光，如果我们在该光上均匀采样，光表面的PDF是 $\frac{1}{a}$。在单位球的面积上是什么定义了方向?幸运的是，有一个简单的对应关系，如图所示:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.07-shape-onto-pdf.jpg"></p><blockquote><p>If we look at a small area 𝑑𝐴 on the light, the probability of sampling it is $𝑝_𝑞(𝑞)⋅𝑑𝐴$. On the sphere, the probability of sampling the small area 𝑑𝑤 on the sphere is $𝑝(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)⋅𝑑𝑤$. There is a geometric relationship between 𝑑𝑤 and 𝑑𝐴:</p></blockquote><p>$$<br>d\omega = \frac{dA \cdot \cos(alpha)}{distance^2(p,q)}<br>$$</p><blockquote><p>Since the probability of sampling dw and dA must be the same, we have</p></blockquote><p>$$<br>p(direction) \cdot \frac{dA \cdot \cos(alpha)}{distance^2(p,q)} = p_q(q) \cdot dA = \frac{dA}{A}<br>$$</p><blockquote><p>So</p></blockquote><p>$$<br>p(direction) = \frac{distance^2(p,q)}{\cos(alpha) \cdot A}<br>$$</p><h4 id="Light-Sampling"><a href="#Light-Sampling" class="headerlink" title="Light Sampling"></a>Light Sampling</h4><blockquote><p>If we hack our <code>ray_color()</code> function to sample the light in a very hard-coded fashion just to check that math and get the concept, we can add it (see the highlighted region):</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(const ray&amp; r, const vec3&amp; background, const hittable&amp; world,int depth) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return vec3(0,0,0);</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (!world.hit(r,0.001,infinity,rec))</span><br><span class="line">        return background;</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    vec3 attenuation;</span><br><span class="line">    vec3 emitted = rec.mat_ptr-&gt;emitted(rec.u, rec.v, rec.p);</span><br><span class="line">    double pdf;</span><br><span class="line">    vec3 albedo;</span><br><span class="line"></span><br><span class="line">    if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf))</span><br><span class="line">        return emitted;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto on_light = vec3(random_double(213, 343), 554, random_double(227, 332));</span></span><br><span class="line"><span class="addition">+   auto to_light = on_light - rec.p;</span></span><br><span class="line"><span class="addition">+   auto distance_squared = to_light.length_squared();</span></span><br><span class="line"><span class="addition">+   to_light = unit_vector(to_light);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (dot(to_light, rec.normal) &lt; 0)</span></span><br><span class="line"><span class="addition">+       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   double light_area = (343 - 213) * (332 - 227);</span></span><br><span class="line"><span class="addition">+   auto light_cosine = fabs(to_light.y());</span></span><br><span class="line"><span class="addition">+   if (light_cosine &lt; 0.000001)</span></span><br><span class="line"><span class="addition">+       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   pdf = distance_squared / (light_cosine * light_area);</span></span><br><span class="line"><span class="addition">+   scattered = ray(rec.p, to_light, r.time());</span></span><br><span class="line"></span><br><span class="line">    return emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span><br><span class="line">                      * ray_color(scattered, background, world, depth - 1) / pdf;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>With 10 samples per pixel this yields:</p></blockquote><p>如果每像素10个样本，就会产生:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.04-cornell-sample-light.jpg"></p><blockquote><p>This is about what we would expect from something that samples only the light sources, so this appears to work.</p></blockquote><p>这是我们从只采样光源的东西中所期望的，所以这似乎是可行的。</p><h4 id="Switching-to-Unidirectional-Light"><a href="#Switching-to-Unidirectional-Light" class="headerlink" title="Switching to Unidirectional Light"></a>Switching to Unidirectional Light</h4><blockquote><p>The noisy pops around the light on the ceiling are because the light is two-sided and there is a small space between light and ceiling. We probably want to have the light just emit down. We can do that by letting the emitted member function of hittable take extra information:</p></blockquote><p>天花板上的灯周围嘈杂的砰砰声是因为灯是双面的，灯和天花板之间有一个很小的空间。我们可能想让光发射下去。我们可以通过让hittable发出的成员函数获取额外的信息来做到这一点:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> vec3 <span class="title">emitted</span><span class="params">(<span class="type">const</span> ray&amp;r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (rec.front_face)</span><br><span class="line">        <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Making sure to call this in our world definition:</p></blockquote><p>确保在我们的世界定义中调用它:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list cornell_box_plus() {</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    auto red = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.65, 0.05, 0.05)));</span><br><span class="line">    auto white = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.73, 0.73, 0.73)));</span><br><span class="line">    auto green = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.12, 0.45, 0.15)));</span><br><span class="line">    auto light = make_shared&lt;diffuse_light&gt;(make_shared&lt;constant_texture&gt;(vec3(15, 15, 15)));</span><br><span class="line"></span><br><span class="line">    objects.add(make_shared&lt;yz_rect&gt;(0, 555, 0, 555, 555, green));</span><br><span class="line">    objects.add(make_shared&lt;yz_rect&gt;(0, 555, 0, 555, 0, red));</span><br><span class="line"><span class="addition">+   objects.add(make_shared&lt;flip_face&gt;(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, light)));</span></span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, light));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(0, 555, 0, 555, 555, white));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(0, 555, 0, 555, 0, white));</span><br><span class="line">    objects.add(make_shared&lt;xy_rect&gt;(0, 555, 0, 555, 555, white));</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This gives us:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.05-cornell-lightdown.jpg"></p><h3 id="混合密度"><a href="#混合密度" class="headerlink" title="混合密度"></a>混合密度</h3><blockquote><p>We have used a PDF related to cos(𝜃), and a PDF related to sampling the light. We would like a PDF that combines these.</p></blockquote><p>我们使用了一个与 $\cos(\theta)$ 有关的PDF，以及一个与光线采样有关的PDF。我们想要一个结合这些的PDF。</p><h4 id="An-Average-of-Lighting-and-Reflection"><a href="#An-Average-of-Lighting-and-Reflection" class="headerlink" title="An Average of Lighting and Reflection"></a>An Average of Lighting and Reflection</h4><blockquote><p>A common tool in probability is to mix the densities to form a mixture density. Any weighted average of PDFs is a PDF. For example, we could just average the two densities:</p></blockquote><p>概率论中的一个常用工具是将密度混合，形成一个混合密度。任何PDF的加权平均值都是PDF。例如，我们可以取两个密度的平均值:<br>$$<br>mixture_{pdf}(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)=\frac{1}{2}reflection_{pdf}(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)+\frac{1}{2}light_{pdf}(𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛)<br>$$</p><blockquote><p>How would we instrument our code to do that? There is a very important detail that makes this not quite as easy as one might expect. Choosing the random direction is simple:</p></blockquote><p>我们该如何编写代码来实现这一点呢?有一个非常重要的细节使得这并不像人们想象的那么容易。选择随机方向很简单:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>)</span><br><span class="line">    pick direction according to pdf_reflection</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    pick direction according to pdf_light</span><br></pre></td></tr></tbody></table></figure><blockquote><p>But evaluating $mixture_{pdf}$ is slightly more subtle. We need to evaluate both $reflection_{pdf}$ and $light_{pdf}$ because there are some directions where either PDF could have generated the direction. For example, we might generate a direction toward the light using $reflection_pdf$.</p></blockquote><p>但是对 mixture_pdf 的计算稍微微妙一些。我们需要同时计算 reflection_pdf 和 light_pdf，因为有一些方向，其中任何一个pdf都可以生成方向。例如，我们可以使用 reflection_pdf 生成一个朝向光的方向。</p><blockquote><p>If we step back a bit, we see that there are two functions a PDF needs to support:</p><ol><li>What is your value at this location?</li><li>Return a random number that is distributed appropriately.</li></ol></blockquote><p>退一步来看，PDF需要支持两个功能:</p><ol><li>你在这里的价值是多少?</li><li>返回一个适当分布的随机数。</li></ol><blockquote><p>The details of how this is done under the hood varies for the $reflection_{pdf}$​ and the $light_{pdf}$​ and the mixture density of the two of them, but that is exactly what class hierarchies were invented for! It’s never obvious what goes in an abstract class, so my approach is to be greedy and hope a minimal interface works, and for the PDF this implies:</p></blockquote><p>这是如何做的细节是不同的 reflection_pdf 和 light_pdf 和两者的混合密度，但这正是类层次结构被发明的!抽象类中有什么是不明显的，所以我的方法是贪婪的，希望一个最小的接口工作，对于PDF这意味着:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"vec3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pdf</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">pdf</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We’ll see if that works by fleshing out the subclasses. For sampling the light, we will need <code>hittable</code> to answer some queries that it doesn’t have an interface for. We’ll probably need to mess with it too, but we can start by seeing if we can put something in <code>hittable</code> involving sampling the bounding box that works with all its subclasses.</p><p>First, let’s try a cosine density:</p></blockquote><p>我们将通过充实子类来看看它是否有效。为了对光线进行采样，我们需要hittable来回答一些它没有接口的查询。我们可能也需要弄乱它，但我们可以先看看是否可以在hittable中放入一些东西，包括采样与所有子类一起工作的边界框。</p><p>首先，我们来试试余弦密度：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cosine_pdf</span> : <span class="keyword">public</span> pdf {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cosine_pdf</span>(<span class="type">const</span> vec3&amp; w) { uvw.<span class="built_in">build_from_w</span>(w); }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(<span class="built_in">unit_vector</span>(direction), uvw.<span class="built_in">w</span>());</span><br><span class="line">        <span class="keyword">return</span> (cosine &lt;= <span class="number">0</span>) ? <span class="number">0</span> : cosine/pi;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    onb uvw;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can try this in the <code>ray_color()</code> function, with the main changes highlighted. We also need to change variable <code>pdf</code> to some other variable name to avoid a name conflict with the new <code>pdf</code> class.</p></blockquote><p>我们可以在 <code>ray_color()</code> 函数中尝试一下，突出显示主要的变化。我们还需要将变量 pdf 更改为其他变量名，以避免与新 pdf 类的名称冲突。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(const ray&amp; r, const vec3&amp; background, const hittable&amp; world,int depth) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return vec3(0,0,0);</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (!world.hit(r,0.001,infinity,rec))</span><br><span class="line">        return background;</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    vec3 attenuation;</span><br><span class="line">    vec3 emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line"><span class="addition">+   double pdf_val;</span></span><br><span class="line">    vec3 albedo;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf_val))</span></span><br><span class="line">        return emitted;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   auto on_light = vec3(random_double(213, 343), 554, random_double(227, 332));</span></span><br><span class="line"><span class="deletion">-   auto to_light = on_light - rec.p;</span></span><br><span class="line"><span class="deletion">-   auto distance_squared = to_light.length_squared();</span></span><br><span class="line"><span class="deletion">-   to_light = unit_vector(to_light);</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   if (dot(to_light, rec.normal) &lt; 0)</span></span><br><span class="line"><span class="deletion">-       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   double light_area = (343 - 213) * (332 - 227);</span></span><br><span class="line"><span class="deletion">-   auto light_cosine = fabs(to_light.y());</span></span><br><span class="line"><span class="deletion">-   if (light_cosine &lt; 0.000001)</span></span><br><span class="line"><span class="deletion">-       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   pdf = distance_squared / (light_cosine * light_area);</span></span><br><span class="line"><span class="deletion">-   scattered = ray(rec.p, to_light, r.time());</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   cosine_pdf p(rec.normal);</span></span><br><span class="line"><span class="addition">+   scattered = ray(rec.p, p.generate(), r.time());</span></span><br><span class="line"><span class="addition">+   pdf_val = p.value(scattered.direction()); </span></span><br><span class="line">    </span><br><span class="line">    return emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span><br><span class="line"><span class="addition">+                * ray_color(scattered, background, world, depth - 1) / pdf_val;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This yields an apparently matching result so all we’ve done so far is refactor where <code>pdf</code> is computed:</p></blockquote><p>这产生一个明显匹配的结果，所以我们所做的一切，到目前为止是重构的pdf计算:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.06-cornell-cos-pdf.jpg"></p><h4 id="Sampling-Directions-towards-a-Hittable"><a href="#Sampling-Directions-towards-a-Hittable" class="headerlink" title="Sampling Directions towards a Hittable"></a>Sampling Directions towards a Hittable</h4><blockquote><p>Now we can try sampling directions toward a <code>hittable</code>, like the light.</p></blockquote><p>现在我们可以试着朝着可击中物体的方向取样，比如光。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_pdf</span> : <span class="keyword">public</span> pdf {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_pdf</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> vec3&amp; origin) : <span class="built_in">ptr</span>(p), <span class="built_in">o</span>(origin) {}</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">pdf_value</span>(o, direction);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 o;</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This assumes two as-yet not implemented functions in the <code>hittable</code> class. To avoid having to add instrumentation to all <code>hittable</code> subclasses, we’ll add two dummy functions to the <code>hittable</code> class:</p></blockquote><p>这假设在hittable类中有两个尚未实现的函数。为了避免向所有hittable子类添加插装，我们将向hittable类添加两个虚拟函数:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class hittable {</span><br><span class="line">public:</span><br><span class="line">    virtual bool hit(const ray&amp; r,double  t_min,double  t_max,hit_record&amp; rec) const = 0;</span><br><span class="line">    virtual bool bounding_box(double t0, double t1, aabb&amp; output_box) const = 0;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   virtual double pdf_value(const vec3&amp; o, const vec3&amp; v) {</span></span><br><span class="line"><span class="addition">+       return 0.0;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   virtual vec3 random(const vec3&amp; o) const {</span></span><br><span class="line"><span class="addition">+       return vec3(1, 0, 0);</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And we change <code>xz_rect</code> to implement those functions:</p></blockquote><p>我们改变 xz_rect 来实现这些函数:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ......    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> vec3&amp; origin, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>{</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(origin, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> area = (x1-x0)*(z1-z0);</span><br><span class="line">        <span class="keyword">auto</span> distance_squared = rec.t * rec.t * v.<span class="built_in">length_squared</span>();</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">fabs</span>(<span class="built_in">dot</span>(v, rec.normal) / v.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> distance_squared / (cosine * area);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> vec3&amp; origin)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> random_point = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(x0,x1), k, <span class="built_in">random_double</span>(z0,z1));</span><br><span class="line">        <span class="keyword">return</span> random_point - origin;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And then change <code>ray_color()</code>:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(</span><br><span class="line">    const ray&amp; r, const color&amp; background, const hittable&amp; world,</span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt;&amp; lights, int depth</span></span><br><span class="line">) {</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    color attenuation;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    double pdf_val;</span><br><span class="line">    color albedo;</span><br><span class="line">    if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf_val))</span><br><span class="line">        return emitted;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   hittable_pdf light_pdf(lights, rec.p);</span></span><br><span class="line"><span class="addition">+   scattered = ray(rec.p, light_pdf.generate(), r.time());</span></span><br><span class="line"><span class="addition">+   pdf_val = light_pdf.value(scattered.direction());</span></span><br><span class="line"></span><br><span class="line">    return emitted</span><br><span class="line">         + albedo * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span><br><span class="line"><span class="addition">+                 * ray_color(scattered, background, world, lights, depth-1) / pdf_val;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">int main() {</span><br><span class="line">    ...</span><br><span class="line">    // World</span><br><span class="line"></span><br><span class="line">    auto world = cornell_box();</span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt; lights =</span></span><br><span class="line"><span class="addition">+       make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, shared_ptr&lt;material&gt;());</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    for (int j = image_height-1; j &gt;= 0; --j) {</span><br><span class="line">        std::cerr &lt;&lt; "\rScanlines remaining: " &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;</span><br><span class="line">        for (int i = 0; i &lt; image_width; ++i) {</span><br><span class="line">            ...</span><br><span class="line"><span class="addition">+           pixel_color += ray_color(r, background, world, lights, max_depth);</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><blockquote><p>At 10 samples per pixel we get:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.07-hittable-light.jpg"></p><h4 id="The-Mixture-PDF-Class"><a href="#The-Mixture-PDF-Class" class="headerlink" title="The Mixture PDF Class"></a>The Mixture PDF Class</h4><blockquote><p>Now we would like to do a mixture density of the cosine and light sampling. The mixture density class is straightforward:</p></blockquote><p>现在我们要做余弦的混合密度和光采样。混合密度类很简单:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mixture_pdf</span> : <span class="keyword">public</span> pdf {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">mixture_pdf</span>(shared_ptr&lt;pdf&gt; p0, shared_ptr&lt;pdf&gt; p1) {</span><br><span class="line">            p[<span class="number">0</span>] = p0;</span><br><span class="line">            p[<span class="number">1</span>] = p1;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span> * p[<span class="number">0</span>]-&gt;<span class="built_in">value</span>(direction) + <span class="number">0.5</span> *p[<span class="number">1</span>]-&gt;<span class="built_in">value</span>(direction);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">return</span> p[<span class="number">0</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p[<span class="number">1</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;pdf&gt; p[<span class="number">2</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And plugging it into <code>ray_color()</code>:</p></blockquote><p>并将其插入 <code>ray_color()</code> 中:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">color ray_color(</span><br><span class="line">    const ray&amp; r, const color&amp; background, const hittable&amp; world,</span><br><span class="line">    shared_ptr&lt;hittable&gt;&amp; lights, int depth</span><br><span class="line">) {</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    color attenuation;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    double pdf_val;</span><br><span class="line">    color albedo;</span><br><span class="line">    if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf_val))</span><br><span class="line">        return emitted;</span><br><span class="line"><span class="addition">+   auto p0 = make_shared&lt;hittable_pdf&gt;(lights, rec.p);</span></span><br><span class="line"><span class="addition">+   auto p1 = make_shared&lt;cosine_pdf&gt;(rec.normal);</span></span><br><span class="line"><span class="addition">+   mixture_pdf mixed_pdf(p0, p1);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   scattered = ray(rec.p, mixed_pdf.generate(), r.time());</span></span><br><span class="line"><span class="addition">+   pdf_val = mixed_pdf.value(scattered.direction());</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>1000 samples per pixel yields:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.08-cosine-and-light.jpg"></p><blockquote><p>We’ve basically gotten this same picture (with different levels of noise) with several different sampling patterns. It looks like the original picture was slightly wrong! Note by “wrong” here I mean not a correct Lambertian picture. Yet Lambertian is just an ideal approximation to matte, so our original picture was some other accidental approximation to matte. I don’t think the new one is any better, but we can at least compare it more easily with other Lambertian renderers.</p></blockquote><h3 id="一些架构决策"><a href="#一些架构决策" class="headerlink" title="一些架构决策"></a>一些架构决策</h3><blockquote><p>I won’t write any code in this chapter. We’re at a crossroads where I need to make some architectural decisions. The mixture-density approach is to not have traditional shadow rays, and is something I personally like, because in addition to lights you can sample windows or bright cracks under doors or whatever else you think might be bright. But most programs branch, and send one or more terminal rays to lights explicitly, and one according to the reflective distribution of the surface. This could be a time you want faster convergence on more restricted scenes and add shadow rays; that’s a personal design preference.</p></blockquote><p>在本章中，我不会写任何代码。我们正处在一个十字路口，我需要做出一些架构上的决定。混合密度方法是不使用传统的阴影光线，这也是我个人喜欢的方法，因为除了灯光，你还可以对窗户、门下的明亮裂缝或任何你认为可能明亮的东西进行采样。但是大多数程序都是分支的，将一个或多个终端光线明确地发送到光，另一个则根据表面的反射分布。这可能是你想要在更有限的场景中更快地收敛和添加阴影光线的时候;这是个人的设计偏好。</p><blockquote><p>There are some other issues with the code.</p></blockquote><p>该代码还有其他一些问题。</p><blockquote><p>The PDF construction is hard coded in the <code>ray_color()</code> function. We should clean that up, probably by passing something into color about the lights. Unlike BVH construction, we should be careful about memory leaks as there are an unbounded number of samples.</p></blockquote><p>PDF结构是在 <code>ray_color()</code> 函数中硬编码的。我们应该把它清理一下，也许通过把一些关于灯光的东西变成颜色。与BVH构造不同，我们应该小心内存泄漏，因为样本的数量是无限的。</p><blockquote><p>The specular rays (glass and metal) are no longer supported. The math would work out if we just made their scattering function a delta function. But that would be floating point disaster. We could either separate out specular reflections, or have surface roughness never be zero and have almost-mirrors that look perfectly smooth but don’t generate NaNs. I don’t have an opinion on which way to do it (I have tried both and they both have their advantages), but we have smooth metal and glass code anyway, so I add perfect specular surfaces that do not do explicit f()/p() calculations.</p></blockquote><p>镜面光线(玻璃和金属)不再被支持。如果我们把它们的散射函数设为脉冲函数，数学就能算出来。但那将是浮点灾难。我们可以将镜面反射分离出来，或者让表面粗糙度永远不为零，拥有看起来完美光滑但不会产生 <code>NaN</code>的准镜面。我对这种方法没有意见(我都试过了，他们都有他们的优势)，但我们有光滑的金属和玻璃代码，所以我添加了完美的镜面，不做显式的f()/p()计算。</p><blockquote><p>We also lack a real background function infrastructure in case we want to add an environment map or more interesting functional background. Some environment maps are HDR (the RGB components are floats rather than 0–255 bytes usually interpreted as 0-1). Our output has been HDR all along; we’ve just been truncating it.</p></blockquote><p>如果我们想要添加环境映射或更有趣的功能背景，我们还缺少真正的后台功能基础设施。有些环境映射是HDR (RGB组件是浮点数，而不是0-255字节，通常被解释为0-1)。我们的输出一直是HDR;我们只是在截短它。</p><blockquote><p>Finally, our renderer is RGB and a more physically based one — like an automobile manufacturer might use — would probably need to use spectral colors and maybe even polarization. For a movie renderer, you would probably want RGB. You can make a hybrid renderer that has both modes, but that is of course harder. I’m going to stick to RGB for now, but I will revisit this near the end of the book.</p></blockquote><p>最后，我们的渲染器是RGB，一个更基于物理的渲染器-就像汽车制造商可能使用的-可能需要使用光谱颜色，甚至极化。对于电影渲染器，您可能需要RGB。你可以制作一个混合渲染器，它有两种模式，但这当然比较困难。现在我将坚持RGB模式，但是我会在本书的末尾重新讨论这个问题。</p><h3 id="优化PDF架构"><a href="#优化PDF架构" class="headerlink" title="优化PDF架构"></a>优化PDF架构</h3><blockquote><p>So far I have the <code>ray_color()</code> function create two hard-coded PDFs:</p><ol><li><code>p0()</code> related to the shape of the light</li><li><code>p1()</code> related to the normal vector and type of surface</li></ol><p>We can pass information about the light (or whatever <code>hittable</code> we want to sample) into the <code>ray_color()</code> function, and we can ask the <code>material</code> function for a PDF (we would have to instrument it to do that). We can also either ask <code>hit</code> function or the <code>material</code> class to supply whether there is a specular vector.</p></blockquote><p>到目前为止，我的 <code>ray_color()</code> 函数创建两个硬编码的 PDF:</p><ol><li><code>p0()</code> 与光的形状有关</li><li><code>p1()</code> 与曲面的法向量和类型有关</li></ol><p>我们可以将关于光的信息(或者任何我们想要采样的 <code>hittable</code>)传递到 <code>ray_color()</code> 函数中，并且我们可以要求材质函数提供一个PDF文件(我们将不得不为此设置它)。我们也可以询问 <code>hit</code> 函数或 <code>material</code> 类是否有一个高光矢量。</p><h4 id="Diffuse-Versus-Specular"><a href="#Diffuse-Versus-Specular" class="headerlink" title="Diffuse Versus Specular"></a>Diffuse Versus Specular</h4><blockquote><p>One thing we would like to allow for is a material like varnished wood that is partially ideal specular (the polish) and partially diffuse (the wood). Some renderers have the material generate two rays: one specular and one diffuse. I am not fond of branching, so I would rather have the material randomly decide whether it is diffuse or specular. The catch with that approach is that we need to be careful when we ask for the PDF value and be aware of whether for this evaluation of <code>ray_color()</code> it is diffuse or specular. Fortunately, we know that we should only call the <code>pdf_value()</code> if it is diffuse so we can handle that implicitly.</p></blockquote><p>我们想要允许的一件事是一个材料，如涂漆的木材，部分是理想的镜面反射(抛光)和部分扩散(木材)。一些渲染器让材质产生两条光线:一条高光，一条漫反射。我不喜欢分支，所以我宁愿让材料随机决定是漫反射还是镜面反射。这种方法的陷阱是，当我们要求PDF值时，我们需要小心，并知道对于 <code>ray_color()</code> 的评估，它是漫反射还是镜面反射。幸运的是，我们知道只有当 <code>pdf_value()</code> 是diffuse时才应该调用它，这样我们就可以隐式地处理它。</p><blockquote><p>We can redesign <code>material</code> and stuff all the new arguments into a <code>struct</code> like we did for <code>hittable</code>:</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">scatter_record</span> {</span><br><span class="line">    ray specular_ray;</span><br><span class="line">    <span class="type">bool</span> is_specular;</span><br><span class="line">    vec3 attenuation;</span><br><span class="line">    shared_ptr&lt;pdf&gt; pdf_ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">emitted</span><span class="params">(<span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in,<span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The Lambertian material becomes simpler:</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> vec3&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(a)) {}</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>{</span><br><span class="line">        srec.is_specular = <span class="literal">false</span>;</span><br><span class="line">        srec.attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        srec.pdf_ptr = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">unit_vector</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And <code>ray_color()</code> changes are small:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">color ray_color(</span><br><span class="line">    const ray&amp; r,</span><br><span class="line">    const color&amp; background,</span><br><span class="line">    const hittable&amp; world,</span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt;&amp; lights,</span></span><br><span class="line">    int depth</span><br><span class="line">) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return color(0,0,0);</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (!world.hit(r, 0.001, infinity, rec))</span><br><span class="line">        return background;</span><br><span class="line"><span class="addition">+   scatter_record srec;</span></span><br><span class="line"><span class="addition">+   color emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span></span><br><span class="line"><span class="addition">+   if (!rec.mat_ptr-&gt;scatter(r, rec, srec))</span></span><br><span class="line"><span class="addition">+       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto light_ptr = make_shared&lt;hittable_pdf&gt;(lights, rec.p);</span></span><br><span class="line"><span class="addition">+   mixture_pdf p(light_ptr, srec.pdf_ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   ray scattered = ray(rec.p, p.generate(), r.time());</span></span><br><span class="line"><span class="addition">+   auto pdf_val = p.value(scattered.direction());</span></span><br><span class="line"></span><br><span class="line">    return emitted</span><br><span class="line"><span class="addition">+       + srec.attenuation * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span></span><br><span class="line">                           * ray_color(scattered, background, world, lights, depth-1) / pdf_val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    ...</span><br><span class="line">    // World</span><br><span class="line"></span><br><span class="line">    auto world = cornell_box();</span><br><span class="line"><span class="addition">+   auto lights = make_shared&lt;hittable_list&gt;();</span></span><br><span class="line"><span class="addition">+   lights-&gt;add(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, shared_ptr&lt;material&gt;()));</span></span><br><span class="line"><span class="addition">+   lights-&gt;add(make_shared&lt;sphere&gt;(point3(190, 90, 190), 90, shared_ptr&lt;material&gt;()));</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><h4 id="Handling-Specular"><a href="#Handling-Specular" class="headerlink" title="Handling Specular"></a>Handling Specular</h4><blockquote><p>We have not yet dealt with specular surfaces, nor instances that mess with the surface normal. But this design is clean overall, and those are all fixable. For now, I will just fix <code>specular</code>. Metal and dielectric materials are easy to fix.</p></blockquote><p>我们还没有处理过镜面，也没有处理过破坏表面法线的情况。但这个设计总体上是干净的，而且这些都是可以修复的。现在，我只修复镜面反射。金属和介电材料很容易固定。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class metal : public material {</span><br><span class="line">    public:</span><br><span class="line">        metal(const color&amp; a, double f) : albedo(a), fuzz(f &lt; 1 ? f : 1) {}</span><br><span class="line">        virtual bool scatter(</span><br><span class="line"><span class="addition">+           const ray&amp; r_in, const hit_record&amp; rec, scatter_record&amp; srec</span></span><br><span class="line">        ) const override {</span><br><span class="line"><span class="addition">+           vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);</span></span><br><span class="line"><span class="addition">+           srec.specular_ray = ray(rec.p, reflected+fuzz*random_in_unit_sphere());</span></span><br><span class="line"><span class="addition">+           srec.attenuation = albedo;</span></span><br><span class="line"><span class="addition">+           srec.is_specular = true;</span></span><br><span class="line"><span class="addition">+           srec.pdf_ptr = 0;</span></span><br><span class="line"><span class="addition">+           return true;</span></span><br><span class="line">        }</span><br><span class="line">    public:</span><br><span class="line">        vec3 albedo;</span><br><span class="line">        double fuzz;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">class dielectric : public material {</span><br><span class="line">    public:</span><br><span class="line">        ...</span><br><span class="line">        virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, scatter_record&amp; srec</span><br><span class="line">        ) const override {</span><br><span class="line"><span class="addition">+           srec.is_specular = true;</span></span><br><span class="line"><span class="addition">+           srec.pdf_ptr = nullptr;</span></span><br><span class="line"><span class="addition">+           srec.attenuation = color(1.0, 1.0, 1.0);</span></span><br><span class="line">            double refraction_ratio = rec.front_face ? (1.0/ir) : ir;</span><br><span class="line">            ...</span><br><span class="line"><span class="addition">+           srec.specular_ray = ray(rec.p, direction, r_in.time());</span></span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Note that if fuzziness is high, this surface isn’t ideally specular, but the implicit sampling works just like it did before.</p><p><code>ray_color()</code> just needs a new case to generate an implicitly sampled ray:</p></blockquote><p>请注意，如果模糊度很高，这个表面不是理想的镜面，但隐式采样工作就像以前一样。</p><p><code>ray_color()</code> 只需要一个新的情况来生成一个隐式采样射线:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(</span><br><span class="line">    const ray&amp; r,</span><br><span class="line">    const vec3&amp; background,</span><br><span class="line">    const hittable&amp; world,</span><br><span class="line">    shared_ptr&lt;hittable&gt;&amp; lights,</span><br><span class="line">    int depth</span><br><span class="line">) {</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    scatter_record srec;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    if (!rec.mat_ptr-&gt;scatter(r, rec, srec))</span><br><span class="line">        return emitted;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (srec.is_specular) {</span></span><br><span class="line"><span class="addition">+       return srec.attenuation</span></span><br><span class="line"><span class="addition">+            * ray_color(srec.specular_ray, background, world, lights, depth-1);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We also need to change the block to metal. We’ll also swap out the short block for a glass sphere.</p></blockquote><p>我们还需要把积木换成金属。我们也会把短块换成玻璃球。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list cornell_box_plus() {</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    auto red = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.65, 0.05, 0.05)));</span><br><span class="line">    auto white = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.73, 0.73, 0.73)));</span><br><span class="line">    auto green = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.12, 0.45, 0.15)));</span><br><span class="line">    auto light = make_shared&lt;diffuse_light&gt;(make_shared&lt;constant_texture&gt;(vec3(15, 15, 15)));</span><br><span class="line"></span><br><span class="line">    objects.add(make_shared&lt;yz_rect&gt;(0, 555, 0, 555, 555, green));</span><br><span class="line">    objects.add(make_shared&lt;yz_rect&gt;(0, 555, 0, 555, 0, red));</span><br><span class="line">    objects.add(make_shared&lt;flip_face&gt;(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, light)));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, light));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(0, 555, 0, 555, 555, white));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(0, 555, 0, 555, 0, white));</span><br><span class="line">    objects.add(make_shared&lt;xy_rect&gt;(0, 555, 0, 555, 555, white));</span><br><span class="line"></span><br><span class="line"><span class="addition">+   shared_ptr&lt;material&gt; aluminum = make_shared&lt;metal&gt;(vec3(0.8, 0.85, 0.88), 0.0);</span></span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt; box1 = make_shared&lt;box&gt;(vec3(0,0,0), vec3(165,330,165), aluminum);</span></span><br><span class="line">    box1 = make_shared&lt;rotate_y&gt;(box1, 15);</span><br><span class="line">    box1 = make_shared&lt;translate&gt;(box1, vec3(265,0,295));</span><br><span class="line">    objects.add(box1);</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = make_shared&lt;box&gt;(vec3(0,0,0), vec3(165,165,165), white);</span><br><span class="line">    box2 = make_shared&lt;rotate_y&gt;(box2, -18);</span><br><span class="line">    box2 = make_shared&lt;translate&gt;(box2, vec3(130,0,65));</span><br><span class="line">    objects.add(box2);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto glass = make_shared&lt;dielectric&gt;(1.5);</span></span><br><span class="line"><span class="addition">+   objects.add(make_shared&lt;sphere&gt;(vec3(190,90,190), 90 , glass));</span></span><br><span class="line"></span><br><span class="line">    return objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The resulting image has a noisy reflection on the ceiling because the directions toward the box are not sampled with more density.</p></blockquote><p>结果图像在天花板上有一个噪声反射，因为朝向盒子的方向没有以更多的密度进行采样。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.09-arbitrary-pdf.jpg"></p><blockquote><p>We could make the PDF include the block. Let’s do that instead with a glass sphere because it’s easier.</p></blockquote><h4 id="Sampling-a-Sphere-Object"><a href="#Sampling-a-Sphere-Object" class="headerlink" title="Sampling a Sphere Object"></a>Sampling a Sphere Object</h4><blockquote><p>When we sample a sphere’s solid angle uniformly from a point outside the sphere, we are really just sampling a cone uniformly (the cone is tangent to the sphere). Let’s say the code has <code>theta_max</code>. Recall from the <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#generatingrandomdirections">Generating Random Directions</a> chapter that to sample 𝜃θ we have:</p></blockquote><p>当我们从球外一点均匀地采样一个球的立体角时，我们实际上是在均匀地采样一个锥(锥与球相切)。假设代码有 <code>theta_max</code>。回想一下生成随机方向那一章，我们有:<br>$$<br>r_2 = \int_0^{\theta}{2\pi \cdot f(t) \cdot \sin(t)dt}<br>$$</p><blockquote><p>Here 𝑓(𝑡) is an as yet uncalculated constant 𝐶, so:</p></blockquote><p>$$<br>r_2 = \int_0^{\theta}{2\pi \cdot C \cdot \sin(t)dt}<br>$$</p><blockquote><p>Doing some algebra/calculus this yields:</p></blockquote><p>做一些代数/微积分可以得到:<br>$$<br>r_2 =2\pi \cdot C \cdot (1-\cos(\theta))<br>$$</p><blockquote><p>So</p></blockquote><p>$$<br>\cos(\theta) = 1 - \frac{r_2}{2\pi \cdot C}<br>$$</p><blockquote><p>We know that for $𝑟_2=1$ we should get $𝜃_𝑚𝑎𝑥$, so we can solve for 𝐶:</p></blockquote><p>我们知道对于 $r_2 = 1$ 我们应该得到 $\theta_{max}$，因此我们可以求解 $C$:<br>$$<br>\cos(\theta) = 1 + r_2 \cdot (\cos(\theta_{max}) - 1)<br>$$</p><blockquote><p>𝜙 we sample like before, so:</p></blockquote><p>$\phi$ 我们像以前一样采样，所以:<br>$$<br>z = \cos(\theta) = 1 + r_2 \cdot (\cos(\theta_{max}) - 1)<br>$$</p><p>$$<br>x = \cos(\phi)\cdot \sin(\theta)=\cos(2\pi \cdot r_1) \cdot \sqrt{1 - z^2}<br>$$</p><p>$$<br>y = \sin(\phi) \cdot \sin(\theta) = \sin(2\pi \cdot r_1) \cdot \sqrt{1 - z^2}<br>$$</p><blockquote><p>Now what is 𝜃𝑚𝑎𝑥?</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.08-sphere-enclosing-cone.jpg"></p><blockquote><p>We can see from the figure that sin(𝜃𝑚𝑎𝑥)=𝑅/𝑙𝑒𝑛𝑔𝑡ℎ(<strong>𝐜</strong>−<strong>𝐩</strong>). So:</p></blockquote><p>$$<br>\cos(\theta_{max}) = \sqrt{1 - \frac{R^2}{length^2(\mathbf c - \mathbf p)}}<br>$$</p><blockquote><p>We also need to evaluate the PDF of directions. For directions toward the sphere this is 1/𝑠𝑜𝑙𝑖𝑑_𝑎𝑛𝑔𝑙𝑒. What is the solid angle of the sphere? It has something to do with the 𝐶 above. It, by definition, is the area on the unit sphere, so the integral is</p></blockquote><p>我们还需要评估说明书的PDF。对于朝向球体的方向，这是 1/𝑠𝑜𝑙𝑖𝑑<em>𝑎𝑛𝑔𝑙𝑒。球的立体角是多少?它与上面的 C 有关。根据定义，它是单位球上的面积，所以积分是<br>$$<br>solid_angle = \int_0^{2\pi}\int_0^{\theta</em>{max}}\sin(\theta) = 2\pi \cdot (1 - \cos(\theta_{max}))<br>$$</p><blockquote><p>It’s good to check the math on all such calculations. I usually plug in the extreme cases (thank you for that concept, Mr. Horton — my high school physics teacher). For a zero radius sphere cos(𝜃𝑚𝑎𝑥)=0 and that works. For a sphere tangent at <strong>𝐩</strong>, cos(𝜃𝑚𝑎𝑥)=0, and 2𝜋 is the area of a hemisphere, so that works too.</p></blockquote><p>在所有这样的计算中检查数学是很好的。我通常会插入一些极端的例子(谢谢你的概念，霍顿先生，我的高中物理老师)。对于一个零半径的球体$\cos \theta_{max} = 0$，这是可行的。对于一个球面，正切在 $\mathbf{p}$， $\cos \theta_{max} = 0$，并且 $2\pi$ 是一个半球的面积，所以也可以这样做。</p><h4 id="Updating-the-Sphere-Code"><a href="#Updating-the-Sphere-Code" class="headerlink" title="Updating the Sphere Code"></a>Updating the Sphere Code</h4><blockquote><p>The sphere class needs the two PDF-related functions:</p></blockquote><p>球体类需要两个pdf相关的函数:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sphere::pdf_value</span><span class="params">(<span class="type">const</span> vec3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>{</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(o, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cos_theta_max = <span class="built_in">sqrt</span>(<span class="number">1</span> - radius*radius/(center-o).<span class="built_in">length_squared</span>());</span><br><span class="line">    <span class="keyword">auto</span> solid_angle = <span class="number">2</span>*pi*(<span class="number">1</span>-cos_theta_max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">1</span> / solid_angle;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">sphere::random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>{</span><br><span class="line">    vec3 direction = center - o;</span><br><span class="line">    <span class="keyword">auto</span> distance_squared = direction.<span class="built_in">length_squared</span>();</span><br><span class="line">    onb uvw;</span><br><span class="line">    uvw.<span class="built_in">build_from_w</span>(direction);</span><br><span class="line">    <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_to_sphere</span>(radius, distance_squared));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>With the utility function:</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_to_sphere</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> distance_squared)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="number">1</span> + r2*(<span class="built_in">sqrt</span>(<span class="number">1</span>-radius*radius/distance_squared) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="number">2</span>*pi*r1;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi)*<span class="built_in">sqrt</span>(<span class="number">1</span>-z*z);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi)*<span class="built_in">sqrt</span>(<span class="number">1</span>-z*z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can first try just sampling the sphere rather than the light:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main() {</span><br><span class="line">    ...</span><br><span class="line">    // World</span><br><span class="line"></span><br><span class="line">    auto world = cornell_box();</span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt; lights =</span></span><br><span class="line"><span class="addition">+   //  make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, shared_ptr&lt;material&gt;());</span></span><br><span class="line"><span class="addition">+       make_shared&lt;sphere&gt;(point3(190, 90, 190), 90, shared_ptr&lt;material&gt;());</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This yields a noisy box, but the caustic under the sphere is good. It took five times as long as sampling the light did for my code. This is probably because those rays that hit the glass are expensive!</p></blockquote><p>这产生了一个有噪声的盒子，但球下面的焦散是好的。它所花费的时间是我代码中灯光采样时间的5倍。这可能是因为撞击玻璃的光线代价很昂贵!</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.10-cornell-glass-sphere.jpg"></p><h4 id="Adding-PDF-Functions-to-Hittable-Lists"><a href="#Adding-PDF-Functions-to-Hittable-Lists" class="headerlink" title="Adding PDF Functions to Hittable Lists"></a>Adding PDF Functions to Hittable Lists</h4><blockquote><p>We should probably just sample both the sphere and the light. We can do that by creating a mixture density of their two densities. We could do that in the <code>ray_color()</code> function by passing a list of hittables in and building a mixture PDF, or we could add PDF functions to <code>hittable_list</code>. I think both tactics would work fine, but I will go with instrumenting <code>hittable_list</code>.</p></blockquote><p>我们应该同时对球体和光进行采样。我们可以通过创建它们两个密度的混合密度来做到这一点。我们可以通过在 <code>ray_color()</code> 函数中传递一个 hittables 列表并构建一个混合 PDF 来做到这一点，或者我们可以在 <code>hittable_list</code> 中添加PDF函数。我认为这两种策略都可以，但我还是选择 <code>hittable_list</code> 工具。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">hittable_list::pdf_value</span><span class="params">(<span class="type">const</span> vec3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> weight = <span class="number">1.0</span>/objects.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects)</span><br><span class="line">        sum += weight * object-&gt;<span class="built_in">pdf_value</span>(o, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">hittable_list::random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> int_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(objects.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> objects[<span class="built_in">random_int</span>(<span class="number">0</span>, int_size<span class="number">-1</span>)]-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We assemble a list to pass to <code>ray_color()</code> <code>from main()</code>:</p></blockquote><p>我们组装了一个列表，从 <code>main()</code> 传递给 <code>ray_color()</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list lights;</span><br><span class="line">lights.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="number">0</span>));</span><br><span class="line">lights.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">90</span>, <span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And we get a decent image with 1000 samples as before:</p></blockquote><p>和之前一样，我们用1000个样本得到了一个不错的图像:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light-20210816114843095.jpg"></p><h4 id="Handling-Surface-Acne"><a href="#Handling-Surface-Acne" class="headerlink" title="Handling Surface Acne"></a>Handling Surface Acne</h4><blockquote><p>An astute reader pointed out there are some black specks in the image above. All Monte Carlo Ray Tracers have this as a main loop:</p></blockquote><p>一位精明的读者指出，上图中有一些黑点。所有蒙特卡罗射线追踪器都有这样一个主循环:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pixel_color = <span class="built_in">average</span>(many many samples)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>If you find yourself getting some form of acne in the images, and this acne is white or black, so one “bad” sample seems to kill the whole pixel, that sample is probably a huge number or a <code>NaN</code> (Not A Number). This particular acne is probably a <code>NaN</code>. Mine seems to come up once in every 10–100 million rays or so.</p></blockquote><p>如果你发现自己在图像中出现了某种形式的痤疮，而且这个痤疮是白色或黑色的，所以一个“坏”样本似乎会毁掉整个像素，这个样本可能是一个巨大的数字或 <code>NaN</code>(不是一个数字)。这个特殊的痤疮可能是 <code>NaN</code>。我的光似乎每1000万到1亿次左右就会出现一次。</p><blockquote><p>So big decision: sweep this bug under the rug and check for <code>NaN</code>s, or just kill <code>NaN</code>s and hope this doesn’t come back to bite us later. I will always opt for the lazy strategy, especially when I know floating point is hard. First, how do we check for a <code>NaN</code>? The one thing I always remember for <code>NaN</code>s is that a <code>NaN</code> does not equal itself. Using this trick, we update the <code>write_color()</code> function to replace any NaN components with zero:</p></blockquote><p>所以这是一个重大的决定:把这个bug掩盖起来，检查 <code>NaN</code>，或者干脆消灭<code>NaN</code>，希望它以后不会再来咬我们。我总是选择惰性策略，特别是当我知道浮点数很难的时候。首先，我们如何检查 <code>NaN</code>?对于 <code>NaN</code>，我总是记得的一件事是 <code>NaN</code> 不等于它自己。使用这个技巧，我们更新 <code>write_color()</code> 函数，将任何 <code>NaN</code> 组件替换为0:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">void write_color(std::ostream &amp;out, vec3 pixel_color, int samples_per_pixel) {</span><br><span class="line">    auto r = pixel_color.x();</span><br><span class="line">    auto g = pixel_color.y();</span><br><span class="line">    auto b = pixel_color.z();</span><br><span class="line"></span><br><span class="line"><span class="addition">+   // Replace NaN components with zero. See explanation in Ray Tracing: The Rest of Your Life.</span></span><br><span class="line"><span class="addition">+   if (r != r) r = 0.0;</span></span><br><span class="line"><span class="addition">+   if (g != g) g = 0.0;</span></span><br><span class="line"><span class="addition">+   if (b != b) b = 0.0;</span></span><br><span class="line"></span><br><span class="line">    // Divide the color by the number of samples and gamma-correct for gamma=2.0.</span><br><span class="line">    auto scale = 1.0 / samples_per_pixel;</span><br><span class="line">    r = sqrt(scale * r);</span><br><span class="line">    g = sqrt(scale * g);</span><br><span class="line">    b = sqrt(scale * b);</span><br><span class="line"></span><br><span class="line">    // Write the translated [0,255] value of each color component.</span><br><span class="line">    out &lt;&lt; static_cast&lt;int&gt;(256 * clamp(r, 0.0, 0.999)) &lt;&lt; ' '</span><br><span class="line">        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(g, 0.0, 0.999)) &lt;&lt; ' '</span><br><span class="line">        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(b, 0.0, 0.999)) &lt;&lt; '\n';</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Happily, the black specks are gone:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.12-book3-final.jpg"></p><h3 id="你的余生"><a href="#你的余生" class="headerlink" title="你的余生"></a>你的余生</h3><blockquote><p>The purpose of this book was to show the details of dotting all the i’s of the math on one way of organizing a physically based renderer’s sampling approach. Now you can explore a lot of different potential paths.</p><p>If you want to explore Monte Carlo methods, look into bidirectional and path spaced approaches such as Metropolis. Your probability space won’t be over solid angle, but will instead be over path space, where a path is a multidimensional point in a high-dimensional space. Don’t let that scare you — if you can describe an object with an array of numbers, mathematicians call it a point in the space of all possible arrays of such points. That’s not just for show. Once you get a clean abstraction like that, your code can get clean too. Clean abstractions are what programming is all about!</p><p>If you want to do movie renderers, look at the papers out of studios and Solid Angle. They are surprisingly open about their craft.</p><p>If you want to do high-performance ray tracing, look first at papers from Intel and NVIDIA. Again, they are surprisingly open.</p><p>If you want to do hard-core physically based renderers, convert your renderer from RGB to spectral. I am a big fan of each ray having a random wavelength and almost all the RGBs in your program turning into floats. It sounds inefficient, but it isn’t!</p><p>Regardless of what direction you take, add a glossy BRDF model. There are many to choose from, and each has its advantages.</p><p>Have fun!</p><p><a target="_blank" rel="noopener" href="https://github.com/petershirley">Peter Shirley</a><br>Salt Lake City, March, 2016</p></blockquote><p>这本书的目的是展示如何用一种方法组织基于物理的渲染器的采样方法来点画所有的数学i的细节。现在你可以探索许多不同的潜在路径。</p><p>如果你想探索蒙特卡罗方法，看看双向和路径间隔的方法，如Metropolis。你的概率空间不会在立体角上，而是在路径空间上，路径是高维空间中的一个多维点。不要被这吓倒——如果你能用一组数字来描述一个对象，数学家们就称它为空间中所有这些点的可能数组中的一个点。这不是作秀。一旦你得到了这样一个清晰的抽象，你的代码也可以变得清晰。干净的抽象就是编程的全部!</p><p>如果你想做电影渲染，看看工作室和立体角的文件。他们对自己的手艺出奇地开放。</p><p>如果你想做高性能的光线追踪，首先看一下来自Intel和NVIDIA的论文。同样，它们出人意料地开放。</p><p>如果你想做硬核的基于物理的渲染器，把你的渲染器从RGB转换成光谱。我非常喜欢每个射线都有一个随机的波长，几乎所有的rgb在你的程序变成浮动。这听起来效率很低，但事实并非如此!</p><p>无论你选择什么方向，添加一个光滑的BRDF模型。有很多选择，而且每种都有其优点。</p><p>玩得开心!</p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/971404c0.html" rel="bookmark">Rendering Course by Wangningbei</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/1503bc5d.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 13</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/e82c1146.html" rel="prev" title="Pipeline and Shading"><i class="fa fa-chevron-left"></i> Pipeline and Shading</a></div><div class="post-nav-item"><a href="/archives/8069546e.html" rel="next" title="Stack">Stack <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">一个简单的蒙特卡罗程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Estimating-Pi"><span class="nav-number">3.1.</span> <span class="nav-text">Estimating Pi</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Showing-Convergence"><span class="nav-number">3.2.</span> <span class="nav-text">Showing Convergence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stratified-Samples-Jittering"><span class="nav-number">3.3.</span> <span class="nav-text">Stratified Samples (Jittering)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4MC%E9%9B%86%E6%88%90"><span class="nav-number">4.</span> <span class="nav-text">一维MC集成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integrating-x%C2%B2"><span class="nav-number">4.1.</span> <span class="nav-text">Integrating x²</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Density-Functions"><span class="nav-number">4.2.</span> <span class="nav-text">Density Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructing-a-PDF"><span class="nav-number">4.3.</span> <span class="nav-text">Constructing a PDF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Importance-Sampling"><span class="nav-number">4.4.</span> <span class="nav-text">Importance Sampling</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%90%91%E7%90%83%E4%B8%8A%E7%9A%84MC%E9%9B%86%E6%88%90"><span class="nav-number">5.</span> <span class="nav-text">方向球上的MC集成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%89%E6%95%A3%E5%B0%84"><span class="nav-number">6.</span> <span class="nav-text">光散射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Albedo"><span class="nav-number">6.1.</span> <span class="nav-text">Albedo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scattering"><span class="nav-number">6.2.</span> <span class="nav-text">Scattering</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Scattering-PDF"><span class="nav-number">6.3.</span> <span class="nav-text">The Scattering PDF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E9%87%87%E6%A0%B7%E6%9D%90%E8%B4%A8"><span class="nav-number">7.</span> <span class="nav-text">重要采样材质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Returning-to-the-Cornell-Box"><span class="nav-number">7.1.</span> <span class="nav-text">Returning to the Cornell Box</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Random-Hemisphere-Sampling"><span class="nav-number">7.2.</span> <span class="nav-text">Random Hemisphere Sampling</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91"><span class="nav-number">8.</span> <span class="nav-text">生成随机方向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Random-Directions-Relative-to-the-Z-Axis"><span class="nav-number">8.1.</span> <span class="nav-text">Random Directions Relative to the Z Axis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Uniform-Sampling-a-Hemisphere"><span class="nav-number">8.2.</span> <span class="nav-text">Uniform Sampling a Hemisphere</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA"><span class="nav-number">9.</span> <span class="nav-text">标准正交基</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Relative-Coordinates"><span class="nav-number">9.1.</span> <span class="nav-text">Relative Coordinates</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generating-an-Orthonormal-Basis"><span class="nav-number">9.2.</span> <span class="nav-text">Generating an Orthonormal Basis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-ONB-Class"><span class="nav-number">9.3.</span> <span class="nav-text">The ONB Class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7"><span class="nav-number">10.</span> <span class="nav-text">直接光源采样</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Getting-the-PDF-of-a-Light"><span class="nav-number">10.1.</span> <span class="nav-text">Getting the PDF of a Light</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Light-Sampling"><span class="nav-number">10.2.</span> <span class="nav-text">Light Sampling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Switching-to-Unidirectional-Light"><span class="nav-number">10.3.</span> <span class="nav-text">Switching to Unidirectional Light</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%AF%86%E5%BA%A6"><span class="nav-number">11.</span> <span class="nav-text">混合密度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#An-Average-of-Lighting-and-Reflection"><span class="nav-number">11.1.</span> <span class="nav-text">An Average of Lighting and Reflection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sampling-Directions-towards-a-Hittable"><span class="nav-number">11.2.</span> <span class="nav-text">Sampling Directions towards a Hittable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Mixture-PDF-Class"><span class="nav-number">11.3.</span> <span class="nav-text">The Mixture PDF Class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%9E%B6%E6%9E%84%E5%86%B3%E7%AD%96"><span class="nav-number">12.</span> <span class="nav-text">一些架构决策</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96PDF%E6%9E%B6%E6%9E%84"><span class="nav-number">13.</span> <span class="nav-text">优化PDF架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Diffuse-Versus-Specular"><span class="nav-number">13.1.</span> <span class="nav-text">Diffuse Versus Specular</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Handling-Specular"><span class="nav-number">13.2.</span> <span class="nav-text">Handling Specular</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sampling-a-Sphere-Object"><span class="nav-number">13.3.</span> <span class="nav-text">Sampling a Sphere Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Updating-the-Sphere-Code"><span class="nav-number">13.4.</span> <span class="nav-text">Updating the Sphere Code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adding-PDF-Functions-to-Hittable-Lists"><span class="nav-number">13.5.</span> <span class="nav-text">Adding PDF Functions to Hittable Lists</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Handling-Surface-Acne"><span class="nav-number">13.6.</span> <span class="nav-text">Handling Surface Acne</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E7%9A%84%E4%BD%99%E7%94%9F"><span class="nav-number">14.</span> <span class="nav-text">你的余生</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">279</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.1m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
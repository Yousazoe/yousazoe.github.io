<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="å¼•è¨€ã€ŠRay Tracing: The Rest of Your Lifeã€‹ï¼ˆã€Šç”¨ä½™ç”Ÿç ”ç©¶å…‰çº¿è¿½è¸ªã€‹ï¼‰ï¼Œ ç”± Peter Shirleyï¼ˆå°±æ˜¯é‚£æœ¬å›¾å½¢å­¦è™ä¹¦çš„ä½œè€…ï¼‰æ‰€ç¼–å†™çš„çš„è½¯æ¸²å…‰è¿½ä¸‰éƒ¨æ›²ç¬¬ä¸‰æœ¬ã€‚åœ¨æœ¬å·ä¸­ï¼Œæˆ‘å‡è®¾ä½ å°†è¿½æ±‚ä¸å…‰çº¿è¿½è¸ªç›¸å…³çš„èŒä¸šï¼Œæˆ‘ä»¬å°†æ·±å…¥åˆ›å»ºä¸€ä¸ªéå¸¸ä¸¥è‚ƒçš„å…‰çº¿è¿½è¸ªå™¨çš„æ•°å­¦ã€‚å½“ä½ å®Œæˆçš„æ—¶å€™ï¼Œä½ åº”è¯¥å‡†å¤‡å¥½å¼€å§‹ä¸ç”µå½±å’Œäº§å“è®¾è®¡è¡Œä¸šçš„è®¸å¤šä¸¥è‚ƒçš„å•†ä¸šå°„çº¿è¿½è¸ªå™¨æ‰“äº¤é“ã€‚"><meta property="og:type" content="article"><meta property="og:title" content="Ray Tracing the Rest of Your Life"><meta property="og:url" content="https://yousazoe.top/archives/e2b2b0f4.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="å¼•è¨€ã€ŠRay Tracing: The Rest of Your Lifeã€‹ï¼ˆã€Šç”¨ä½™ç”Ÿç ”ç©¶å…‰çº¿è¿½è¸ªã€‹ï¼‰ï¼Œ ç”± Peter Shirleyï¼ˆå°±æ˜¯é‚£æœ¬å›¾å½¢å­¦è™ä¹¦çš„ä½œè€…ï¼‰æ‰€ç¼–å†™çš„çš„è½¯æ¸²å…‰è¿½ä¸‰éƒ¨æ›²ç¬¬ä¸‰æœ¬ã€‚åœ¨æœ¬å·ä¸­ï¼Œæˆ‘å‡è®¾ä½ å°†è¿½æ±‚ä¸å…‰çº¿è¿½è¸ªç›¸å…³çš„èŒä¸šï¼Œæˆ‘ä»¬å°†æ·±å…¥åˆ›å»ºä¸€ä¸ªéå¸¸ä¸¥è‚ƒçš„å…‰çº¿è¿½è¸ªå™¨çš„æ•°å­¦ã€‚å½“ä½ å®Œæˆçš„æ—¶å€™ï¼Œä½ åº”è¯¥å‡†å¤‡å¥½å¼€å§‹ä¸ç”µå½±å’Œäº§å“è®¾è®¡è¡Œä¸šçš„è®¸å¤šä¸¥è‚ƒçš„å•†ä¸šå°„çº¿è¿½è¸ªå™¨æ‰“äº¤é“ã€‚"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.01-circ-square.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.02-jitter.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.03-histogram.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.04-linear-pdf.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.05-solid-angle.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.01-cornell-refactor1.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.02-cornell-refactor2.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.06-rand-pts-sphere.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.03-cornell-ortho.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.07-shape-onto-pdf.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.04-cornell-sample-light.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.05-cornell-lightdown.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.06-cornell-cos-pdf.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.07-hittable-light.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.08-cosine-and-light.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.09-arbitrary-pdf.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.08-sphere-enclosing-cone.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.10-cornell-glass-sphere.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light-20210816114843095.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.12-book3-final.jpg"><meta property="article:published_time" content="2021-08-14T02:16:55.000Z"><meta property="article:modified_time" content="2022-10-02T15:06:32.392Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light.jpg"><link rel="canonical" href="https://yousazoe.top/archives/e2b2b0f4.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Ray Tracing the Rest of Your Life | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/e2b2b0f4.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Ray Tracing the Rest of Your Life</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-08-14 10:16:55" itemprop="dateCreated datePublished" datetime="2021-08-14T10:16:55+08:00">2021-08-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">å…‰çº¿è¿½è¸ª (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>69k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>2:06</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light.jpg"></p><h3 id="å¼•è¨€"><a href="#å¼•è¨€" class="headerlink" title="å¼•è¨€"></a>å¼•è¨€</h3><p><a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html">ã€ŠRay Tracing: The Rest of Your Lifeã€‹</a>ï¼ˆã€Šç”¨ä½™ç”Ÿç ”ç©¶å…‰çº¿è¿½è¸ªã€‹ï¼‰ï¼Œ ç”± Peter Shirleyï¼ˆå°±æ˜¯é‚£æœ¬å›¾å½¢å­¦è™ä¹¦çš„ä½œè€…ï¼‰æ‰€ç¼–å†™çš„çš„è½¯æ¸²å…‰è¿½ä¸‰éƒ¨æ›²ç¬¬ä¸‰æœ¬ã€‚åœ¨æœ¬å·ä¸­ï¼Œæˆ‘å‡è®¾ä½ å°†è¿½æ±‚ä¸å…‰çº¿è¿½è¸ªç›¸å…³çš„èŒä¸šï¼Œæˆ‘ä»¬å°†æ·±å…¥åˆ›å»ºä¸€ä¸ªéå¸¸ä¸¥è‚ƒçš„å…‰çº¿è¿½è¸ªå™¨çš„æ•°å­¦ã€‚å½“ä½ å®Œæˆçš„æ—¶å€™ï¼Œä½ åº”è¯¥å‡†å¤‡å¥½å¼€å§‹ä¸ç”µå½±å’Œäº§å“è®¾è®¡è¡Œä¸šçš„è®¸å¤šä¸¥è‚ƒçš„å•†ä¸šå°„çº¿è¿½è¸ªå™¨æ‰“äº¤é“ã€‚</p><span id="more"></span><blockquote><p>åŸæ–‡æºè‡ª <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html">ã€ŠRay Tracing: The Rest of Your Lifeã€‹</a></p></blockquote><h3 id="æ¦‚è¿°"><a href="#æ¦‚è¿°" class="headerlink" title="æ¦‚è¿°"></a>æ¦‚è¿°</h3><blockquote><p>In <em>Ray Tracing in One Weekend</em> and <em>Ray Tracing: the Next Week</em>, you built a â€œrealâ€ ray tracer.</p></blockquote><p>åœ¨Ray Tracing In One Weekendå’ŒRay Tracing: the Next Weekä¸­ï¼Œä½ æ„å»ºäº†ä¸€ä¸ªâ€œçœŸæ­£çš„â€Ray Tracingã€‚</p><blockquote><p>In this volume, I assume you will be pursuing a career related to ray tracing, and we will dive into the math of creating a very serious ray tracer. When you are done you should be ready to start messing with the many serious commercial ray tracers underlying the movie and product design industries. There are many many things I do not cover in this short volume; I dive into only one of many ways to write a Monte Carlo rendering program. I donâ€™t do shadow rays (instead I make rays more likely to go toward lights), bidirectional methods, Metropolis methods, or photon mapping. What I do is speak in the language of the field that studies those methods. I think of this book as a deep exposure that can be your first of many, and it will equip you with some of the concepts, math, and terms you will need to study the others.</p></blockquote><p>åœ¨æœ¬å·ä¸­ï¼Œæˆ‘å‡è®¾ä½ å°†è¿½æ±‚ä¸å…‰çº¿è¿½è¸ªç›¸å…³çš„èŒä¸šï¼Œæˆ‘ä»¬å°†æ·±å…¥åˆ›å»ºä¸€ä¸ªéå¸¸ä¸¥è‚ƒçš„å…‰çº¿è¿½è¸ªå™¨çš„æ•°å­¦ã€‚å½“ä½ å®Œæˆçš„æ—¶å€™ï¼Œä½ åº”è¯¥å‡†å¤‡å¥½å¼€å§‹ä¸ç”µå½±å’Œäº§å“è®¾è®¡è¡Œä¸šçš„è®¸å¤šä¸¥è‚ƒçš„å•†ä¸šå°„çº¿è¿½è¸ªå™¨æ‰“äº¤é“ã€‚åœ¨è¿™ä¸€å°å·ä¹¦ä¸­ï¼Œæœ‰è®¸å¤šäº‹æƒ…æˆ‘æ²¡æœ‰æ¶‰åŠï¼›æˆ‘åªç ”ç©¶äº†è®¸å¤šç¼–å†™è’™ç‰¹å¡ç½—æ¸²æŸ“ç¨‹åºçš„æ–¹æ³•ä¸­çš„ä¸€ç§ã€‚æˆ‘ä¸åšé˜´å½±å°„çº¿(ç›¸åï¼Œæˆ‘è®©å°„çº¿æ›´æœ‰å¯èƒ½æœå‘å…‰)ï¼ŒåŒå‘æ–¹æ³•ï¼Œå¤§éƒ½å¸‚æ–¹æ³•ï¼Œæˆ–å…‰å­æ˜ å°„ã€‚æˆ‘æ‰€åšçš„å°±æ˜¯ç”¨ç ”ç©¶è¿™äº›æ–¹æ³•çš„é¢†åŸŸçš„è¯­è¨€è¯´è¯ã€‚æˆ‘è®¤ä¸ºè¿™æœ¬ä¹¦æ˜¯ä½ çš„ç¬¬ä¸€æ¬¡æ·±å…¥æ¥è§¦ï¼Œå®ƒä¼šè£…å¤‡ä½ ä¸€äº›æ¦‚å¿µï¼Œæ•°å­¦å’Œæœ¯è¯­ï¼Œä½ å°†éœ€è¦å­¦ä¹ å…¶ä»–ã€‚</p><blockquote><p>As before, <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com/</a> will have further readings and references.</p><p>Thanks to everyone who lent a hand on this project. You can find them in the <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#acknowledgments">acknowledgments</a> section at the end of this book.</p></blockquote><p>å’Œä¹‹å‰ä¸€æ ·ï¼Œ<a href="https://link.zhihu.com/?target=https://in1weekend.blogspot.com/%E5%B0%86%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99%E5%92%8C%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E3%80%82">https://in1weekend.blogspot.com/å°†æä¾›æ›´å¤šçš„é˜…è¯»ææ–™å’Œå‚è€ƒèµ„æ–™ã€‚</a></p><p>æ„Ÿè°¢æ¯ä¸€ä¸ªä¸ºè¿™ä¸ªé¡¹ç›®æä¾›å¸®åŠ©çš„äººã€‚ä½ å¯ä»¥åœ¨æœ¬ä¹¦æœ«å°¾çš„è‡´è°¢éƒ¨åˆ†æ‰¾åˆ°å®ƒä»¬ã€‚</p><h3 id="ä¸€ä¸ªç®€å•çš„è’™ç‰¹å¡ç½—ç¨‹åº"><a href="#ä¸€ä¸ªç®€å•çš„è’™ç‰¹å¡ç½—ç¨‹åº" class="headerlink" title="ä¸€ä¸ªç®€å•çš„è’™ç‰¹å¡ç½—ç¨‹åº"></a>ä¸€ä¸ªç®€å•çš„è’™ç‰¹å¡ç½—ç¨‹åº</h3><blockquote><p>Letâ€™s start with one of the simplest Monte Carlo (MC) programs. MC programs give a statistical estimate of an answer, and this estimate gets more and more accurate the longer you run it. This basic characteristic of simple programs producing noisy but ever-better answers is what MC is all about, and it is especially good for applications like graphics where great accuracy is not needed.</p></blockquote><p>è®©æˆ‘ä»¬ä»ä¸€ä¸ªæœ€ç®€å•çš„è’™ç‰¹å¡æ´›(Monte Carlo, MC)ç¨‹åºå¼€å§‹ã€‚MCç¨‹åºå¯¹ä¸€ä¸ªç­”æ¡ˆç»™å‡ºä¸€ä¸ªç»Ÿè®¡ä¼°è®¡ï¼Œå¹¶ä¸”è¿™ä¸ªä¼°è®¡ä¼šéšç€ä½ è¿è¡Œæ—¶é—´çš„å»¶é•¿è€Œå˜å¾—è¶Šæ¥è¶Šå‡†ç¡®ã€‚è¿™ç§ç®€å•ç¨‹åºäº§ç”Ÿå˜ˆæ‚ä½†æ›´å¥½çš„ç­”æ¡ˆçš„åŸºæœ¬ç‰¹å¾å°±æ˜¯MCçš„å…¨éƒ¨ï¼Œå®ƒå°¤å…¶é€‚ç”¨äºä¸éœ€è¦å¾ˆé«˜ç²¾ç¡®åº¦çš„å›¾å½¢ç­‰åº”ç”¨ç¨‹åºã€‚</p><h4 id="Estimating-Pi"><a href="#Estimating-Pi" class="headerlink" title="Estimating Pi"></a>Estimating Pi</h4><blockquote><p>As an example, letâ€™s estimate ğœ‹. There are many ways to do this, with the Buffon Needle problem being a classic case study. Weâ€™ll do a variation inspired by that. Suppose you have a circle inscribed inside a square:</p></blockquote><p>ä½œä¸ºä¸€ä¸ªä¾‹å­ï¼Œè®©æˆ‘ä»¬ä¼°ç®— piã€‚æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œå¸ƒä¸°é’ˆé—®é¢˜å°±æ˜¯ä¸€ä¸ªç»å…¸çš„æ¡ˆä¾‹ç ”ç©¶ã€‚æˆ‘ä»¬ä¼šå—å¯å‘åšä¸€ä¸ªå˜å¥ã€‚å‡è®¾åœ¨ä¸€ä¸ªæ­£æ–¹å½¢ä¸­æœ‰ä¸€ä¸ªå†…åœ†:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.01-circ-square.jpg"></p><blockquote><p>Now, suppose you pick random points inside the square. The fraction of those random points that end up inside the circle should be proportional to the area of the circle. The exact fraction should in fact be the ratio of the circle area to the square area. Fraction:</p></blockquote><p>ç°åœ¨ï¼Œå‡è®¾ä½ åœ¨æ­£æ–¹å½¢ä¸­éšæœºé€‰å–ç‚¹ã€‚è¿™äº›éšæœºç‚¹åœ¨åœ†å†…çš„æ¯”ä¾‹åº”è¯¥ä¸åœ†çš„é¢ç§¯æˆæ­£æ¯”ã€‚ç¡®åˆ‡çš„åˆ†æ•°å®é™…ä¸Šåº”è¯¥æ˜¯åœ†é¢ç§¯å’Œå¹³æ–¹é¢ç§¯çš„æ¯”å€¼ã€‚åˆ†æ•°:</p><p>$\frac{\pi r^2}{(2r)^2} = \frac{\pi}{4}$</p><blockquote><p>Since the ğ‘Ÿ cancels out, we can pick whatever is computationally convenient. Letâ€™s go with ğ‘Ÿ=1, centered at the origin:</p></blockquote><p>å› ä¸º r æ¶ˆæ‰äº†ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©è®¡ç®—ä¸Šæ–¹ä¾¿çš„å€¼ã€‚è®©æˆ‘ä»¬ä½¿ç”¨ r=1 ï¼Œåœ¨åŸç‚¹å±…ä¸­:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimatePI</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> inside_circle = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> runs = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    runs++;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>)</span><br><span class="line">        inside_circle++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runs % <span class="number">100000</span> == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Estimate of Pi = "</span></span><br><span class="line">        &lt;&lt; <span class="number">4</span> * <span class="built_in">double</span>(inside_circle) / runs</span><br><span class="line">        &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The answer of ğœ‹Ï€ found will vary from computer to computer based on the initial random seed. On my computer, this gives me the answer <code>Estimate of Pi = 3.0880000000</code></p></blockquote><p>æ‰€æ‰¾åˆ°çš„ <em>Ï€</em> çš„ç­”æ¡ˆå°†æ ¹æ®åˆå§‹çš„éšæœºç§å­è€Œå› è®¡ç®—æœºè€Œå¼‚ã€‚åœ¨æˆ‘çš„ç”µè„‘ä¸Šï¼Œæˆ‘çš„ç­”æ¡ˆä¼°è®¡ <code>Estimate of Pi = 3.0880000000</code></p><h4 id="Showing-Convergence"><a href="#Showing-Convergence" class="headerlink" title="Showing Convergence"></a>Showing Convergence</h4><blockquote><p>If we change the program to run forever and just print out a running estimate:</p></blockquote><p>å¦‚æœæˆ‘ä»¬å°†ç¨‹åºæ›´æ”¹ä¸ºæ°¸è¿œè¿è¡Œï¼Œå¹¶æ‰“å°å‡ºä¸€ä¸ªè¿è¡Œä¼°è®¡:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void estimatePI() {</span><br><span class="line">    int inside_circle = 0;</span><br><span class="line">    int runs = 0;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   while (true) {</span></span><br><span class="line">        runs++;</span><br><span class="line">        auto x = random_double(-1, 1);</span><br><span class="line">        auto y = random_double(-1, 1);</span><br><span class="line"></span><br><span class="line">        if (x * x + y * y &lt; 1)</span><br><span class="line">            inside_circle++;</span><br><span class="line"></span><br><span class="line">        if (runs % 100000 == 0)</span><br><span class="line">            std::cout &lt;&lt; "Estimate of Pi = "</span><br><span class="line">                      &lt;&lt; 4 * double(inside_circle) / runs</span><br><span class="line">                      &lt;&lt; '\n';</span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Stratified-Samples-Jittering"><a href="#Stratified-Samples-Jittering" class="headerlink" title="Stratified Samples (Jittering)"></a>Stratified Samples (Jittering)</h4><blockquote><p>We get very quickly near ğœ‹, and then more slowly zero in on it. This is an example of the <em>Law of Diminishing Returns</em>, where each sample helps less than the last. This is the worst part of MC. We can mitigate this diminishing return by <em>stratifying</em> the samples (often called <em>jittering</em>), where instead of taking random samples, we take a grid and take one sample within each:</p></blockquote><p>æˆ‘ä»¬å¾ˆå¿«åœ°æ¥è¿‘ $\pi$ï¼Œç„¶åæ…¢æ…¢åœ°ç„å‡†å®ƒã€‚è¿™æ˜¯æ”¶ç›Šé€’å‡å®šå¾‹çš„ä¸€ä¸ªä¾‹å­ï¼Œæ¯ä¸ªæ ·æœ¬çš„å¸®åŠ©éƒ½å°äºå‰ä¸€ä¸ªæ ·æœ¬ã€‚è¿™æ˜¯MCä¸­æœ€ç³Ÿç³•çš„éƒ¨åˆ†ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ†å±‚æ ·æœ¬(é€šå¸¸ç§°ä¸ºæŠ–åŠ¨)æ¥ç¼“è§£è¿™ç§é€’å‡çš„æ”¶ç›Šï¼Œè¿™é‡Œæˆ‘ä»¬ä¸æ˜¯éšæœºæŠ½å–æ ·æœ¬ï¼Œè€Œæ˜¯å–ä¸€ä¸ªç½‘æ ¼ï¼Œåœ¨æ¯ä¸ªç½‘æ ¼ä¸­æŠ½å–ä¸€ä¸ªæ ·æœ¬:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.02-jitter.jpg"></p><blockquote><p>This changes the sample generation, but we need to know how many samples we are taking in advance because we need to know the grid. Letâ€™s take a hundred million and try it both ways:</p></blockquote><p>è¿™æ”¹å˜äº†æ ·æœ¬ç”Ÿæˆï¼Œä½†æˆ‘ä»¬éœ€è¦æå‰çŸ¥é“æˆ‘ä»¬å–äº†å¤šå°‘æ ·æœ¬ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦çŸ¥é“ç½‘æ ¼ã€‚è®©æˆ‘ä»¬ä»¥1äº¿ä¸ºä¾‹ï¼Œä¸¤ç§æ–¹æ³•éƒ½è¯•ä¸€ä¸‹:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimatePI</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> inside_circle = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> inside_circle_stratified = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sqrt_N = <span class="number">10000</span>;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sqrt_N; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sqrt_N; ++j) {</span><br><span class="line">            <span class="keyword">auto</span> x = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">auto</span> y = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>)</span><br><span class="line">                inside_circle++;</span><br><span class="line"></span><br><span class="line">            x = <span class="number">2</span> * ((i + <span class="built_in">random_double</span>()) / sqrt_N) - <span class="number">1</span>;</span><br><span class="line">            y = <span class="number">2</span> * ((j + <span class="built_in">random_double</span>()) / sqrt_N) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>)</span><br><span class="line">                inside_circle_stratified++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> N = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(sqrt_N) * sqrt_N;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout</span><br><span class="line">            &lt;&lt; <span class="string">"Regular    Estimate of Pi = "</span></span><br><span class="line">            &lt;&lt; <span class="number">4</span>*<span class="built_in">double</span>(inside_circle) / (sqrt_N*sqrt_N) &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"Stratified Estimate of Pi = "</span></span><br><span class="line">            &lt;&lt; <span class="number">4</span>*<span class="built_in">double</span>(inside_circle_stratified) / (sqrt_N*sqrt_N) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>On my computer, I get:</p></blockquote><p>åœ¨æˆ‘çš„ç”µè„‘ä¸Šï¼Œæˆ‘å¾—åˆ°äº†ï¼š</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Regular    Estimate of Pi = 3.14151480</span><br><span class="line">Stratified Estimate of Pi = 3.14158948</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Interestingly, the stratified method is not only better, it converges with a better asymptotic rate! Unfortunately, this advantage decreases with the dimension of the problem (so for example, with the 3D sphere volume version the gap would be less). This is called the <em>Curse of Dimensionality</em>. We are going to be very high dimensional (each reflection adds two dimensions), so I wonâ€™t stratify in this book, but if you are ever doing single-reflection or shadowing or some strictly 2D problem, you definitely want to stratify.</p></blockquote><p>æœ‰è¶£çš„æ˜¯ï¼Œåˆ†å±‚æ–¹æ³•ä¸ä»…æ›´å¥½ï¼Œè€Œä¸”å®ƒå…·æœ‰æ›´å¥½çš„æ¸è¿‘æ”¶æ•›ç‡ï¼ä¸å¹¸çš„æ˜¯ï¼Œè¿™ç§ä¼˜åŠ¿ä¼šéšç€é—®é¢˜çš„å¤§å°è€Œå‡å°(ä¾‹å¦‚ï¼Œåœ¨3Dçƒä½“ä½“ç§¯ç‰ˆæœ¬ä¸­ï¼Œå·®è·ä¼šæ›´å°)ã€‚è¿™è¢«ç§°ä¸ºç»´åº¦è¯…å’’ã€‚æˆ‘ä»¬å°†ä¼šæ˜¯éå¸¸é«˜ç»´çš„(æ¯ä¸ªåå°„éƒ½å¢åŠ ä¸¤ä¸ªç»´åº¦)ï¼Œæ‰€ä»¥æˆ‘ä¸ä¼šåœ¨è¿™æœ¬ä¹¦ä¸­åˆ†å±‚ï¼Œä½†å¦‚æœä½ åšè¿‡å•åå°„æˆ–é˜´å½±æˆ–ä¸€äº›ä¸¥æ ¼çš„äºŒç»´é—®é¢˜ï¼Œä½ è‚¯å®šæƒ³åˆ†å±‚ã€‚</p><h3 id="ä¸€ç»´MCé›†æˆ"><a href="#ä¸€ç»´MCé›†æˆ" class="headerlink" title="ä¸€ç»´MCé›†æˆ"></a>ä¸€ç»´MCé›†æˆ</h3><blockquote><p>Integration is all about computing areas and volumes, so we could have framed chapter <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#toc2">2</a> in an integral form if we wanted to make it maximally confusing. But sometimes integration is the most natural and clean way to formulate things. Rendering is often such a problem.</p></blockquote><p>ç§¯åˆ†æ˜¯å…³äºè®¡ç®—é¢ç§¯å’Œä½“ç§¯çš„ï¼Œæˆ‘ä»¬æƒ³è®©å®ƒæ›´æ··ä¹±çš„è¯ï¼Œå¯ä»¥æŠŠç¬¬äºŒç« æ¡†å®šä¸ºä¸€ä¸ªç§¯åˆ†å½¢å¼ã€‚ä½†æœ‰æ—¶å€™ï¼Œç§¯åˆ†æ˜¯æœ€è‡ªç„¶ã€æœ€å¹²å‡€çš„è¡¨è¿°æ–¹å¼ã€‚æ¸²æŸ“é€šå¸¸å°±æ˜¯è¿™æ ·ä¸€ä¸ªé—®é¢˜ã€‚</p><h4 id="Integrating-xÂ²"><a href="#Integrating-xÂ²" class="headerlink" title="Integrating xÂ²"></a>Integrating xÂ²</h4><blockquote><p>Letâ€™s look at a classic integral:</p></blockquote><p>æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªç»å…¸çš„ç§¯åˆ†:</p><p>$I = \int^2_0{x^2dx}$</p><blockquote><p>In computer sciency notation, we might write this as:</p></blockquote><p>åœ¨è®¡ç®—æœºç§‘å­¦ç¬¦å·ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™:</p><p>$I = area{(x^2, 0, 2)}$</p><blockquote><p>We could also write it as:</p></blockquote><p>æˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™:</p><p>$I = 2 \cdot average(x^2, 0, 2)$</p><blockquote><p>This suggests a MC approach:</p></blockquote><p>è¿™å°±æå‡ºäº†MCæ–¹æ³•:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        <span class="keyword">auto</span> x = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        sum += x * x;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"I = "</span> &lt;&lt; <span class="number">2</span> * sum / N &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This, as expected, produces approximately the exact answer we get with algebra, ğ¼=8/3. We could also do it for functions that we canâ€™t analytically integrate like $\log(\sin(ğ‘¥))$. In graphics, we often have functions we can evaluate but canâ€™t write down explicitly, or functions we can only probabilistically evaluate. That is in fact what the ray tracing <code>ray_color()</code> function of the last two books is â€” we donâ€™t know what color is seen in every direction, but we can statistically estimate it in any given dimension.</p></blockquote><p>æ­£å¦‚é¢„æœŸçš„é‚£æ ·ï¼Œè¿™äº§ç”Ÿäº†æˆ‘ä»¬ç”¨ä»£æ•°å¾—åˆ°çš„å¤§è‡´å‡†ç¡®ç­”æ¡ˆï¼ŒI = 8/3ã€‚å¯¹äºä¸èƒ½è§£æç§¯åˆ†çš„å‡½æ•°ä¹Ÿå¯ä»¥è¿™æ ·åšï¼Œæ¯”å¦‚$\log(\sin(x))$ã€‚åœ¨å›¾å½¢å­¦ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸æœ‰å¯ä»¥æ±‚å€¼ä½†ä¸èƒ½æ˜¾å¼åœ°å†™å‡ºæ¥çš„å‡½æ•°ï¼Œæˆ–è€…åªèƒ½æŒ‰æ¦‚ç‡æ±‚å€¼çš„å‡½æ•°ã€‚è¿™å®é™…ä¸Šæ˜¯å°„çº¿è¿½è¸ªçš„ <code>ray_color()</code> å‡½æ•°çš„æœ€åä¸¤æœ¬ä¹¦-æˆ‘ä»¬ä¸çŸ¥é“åœ¨æ¯ä¸ªæ–¹å‘ä¸Šçœ‹åˆ°ä»€ä¹ˆé¢œè‰²ï¼Œä½†æˆ‘ä»¬å¯ä»¥ç»Ÿè®¡ä¼°è®¡å®ƒåœ¨ä»»ä½•ç»™å®šçš„ç»´åº¦ã€‚</p><blockquote><p>One problem with the random program we wrote in the first two books is that small light sources create too much noise. This is because our uniform sampling doesnâ€™t sample these light sources often enough. Light sources are only sampled if a ray scatters toward them, but this can be unlikely for a small light, or a light that is far away. We could lessen this problem if we sent more random samples toward this light, but this will cause the scene to be inaccurately bright. We can remove this inaccuracy by downweighting these samples to adjust for the over-sampling. How we do that adjustment? To do that, we will need the concept of a <em>probability density function</em>.</p></blockquote><p>æˆ‘ä»¬åœ¨å‰ä¸¤æœ¬ä¹¦ä¸­æ‰€å†™çš„éšæœºç¨‹åºçš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œå°çš„å…‰æºä¼šäº§ç”Ÿå¤ªå¤šçš„å™ªéŸ³ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„å‡åŒ€é‡‡æ ·å¹¶æ²¡æœ‰å¯¹è¿™äº›å…‰æºè¿›è¡Œè¶³å¤Ÿé¢‘ç¹çš„é‡‡æ ·ã€‚åªæœ‰å½“å…‰çº¿å‘å…‰æºæ•£å°„æ—¶ï¼Œæ‰ä¼šå¯¹å…‰æºè¿›è¡Œé‡‡æ ·ï¼Œä½†å¯¹äºè¾ƒå°çš„å…‰æˆ–è·ç¦»è¾ƒè¿œçš„å…‰æ¥è¯´ï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ã€‚æˆ‘ä»¬å¯ä»¥å‡å°‘è¿™ä¸ªé—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬å‘è¿™ä¸ªå…‰å‘é€æ›´å¤šçš„éšæœºæ ·æœ¬ï¼Œä½†è¿™ä¼šå¯¼è‡´åœºæ™¯çš„äº®åº¦ä¸å‡†ç¡®ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡é™ä½è¿™äº›æ ·æœ¬çš„æƒé‡æ¥è°ƒæ•´è¿‡åº¦é‡‡æ ·æ¥æ¶ˆé™¤è¿™ç§ä¸å‡†ç¡®æ€§ã€‚æˆ‘ä»¬å¦‚ä½•è¿›è¡Œè°ƒæ•´?è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦æ¦‚ç‡å¯†åº¦å‡½æ•°çš„æ¦‚å¿µã€‚</p><h4 id="Density-Functions"><a href="#Density-Functions" class="headerlink" title="Density Functions"></a>Density Functions</h4><blockquote><p>First, what is a <em>density function</em>? Itâ€™s just a continuous form of a histogram. Hereâ€™s an example from the histogram Wikipedia page:</p></blockquote><p>é¦–å…ˆï¼Œä»€ä¹ˆæ˜¯å¯†åº¦å‡½æ•°?å®ƒæ˜¯ç›´æ–¹å›¾çš„è¿ç»­å½¢å¼ã€‚ä»¥ä¸‹æ˜¯æ¥è‡ªç»´åŸºç™¾ç§‘ç›´æ–¹å›¾é¡µé¢çš„ä¸€ä¸ªä¾‹å­:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.03-histogram.jpg"></p><blockquote><p>If we added data for more trees, the histogram would get taller. If we divided the data into more bins, it would get shorter. A discrete density function differs from a histogram in that it normalizes the frequency y-axis to a fraction or percentage (just a fraction times 100). A continuous histogram, where we take the number of bins to infinity, canâ€™t be a fraction because the height of all the bins would drop to zero. A density function is one where we take the bins and adjust them so they donâ€™t get shorter as we add more bins. For the case of the tree histogram above we might try:</p></blockquote><p>å¦‚æœæˆ‘ä»¬ä¸ºæ›´å¤šçš„æ ‘æ·»åŠ æ•°æ®ï¼Œç›´æ–¹å›¾ä¼šå˜å¾—æ›´é«˜ã€‚å¦‚æœæˆ‘ä»¬æŠŠæ•°æ®åˆ†æˆæ›´å¤šçš„ç®±å­ï¼Œå®ƒå°±ä¼šå˜çŸ­ã€‚ç¦»æ•£å¯†åº¦å‡½æ•°ä¸åŒäºç›´æ–¹å›¾ï¼Œå®ƒå°†é¢‘ç‡yè½´å½’ä¸€åŒ–ä¸ºä¸€ä¸ªåˆ†æ•°æˆ–ç™¾åˆ†æ¯”(åªæ˜¯åˆ†æ•°ä¹˜ä»¥100)ã€‚ä¸€ä¸ªè¿ç»­çš„ç›´æ–¹å›¾ï¼Œæˆ‘ä»¬æŠŠç®±å­çš„æ•°é‡å–åˆ°æ— ç©·å¤§ï¼Œä¸å¯èƒ½æ˜¯ä¸€ä¸ªåˆ†æ•°ï¼Œå› ä¸ºæ‰€æœ‰ç®±å­çš„é«˜åº¦ä¼šé™ä¸ºé›¶ã€‚å¯†åº¦å‡½æ•°æ˜¯æŒ‡æˆ‘ä»¬å¯¹ç®±å­è¿›è¡Œè°ƒæ•´ä½¿å®ƒä»¬ä¸ä¼šéšç€ç®±å­çš„å¢åŠ è€Œå˜çŸ­ã€‚å¯¹äºä¸Šé¢çš„æ ‘ç›´æ–¹å›¾ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•:</p><p>$bin-height = \frac{(Fraction \space of \space tree \space between \space height \space H \space and \space Hâ€™)}{(H-Hâ€™)}$â€‹</p><blockquote><p>That would work! We could interpret that as a statistical predictor of a treeâ€™s height:</p></blockquote><p>è¿™æ˜¯å¯è¡Œçš„!æˆ‘ä»¬å¯ä»¥å°†å…¶è§£é‡Šä¸ºä¸€æ£µæ ‘é«˜åº¦çš„ç»Ÿè®¡é¢„æµ‹æŒ‡æ ‡:</p><p>$Probability \space a \space random \space tree \space is \space between \space H \space and \space Hâ€™ = bin-height \cdot (H - Hâ€™)$</p><blockquote><p>If we wanted to know about the chances of being in a span of multiple bins, we would sum.</p><p>A <em>probability density function</em>, henceforth <em>PDF</em>, is that fractional histogram made continuous.</p></blockquote><p>å¦‚æœæˆ‘ä»¬æƒ³çŸ¥é“åœ¨å¤šä¸ªç®±å­å¼ æˆçš„ç©ºé—´é‡Œçš„æ¦‚ç‡ï¼Œæˆ‘ä»¬è¦æ±‚å’Œã€‚</p><p>æ¦‚ç‡å¯†åº¦å‡½æ•°ï¼Œå³ä»¥åçš„PDFï¼Œæ˜¯ä½¿åˆ†æ•°ç›´æ–¹å›¾è¿ç»­çš„ã€‚</p><h4 id="Constructing-a-PDF"><a href="#Constructing-a-PDF" class="headerlink" title="Constructing a PDF"></a>Constructing a PDF</h4><blockquote><p>Letâ€™s make a <em>PDF</em> and use it a bit to understand it more. Suppose I want a random number ğ‘Ÿ between 0 and 2 whose probability is proportional to itself: ğ‘Ÿ. We would expect the PDF ğ‘(ğ‘Ÿ) to look something like the figure below, but how high should it be?</p></blockquote><p>è®©æˆ‘ä»¬åˆ¶ä½œä¸€ä¸ªPDFï¼Œå¹¶ä½¿ç”¨å®ƒæ¥æ›´å¥½åœ°ç†è§£å®ƒã€‚å‡è®¾æˆ‘æƒ³è¦ä¸€ä¸ª0åˆ°2ä¹‹é—´çš„éšæœºæ•° $r$ï¼Œå…¶æ¦‚ç‡ä¸è‡ªèº«æˆæ­£æ¯”: $r$ã€‚æˆ‘ä»¬å¸Œæœ›PDF $p(r)$çœ‹èµ·æ¥åƒä¸‹é¢çš„æ•°å­—ï¼Œä½†å®ƒåº”è¯¥æœ‰å¤šé«˜?</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.04-linear-pdf.jpg"></p><blockquote><p>The height is just ğ‘(2). What should that be? We could reasonably make it anything by convention, and we should pick something that is convenient. Just as with histograms we can sum up (integrate) the region to figure out the probability that ğ‘Ÿ is in some interval (ğ‘¥0,ğ‘¥1):</p></blockquote><p>é«˜åº¦å°±æ˜¯ $p(2)$ã€‚åº”è¯¥æ˜¯ä»€ä¹ˆå‘¢?æˆ‘ä»¬å¯ä»¥æŒ‰ç…§æƒ¯ä¾‹æŠŠå®ƒå†™æˆä»»ä½•å½¢å¼ï¼Œæˆ‘ä»¬åº”è¯¥é€‰ä¸€ä¸ªæ–¹ä¾¿çš„å½¢å¼ã€‚å°±åƒç”¨ç›´æ–¹å›¾ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åŒºåŸŸæ±‚å’Œ(ç§¯åˆ†)æ¥è®¡ç®—å‡º $r$ åœ¨æŸä¸ªåŒºé—´å†…çš„æ¦‚ç‡(x0,x1):</p><p>$Probability \space ğ‘¥_0 &lt; ğ‘Ÿ &lt; ğ‘¥_1 = ğ¶â‹…area(ğ‘(ğ‘Ÿ),ğ‘¥_0,ğ‘¥_1)$</p><blockquote><p>where ğ¶ is a scaling constant. We may as well make ğ¶=1 for cleanliness, and that is exactly what is done in probability. We also know the probability ğ‘Ÿ has the value 1 somewhere, so for this case</p></blockquote><p>å…¶ä¸­ C æ˜¯ç¼©æ”¾å¸¸æ•°ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨ C = 1 æ¥è¡¨ç¤ºæ•´æ´ï¼Œè¿™æ­£æ˜¯æ¦‚ç‡æ‰€åšçš„ã€‚æˆ‘ä»¬ä¹ŸçŸ¥é“æ¦‚ç‡ r åœ¨æŸä¸ªåœ°æ–¹çš„å€¼æ˜¯1ï¼Œæ‰€ä»¥åœ¨è¿™ç§æƒ…å†µä¸‹ï¼š</p><p>$area(p(r), 0, 2) = 1$</p><blockquote><p>Since ğ‘(ğ‘Ÿ) is proportional to ğ‘Ÿr, <em>i.e.</em>, ğ‘=ğ¶â€²â‹…ğ‘Ÿ for some other constant ğ¶â€²</p></blockquote><p>$area(Câ€™,r,0,2) = \int^2_0{Câ€™rdr} = \frac{Câ€™r^2}{2}|^{r=2}_{r=0} = \frac{Câ€™ \cdot 2^2}{2} - \frac{Câ€™ \cdot 0^2}{2} = 2Câ€™$</p><blockquote><p>So ğ‘(ğ‘Ÿ)=ğ‘Ÿ/2.</p></blockquote><p>æ‰€ä»¥ $p(r) = r / 2$</p><blockquote><p>How do we generate a random number with that PDF $ğ‘(ğ‘Ÿ)$? For that we will need some more machinery. Donâ€™t worry this doesnâ€™t go on forever!</p><p>Given a random number from <code>d = random_double()</code> that is uniform and between 0 and 1, we should be able to find some function $ğ‘“(ğ‘‘)$ that gives us what we want. Suppose $ğ‘’=ğ‘“(ğ‘‘)=ğ‘‘^2$. This is no longer a uniform PDF. The PDF of $ğ‘’$ will be bigger near 1 than it is near 0 (squaring a number between 0 and 1 makes it smaller). To convert this general observation to a function, we need the cumulative probability distribution function $ğ‘ƒ(ğ‘¥)$:</p></blockquote><p>æˆ‘ä»¬å¦‚ä½•ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ä¸ PDF $p(r)$?ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤šçš„æœºå™¨ã€‚åˆ«æ‹…å¿ƒï¼Œè¿™ä¸ä¼šæ°¸è¿œæŒç»­ä¸‹å»!</p><p>ç»™å®š <code>d = random_double()</code> ä¸­çš„ä¸€ä¸ªå‡åŒ€ä¸”ä»‹äº 0 å’Œ 1 ä¹‹é—´çš„éšæœºæ•°ï¼Œæˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿæ‰¾åˆ°ä¸€äº›å‡½æ•°(f(d))ï¼Œä»è€Œå¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„ç»“æœã€‚å‡è®¾ $e = f(d) = d^2$ã€‚è¿™ä¸å†æ˜¯ä¸€ä¸ªç»Ÿä¸€çš„PDFæ–‡ä»¶ã€‚PDFçš„ $e$ åœ¨æ¥è¿‘1æ—¶ä¼šæ¯”æ¥è¿‘ 0 æ—¶æ›´å¤§(å°† 0 å’Œ 1 ä¹‹é—´çš„æ•°å­—å¹³æ–¹ä¼šä½¿å®ƒæ›´å°)ã€‚ä¸ºäº†å°†è¿™ä¸ªä¸€èˆ¬çš„è§‚å¯Ÿç»“æœè½¬åŒ–ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦ç´¯ç§¯æ¦‚ç‡åˆ†å¸ƒå‡½æ•° $P(x)$:</p><p>$P(x) = area(p, -\infin, x)$</p><blockquote><p>Note that for ğ‘¥ where we didnâ€™t define ğ‘(ğ‘¥), ğ‘(ğ‘¥)=0, i.e., the probability of an ğ‘¥ there is zero. For our example PDF ğ‘(ğ‘Ÿ)=ğ‘Ÿ/2, the ğ‘ƒ(ğ‘¥) is:</p></blockquote><p>æ³¨æ„ï¼Œå¯¹äºæ²¡æœ‰å®šä¹‰çš„ $p(x)$ï¼Œ$p(x) = 0$ï¼Œå³å­˜åœ¨ä¸€ä¸ª $x$ çš„æ¦‚ç‡ä¸º 0ã€‚å¯¹äºæˆ‘ä»¬çš„ç¤ºä¾‹PDF $p (r) = r / 2$, $P(x)$ æ˜¯:</p><p>$P(x) = 0:x &lt; 0$â€‹</p><p>$P(x) = \frac{x^2}{4}: 0 &lt; x &lt; 2$</p><p>$P(x) = 1 : x &gt; 2$</p><blockquote><p>One question is, whatâ€™s up with ğ‘¥ versus ğ‘Ÿ? They are dummy variables â€” analogous to the function arguments in a program. If we evaluate ğ‘ƒ at ğ‘¥=1.0, we get:</p></blockquote><p>ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œx å’Œ r æ˜¯ä»€ä¹ˆå…³ç³»?å®ƒä»¬æ˜¯è™šæ‹Ÿå˜é‡â€”ç±»ä¼¼äºç¨‹åºä¸­çš„å‡½æ•°å‚æ•°ã€‚å¦‚æœåœ¨ x = 1.0 å¤„æ±‚ P å€¼ï¼Œåˆ™å¾—åˆ°:</p><p>$P(1.0) = \frac{1}{4}$â€‹</p><blockquote><p>This says <em>the probability that a random variable with our PDF is less than one is 25%</em>. This gives rise to a clever observation that underlies many methods to generate non-uniform random numbers.</p></blockquote><p>ä¹Ÿå°±æ˜¯è¯´ï¼ŒPDFå€¼å°äº1çš„éšæœºå˜é‡çš„æ¦‚ç‡æ˜¯25%è¿™å°±äº§ç”Ÿäº†ä¸€ä¸ªèªæ˜çš„è§‚å¯Ÿç»“æœï¼š</p><p>$f(P(x)) = x$</p><blockquote><p>That means ğ‘“ just undoes whatever ğ‘ƒ does. So,</p></blockquote><p>è¿™æ„å‘³ç€å‡½æ•° <strong>f</strong> åªæ˜¯æ’¤æ¶ˆå‡½æ•° <strong>P</strong> æ‰€åšçš„ä»»ä½•äº‹æƒ…ã€‚æ‰€ä»¥,</p><p>$f(x) = P^{-1}(x)$</p><blockquote><p>The âˆ’1 means â€œinverse functionâ€. Ugly notation, but standard. For our purposes, if we have PDF $ğ‘()$ and cumulative distribution function $ğ‘ƒ()$, we can use this â€œinverse functionâ€ with a random number to get what we want:</p></blockquote><p>âˆ’1è¡¨ç¤ºâ€œé€†å‡½æ•°â€ã€‚å¾ˆéš¾çœ‹çš„ç¬¦å·ï¼Œä½†å¾ˆæ ‡å‡†ã€‚å¯¹äºæˆ‘ä»¬çš„ç›®çš„ï¼Œå¦‚æœæˆ‘ä»¬æœ‰PDF $p()$ å’Œç´¯ç§¯åˆ†å¸ƒå‡½æ•° $P()$ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™ä¸ªâ€œé€†å‡½æ•°â€ä¸ä¸€ä¸ªéšæœºæ•°æ¥å¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„:</p><p>$e = P^{-1}(random_double())$</p><blockquote><p>For our PDF ğ‘(ğ‘¥)=ğ‘¥/2, and corresponding ğ‘ƒ(ğ‘¥), we need to compute the inverse of ğ‘ƒ. If we have</p></blockquote><p>å¯¹äºæˆ‘ä»¬çš„ <strong>PDFp(x)=x/2</strong>ï¼Œä»¥åŠç›¸åº”çš„P(x)ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—<strong>P</strong>çš„é€†ã€‚å¦‚æœæˆ‘ä»¬æœ‰</p><p>$y = \frac{x^2}{4}$</p><blockquote><p>we get the inverse by solving for ğ‘¥ in terms of ğ‘¦:</p></blockquote><p>æˆ‘ä»¬é€šè¿‡ç”¨ $y$ æ±‚å‡º $x$ æ¥æ±‚é€†:</p><p>$x = \sqrt{4y}$</p><blockquote><p>Thus our random number with density ğ‘ is found with:</p></blockquote><p>å› æ­¤ï¼Œå¯†åº¦ä¸ºçš„éšæœºæ•°æ˜¯:</p><p>$e = \sqrt{4 \cdot random_double()}$</p><blockquote><p>Note that this ranges from 0 to 2 as hoped, and if we check our work by replacing <code>random_double()</code> with $\frac{1}{4}$ we get 1 as expected.</p><p>We can now sample our old integral</p></blockquote><p>æ³¨æ„ï¼Œè¿™ä¸ªèŒƒå›´å¦‚é¢„æœŸçš„ä» 0 åˆ° 2ï¼Œå¦‚æœæˆ‘ä»¬ç”¨ 1/4 æ›¿æ¢ <code>random_double()</code> æ¥æ£€æŸ¥æˆ‘ä»¬çš„å·¥ä½œï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°é¢„æœŸçš„1ã€‚</p><p>æˆ‘ä»¬å¯ä»¥å¯¹æ—§çš„ç§¯åˆ†è¿›è¡ŒæŠ½æ ·</p><p>$I = \int_0^2x^2$</p><blockquote><p>We need to account for the non-uniformity of the PDF of ğ‘¥. Where we sample too much we should down-weight. The PDF is a perfect measure of how much or little sampling is being done. So the weighting function should be proportional to 1/ğ‘ğ‘‘ğ‘“. In fact it is exactly 1/ğ‘ğ‘‘ğ‘“:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "rtweekend.h"</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">inline double pdf(double x) {</span><br><span class="line">    return 0.5*x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int N = 100000;</span><br><span class="line">    auto sum = 0.0;</span><br><span class="line">    for (int i = 0; i &lt; N; ++i) {</span><br><span class="line"><span class="deletion">-       auto x = random_double(0, 2);</span></span><br><span class="line"><span class="deletion">-       sum += x * x;</span></span><br><span class="line"><span class="addition">+       auto x = sqrt(random_double(0,4));</span></span><br><span class="line"><span class="addition">+       sum += x*x / pdf(x);</span></span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12);</span><br><span class="line">    std::cout &lt;&lt; "I = " &lt;&lt; 2 * sum / N &lt;&lt; '\n';</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="Importance-Sampling"><a href="#Importance-Sampling" class="headerlink" title="Importance Sampling"></a>Importance Sampling</h4><blockquote><p>Since we are sampling more where the integrand is big, we might expect less noise and thus faster convergence. In effect, we are steering our samples toward the parts of the distribution that are more <em>important</em>. This is why using a carefully chosen non-uniform PDF is usually called <em>importance sampling</em>.</p></blockquote><p>ç”±äºæˆ‘ä»¬åœ¨è¢«ç§¯å‡½æ•°è¾ƒå¤§çš„åœ°æ–¹è¿›è¡Œæ›´å¤šé‡‡æ ·ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæœŸæœ›æ›´å°‘çš„å™ªå£°ï¼Œä»è€Œæ›´å¿«åœ°æ”¶æ•›ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬æ­£åœ¨å°†æ ·æœ¬è½¬å‘åˆ†å¸ƒä¸­æ›´é‡è¦çš„éƒ¨åˆ†ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½¿ç”¨ç²¾å¿ƒé€‰æ‹©çš„éå‡åŒ€PDFé€šå¸¸è¢«ç§°ä¸ºé‡è¦æŠ½æ ·ã€‚</p><blockquote><p>If we take that same code with uniform samples so the PDF = 1/2 over the range [0,2] we can use the machinery to get <code>x = random_double(0,2)</code>, and the code is:</p></blockquote><p>å¦‚æœæˆ‘ä»¬ä½¿ç”¨ç»Ÿä¸€æ ·æœ¬çš„ç›¸åŒä»£ç ï¼Œé‚£ä¹ˆåœ¨[0,2]èŒƒå›´å†…çš„PDF = 1/2 ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>x = random_double(0,2)</code> è·å¾—ï¼Œä»£ç æ˜¯:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+inline double pdf(double x) {</span></span><br><span class="line"><span class="addition">+   return 0.5;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int N = 1000000;</span><br><span class="line">    auto sum = 0.0;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) {</span><br><span class="line"><span class="addition">+       auto x = random_double(0,2);</span></span><br><span class="line">        sum += x*x / pdf(x);</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12);</span><br><span class="line">    std::cout &lt;&lt; "I = " &lt;&lt; sum/N &lt;&lt; '\n';</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Note that we donâ€™t need that 2 in the <code>2*sum/N</code> anymore â€” that is handled by the PDF, which is 2 when you divide by it. Youâ€™ll note that importance sampling helps a little, but not a ton. We could make the PDF follow the integrand exactly:</p></blockquote><p>æ³¨æ„ï¼Œæˆ‘ä»¬ä¸å†éœ€è¦ <code>2*sum/N</code> ä¸­çš„ 2ï¼Œå®ƒæ˜¯ç”±PDFå¤„ç†çš„ï¼Œå½“ä½ é™¤ä»¥å®ƒæ—¶ï¼Œå®ƒæ˜¯ 2ã€‚æ‚¨ä¼šæ³¨æ„åˆ°ï¼Œé‡è¦æŠ½æ ·çš„ä½œç”¨ä¸å¤§ã€‚æˆ‘ä»¬å¯ä»¥è®©PDFå®Œå…¨éµå¾ªè¢«ç§¯å‡½æ•°:</p><p>$p(x) = \frac{3}{8}x^2$</p><blockquote><p>And we get the corresponding</p></blockquote><p>æˆ‘ä»¬å¾—åˆ°ç›¸åº”çš„ï¼š</p><p>$P(x) = \frac{x^3}{8}$</p><blockquote><p>and</p></blockquote><p>å’Œï¼š</p><p>$P^{-1}(x) = 8x^{\frac{1}{3}}$</p><blockquote><p>This perfect importance sampling is only possible when we already know the answer (we got ğ‘ƒ by integrating ğ‘ analytically), but itâ€™s a good exercise to make sure our code works. For just 1 sample we get:</p></blockquote><p>åªæœ‰å½“æˆ‘ä»¬å·²ç»çŸ¥é“ç­”æ¡ˆæ—¶(æˆ‘ä»¬é€šè¿‡å¯¹ $P$ è¿›è¡Œåˆ†ææ¥å¾—åˆ° $p$)ï¼Œè¿™ä¸ªå®Œç¾çš„é‡è¦æŠ½æ ·æ‰å¯èƒ½å®ç°ï¼Œä½†è¿™æ˜¯ç¡®ä¿ä»£ç å·¥ä½œçš„ä¸€ä¸ªå¾ˆå¥½çš„ç»ƒä¹ ã€‚å¯¹äºä¸€ä¸ªæ ·æœ¬ï¼Œæˆ‘ä»¬å¾—åˆ°:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+inline double pdf(double x) {</span></span><br><span class="line"><span class="addition">+   return 3*x*x/8;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line"><span class="addition">+   int N = 1;</span></span><br><span class="line">    auto sum = 0.0;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) {</span><br><span class="line"><span class="addition">+       auto x = pow(random_double(0,8), 1./3.);</span></span><br><span class="line">        sum += x*x / pdf(x);</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12);</span><br><span class="line">    std::cout &lt;&lt; "I = " &lt;&lt; sum/N &lt;&lt; '\n';</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which always returns the exact answer.</p><p>Letâ€™s review now because that was most of the concepts that underlie MC ray tracers.</p><ol><li>You have an integral of ğ‘“(ğ‘¥) over some domain [ğ‘,ğ‘]</li><li>You pick a PDF ğ‘ that is non-zero over [ğ‘,ğ‘]</li><li>You average a whole ton of $\frac{ğ‘“(ğ‘Ÿ)}{ğ‘(ğ‘Ÿ)}$ where ğ‘Ÿr is a random number with PDF ğ‘.</li></ol><p>Any choice of PDF ğ‘ will always converge to the right answer, but the closer that ğ‘p approximates ğ‘“, the faster that it will converge.</p></blockquote><p>å®ƒæ€»æ˜¯è¿”å›å‡†ç¡®çš„ç­”æ¡ˆã€‚</p><p>ç°åœ¨è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ï¼Œå› ä¸ºè¿™æ˜¯MCå°„çº¿ç¤ºè¸ªä»ªçš„åŸºæœ¬æ¦‚å¿µã€‚</p><ol><li>ä½ æœ‰ä¸€ä¸ªf(x)åœ¨æŸä¸ªå®šä¹‰åŸŸ [a,b] ä¸Šçš„ç§¯åˆ†</li><li>ä½ é€‰æ‹©ä¸€ä¸ªé0 [a,b] çš„ PDF(p)</li><li>ä½ å¹³å‡ä¸€æ•´å¨çš„ f(r)/p(r)ï¼Œå…¶ä¸­ r æ˜¯PDF(p)çš„ä¸€ä¸ªéšæœºæ•°ã€‚</li></ol><p>ä»»ä½• PDF(p) çš„é€‰æ‹©æ€»æ˜¯æ”¶æ•›åˆ°æ­£ç¡®çš„ç­”æ¡ˆï¼Œä½†æ˜¯ï¼Œp ä¸ fçš„è¿‘è·è¶Šè¿‘ï¼Œå®ƒæ”¶æ•›çš„é€Ÿåº¦å°±è¶Šå¿«<em>ã€‚</em></p><h3 id="æ–¹å‘çƒä¸Šçš„MCé›†æˆ"><a href="#æ–¹å‘çƒä¸Šçš„MCé›†æˆ" class="headerlink" title="æ–¹å‘çƒä¸Šçš„MCé›†æˆ"></a>æ–¹å‘çƒä¸Šçš„MCé›†æˆ</h3><blockquote><p>In our ray tracer we pick random directions, and directions can be represented as points on the unit sphere. The same methodology as before applies, but now we need to have a PDF defined over 2D.</p><p>Suppose we have this integral over all directions:</p></blockquote><p>åœ¨æˆ‘ä»¬çš„å°„çº¿è¿½è¸ªå™¨ä¸­ï¼Œæˆ‘ä»¬é€‰æ‹©éšæœºçš„æ–¹å‘ï¼Œæ–¹å‘å¯ä»¥ç”¨å•ä½çƒä¸Šçš„ç‚¹è¡¨ç¤ºã€‚ä¸ä¹‹å‰çš„æ–¹æ³•ç›¸åŒï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬éœ€è¦ä¸€ä¸ªåœ¨2Dä¸Šå®šä¹‰çš„PDFã€‚</p><p>å‡è®¾æˆ‘ä»¬åœ¨æ‰€æœ‰æ–¹å‘ä¸Šç§¯åˆ†</p><p>$\int{\cos^2(\theta)}$</p><blockquote><p>By MC integration, we should just be able to sample $\cos^2(ğœƒ)/ğ‘(direction)$, but what is <em>direction</em> in that context? We could make it based on polar coordinates, so ğ‘ would be in terms of $(ğœƒ,ğœ™)$. However you do it, remember that a PDF has to integrate to 1 and represent the relative probability of that direction being sampled. Recall that we have vec3 functions to take uniform random samples in (<code>random_in_unit_sphere()</code>) or on (<code>random_unit_vector()</code>) a unit sphere.</p></blockquote><p>é€šè¿‡MCç§¯åˆ†ï¼Œæˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿé‡‡æ · $\cos^2(theta) / p(direction)$ï¼Œä½†æ–¹å‘åœ¨è¿™ç§æƒ…å†µä¸‹æ˜¯ä»€ä¹ˆ?æˆ‘ä»¬å¯ä»¥è®©å®ƒåŸºäºæåæ ‡ï¼Œæ‰€ä»¥ p æ˜¯ç”¨ (theta, phi) è¡¨ç¤ºçš„ã€‚ä¸ç®¡ä½ æ€ä¹ˆåšï¼Œè®°ä½PDFå¿…é¡»ç§¯åˆ†åˆ°1ï¼Œå¹¶è¡¨ç¤ºè¯¥æ–¹å‘è¢«é‡‡æ ·çš„ç›¸å¯¹æ¦‚ç‡ã€‚å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨vec3å‡½æ•°åœ¨(<code>random_in_unit_sphere()</code>)æˆ–(<code>random_unit_vector()</code>)å•ä½çƒä½“ä¸Šè¿›è¡Œå‡åŒ€éšæœºé‡‡æ ·ã€‚</p><blockquote><p>Now what is the PDF of these uniform points? As a density on the unit sphere, it is 1/area of the sphere or 1/(4ğœ‹). If the integrand is $cos^2(ğœƒ)$, and ğœƒ is the angle with the z axis:</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"vec3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">pdf</span><span class="params">(<span class="type">const</span> vec3&amp; p)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">4</span>*pi);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        vec3 d = <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="keyword">auto</span> cosine_squared = d.<span class="built_in">z</span>()*d.<span class="built_in">z</span>();</span><br><span class="line">        sum += cosine_squared / <span class="built_in">pdf</span>(d);</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"I = "</span> &lt;&lt; sum/N &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The analytic answer (if you remember enough advanced calc, check me!) is $\frac{4}{3}ğœ‹$, and the code above produces that. Next, we are ready to apply that in ray tracing!</p><p>The key point here is that all the integrals and probability and all that are over the unit sphere. The area on the unit sphere is how you measure the directions. Call it direction, solid angle, or area â€” itâ€™s all the same thing. Solid angle is the term usually used. If you are comfortable with that, great! If not, do what I do and imagine the area on the unit sphere that a set of directions goes through. The solid angle ğœ” and the projected area ğ´ on the unit sphere are the same thing.</p></blockquote><p>è§£æç­”æ¡ˆï¼ˆå¦‚æœä½ è¿˜è®°å¾—è¶³å¤Ÿçš„é«˜çº§è®¡ç®—ï¼Œè¯·æ£€æŸ¥æˆ‘!ï¼‰æ˜¯ $\frac{4}{3} \pi$ï¼Œä¸Šé¢çš„ä»£ç äº§ç”Ÿäº†è¿™ä¸ªç»“æœã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å‡†å¤‡åœ¨å…‰çº¿è¿½è¸ªä¸­åº”ç”¨å®ƒ!</p><p>è¿™é‡Œçš„å…³é”®ç‚¹æ˜¯æ‰€æœ‰çš„ç§¯åˆ†å’Œæ¦‚ç‡ï¼Œæ‰€æœ‰çš„éƒ½åœ¨å•ä½çƒä¸Šã€‚å•ä½çƒä¸Šçš„é¢ç§¯å°±æ˜¯æµ‹é‡æ–¹å‘çš„æ–¹æ³•ã€‚å«å®ƒæ–¹å‘ï¼Œç«‹ä½“è§’ï¼Œæˆ–è€…é¢ç§¯ï¼Œéƒ½æ˜¯ä¸€æ ·çš„ã€‚ç«‹ä½“è§’æ˜¯å¸¸ç”¨çš„æœ¯è¯­ã€‚å¦‚æœä½ è§‰å¾—æ²¡é—®é¢˜ï¼Œé‚£å¤ªå¥½äº†!å¦‚æœæ²¡æœ‰ï¼Œå°±åƒæˆ‘åšçš„ä¸€æ ·ï¼Œæƒ³è±¡å•ä½çƒä¸Šä¸€ç³»åˆ—æ–¹å‘ç»è¿‡çš„é¢ç§¯ã€‚å®å¿ƒè§’omega å’Œå•ä½çƒä¸Šçš„æŠ•å½±é¢ç§¯ A æ˜¯ä¸€æ ·çš„ã€‚</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.05-solid-angle.jpg"></p><h3 id="å…‰æ•£å°„"><a href="#å…‰æ•£å°„" class="headerlink" title="å…‰æ•£å°„"></a>å…‰æ•£å°„</h3><blockquote><p>In this chapter we wonâ€™t actually program anything. We will set up for a big lighting change in the next chapter.</p></blockquote><p>åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šå®é™…ç¼–å†™ä»»ä½•ç¨‹åºã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« è®¾ç½®ä¸€ä¸ªå¤§çš„ç…§æ˜å˜åŒ–ã€‚</p><h4 id="Albedo"><a href="#Albedo" class="headerlink" title="Albedo"></a>Albedo</h4><blockquote><p>Our program from the last books already scatters rays from a surface or volume. This is the commonly used model for light interacting with a surface. One natural way to model this is with probability. First, is the light absorbed?</p></blockquote><p>ä¸Šä¸€æœ¬ä¹¦ä¸­çš„ç¨‹åºå·²ç»å°†å…‰çº¿ä»è¡¨é¢æˆ–ä½“ç§¯ä¸Šæ•£å°„ã€‚è¿™æ˜¯å…‰ä¸è¡¨é¢ç›¸äº’ä½œç”¨çš„å¸¸ç”¨æ¨¡å‹ã€‚ä¸€ä¸ªå¾ˆè‡ªç„¶çš„å»ºæ¨¡æ–¹æ³•æ˜¯ç”¨æ¦‚ç‡ã€‚é¦–å…ˆï¼Œå…‰çº¿è¢«å¸æ”¶äº†å—?</p><blockquote><p>Probability of light scattering: ğ´</p><p>Probability of light being absorbed: 1âˆ’ğ´</p></blockquote><p>å…‰æ•£å°„æ¦‚ç‡: A</p><p>å…‰è¢«å¸æ”¶çš„æ¦‚ç‡: 1-A</p><blockquote><p>Here ğ´ stands for <em>albedo</em> (latin for <em>whiteness</em>). Albedo is a precise technical term in some disciplines, but in all cases it is used to define some form of <em>fractional reflectance</em>. This <em>fractional reflectance</em> (or albedo) will vary with color and (as we implemented for our glass in book one) can vary with incident direction.</p></blockquote><p>è¿™é‡Œ A ä»£è¡¨åç…§ç‡(æ‹‰ä¸è¯­ä¸­ç™½è‰²çš„æ„æ€)ã€‚åç…§ç‡åœ¨æŸäº›å­¦ç§‘ä¸­æ˜¯ä¸€ä¸ªç²¾ç¡®çš„æŠ€æœ¯æœ¯è¯­ï¼Œä½†åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼Œå®ƒè¢«ç”¨æ¥å®šä¹‰æŸç§å½¢å¼çš„åˆ†æ•°åå°„ç‡ã€‚è¿™éƒ¨åˆ†åå°„ç‡(æˆ–åç…§ç‡)ä¼šéšç€é¢œè‰²çš„å˜åŒ–è€Œå˜åŒ–(æ­£å¦‚æˆ‘ä»¬åœ¨ä¹¦ä¸€ä¸­ä¸ºæˆ‘ä»¬çš„ç»ç’ƒå®ç°çš„é‚£æ ·)ï¼Œå¯ä»¥éšç€å…¥å°„æ–¹å‘è€Œå˜åŒ–ã€‚</p><h4 id="Scattering"><a href="#Scattering" class="headerlink" title="Scattering"></a>Scattering</h4><blockquote><p>In most physically based renderers, we would use a set of wavelengths for the light color rather than RGB. We can extend our intuition by thinking of R, G, and B as specific algebraic mixtures of long, medium, and short wavelengths.</p></blockquote><p>åœ¨å¤§å¤šæ•°åŸºäºç‰©ç†çš„æ¸²æŸ“å™¨ä¸­ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨ä¸€ç»„æ³¢é•¿çš„å…‰é¢œè‰²ï¼Œè€Œä¸æ˜¯RGBã€‚æˆ‘ä»¬å¯ä»¥æ‰©å±•æˆ‘ä»¬çš„ç›´è§‰ï¼ŒæŠŠRã€Gå’ŒBçœ‹ä½œæ˜¯é•¿ã€ä¸­ã€çŸ­æ³¢é•¿çš„ç‰¹æ®Šä»£æ•°æ··åˆç‰©ã€‚</p><blockquote><p>If the light does scatter, it will have a directional distribution that we can describe as a PDF over solid angle. I will refer to this as its <em>scattering PDF</em>: ğ‘ (ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›). The scattering PDF can also vary with <em>incident direction</em>, which is the direction of the incoming ray. You can see this varying with incident direction when you look at reflections off a road â€” they become mirror-like as your viewing angle (incident angle) approaches grazing.</p></blockquote><p>å¦‚æœå…‰æ•£å°„ï¼Œå®ƒå°†æœ‰ä¸€ä¸ªæ–¹å‘åˆ†å¸ƒï¼Œæˆ‘ä»¬å¯ä»¥æè¿°ä¸ºPDFç«‹ä½“è§’ã€‚æˆ‘å°†æŠŠå®ƒç§°ä¸ºæ•£å°„PDF: s(direction)ã€‚æ•£å°„PDFä¹Ÿå¯ä»¥éšå…¥å°„æ–¹å‘è€Œå˜åŒ–ï¼Œå…¥å°„æ–¹å‘æ˜¯å…¥å°„å°„çº¿çš„æ–¹å‘ã€‚å½“ä½ è§‚å¯Ÿé“è·¯ä¸Šçš„åå°„æ—¶ï¼Œä½ å¯ä»¥çœ‹åˆ°è¿™éšç€å…¥å°„æ–¹å‘çš„å˜åŒ–è€Œå˜åŒ–â€”â€”å½“ä½ çš„è§†è§’(å…¥å°„è§’)æ¥è¿‘å…¥å°„æ—¶ï¼Œå®ƒä»¬å˜æˆäº†é•œå­ä¸€æ ·ã€‚</p><blockquote><p>The color of a surface in terms of these quantities is:</p></blockquote><p>ç”¨è¿™äº›é‡è¡¨ç¤ºçš„è¡¨é¢é¢œè‰²æ˜¯:</p><p>$Color = \int{A \cdot s(direction) \cdot color(direction)}$</p><blockquote><p>Note that ğ´ and ğ‘ () may depend on the view direction or the scattering position (position on a surface or position within a volume). Therefore, the output color may also vary with view direction or scattering position.</p></blockquote><p>æ³¨æ„ A å’Œ s()å¯èƒ½å–å†³äºè§†å›¾æ–¹å‘æˆ–æ•£å°„ä½ç½®(è¡¨é¢ä¸Šçš„ä½ç½®æˆ–ä½“ç§¯å†…çš„ä½ç½®)ã€‚å› æ­¤ï¼Œè¾“å‡ºé¢œè‰²ä¹Ÿå¯èƒ½éšç€è§†å›¾æ–¹å‘æˆ–æ•£å°„ä½ç½®çš„å˜åŒ–è€Œå˜åŒ–ã€‚</p><h4 id="The-Scattering-PDF"><a href="#The-Scattering-PDF" class="headerlink" title="The Scattering PDF"></a>The Scattering PDF</h4><blockquote><p>If we apply the MC basic formula we get the following statistical estimate:</p></blockquote><p>å¦‚æœæˆ‘ä»¬åº”ç”¨MCåŸºæœ¬å…¬å¼ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹ç»Ÿè®¡ä¼°è®¡:</p><p>$Color = \frac{A \cdot s(direction) \cdot color(direction)}{p(direction)}$</p><blockquote><p>where ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›) is the PDF of whatever direction we randomly generate.</p></blockquote><p>å…¶ä¸­p(direction)æ˜¯æˆ‘ä»¬éšæœºç”Ÿæˆçš„ä»»æ„æ–¹å‘çš„PDFã€‚</p><blockquote><p>For a Lambertian surface we already implicitly implemented this formula for the special case where ğ‘() is a cosine density. The ğ‘ () of a Lambertian surface is proportional to cos(ğœƒ), where ğœƒ is the angle relative to the surface normal. Remember that all PDF need to integrate to one. For cos(ğœƒ)&lt;0 we have ğ‘ (ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=0, and the integral of cos over the hemisphere is ğœ‹.</p></blockquote><p>å¯¹äºæœ—ä¼¯æ›²é¢ï¼Œæˆ‘ä»¬å·²ç»éšå¼åœ°å®ç°äº†è¿™ç§ç‰¹æ®Šæƒ…å†µä¸‹çš„å…¬å¼ï¼Œå…¶ä¸­ $p()$â€‹ æ˜¯ä¸€ä¸ªä½™å¼¦å¯†åº¦ã€‚æœ—ä¼¯æ›²é¢çš„ $s()$â€‹ æ­£æ¯”äº $cos(\theta)$â€‹ï¼Œå…¶ä¸­ $\theta$â€‹ æ˜¯ç›¸å¯¹äºæ›²é¢æ³•çº¿çš„è§’åº¦ã€‚è®°ä½ï¼Œæ‰€æœ‰çš„PDFéƒ½éœ€è¦é›†æˆåˆ°ä¸€ä¸ªã€‚å¯¹äº$cos(\theta) &lt; 0$â€‹ æˆ‘ä»¬æœ‰ $s(direction) = 0$ï¼Œ cosåœ¨åŠçƒä¸Šçš„ç§¯åˆ†æ˜¯ $\pi$</p><blockquote><p>To see that, remember that in spherical coordinates:</p></blockquote><p>è®°ä½ï¼Œåœ¨çƒåæ ‡ä¸‹</p><p>$dA = \sin(\theta)d\theta d\phi$</p><blockquote><p>So:</p></blockquote><p>æ‰€ä»¥:</p><p>$Area = \int_0^{2\pi}\int_0^{\pi/2}{\cos{\theta} \sin{\theta} d\theta d\phi} = 2 \pi \frac{1}{2} = \pi$</p><blockquote><p>So for a Lambertian surface the scattering PDF is:</p></blockquote><p>æ‰€ä»¥å¯¹äºæœ—ä¼¯æ›²é¢æ•£å°„PDFæ˜¯:</p><p>$s(direction) = \frac{\cos{\theta}}{\pi}$</p><blockquote><p>If we sample using a PDF that equals the scattering PDF:</p></blockquote><p>å¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç­‰äºæ•£å°„PDFçš„PDFè¿›è¡Œé‡‡æ ·:</p><p>$p(direction) = s(direction) = \frac{\cos{\theta}}{\pi}$</p><blockquote><p>The numerator and denominator cancel out, and we get:</p></blockquote><p>åˆ†å­åˆ†æ¯çº¦æ‰äº†ï¼Œå¾—åˆ°</p><p>$Color = A \cdot color(direction)$â€‹</p><blockquote><p>This is exactly what we had in our original <code>ray_color()</code> function! However, we need to generalize so we can send extra rays in important directions, such as toward the lights.</p></blockquote><p>è¿™æ­£æ˜¯æˆ‘ä»¬åœ¨åŸæ¥çš„ray_color()å‡½æ•°ä¸­æ‰€ä½¿ç”¨çš„ï¼ç„¶è€Œï¼Œæˆ‘ä»¬éœ€è¦ä¸€èˆ¬åŒ–ï¼Œè¿™æ ·æˆ‘ä»¬æ‰èƒ½åœ¨é‡è¦çš„æ–¹å‘å‘é€é¢å¤–çš„å…‰çº¿ï¼Œæ¯”å¦‚å‘å…‰çš„æ–¹å‘ã€‚</p><blockquote><p>The treatment above is slightly non-standard because I want the same math to work for surfaces and volumes. To do otherwise will make some ugly code.</p></blockquote><p>ä¸Šé¢çš„å¤„ç†æœ‰ç‚¹ä¸æ ‡å‡†ï¼Œå› ä¸ºæˆ‘æƒ³ç”¨åŒæ ·çš„æ•°å­¦æ–¹æ³•æ¥å¤„ç†è¡¨é¢å’Œä½“ç§¯ã€‚å¦åˆ™å°†ä¼šäº§ç”Ÿä¸€äº›ä¸‘é™‹çš„ä»£ç ã€‚</p><blockquote><p>If you read the literature, youâ€™ll see reflection described by the bidirectional reflectance distribution function (BRDF). It relates pretty simply to our terms:</p></blockquote><p>å¦‚æœä½ é˜…è¯»æ–‡çŒ®ï¼Œä½ ä¼šçœ‹åˆ°åå°„æ˜¯ç”±åŒå‘åå°„åˆ†å¸ƒå‡½æ•°(BRDF)æè¿°çš„ã€‚å®ƒä¸æˆ‘ä»¬çš„æœ¯è¯­éå¸¸ç®€å•:</p><p>$BRDF = \frac{A \cdot s(direction)}{\cos{\theta}}$</p><blockquote><p>So for a Lambertian surface for example, ğµğ‘…ğ·ğ¹=ğ´/ğœ‹. Translation between our terms and BRDF is easy.</p></blockquote><p>ä»¥æœ—ä¼¯æ›²é¢ä¸ºä¾‹ï¼ŒBRDF=A/Ï€ æˆ‘ä»¬çš„æœ¯è¯­å’ŒBRDFä¹‹é—´çš„è½¬æ¢å¾ˆå®¹æ˜“ã€‚</p><blockquote><p>For participation media (volumes), our albedo is usually called <em>scattering albedo</em>, and our scattering PDF is usually called <em>phase function</em>.</p></blockquote><p>å¯¹äºå‚ä¸ä»‹è´¨(ä½“ç§¯)ï¼Œæˆ‘ä»¬çš„åç…§ç‡é€šå¸¸ç§°ä¸ºæ•£å°„åç…§ç‡ï¼Œæˆ‘ä»¬çš„æ•£å°„PDFé€šå¸¸ç§°ä¸ºç›¸ä½å‡½æ•°ã€‚</p><h3 id="é‡è¦é‡‡æ ·æè´¨"><a href="#é‡è¦é‡‡æ ·æè´¨" class="headerlink" title="é‡è¦é‡‡æ ·æè´¨"></a>é‡è¦é‡‡æ ·æè´¨</h3><blockquote><p>Our goal over the next two chapters is to instrument our program to send a bunch of extra rays toward light sources so that our picture is less noisy. Letâ€™s assume we can send a bunch of rays toward the light source using a PDF ğ‘ğ¿ğ‘–ğ‘”â„ğ‘¡(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›). Letâ€™s also assume we have a PDF related to ğ‘ , and letâ€™s call that ğ‘ğ‘†ğ‘¢ğ‘Ÿğ‘“ğ‘ğ‘ğ‘’(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›). A great thing about PDFs is that you can just use linear mixtures of them to form mixture densities that are also PDFs. For example, the simplest would be:</p></blockquote><p>æˆ‘ä»¬çš„ç›®æ ‡åœ¨æ¥ä¸‹æ¥çš„ä¸¤ç« æ˜¯ä»ªå™¨æˆ‘ä»¬çš„ç¨‹åºå‘é€ä¸€æŸé¢å¤–çš„å°„çº¿åˆ°å…‰æºï¼Œä½¿æˆ‘ä»¬çš„å›¾ç‰‡å™ªéŸ³æ›´å°ã€‚è®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬å¯ä»¥ä½¿ç”¨PDF (å…‰ç…§(æ–¹å‘)) å‘å…‰æºå‘é€ä¸€æŸå…‰çº¿ã€‚æˆ‘ä»¬è¿˜å‡è®¾æœ‰ä¸€ä¸ªä¸ $s$â€‹ ç›¸å…³çš„ PDFï¼Œå¹¶å°†å…¶å‘½åä¸º *pSurface(direction)*ã€‚å…³äºpdf çš„ä¸€ä¸ªå¾ˆæ£’çš„åœ°æ–¹æ˜¯ä½ å¯ä»¥ä½¿ç”¨å®ƒä»¬çš„çº¿æ€§æ··åˆæ¥å½¢æˆæ··åˆå¯†åº¦ä¹Ÿæ˜¯ pdfã€‚ä¾‹å¦‚ï¼Œæœ€ç®€å•çš„æ˜¯:</p><p>$p(direction) = \frac{1}{2}\cdot Light(direction) + \frac{1}{2} \cdot pSurface(dirction)$</p><blockquote><p>As long as the weights are positive and add up to one, any such mixture of PDFs is a PDF. Remember, we can use any PDF: <em>all PDFs eventually converge to the correct answer</em>. So, the game is to figure out how to make the PDF larger where the product ğ‘ (ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)â‹…ğ‘ğ‘œğ‘™ğ‘œğ‘Ÿ(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›) is large. For diffuse surfaces, this is mainly a matter of guessing where ğ‘ğ‘œğ‘™ğ‘œğ‘Ÿ(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›) is high.</p></blockquote><p>åªè¦æƒå€¼æ˜¯æ­£çš„å¹¶ä¸”åŠ èµ·æ¥æ˜¯1ï¼Œä»»ä½•è¿™æ ·çš„ PDF æ··åˆéƒ½æ˜¯ PDFã€‚è®°ä½ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»»ä½• PDF: æ‰€æœ‰çš„ PDF æœ€ç»ˆéƒ½ä¼šæ”¶æ•›åˆ°æ­£ç¡®çš„ç­”æ¡ˆã€‚æ‰€ä»¥ï¼Œæ¸¸æˆæ˜¯è¦æ‰¾å‡ºå¦‚ä½•ä½¿ PDF æ›´å¤§çš„äº§å“ <em>s(direction)â‹… color(direction)</em> æ˜¯å¤§ã€‚å¯¹äºæ¼«åå°„è¡¨é¢ï¼Œè¿™ä¸»è¦æ˜¯çŒœæµ‹å“ªé‡Œ <em>color(direction)</em> é«˜çš„é—®é¢˜ã€‚</p><blockquote><p>For a mirror, ğ‘ () is huge only near one direction, so it matters a lot more. Most renderers in fact make mirrors a special case, and just make the ğ‘ /ğ‘ implicit â€” our code currently does that.</p></blockquote><p>å¯¹äºé•œå­æ¥è¯´ï¼Œåªåœ¨ä¸€ä¸ªæ–¹å‘ä¸Šï¼Œ$s()$ æ˜¯å·¨å¤§çš„ï¼Œæ‰€ä»¥å®ƒæ›´é‡è¦ã€‚äº‹å®ä¸Šï¼Œå¤§å¤šæ•°æ¸²æŸ“å™¨éƒ½å°†é•œåƒä½œä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå¹¶ä¸”åªéšå¼åœ°ä½¿ç”¨ <em>s/p</em>â€”â€”æˆ‘ä»¬çš„ä»£ç ç›®å‰å°±æ˜¯è¿™æ ·åšçš„ã€‚</p><h4 id="Returning-to-the-Cornell-Box"><a href="#Returning-to-the-Cornell-Box" class="headerlink" title="Returning to the Cornell Box"></a>Returning to the Cornell Box</h4><blockquote><p>Letâ€™s do a simple refactoring and temporarily remove all materials that arenâ€™t Lambertian. We can use our Cornell Box scene again, and letâ€™s generate the camera in the function that generates the model.</p></blockquote><p>è®©æˆ‘ä»¬åšä¸€ä¸ªç®€å•çš„é‡æ„ï¼Œæš‚æ—¶åˆ é™¤æ‰€æœ‰ä¸å±äº Lambertian çš„ææ–™ã€‚æˆ‘ä»¬å¯ä»¥å†æ¬¡ä½¿ç”¨ Cornell Box åœºæ™¯ï¼Œè®©æˆ‘ä»¬åœ¨ç”Ÿæˆæ¨¡å‹çš„å‡½æ•°ä¸­ç”Ÿæˆæ‘„åƒæœºã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(...)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>{</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red   = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>,<span class="number">330</span>,<span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>,<span class="number">0</span>,<span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>,<span class="number">165</span>,<span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>,<span class="number">0</span>,<span class="number">65</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">1.0</span> / <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">600</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">cornell_box</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">color <span class="title">background</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> time0 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> time1 = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, time0, time1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"P3\n"</span> &lt;&lt; image_width &lt;&lt; <span class="string">' '</span> &lt;&lt; image_height &lt;&lt; <span class="string">"\n255\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) {</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>At 500Ã—500 my code produces this image in 10min on 1 core of my Macbook:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.01-cornell-refactor1.jpg"></p><blockquote><p>Reducing that noise is our goal. Weâ€™ll do that by constructing a PDF that sends more rays to the light.</p></blockquote><p>å‡å°‘å™ªéŸ³æ˜¯æˆ‘ä»¬çš„ç›®æ ‡ã€‚æˆ‘ä»¬å°†é€šè¿‡æ„å»ºä¸€ä¸ªå‘å…‰çº¿å‘å°„æ›´å¤šå°„çº¿çš„PDFæ¥å®ç°è¿™ä¸€ç‚¹ã€‚</p><blockquote><p>First, letâ€™s instrument the code so that it explicitly samples some PDF and then normalizes for that. Remember MC basics: $âˆ«ğ‘“(ğ‘¥)â‰ˆğ‘“(ğ‘Ÿ)/ğ‘(ğ‘Ÿ)$â€‹â€‹. For the Lambertian material, letâ€™s sample like we do now: $ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=\cos(ğœƒ)/ğœ‹$â€‹.</p></blockquote><p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬å¯¹ä»£ç è¿›è¡Œæµ‹è¯•ï¼Œä»¥ä¾¿å®ƒæ˜¾å¼åœ°å¯¹ä¸€äº›PDFè¿›è¡Œé‡‡æ ·ï¼Œç„¶åå¯¹å…¶è¿›è¡Œè§„èŒƒåŒ–ã€‚è®°ä½MCåŸºç¡€çŸ¥è¯†ï¼š$âˆ«ğ‘“(ğ‘¥)â‰ˆğ‘“(ğ‘Ÿ)/ğ‘(ğ‘Ÿ)$â€‹ã€‚å¯¹äºæœ—ä¼¯ææ–™ï¼Œè®©æˆ‘ä»¬åƒç°åœ¨ä¸€æ ·é‡‡æ ·: $p(direction)=\cos(Î¸)/Ï€$â€‹â€‹ã€‚</p><blockquote><p>We modify the base-class <code>material</code> to enable this importance sampling:</p></blockquote><p>æˆ‘ä»¬ä¿®æ”¹åŸºç±» <code>material</code> æ¥å¯ç”¨è¿™ä¸ªé‡è¦æŠ½æ ·:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class material {</span><br><span class="line">    public:</span><br><span class="line"></span><br><span class="line">        virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, color&amp; albedo, ray&amp; scattered, double&amp; pdf</span><br><span class="line"><span class="addition">+       ) const {</span></span><br><span class="line"><span class="addition">+           return false;</span></span><br><span class="line"><span class="addition">+       }</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+       virtual double scattering_pdf(</span></span><br><span class="line"><span class="addition">+           const ray&amp; r_in, const hit_record&amp; rec, const ray&amp; scattered</span></span><br><span class="line"><span class="addition">+       ) const {</span></span><br><span class="line"><span class="addition">+           return 0;</span></span><br><span class="line"><span class="addition">+       }</span></span><br><span class="line"></span><br><span class="line">        virtual vec3 emitted(double u, double v, const point3&amp; p) const {</span><br><span class="line">            return vec3(0,0,0);</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And <em>Lambertian</em> material becomes:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class material {</span><br><span class="line">public:</span><br><span class="line">    virtual vec3 emitted(double u, double v, const vec3&amp; p) const {</span><br><span class="line">        return vec3(0, 0, 0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in,const hit_record&amp; rec,vec3&amp; attenuation,ray&amp; scattered, double&amp; pdf</span><br><span class="line"><span class="addition">+           ) const {</span></span><br><span class="line"><span class="addition">+       return false;</span></span><br><span class="line"><span class="addition">+   };</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   virtual double scattering_pdf (</span></span><br><span class="line"><span class="addition">+           const ray&amp; r_in, const hit_record&amp; rec, const ray&amp; scattered</span></span><br><span class="line"><span class="addition">+           ) const {</span></span><br><span class="line"><span class="addition">+       return 0;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And the <code>ray_color</code> function gets a minor modification:</p></blockquote><p><code>ray_color</code> å‡½æ•°å¾—åˆ°äº†ä¸€ä¸ªå°ä¿®æ”¹:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(const ray&amp; r, const color&amp; background, const hittable&amp; world, int depth) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return color(0,0,0);</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (!world.hit(r, 0.001, infinity, rec))</span><br><span class="line">        return background;</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    vec3 attenuation;</span><br><span class="line">    vec3 emitted = rec.mat_ptr-&gt;emitted(rec.u, rec.v, rec.p);</span><br><span class="line"><span class="addition">+   double pdf;</span></span><br><span class="line"><span class="addition">+   vec3 albedo;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf))</span></span><br><span class="line"><span class="addition">+       return emitted;</span></span><br><span class="line"></span><br><span class="line">    return emitted</span><br><span class="line"><span class="addition">+        + albedo * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span></span><br><span class="line"><span class="addition">+                 * ray_color(scattered, background, world, depth-1) / pdf;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>You should get exactly the same picture.</p></blockquote><h4 id="Random-Hemisphere-Sampling"><a href="#Random-Hemisphere-Sampling" class="headerlink" title="Random Hemisphere Sampling"></a>Random Hemisphere Sampling</h4><blockquote><p>Now, just for the experience, try a different sampling strategy. As in the first book, Letâ€™s choose randomly from the hemisphere above the surface. This would be $ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=\frac{1}{2ğœ‹}$.</p></blockquote><p>ç°åœ¨ï¼Œä¸ºäº†ä½“éªŒï¼Œå°è¯•ä¸€ä¸ªä¸åŒçš„æŠ½æ ·ç­–ç•¥ã€‚å’Œç¬¬ä¸€æœ¬ä¹¦ä¸€æ ·ï¼Œè®©æˆ‘ä»¬ä»è¡¨é¢ä¸Šçš„åŠçƒä¸­éšæœºé€‰æ‹©ã€‚è¿™å°†æ˜¯ $p(direction)=1/2Ï€$</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; alb, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">unit_vector</span>(direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">    alb = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    pdf = <span class="number">0.5</span> / pi;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And again I <em>should</em> get the same picture except with different variance, but I donâ€™t!</p></blockquote><p>åŒæ ·ï¼Œæˆ‘åº”è¯¥å¾—åˆ°ç›¸åŒçš„å›¾åƒé™¤äº†ä¸åŒçš„æ–¹å·®ï¼Œä½†æˆ‘æ²¡æœ‰!</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.02-cornell-refactor2.jpg"></p><blockquote><p>Itâ€™s pretty close to our old picture, but there are differences that are not noise. The front of the tall box is much more uniform in color. So I have the most difficult kind of bug to find in a Monte Carlo program â€” a bug that produces a reasonable looking image. I also donâ€™t know if the bug is the first version of the program, or the second, or both!</p><p>Letâ€™s build some infrastructure to address this.</p></blockquote><p>å®ƒå’Œæˆ‘ä»¬çš„æ—§å›¾ç‰‡å¾ˆæ¥è¿‘ï¼Œä½†æ˜¯æœ‰ä¸€äº›åŒºåˆ«ä¸æ˜¯å™ªéŸ³ã€‚é«˜ç›’å­çš„æ­£é¢é¢œè‰²æ›´åŠ ç»Ÿä¸€ã€‚æ‰€ä»¥æˆ‘æœ‰ä¸€ä¸ªåœ¨è’™ç‰¹å¡ç½—ç¨‹åºä¸­æœ€éš¾æ‰¾åˆ°çš„é”™è¯¯â€”â€”ä¸€ä¸ªäº§ç”Ÿåˆç†å¤–è§‚å›¾åƒçš„é”™è¯¯ã€‚æˆ‘ä¹Ÿä¸çŸ¥é“è¿™ä¸ªbugæ˜¯ç¨‹åºçš„ç¬¬ä¸€ä¸ªç‰ˆæœ¬ï¼Œè¿˜æ˜¯ç¬¬äºŒä¸ªç‰ˆæœ¬ï¼Œæˆ–è€…ä¸¤è€…éƒ½æœ‰!</p><p>è®©æˆ‘ä»¬æ„å»ºä¸€äº›åŸºç¡€è®¾æ–½æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p><h3 id="ç”Ÿæˆéšæœºæ–¹å‘"><a href="#ç”Ÿæˆéšæœºæ–¹å‘" class="headerlink" title="ç”Ÿæˆéšæœºæ–¹å‘"></a>ç”Ÿæˆéšæœºæ–¹å‘</h3><blockquote><p>In this and the next two chapters, letâ€™s harden our understanding and tools and figure out which Cornell Box is right.</p></blockquote><p>åœ¨è¿™ä¸¤ç« å’Œæ¥ä¸‹æ¥çš„ä¸¤ç« ä¸­ï¼Œè®©æˆ‘ä»¬åŠ å¼ºæˆ‘ä»¬çš„ç†è§£å’Œå·¥å…·ï¼Œå¹¶æ‰¾å‡ºå“ªä¸ªCornell Boxæ˜¯æ­£ç¡®çš„ã€‚</p><h4 id="Random-Directions-Relative-to-the-Z-Axis"><a href="#Random-Directions-Relative-to-the-Z-Axis" class="headerlink" title="Random Directions Relative to the Z Axis"></a>Random Directions Relative to the Z Axis</h4><blockquote><p>Letâ€™s first figure out how to generate random directions. To simplify things, letâ€™s assume the z-axis is the surface normal, and $ğœƒ$ is the angle from the normal. Weâ€™ll get them oriented to the surface normal vector in the next chapter. We will only deal with distributions that are rotationally symmetric about $ğ‘§$. So $ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=ğ‘“(ğœƒ)$. If you have had advanced calculus, you may recall that on the sphere in spherical coordinates $ğ‘‘ğ´=sin(ğœƒ)â‹…ğ‘‘ğœƒâ‹…ğ‘‘ğœ™$. If you havenâ€™t, youâ€™ll have to take my word for the next step, but youâ€™ll get it when you take advanced calculus.</p></blockquote><p>è®©æˆ‘ä»¬å…ˆå¼„æ¸…æ¥šå¦‚ä½•ç”Ÿæˆéšæœºæ–¹å‘ã€‚ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å‡è®¾zè½´æ˜¯è¡¨é¢æ³•çº¿ï¼Œè€Œ $Î¸$ æ˜¯ä¸æ³•çº¿çš„è§’åº¦ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« ä¸­è®©å®ƒä»¬æŒ‡å‘æ›²é¢æ³•å‘é‡ã€‚æˆ‘ä»¬åªè®¨è®ºå…³äº z æ—‹è½¬å¯¹ç§°çš„åˆ†å¸ƒã€‚æ‰€ä»¥ $p(direction)=f(Î¸)$ å¦‚æœä½ å­¦è¿‡é«˜ç­‰å¾®ç§¯åˆ†ï¼Œä½ å¯èƒ½ä¼šè®°å¾—ï¼Œåœ¨çƒåæ ‡ä¸‹ $dA=sin(Î¸)â‹…dÎ¸â‹…dÏ•$ã€‚å¦‚æœä½ è¿˜æ²¡å­¦è¿‡ï¼Œä¸‹ä¸€æ­¥ä½ å°±å¾—å¬æˆ‘çš„äº†ï¼Œä½†ç­‰ä½ ä¸Šé«˜ç­‰å¾®ç§¯åˆ†çš„æ—¶å€™ä½ å°±ä¼šæ˜ç™½äº†ã€‚</p><blockquote><p>Given a directional PDF, $ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=ğ‘“(ğœƒ)$ on the sphere, the 1D PDFs on $ğœƒ$ and $ğœ™$ are:</p></blockquote><p>ç»™å®šä¸€ä¸ªå®šå‘PDFï¼Œ$p(direction) = f(Î¸)$ åœ¨çƒä½“ä¸Šï¼Œåœ¨ $\theta$ å’Œ $\phi$ ä¸Šçš„1D PDFæ˜¯:</p><p>$a(\phi) = \frac{1}{2\pi}$</p><blockquote><p>(uniform)</p></blockquote><p>$b(\theta) = 2 \pi f(\theta)\sin(\theta)$</p><blockquote><p>For uniform random numbers $ğ‘Ÿ_1$ and $ğ‘Ÿ_2$, the material presented in the <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#onedimensionalmcintegration">One Dimensional MC Integration</a> chapter leads to:</p></blockquote><p>å¯¹äºç»Ÿä¸€éšæœºæ•° $r_1$ å’Œ $r_2$ï¼Œä¸€ç»´MCé›†æˆä¸€ç« çš„å†…å®¹å¦‚ä¸‹:</p><p>$r_1 = \int_0^{\phi}{\frac{1}{2\pi}dt} = \frac{\phi}{2\pi}$</p><blockquote><p>Solving for $ğœ™$ we get:</p></blockquote><p>æ±‚è§£ $\phi$ æˆ‘ä»¬å¾—åˆ°:</p><p>$\phi = 2\pi \cdot r_1$</p><blockquote><p>For $ğœƒ$ we have:</p></blockquote><p>å¯¹äº $Î¸$ æˆ‘ä»¬æœ‰:</p><p>$r_2 = \int_0^{\theta}2\pi f(t)\sin(t)dt$</p><blockquote><p>Here, $ğ‘¡$ is a dummy variable. Letâ€™s try some different functions for $ğ‘“()$. Letâ€™s first try a uniform density on the sphere. The area of the unit sphere is $4ğœ‹$, so a uniform $ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=\frac{1}{4ğœ‹}$ on the unit sphere.</p></blockquote><p>è¿™é‡Œï¼Œ$t$ æ˜¯ä¸€ä¸ªå“‘å˜é‡ã€‚è®©æˆ‘ä»¬å°è¯•ä¸€äº›ä¸åŒçš„ $f()$ å‡½æ•°ã€‚é¦–å…ˆè®©æˆ‘ä»¬åœ¨çƒä½“ä¸Šå°è¯•å‡åŒ€å¯†åº¦ã€‚å•ä½çƒçš„é¢ç§¯æ˜¯ $4Ï€$â€‹ï¼Œæ‰€ä»¥å•ä½çƒä¸Šçš„ä¸€ä¸ªå‡åŒ€çš„$p(direction)=\frac{1}{4Ï€}$ã€‚<br>$$<br>r_2 = \int_0^{\theta}{2\pi \frac{1}{4 \pi} \sin(t)dt} \newline<br>= \int_0^{\theta}{\frac{1}{2} \sin(t)dt} \newline<br>= \frac{-\cos(\theta)}{2} - \frac{-\cos(0)}{2} \newline<br>= \frac{1 - \cos(\theta)}{2}<br>$$</p><blockquote><p>Solving for $\cos(ğœƒ)$ gives:</p></blockquote><p>æ±‚è§£ $\cos(Î¸)$ ç»™å‡º:</p><p>$\cos(\theta) = 1 - 2r_2$</p><blockquote><p>We donâ€™t solve for theta because we probably only need to know $\cos(ğœƒ)$ anyway, and donâ€™t want needless $\arccos()$ calls running around.</p></blockquote><p>æˆ‘ä»¬ä¸æ±‚è§£ï¼Œå› ä¸ºæˆ‘ä»¬å¯èƒ½åªéœ€è¦çŸ¥é“ $\cos(Î¸)$ï¼Œè€Œä¸å¸Œæœ›ä¸å¿…è¦çš„ $\arccos()$ è°ƒç”¨åˆ°å¤„è¿è¡Œã€‚</p><blockquote><p>To generate a unit vector direction toward $(ğœƒ,ğœ™)$ we convert to Cartesian coordinates:</p></blockquote><p>ä¸ºäº†ç”ŸæˆæŒ‡å‘ $(Î¸,Ï•)$ çš„å•ä½çŸ¢é‡ï¼Œæˆ‘ä»¬è½¬æ¢ä¸ºç¬›å¡å°”åæ ‡:<br>$$<br>x = \cos(\phi) \cdot \sin(\theta)	\space<br>y = \sin(\theta) \cdot \sin(\theta)	\space<br>z = \cos(\theta)<br>$$</p><blockquote><p>And using the identity that $\cos^2+\sin^2=1$, we get the following in terms of random $(ğ‘Ÿ_1,ğ‘Ÿ_2)$:</p></blockquote><p>ä½¿ç”¨æ’ç­‰å¼ $\cos^2 + \sin^2 = 1$ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹éšæœºçš„ $(r_1,r_2)$:<br>$$<br>x = \cos(2\pi \cdot r_1) \sqrt{1 - (1 - 2r_2)^2} \space<br>y = \sin(2\pi \cdot r_1) \sqrt{1 - (1 - 2r_2)^2} \space<br>z = 1 - 2r_2<br>$$</p><blockquote><p>Simplifying a little, $(1âˆ’2ğ‘Ÿ_2)^2=1âˆ’4ğ‘Ÿ_2+4ğ‘Ÿ_2^2$, so:</p></blockquote><p>ç®€åŒ–ä¸€ä¸‹ï¼Œ$(1âˆ’2ğ‘Ÿ_2)^2=1âˆ’4ğ‘Ÿ_2+4ğ‘Ÿ_2^2$â€‹ï¼Œæ‰€ä»¥ï¼š<br>$$<br>x = \cos(2\pi r_1) \cdot 2\sqrt{r_2(1-r_2)} \space<br>y - \sin(2\pi r_1) \cdot 2\sqrt{r_2(1-r_2)} \space<br>z = 1 - 2r_2<br>$$</p><blockquote><p>We can output some of these:</p></blockquote><p>æˆ‘ä»¬å¯ä»¥è¾“å‡ºå…¶ä¸­ä¸€äº›:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) {</span><br><span class="line">        <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">        <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">        <span class="keyword">auto</span> x = <span class="built_in">cos</span>(<span class="number">2</span>*pi*r1)*<span class="number">2</span>*<span class="built_in">sqrt</span>(r2*(<span class="number">1</span>-r2));</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">sin</span>(<span class="number">2</span>*pi*r1)*<span class="number">2</span>*<span class="built_in">sqrt</span>(r2*(<span class="number">1</span>-r2));</span><br><span class="line">        <span class="keyword">auto</span> z = <span class="number">1</span> - <span class="number">2</span>*r2;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="string">" "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And plot them for free on plot.ly (a great site with 3D scatterplot support):</p></blockquote><p>ç„¶ååœ¨åœ°å›¾ä¸Šå…è´¹æ ‡å‡ºå®ƒä»¬ã€‚ly(ä¸€ä¸ªå¾ˆæ£’çš„ç½‘ç«™ï¼Œæ”¯æŒ3Dæ•£ç‚¹å›¾):</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.06-rand-pts-sphere.jpg"></p><blockquote><p>On the plot.ly website you can rotate that around and see that it appears uniform.</p></blockquote><p>ä½ å¯ä»¥æ—‹è½¬å®ƒï¼Œçœ‹åˆ°å®ƒçœ‹èµ·æ¥æ˜¯ä¸€è‡´çš„ã€‚</p><h4 id="Uniform-Sampling-a-Hemisphere"><a href="#Uniform-Sampling-a-Hemisphere" class="headerlink" title="Uniform Sampling a Hemisphere"></a>Uniform Sampling a Hemisphere</h4><blockquote><p>Now letâ€™s derive uniform on the hemisphere. The density being uniform on the hemisphere means $ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=\frac{1}{2ğœ‹}$â€‹. Just changing the constant in the theta equations yields:</p></blockquote><p>ç°åœ¨æˆ‘ä»¬æ¥æ¨å¯¼åŠçƒä¸Šçš„å‡åŒ€æ€§ã€‚å¯†åº¦åœ¨åŠçƒä¸Šæ˜¯å‡åŒ€çš„ï¼Œæ„å‘³ç€ $p(direction)= \frac{1}{2\pi}$â€‹ã€‚åªè¦æ”¹å˜æ–¹ç¨‹ä¸­çš„å¸¸æ•°å°±èƒ½å¾—åˆ°:<br>$$<br>\cos(\theta) = 1 - r^2<br>$$</p><blockquote><p>It is comforting that $\cos(ğœƒ)$ will vary from 1 to 0, and thus theta will vary from 0 to ğœ‹/2. Rather than plot it, letâ€™s do a 2D integral with a known solution. Letâ€™s integrate cosine cubed over the hemisphere (just picking something arbitrary with a known solution). First letâ€™s do it by hand:</p></blockquote><p>$$<br>\int{\cos^3(\theta)dA} = \int_0^{2\pi} \int_0^{\pi/2}{\cos^3(\theta) \sin(\theta)d\theta d\phi} = 2\pi \int_0^{\pi/2}{\cos^3(\theta})\sin(\theta) = \frac{\pi}{2}<br>$$</p><blockquote><p>Now for integration with importance sampling. $ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=\frac{1}{2ğœ‹}$, so we average $ğ‘“/ğ‘$ which is $cos^3(ğœƒ)/(1/2ğœ‹)$, and we can test this:</p></blockquote><p>ä¸‹é¢æ˜¯é‡è¦æŠ½æ ·çš„é›†æˆã€‚$p(direction)=\frac{1}{2Ï€}$ï¼Œæ‰€ä»¥æˆ‘ä»¬å– $f/p$ çš„å¹³å‡å€¼ï¼Œå³ $cos^3(ğœƒ)/(1/2ğœ‹)$ï¼Œæˆ‘ä»¬å¯ä»¥æµ‹è¯•è¿™ä¸ª:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">        <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">        <span class="keyword">auto</span> x = <span class="built_in">cos</span>(<span class="number">2</span>*pi*r1)*<span class="number">2</span>*<span class="built_in">sqrt</span>(r2*(<span class="number">1</span>-r2));</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">sin</span>(<span class="number">2</span>*pi*r1)*<span class="number">2</span>*<span class="built_in">sqrt</span>(r2*(<span class="number">1</span>-r2));</span><br><span class="line">        <span class="keyword">auto</span> z = <span class="number">1</span> - r2;</span><br><span class="line">        sum += z*z*z / (<span class="number">1.0</span>/(<span class="number">2.0</span>*pi));</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Pi/2     = "</span> &lt;&lt; pi/<span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Estimate = "</span> &lt;&lt; sum/N &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Now letâ€™s generate directions with ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ )=cos(ğœƒ)/ğœ‹.</p></blockquote><p>ç°åœ¨è®©æˆ‘ä»¬ç”¨ p(directions)=cos(Î¸)/Ï€ æ¥ç”Ÿæˆæ–¹å‘ã€‚<br>$$<br>r_2 = \int_0^{\theta}{2\pi \frac{\cos(t)}{\pi} \sin(t) = 1 - \cos^2(\theta)}<br>$$</p><blockquote><p>So,</p></blockquote><p>$$<br>\cos(\theta) = \sqrt{1 - r_2}<br>$$</p><blockquote><p>We can save a little algebra on specific cases by noting</p></blockquote><p>é€šè¿‡æ ‡æ³¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ç‰¹å®šæƒ…å†µä¸‹èŠ‚çœä¸€äº›ä»£æ•°è¿ç®—<br>$$<br>z = \cos(\theta) = \sqrt{1 - r_2}<br>$$</p><p>$$<br>x = \cos(\phi)\sin(\theta) = \cos(2\pi r_1)\sqrt{1 - z^2} = \cos(2\pi r_1)\sqrt{r_2}<br>$$</p><p>$$<br>y = \sin(\phi)\sin(\theta) = \sin(2\pi r_1)\sqrt{1 - z^2} = \sin(2 \pi r_2)<br>$$</p><blockquote><p>Letâ€™s also start generating them as random vectors:</p></blockquote><p>è®©æˆ‘ä»¬å¼€å§‹ä»¥éšæœºå‘é‡çš„å½¢å¼ç”Ÿæˆå®ƒä»¬:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtweekend.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_cosine_direction</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">sqrt</span>(<span class="number">1</span>-r2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="number">2</span>*pi*r1;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi)*<span class="built_in">sqrt</span>(r2);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi)*<span class="built_in">sqrt</span>(r2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">random_cosine_direction</span>();</span><br><span class="line">        sum += v.<span class="built_in">z</span>()*v.<span class="built_in">z</span>()*v.<span class="built_in">z</span>() / (v.<span class="built_in">z</span>()/pi);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Pi/2     = "</span> &lt;&lt; pi/<span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Estimate = "</span> &lt;&lt; sum/N &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can generate other densities later as we need them. In the next chapter weâ€™ll get them aligned to the surface normal vector.</p></blockquote><p>æˆ‘ä»¬å¯ä»¥åœ¨ä»¥åéœ€è¦æ—¶ç”Ÿæˆå…¶ä»–å¯†åº¦ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†è®©å®ƒä»¬ä¸è¡¨é¢æ³•å‘é‡å¯¹é½ã€‚</p><h3 id="æ ‡å‡†æ­£äº¤åŸº"><a href="#æ ‡å‡†æ­£äº¤åŸº" class="headerlink" title="æ ‡å‡†æ­£äº¤åŸº"></a>æ ‡å‡†æ­£äº¤åŸº</h3><blockquote><p>In the last chapter we developed methods to generate random directions relative to the Z-axis. Weâ€™d like to be able to do that relative to a surface normal vector.</p></blockquote><p>åœ¨æœ€åä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å¼€å‘äº†ç”Ÿæˆç›¸å¯¹äºzè½´çš„éšæœºæ–¹å‘çš„æ–¹æ³•ã€‚æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿç›¸å¯¹äºæ›²é¢æ³•å‘é‡æ¥åšè¿™ä¸ªã€‚</p><h4 id="Relative-Coordinates"><a href="#Relative-Coordinates" class="headerlink" title="Relative Coordinates"></a>Relative Coordinates</h4><blockquote><p>An orthonormal basis (ONB) is a collection of three mutually orthogonal unit vectors. The Cartesian XYZ axes are one such ONB, and I sometimes forget that it has to sit in some real place with real orientation to have meaning in the real world, and some virtual place and orientation in the virtual world. A picture is a result of the relative positions/orientations of the camera and scene, so as long as the camera and scene are described in the same coordinate system, all is well.</p></blockquote><p>ä¸€ä¸ªæ ‡å‡†æ­£äº¤åŸº(ONB)æ˜¯ä¸‰ä¸ªç›¸äº’æ­£äº¤çš„å•ä½å‘é‡çš„é›†åˆã€‚ç¬›å¡å°”çš„XYZè½´å°±æ˜¯è¿™æ ·ä¸€ä¸ªONBï¼Œæˆ‘æœ‰æ—¶ä¼šå¿˜è®°å®ƒå¿…é¡»ä½äºçœŸå®çš„ä½ç½®ï¼Œå…·æœ‰çœŸå®çš„æ–¹å‘ï¼Œæ‰èƒ½åœ¨ç°å®ä¸–ç•Œä¸­æœ‰æ„ä¹‰ï¼Œåœ¨è™šæ‹Ÿä¸–ç•Œä¸­ä¹Ÿæœ‰è™šæ‹Ÿçš„ä½ç½®å’Œæ–¹å‘ã€‚å›¾ç‰‡æ˜¯ç›¸æœºå’Œåœºæ™¯çš„ç›¸å¯¹ä½ç½®/æ–¹å‘çš„ç»“æœï¼Œæ‰€ä»¥åªè¦ç›¸æœºå’Œåœºæ™¯åœ¨åŒä¸€ä¸ªåæ ‡ç³»ä¸­æè¿°ï¼Œä¸€åˆ‡éƒ½å¥½ã€‚</p><blockquote><p>Suppose we have an origin <strong>ğ</strong> and cartesian unit vectors <strong>ğ±</strong>, <strong>ğ²</strong>, and <strong>ğ³</strong>. When we say a location is (3,-2,7), we really are saying:</p></blockquote><p>å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåŸç‚¹ <strong>O</strong> å’Œç¬›å¡å­å•ä½å‘é‡ <strong>x</strong>ã€ <strong>y</strong> å’Œ <strong>z</strong>ã€‚å½“æˆ‘ä»¬è¯´ä¸€ä¸ªä½ç½®æ˜¯(3ï¼Œ-2,7)æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨è¯´:<br>$$<br>Location \space is \space O + 3x - 2y + 7z<br>$$</p><blockquote><p>If we want to measure coordinates in another coordinate system with origin <strong>ğ</strong>â€² and basis vectors <strong>ğ®</strong>, <strong>ğ¯</strong>, and <strong>ğ°</strong>, we can just find the numbers (ğ‘¢,ğ‘£,ğ‘¤) such that:</p></blockquote><p>å¦‚æœæˆ‘ä»¬æƒ³æµ‹é‡å¦ä¸€ä¸ªä»¥åŸç‚¹ $\mathbf{O}â€™$ å’ŒåŸºå‘é‡ $\mathbf{u}$ã€$\mathbf{v}$ å’Œ $\mathbf{w}$ ä¸ºåŸç‚¹çš„åæ ‡ç³»ä¸­çš„åæ ‡ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°æ•°å­— $(u,v,w)$ï¼Œè¿™æ ·:<br>$$<br>Location \space is \space Oâ€™ + ğ‘¢\mathbf{u} + v\mathbf{v} + w\mathbf{w}<br>$$</p><h4 id="Generating-an-Orthonormal-Basis"><a href="#Generating-an-Orthonormal-Basis" class="headerlink" title="Generating an Orthonormal Basis"></a>Generating an Orthonormal Basis</h4><blockquote><p>If you take an intro graphics course, there will be a lot of time spent on coordinate systems and 4Ã—4 coordinate transformation matrices. Pay attention, itâ€™s important stuff in graphics! But we wonâ€™t need it. What we need to is generate random directions with a set distribution relative to <strong>ğ§</strong>. We donâ€™t need an origin because a direction is relative to no specified origin. We do need two cotangent vectors that are mutually perpendicular to <strong>ğ§</strong> and to each other.</p></blockquote><p>å¦‚æœä½ ä¸Šäº†ä¸€é—¨å›¾å½¢å…¥é—¨è¯¾ç¨‹ï¼Œä½ ä¼šèŠ±å¾ˆå¤šæ—¶é—´å­¦ä¹ åæ ‡ç³»ç»Ÿå’Œ 4Ã—4 åæ ‡å˜æ¢çŸ©é˜µã€‚æ³¨æ„äº†ï¼Œè¿™æ˜¯å›¾åƒä¸­çš„é‡è¦å†…å®¹!ä½†æˆ‘ä»¬ä¸éœ€è¦å®ƒã€‚æˆ‘ä»¬éœ€è¦çš„æ˜¯ç”¨ç›¸å¯¹äº $\mathbf{n}$ çš„é›†åˆåˆ†å¸ƒç”Ÿæˆéšæœºæ–¹å‘ã€‚æˆ‘ä»¬ä¸éœ€è¦åŸç‚¹ï¼Œå› ä¸ºæ–¹å‘ç›¸å¯¹äºæ²¡æœ‰ç‰¹å®šçš„åŸç‚¹ã€‚æˆ‘ä»¬ç¡®å®éœ€è¦ä¸¤ä¸ªä½™åˆ‡å‘é‡ï¼Œå®ƒä»¬ç›¸äº’å‚ç›´äº $\mathbf{n}$ å¹¶ä¸”å½¼æ­¤å‚ç›´ã€‚</p><blockquote><p>Some models will come with one or more cotangent vectors. If our model has only one cotangent vector, then the process of making an ONB is a nontrivial one. Suppose we have any vector <strong>ğš</strong> that is of nonzero length and not parallel to <strong>ğ§</strong>. We can get vectors <strong>ğ¬</strong> and <strong>ğ­</strong>t perpendicular to <strong>ğ§</strong> by using the property of the cross product that <strong>ğœ</strong>Ã—<strong>ğ</strong>cÃ—d is perpendicular to both <strong>ğœ</strong> and <strong>ğ</strong>:</p></blockquote><p>æœ‰äº›æ¨¡å‹ä¼šå¸¦æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªä½™åˆ‡å‘é‡ã€‚å¦‚æœæˆ‘ä»¬çš„æ¨¡å‹åªæœ‰ä¸€ä¸ªä½™åˆ‡å‘é‡ï¼Œé‚£ä¹ˆç”ŸæˆONBçš„è¿‡ç¨‹å°±ä¸æ˜¯ç®€å•çš„äº†ã€‚å‡è®¾æœ‰ä»»ä½•é•¿åº¦éé›¶ä¸”ä¸å¹³è¡Œäº $\mathbf{n}$ çš„å‘é‡ $\mathbf{a}$ã€‚é€šè¿‡ä½¿ç”¨ $\mathbf{c}$ ä¹˜ä»¥ $\mathbf{d}$ åŒæ—¶å‚ç›´äº $\mathbf{c}$ å’Œ $\mathbf{d}$â€‹ çš„å‰ç§¯å±æ€§ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å‚ç›´äº $\mathbf{s}$ å’Œ $\mathbf{t}$ çš„å‘é‡:<br>$$<br>\mathbf{t} = unit_vector(\mathbf a \times \mathbf n)<br>$$</p><p>$$<br>\mathbf{s} = \mathbf{t} \times \mathbf{n}<br>$$</p><blockquote><p>This is all well and good, but the catch is that we may not be given an <strong>ğš</strong> when we load a model, and we donâ€™t have an <strong>ğš</strong> with our existing program. If we went ahead and picked an arbitrary <strong>ğš</strong> to use as our initial vector we may get an <strong>ğš</strong>a that is parallel to <strong>ğ§</strong>. A common method is to use an if-statement to determine whether <strong>ğ§</strong> is a particular axis, and if not, use that axis.</p></blockquote><p>è¿™ä¸€åˆ‡éƒ½å¾ˆå¥½ï¼Œä½†é—®é¢˜æ˜¯ï¼Œåœ¨åŠ è½½æ¨¡å‹æ—¶ï¼Œå¯èƒ½ä¸ä¼šç»™æˆ‘ä»¬ä¸€ä¸ª <strong>a</strong>ï¼Œè€Œä¸”åœ¨ç°æœ‰çš„ç¨‹åºä¸­ä¹Ÿæ²¡æœ‰ <strong>a</strong>ã€‚å¦‚æœæˆ‘ä»¬ç»§ç»­å¹¶é€‰æ‹©ä¸€ä¸ªä»»æ„çš„ <strong>a</strong> ä½œä¸ºåˆå§‹å‘é‡ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¾—åˆ°ä¸€ä¸ªä¸ <strong>n</strong> å¹¶è¡Œçš„ <strong>a</strong>ã€‚ä¸€ä¸ªå¸¸è§çš„æ–¹æ³•æ˜¯ä½¿ç”¨ifè¯­å¥æ¥ç¡®å®š <strong>n</strong> æ˜¯å¦æ˜¯ä¸€ä¸ªç‰¹å®šçš„è½´ï¼Œå¦‚æœä¸æ˜¯ï¼Œå°±ä½¿ç”¨è¿™ä¸ªè½´ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">absolute</span><span class="params">(n.x &gt; <span class="number">0.9</span>)</span></span></span><br><span class="line"><span class="function">    a â† <span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span></span></span><br><span class="line"><span class="function">    a â† <span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Once we have an ONB of <strong>ğ¬</strong>, <strong>ğ­</strong>, and <strong>ğ§</strong>, and we have a ğ‘Ÿğ‘ğ‘›ğ‘‘ğ‘œğ‘š(ğ‘¥,ğ‘¦,ğ‘§) relative to the Z-axis, we can get the vector relative to <strong>ğ§</strong> as:</p></blockquote><p>ä¸€æ—¦æˆ‘ä»¬æœ‰äº†ä¸€ä¸ª <strong>s</strong>ï¼Œ <strong>t</strong>ï¼Œå’Œ <strong>n</strong> çš„ONBï¼Œå¹¶ä¸”æœ‰äº†ä¸€ä¸ªç›¸å¯¹äºzè½´çš„random(x,y,z)ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°ç›¸å¯¹äº <strong>n</strong> çš„å‘é‡:<br>$$<br>Random \space vector = x\mathbf s + y\mathbf t + z\mathbf n<br>$$</p><blockquote><p>You may notice we used similar math to get rays from a camera. That could be viewed as a change to the cameraâ€™s natural coordinate system.</p></blockquote><p>ä½ å¯èƒ½ä¼šæ³¨æ„åˆ°ï¼Œæˆ‘ä»¬ç”¨ç±»ä¼¼çš„æ•°å­¦æ–¹æ³•ä»ç›¸æœºä¸­è·å–å…‰çº¿ã€‚è¿™å¯ä»¥çœ‹ä½œæ˜¯ç›¸æœºè‡ªç„¶åæ ‡ç³»ç»Ÿçš„æ”¹å˜ã€‚</p><h4 id="The-ONB-Class"><a href="#The-ONB-Class" class="headerlink" title="The ONB Class"></a>The ONB Class</h4><blockquote><p>Should we make a class for ONBs, or are utility functions enough? Iâ€™m not sure, but letâ€™s make a class because it wonâ€™t really be more complicated than utility functions:</p></blockquote><p>æˆ‘ä»¬åº”è¯¥ä¸ºonbåˆ›å»ºä¸€ä¸ªç±»ï¼Œè¿˜æ˜¯å®ç”¨å‡½æ•°å°±è¶³å¤Ÿäº†?æˆ‘ä¸ç¡®å®šï¼Œä½†è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªç±»ï¼Œå› ä¸ºå®ƒä¸ä¼šæ¯”å®ç”¨å‡½æ•°æ›´å¤æ‚:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONB_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">onb</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">onb</span>() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">inline</span> vec3 <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> { <span class="keyword">return</span> axis[i]; }</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">u</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> axis[<span class="number">0</span>]; }</span><br><span class="line">        <span class="function">vec3 <span class="title">v</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> axis[<span class="number">1</span>]; }</span><br><span class="line">        <span class="function">vec3 <span class="title">w</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> axis[<span class="number">2</span>]; }</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> a*<span class="built_in">u</span>() + b*<span class="built_in">v</span>() + c*<span class="built_in">w</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">const</span> vec3&amp; a)</span> <span class="type">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> a.<span class="built_in">x</span>()*<span class="built_in">u</span>() + a.<span class="built_in">y</span>()*<span class="built_in">v</span>() + a.<span class="built_in">z</span>()*<span class="built_in">w</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 axis[<span class="number">3</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onb::build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp; n)</span> </span>{</span><br><span class="line">    axis[<span class="number">2</span>] = <span class="built_in">unit_vector</span>(n);</span><br><span class="line">    vec3 a = (<span class="built_in">fabs</span>(<span class="built_in">w</span>().<span class="built_in">x</span>()) &gt; <span class="number">0.9</span>) ? <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>) : <span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    axis[<span class="number">1</span>] = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(<span class="built_in">w</span>(), a));</span><br><span class="line">    axis[<span class="number">0</span>] = <span class="built_in">cross</span>(<span class="built_in">w</span>(), <span class="built_in">v</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can rewrite our Lambertian material using this to get:</p></blockquote><p>æˆ‘ä»¬å¯ä»¥ç”¨è¿™ä¸ªæ”¹å†™æœ—ä¼¯å…¬å¼å¾—åˆ°</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">virtual bool scatter(</span><br><span class="line">    const ray&amp; r_in, const hit_record&amp; rec, color&amp; alb, ray&amp; scattered, double&amp; pdf</span><br><span class="line">) const override {</span><br><span class="line"><span class="addition">+   onb uvw;</span></span><br><span class="line"><span class="addition">+   uvw.build_from_w(rec.normal);</span></span><br><span class="line"><span class="addition">+   auto direction = uvw.local(random_cosine_direction());</span></span><br><span class="line">    scattered = ray(rec.p, unit_vector(direction), r_in.time());</span><br><span class="line">    alb = albedo-&gt;value(rec.u, rec.v, rec.p);</span><br><span class="line"><span class="addition">+   pdf = dot(uvw.w(), scattered.direction()) / pi;</span></span><br><span class="line">    return true;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which produces:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.03-cornell-ortho.jpg"></p><blockquote><p>Is that right? We still donâ€™t know for sure. Tracking down bugs is hard in the absence of reliable reference solutions. Letâ€™s table that for now and get rid of some of that noise.</p></blockquote><p>æ˜¯è¿™æ ·å—?æˆ‘ä»¬è¿˜ä¸ç¡®å®šã€‚åœ¨ç¼ºä¹å¯é çš„å‚è€ƒè§£å†³æ–¹æ¡ˆçš„æƒ…å†µä¸‹ï¼Œè¿½è¸ªbugæ˜¯å¾ˆå›°éš¾çš„ã€‚æˆ‘ä»¬å…ˆæŠŠå®ƒæ”¾åœ¨æ¡Œå­ä¸Šï¼Œå»æ‰ä¸€äº›æ‚éŸ³ã€‚</p><h3 id="ç›´æ¥å…‰æºé‡‡æ ·"><a href="#ç›´æ¥å…‰æºé‡‡æ ·" class="headerlink" title="ç›´æ¥å…‰æºé‡‡æ ·"></a>ç›´æ¥å…‰æºé‡‡æ ·</h3><blockquote><p>The problem with sampling almost uniformly over directions is that lights are not sampled any more than unimportant directions. We could use shadow rays and separate out direct lighting. Instead, Iâ€™ll just send more rays to the light. We can then use that later to send more rays in whatever direction we want.</p><p>Itâ€™s really easy to pick a random direction toward the light; just pick a random point on the light and send a ray in that direction. We also need to know the PDF, ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›). What is that?</p></blockquote><p>å¯¹æ–¹å‘è¿›è¡Œå‡ ä¹ä¸€è‡´çš„é‡‡æ ·çš„é—®é¢˜æ˜¯ï¼Œå…‰çš„é‡‡æ ·å¹¶ä¸æ¯”ä¸é‡è¦çš„æ–¹å‘å¤šã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨é˜´å½±å…‰çº¿æ¥åˆ†ç¦»ç›´æ¥ç…§æ˜ã€‚ç›¸åï¼Œæˆ‘å°†å‘å…‰å‘å°„æ›´å¤šçš„å°„çº¿ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥ç”¨å®ƒå‘ä»»ä½•æˆ‘ä»¬æƒ³è¦çš„æ–¹å‘å‘é€æ›´å¤šçš„å°„çº¿ã€‚</p><p>æˆ‘ä»¬å¾ˆå®¹æ˜“é€‰æ‹©ä¸€ä¸ªéšæœºçš„æœå‘å…‰çš„æ–¹å‘;åœ¨å…‰ä¸Šéšä¾¿é€‰ä¸€ä¸ªç‚¹ï¼Œç„¶åå¾€é‚£ä¸ªæ–¹å‘å‘é€ä¸€æ¡å°„çº¿ã€‚æˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“PDFï¼Œ $p(direction)$ã€‚é‚£æ˜¯ä»€ä¹ˆ?</p><h4 id="Getting-the-PDF-of-a-Light"><a href="#Getting-the-PDF-of-a-Light" class="headerlink" title="Getting the PDF of a Light"></a>Getting the PDF of a Light</h4><blockquote><p>For a light of area ğ´, if we sample uniformly on that light, the PDF on the surface of the light is $\frac{1}{ğ´}$. What is it on the area of the unit sphere that defines directions? Fortunately, there is a simple correspondence, as outlined in the diagram:</p></blockquote><p>å¯¹äºä¸€ä¸ªåŒºåŸŸ(a)çš„å…‰ï¼Œå¦‚æœæˆ‘ä»¬åœ¨è¯¥å…‰ä¸Šå‡åŒ€é‡‡æ ·ï¼Œå…‰è¡¨é¢çš„PDFæ˜¯ $\frac{1}{a}$ã€‚åœ¨å•ä½çƒçš„é¢ç§¯ä¸Šæ˜¯ä»€ä¹ˆå®šä¹‰äº†æ–¹å‘?å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸€ä¸ªç®€å•çš„å¯¹åº”å…³ç³»ï¼Œå¦‚å›¾æ‰€ç¤º:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.07-shape-onto-pdf.jpg"></p><blockquote><p>If we look at a small area ğ‘‘ğ´ on the light, the probability of sampling it is $ğ‘_ğ‘(ğ‘)â‹…ğ‘‘ğ´$. On the sphere, the probability of sampling the small area ğ‘‘ğ‘¤ on the sphere is $ğ‘(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)â‹…ğ‘‘ğ‘¤$. There is a geometric relationship between ğ‘‘ğ‘¤ and ğ‘‘ğ´:</p></blockquote><p>$$<br>d\omega = \frac{dA \cdot \cos(alpha)}{distance^2(p,q)}<br>$$</p><blockquote><p>Since the probability of sampling dw and dA must be the same, we have</p></blockquote><p>$$<br>p(direction) \cdot \frac{dA \cdot \cos(alpha)}{distance^2(p,q)} = p_q(q) \cdot dA = \frac{dA}{A}<br>$$</p><blockquote><p>So</p></blockquote><p>$$<br>p(direction) = \frac{distance^2(p,q)}{\cos(alpha) \cdot A}<br>$$</p><h4 id="Light-Sampling"><a href="#Light-Sampling" class="headerlink" title="Light Sampling"></a>Light Sampling</h4><blockquote><p>If we hack our <code>ray_color()</code> function to sample the light in a very hard-coded fashion just to check that math and get the concept, we can add it (see the highlighted region):</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(const ray&amp; r, const vec3&amp; background, const hittable&amp; world,int depth) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return vec3(0,0,0);</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (!world.hit(r,0.001,infinity,rec))</span><br><span class="line">        return background;</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    vec3 attenuation;</span><br><span class="line">    vec3 emitted = rec.mat_ptr-&gt;emitted(rec.u, rec.v, rec.p);</span><br><span class="line">    double pdf;</span><br><span class="line">    vec3 albedo;</span><br><span class="line"></span><br><span class="line">    if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf))</span><br><span class="line">        return emitted;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto on_light = vec3(random_double(213, 343), 554, random_double(227, 332));</span></span><br><span class="line"><span class="addition">+   auto to_light = on_light - rec.p;</span></span><br><span class="line"><span class="addition">+   auto distance_squared = to_light.length_squared();</span></span><br><span class="line"><span class="addition">+   to_light = unit_vector(to_light);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (dot(to_light, rec.normal) &lt; 0)</span></span><br><span class="line"><span class="addition">+       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   double light_area = (343 - 213) * (332 - 227);</span></span><br><span class="line"><span class="addition">+   auto light_cosine = fabs(to_light.y());</span></span><br><span class="line"><span class="addition">+   if (light_cosine &lt; 0.000001)</span></span><br><span class="line"><span class="addition">+       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   pdf = distance_squared / (light_cosine * light_area);</span></span><br><span class="line"><span class="addition">+   scattered = ray(rec.p, to_light, r.time());</span></span><br><span class="line"></span><br><span class="line">    return emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span><br><span class="line">                      * ray_color(scattered, background, world, depth - 1) / pdf;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>With 10 samples per pixel this yields:</p></blockquote><p>å¦‚æœæ¯åƒç´ 10ä¸ªæ ·æœ¬ï¼Œå°±ä¼šäº§ç”Ÿ:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.04-cornell-sample-light.jpg"></p><blockquote><p>This is about what we would expect from something that samples only the light sources, so this appears to work.</p></blockquote><p>è¿™æ˜¯æˆ‘ä»¬ä»åªé‡‡æ ·å…‰æºçš„ä¸œè¥¿ä¸­æ‰€æœŸæœ›çš„ï¼Œæ‰€ä»¥è¿™ä¼¼ä¹æ˜¯å¯è¡Œçš„ã€‚</p><h4 id="Switching-to-Unidirectional-Light"><a href="#Switching-to-Unidirectional-Light" class="headerlink" title="Switching to Unidirectional Light"></a>Switching to Unidirectional Light</h4><blockquote><p>The noisy pops around the light on the ceiling are because the light is two-sided and there is a small space between light and ceiling. We probably want to have the light just emit down. We can do that by letting the emitted member function of hittable take extra information:</p></blockquote><p>å¤©èŠ±æ¿ä¸Šçš„ç¯å‘¨å›´å˜ˆæ‚çš„ç °ç °å£°æ˜¯å› ä¸ºç¯æ˜¯åŒé¢çš„ï¼Œç¯å’Œå¤©èŠ±æ¿ä¹‹é—´æœ‰ä¸€ä¸ªå¾ˆå°çš„ç©ºé—´ã€‚æˆ‘ä»¬å¯èƒ½æƒ³è®©å…‰å‘å°„ä¸‹å»ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è®©hittableå‘å‡ºçš„æˆå‘˜å‡½æ•°è·å–é¢å¤–çš„ä¿¡æ¯æ¥åšåˆ°è¿™ä¸€ç‚¹:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> vec3 <span class="title">emitted</span><span class="params">(<span class="type">const</span> ray&amp;r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (rec.front_face)</span><br><span class="line">        <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Making sure to call this in our world definition:</p></blockquote><p>ç¡®ä¿åœ¨æˆ‘ä»¬çš„ä¸–ç•Œå®šä¹‰ä¸­è°ƒç”¨å®ƒ:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list cornell_box_plus() {</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    auto red = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.65, 0.05, 0.05)));</span><br><span class="line">    auto white = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.73, 0.73, 0.73)));</span><br><span class="line">    auto green = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.12, 0.45, 0.15)));</span><br><span class="line">    auto light = make_shared&lt;diffuse_light&gt;(make_shared&lt;constant_texture&gt;(vec3(15, 15, 15)));</span><br><span class="line"></span><br><span class="line">    objects.add(make_shared&lt;yz_rect&gt;(0, 555, 0, 555, 555, green));</span><br><span class="line">    objects.add(make_shared&lt;yz_rect&gt;(0, 555, 0, 555, 0, red));</span><br><span class="line"><span class="addition">+   objects.add(make_shared&lt;flip_face&gt;(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, light)));</span></span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, light));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(0, 555, 0, 555, 555, white));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(0, 555, 0, 555, 0, white));</span><br><span class="line">    objects.add(make_shared&lt;xy_rect&gt;(0, 555, 0, 555, 555, white));</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This gives us:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.05-cornell-lightdown.jpg"></p><h3 id="æ··åˆå¯†åº¦"><a href="#æ··åˆå¯†åº¦" class="headerlink" title="æ··åˆå¯†åº¦"></a>æ··åˆå¯†åº¦</h3><blockquote><p>We have used a PDF related to cos(ğœƒ), and a PDF related to sampling the light. We would like a PDF that combines these.</p></blockquote><p>æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªä¸ $\cos(\theta)$ æœ‰å…³çš„PDFï¼Œä»¥åŠä¸€ä¸ªä¸å…‰çº¿é‡‡æ ·æœ‰å…³çš„PDFã€‚æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªç»“åˆè¿™äº›çš„PDFã€‚</p><h4 id="An-Average-of-Lighting-and-Reflection"><a href="#An-Average-of-Lighting-and-Reflection" class="headerlink" title="An Average of Lighting and Reflection"></a>An Average of Lighting and Reflection</h4><blockquote><p>A common tool in probability is to mix the densities to form a mixture density. Any weighted average of PDFs is a PDF. For example, we could just average the two densities:</p></blockquote><p>æ¦‚ç‡è®ºä¸­çš„ä¸€ä¸ªå¸¸ç”¨å·¥å…·æ˜¯å°†å¯†åº¦æ··åˆï¼Œå½¢æˆä¸€ä¸ªæ··åˆå¯†åº¦ã€‚ä»»ä½•PDFçš„åŠ æƒå¹³å‡å€¼éƒ½æ˜¯PDFã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å–ä¸¤ä¸ªå¯†åº¦çš„å¹³å‡å€¼:<br>$$<br>mixture_{pdf}(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)=\frac{1}{2}reflection_{pdf}(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)+\frac{1}{2}light_{pdf}(ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›)<br>$$</p><blockquote><p>How would we instrument our code to do that? There is a very important detail that makes this not quite as easy as one might expect. Choosing the random direction is simple:</p></blockquote><p>æˆ‘ä»¬è¯¥å¦‚ä½•ç¼–å†™ä»£ç æ¥å®ç°è¿™ä¸€ç‚¹å‘¢?æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„ç»†èŠ‚ä½¿å¾—è¿™å¹¶ä¸åƒäººä»¬æƒ³è±¡çš„é‚£ä¹ˆå®¹æ˜“ã€‚é€‰æ‹©éšæœºæ–¹å‘å¾ˆç®€å•:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>)</span><br><span class="line">    pick direction according to pdf_reflection</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    pick direction according to pdf_light</span><br></pre></td></tr></tbody></table></figure><blockquote><p>But evaluating $mixture_{pdf}$ is slightly more subtle. We need to evaluate both $reflection_{pdf}$ and $light_{pdf}$ because there are some directions where either PDF could have generated the direction. For example, we might generate a direction toward the light using $reflection_pdf$.</p></blockquote><p>ä½†æ˜¯å¯¹ mixture_pdf çš„è®¡ç®—ç¨å¾®å¾®å¦™ä¸€äº›ã€‚æˆ‘ä»¬éœ€è¦åŒæ—¶è®¡ç®— reflection_pdf å’Œ light_pdfï¼Œå› ä¸ºæœ‰ä¸€äº›æ–¹å‘ï¼Œå…¶ä¸­ä»»ä½•ä¸€ä¸ªpdféƒ½å¯ä»¥ç”Ÿæˆæ–¹å‘ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ reflection_pdf ç”Ÿæˆä¸€ä¸ªæœå‘å…‰çš„æ–¹å‘ã€‚</p><blockquote><p>If we step back a bit, we see that there are two functions a PDF needs to support:</p><ol><li>What is your value at this location?</li><li>Return a random number that is distributed appropriately.</li></ol></blockquote><p>é€€ä¸€æ­¥æ¥çœ‹ï¼ŒPDFéœ€è¦æ”¯æŒä¸¤ä¸ªåŠŸèƒ½:</p><ol><li>ä½ åœ¨è¿™é‡Œçš„ä»·å€¼æ˜¯å¤šå°‘?</li><li>è¿”å›ä¸€ä¸ªé€‚å½“åˆ†å¸ƒçš„éšæœºæ•°ã€‚</li></ol><blockquote><p>The details of how this is done under the hood varies for the $reflection_{pdf}$â€‹ and the $light_{pdf}$â€‹ and the mixture density of the two of them, but that is exactly what class hierarchies were invented for! Itâ€™s never obvious what goes in an abstract class, so my approach is to be greedy and hope a minimal interface works, and for the PDF this implies:</p></blockquote><p>è¿™æ˜¯å¦‚ä½•åšçš„ç»†èŠ‚æ˜¯ä¸åŒçš„ reflection_pdf å’Œ light_pdf å’Œä¸¤è€…çš„æ··åˆå¯†åº¦ï¼Œä½†è¿™æ­£æ˜¯ç±»å±‚æ¬¡ç»“æ„è¢«å‘æ˜çš„!æŠ½è±¡ç±»ä¸­æœ‰ä»€ä¹ˆæ˜¯ä¸æ˜æ˜¾çš„ï¼Œæ‰€ä»¥æˆ‘çš„æ–¹æ³•æ˜¯è´ªå©ªçš„ï¼Œå¸Œæœ›ä¸€ä¸ªæœ€å°çš„æ¥å£å·¥ä½œï¼Œå¯¹äºPDFè¿™æ„å‘³ç€:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"vec3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pdf</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">pdf</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Weâ€™ll see if that works by fleshing out the subclasses. For sampling the light, we will need <code>hittable</code> to answer some queries that it doesnâ€™t have an interface for. Weâ€™ll probably need to mess with it too, but we can start by seeing if we can put something in <code>hittable</code> involving sampling the bounding box that works with all its subclasses.</p><p>First, letâ€™s try a cosine density:</p></blockquote><p>æˆ‘ä»¬å°†é€šè¿‡å……å®å­ç±»æ¥çœ‹çœ‹å®ƒæ˜¯å¦æœ‰æ•ˆã€‚ä¸ºäº†å¯¹å…‰çº¿è¿›è¡Œé‡‡æ ·ï¼Œæˆ‘ä»¬éœ€è¦hittableæ¥å›ç­”ä¸€äº›å®ƒæ²¡æœ‰æ¥å£çš„æŸ¥è¯¢ã€‚æˆ‘ä»¬å¯èƒ½ä¹Ÿéœ€è¦å¼„ä¹±å®ƒï¼Œä½†æˆ‘ä»¬å¯ä»¥å…ˆçœ‹çœ‹æ˜¯å¦å¯ä»¥åœ¨hittableä¸­æ”¾å…¥ä¸€äº›ä¸œè¥¿ï¼ŒåŒ…æ‹¬é‡‡æ ·ä¸æ‰€æœ‰å­ç±»ä¸€èµ·å·¥ä½œçš„è¾¹ç•Œæ¡†ã€‚</p><p>é¦–å…ˆï¼Œæˆ‘ä»¬æ¥è¯•è¯•ä½™å¼¦å¯†åº¦ï¼š</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cosine_pdf</span> : <span class="keyword">public</span> pdf {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cosine_pdf</span>(<span class="type">const</span> vec3&amp; w) { uvw.<span class="built_in">build_from_w</span>(w); }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(<span class="built_in">unit_vector</span>(direction), uvw.<span class="built_in">w</span>());</span><br><span class="line">        <span class="keyword">return</span> (cosine &lt;= <span class="number">0</span>) ? <span class="number">0</span> : cosine/pi;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    onb uvw;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can try this in the <code>ray_color()</code> function, with the main changes highlighted. We also need to change variable <code>pdf</code> to some other variable name to avoid a name conflict with the new <code>pdf</code> class.</p></blockquote><p>æˆ‘ä»¬å¯ä»¥åœ¨ <code>ray_color()</code> å‡½æ•°ä¸­å°è¯•ä¸€ä¸‹ï¼Œçªå‡ºæ˜¾ç¤ºä¸»è¦çš„å˜åŒ–ã€‚æˆ‘ä»¬è¿˜éœ€è¦å°†å˜é‡ pdf æ›´æ”¹ä¸ºå…¶ä»–å˜é‡åï¼Œä»¥é¿å…ä¸æ–° pdf ç±»çš„åç§°å†²çªã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(const ray&amp; r, const vec3&amp; background, const hittable&amp; world,int depth) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return vec3(0,0,0);</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (!world.hit(r,0.001,infinity,rec))</span><br><span class="line">        return background;</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    vec3 attenuation;</span><br><span class="line">    vec3 emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line"><span class="addition">+   double pdf_val;</span></span><br><span class="line">    vec3 albedo;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf_val))</span></span><br><span class="line">        return emitted;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   auto on_light = vec3(random_double(213, 343), 554, random_double(227, 332));</span></span><br><span class="line"><span class="deletion">-   auto to_light = on_light - rec.p;</span></span><br><span class="line"><span class="deletion">-   auto distance_squared = to_light.length_squared();</span></span><br><span class="line"><span class="deletion">-   to_light = unit_vector(to_light);</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   if (dot(to_light, rec.normal) &lt; 0)</span></span><br><span class="line"><span class="deletion">-       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   double light_area = (343 - 213) * (332 - 227);</span></span><br><span class="line"><span class="deletion">-   auto light_cosine = fabs(to_light.y());</span></span><br><span class="line"><span class="deletion">-   if (light_cosine &lt; 0.000001)</span></span><br><span class="line"><span class="deletion">-       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   pdf = distance_squared / (light_cosine * light_area);</span></span><br><span class="line"><span class="deletion">-   scattered = ray(rec.p, to_light, r.time());</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   cosine_pdf p(rec.normal);</span></span><br><span class="line"><span class="addition">+   scattered = ray(rec.p, p.generate(), r.time());</span></span><br><span class="line"><span class="addition">+   pdf_val = p.value(scattered.direction()); </span></span><br><span class="line">    </span><br><span class="line">    return emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span><br><span class="line"><span class="addition">+                * ray_color(scattered, background, world, depth - 1) / pdf_val;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This yields an apparently matching result so all weâ€™ve done so far is refactor where <code>pdf</code> is computed:</p></blockquote><p>è¿™äº§ç”Ÿä¸€ä¸ªæ˜æ˜¾åŒ¹é…çš„ç»“æœï¼Œæ‰€ä»¥æˆ‘ä»¬æ‰€åšçš„ä¸€åˆ‡ï¼Œåˆ°ç›®å‰ä¸ºæ­¢æ˜¯é‡æ„çš„pdfè®¡ç®—:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.06-cornell-cos-pdf.jpg"></p><h4 id="Sampling-Directions-towards-a-Hittable"><a href="#Sampling-Directions-towards-a-Hittable" class="headerlink" title="Sampling Directions towards a Hittable"></a>Sampling Directions towards a Hittable</h4><blockquote><p>Now we can try sampling directions toward a <code>hittable</code>, like the light.</p></blockquote><p>ç°åœ¨æˆ‘ä»¬å¯ä»¥è¯•ç€æœç€å¯å‡»ä¸­ç‰©ä½“çš„æ–¹å‘å–æ ·ï¼Œæ¯”å¦‚å…‰ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_pdf</span> : <span class="keyword">public</span> pdf {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_pdf</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> vec3&amp; origin) : <span class="built_in">ptr</span>(p), <span class="built_in">o</span>(origin) {}</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">pdf_value</span>(o, direction);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 o;</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This assumes two as-yet not implemented functions in the <code>hittable</code> class. To avoid having to add instrumentation to all <code>hittable</code> subclasses, weâ€™ll add two dummy functions to the <code>hittable</code> class:</p></blockquote><p>è¿™å‡è®¾åœ¨hittableç±»ä¸­æœ‰ä¸¤ä¸ªå°šæœªå®ç°çš„å‡½æ•°ã€‚ä¸ºäº†é¿å…å‘æ‰€æœ‰hittableå­ç±»æ·»åŠ æ’è£…ï¼Œæˆ‘ä»¬å°†å‘hittableç±»æ·»åŠ ä¸¤ä¸ªè™šæ‹Ÿå‡½æ•°:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class hittable {</span><br><span class="line">public:</span><br><span class="line">    virtual bool hit(const ray&amp; r,double  t_min,double  t_max,hit_record&amp; rec) const = 0;</span><br><span class="line">    virtual bool bounding_box(double t0, double t1, aabb&amp; output_box) const = 0;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   virtual double pdf_value(const vec3&amp; o, const vec3&amp; v) {</span></span><br><span class="line"><span class="addition">+       return 0.0;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   virtual vec3 random(const vec3&amp; o) const {</span></span><br><span class="line"><span class="addition">+       return vec3(1, 0, 0);</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And we change <code>xz_rect</code> to implement those functions:</p></blockquote><p>æˆ‘ä»¬æ”¹å˜ xz_rect æ¥å®ç°è¿™äº›å‡½æ•°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ......    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> vec3&amp; origin, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>{</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(origin, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> area = (x1-x0)*(z1-z0);</span><br><span class="line">        <span class="keyword">auto</span> distance_squared = rec.t * rec.t * v.<span class="built_in">length_squared</span>();</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">fabs</span>(<span class="built_in">dot</span>(v, rec.normal) / v.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> distance_squared / (cosine * area);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> vec3&amp; origin)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> random_point = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(x0,x1), k, <span class="built_in">random_double</span>(z0,z1));</span><br><span class="line">        <span class="keyword">return</span> random_point - origin;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And then change <code>ray_color()</code>:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(</span><br><span class="line">    const ray&amp; r, const color&amp; background, const hittable&amp; world,</span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt;&amp; lights, int depth</span></span><br><span class="line">) {</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    color attenuation;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    double pdf_val;</span><br><span class="line">    color albedo;</span><br><span class="line">    if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf_val))</span><br><span class="line">        return emitted;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   hittable_pdf light_pdf(lights, rec.p);</span></span><br><span class="line"><span class="addition">+   scattered = ray(rec.p, light_pdf.generate(), r.time());</span></span><br><span class="line"><span class="addition">+   pdf_val = light_pdf.value(scattered.direction());</span></span><br><span class="line"></span><br><span class="line">    return emitted</span><br><span class="line">         + albedo * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span><br><span class="line"><span class="addition">+                 * ray_color(scattered, background, world, lights, depth-1) / pdf_val;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">int main() {</span><br><span class="line">    ...</span><br><span class="line">    // World</span><br><span class="line"></span><br><span class="line">    auto world = cornell_box();</span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt; lights =</span></span><br><span class="line"><span class="addition">+       make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, shared_ptr&lt;material&gt;());</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    for (int j = image_height-1; j &gt;= 0; --j) {</span><br><span class="line">        std::cerr &lt;&lt; "\rScanlines remaining: " &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;</span><br><span class="line">        for (int i = 0; i &lt; image_width; ++i) {</span><br><span class="line">            ...</span><br><span class="line"><span class="addition">+           pixel_color += ray_color(r, background, world, lights, max_depth);</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><blockquote><p>At 10 samples per pixel we get:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.07-hittable-light.jpg"></p><h4 id="The-Mixture-PDF-Class"><a href="#The-Mixture-PDF-Class" class="headerlink" title="The Mixture PDF Class"></a>The Mixture PDF Class</h4><blockquote><p>Now we would like to do a mixture density of the cosine and light sampling. The mixture density class is straightforward:</p></blockquote><p>ç°åœ¨æˆ‘ä»¬è¦åšä½™å¼¦çš„æ··åˆå¯†åº¦å’Œå…‰é‡‡æ ·ã€‚æ··åˆå¯†åº¦ç±»å¾ˆç®€å•:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mixture_pdf</span> : <span class="keyword">public</span> pdf {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">mixture_pdf</span>(shared_ptr&lt;pdf&gt; p0, shared_ptr&lt;pdf&gt; p1) {</span><br><span class="line">            p[<span class="number">0</span>] = p0;</span><br><span class="line">            p[<span class="number">1</span>] = p1;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span> * p[<span class="number">0</span>]-&gt;<span class="built_in">value</span>(direction) + <span class="number">0.5</span> *p[<span class="number">1</span>]-&gt;<span class="built_in">value</span>(direction);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">return</span> p[<span class="number">0</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p[<span class="number">1</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;pdf&gt; p[<span class="number">2</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And plugging it into <code>ray_color()</code>:</p></blockquote><p>å¹¶å°†å…¶æ’å…¥ <code>ray_color()</code> ä¸­:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">color ray_color(</span><br><span class="line">    const ray&amp; r, const color&amp; background, const hittable&amp; world,</span><br><span class="line">    shared_ptr&lt;hittable&gt;&amp; lights, int depth</span><br><span class="line">) {</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ray scattered;</span><br><span class="line">    color attenuation;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    double pdf_val;</span><br><span class="line">    color albedo;</span><br><span class="line">    if (!rec.mat_ptr-&gt;scatter(r, rec, albedo, scattered, pdf_val))</span><br><span class="line">        return emitted;</span><br><span class="line"><span class="addition">+   auto p0 = make_shared&lt;hittable_pdf&gt;(lights, rec.p);</span></span><br><span class="line"><span class="addition">+   auto p1 = make_shared&lt;cosine_pdf&gt;(rec.normal);</span></span><br><span class="line"><span class="addition">+   mixture_pdf mixed_pdf(p0, p1);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   scattered = ray(rec.p, mixed_pdf.generate(), r.time());</span></span><br><span class="line"><span class="addition">+   pdf_val = mixed_pdf.value(scattered.direction());</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>1000 samples per pixel yields:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.08-cosine-and-light.jpg"></p><blockquote><p>Weâ€™ve basically gotten this same picture (with different levels of noise) with several different sampling patterns. It looks like the original picture was slightly wrong! Note by â€œwrongâ€ here I mean not a correct Lambertian picture. Yet Lambertian is just an ideal approximation to matte, so our original picture was some other accidental approximation to matte. I donâ€™t think the new one is any better, but we can at least compare it more easily with other Lambertian renderers.</p></blockquote><h3 id="ä¸€äº›æ¶æ„å†³ç­–"><a href="#ä¸€äº›æ¶æ„å†³ç­–" class="headerlink" title="ä¸€äº›æ¶æ„å†³ç­–"></a>ä¸€äº›æ¶æ„å†³ç­–</h3><blockquote><p>I wonâ€™t write any code in this chapter. Weâ€™re at a crossroads where I need to make some architectural decisions. The mixture-density approach is to not have traditional shadow rays, and is something I personally like, because in addition to lights you can sample windows or bright cracks under doors or whatever else you think might be bright. But most programs branch, and send one or more terminal rays to lights explicitly, and one according to the reflective distribution of the surface. This could be a time you want faster convergence on more restricted scenes and add shadow rays; thatâ€™s a personal design preference.</p></blockquote><p>åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä¸ä¼šå†™ä»»ä½•ä»£ç ã€‚æˆ‘ä»¬æ­£å¤„åœ¨ä¸€ä¸ªåå­—è·¯å£ï¼Œæˆ‘éœ€è¦åšå‡ºä¸€äº›æ¶æ„ä¸Šçš„å†³å®šã€‚æ··åˆå¯†åº¦æ–¹æ³•æ˜¯ä¸ä½¿ç”¨ä¼ ç»Ÿçš„é˜´å½±å…‰çº¿ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä¸ªäººå–œæ¬¢çš„æ–¹æ³•ï¼Œå› ä¸ºé™¤äº†ç¯å…‰ï¼Œä½ è¿˜å¯ä»¥å¯¹çª—æˆ·ã€é—¨ä¸‹çš„æ˜äº®è£‚ç¼æˆ–ä»»ä½•ä½ è®¤ä¸ºå¯èƒ½æ˜äº®çš„ä¸œè¥¿è¿›è¡Œé‡‡æ ·ã€‚ä½†æ˜¯å¤§å¤šæ•°ç¨‹åºéƒ½æ˜¯åˆ†æ”¯çš„ï¼Œå°†ä¸€ä¸ªæˆ–å¤šä¸ªç»ˆç«¯å…‰çº¿æ˜ç¡®åœ°å‘é€åˆ°å…‰ï¼Œå¦ä¸€ä¸ªåˆ™æ ¹æ®è¡¨é¢çš„åå°„åˆ†å¸ƒã€‚è¿™å¯èƒ½æ˜¯ä½ æƒ³è¦åœ¨æ›´æœ‰é™çš„åœºæ™¯ä¸­æ›´å¿«åœ°æ”¶æ•›å’Œæ·»åŠ é˜´å½±å…‰çº¿çš„æ—¶å€™;è¿™æ˜¯ä¸ªäººçš„è®¾è®¡åå¥½ã€‚</p><blockquote><p>There are some other issues with the code.</p></blockquote><p>è¯¥ä»£ç è¿˜æœ‰å…¶ä»–ä¸€äº›é—®é¢˜ã€‚</p><blockquote><p>The PDF construction is hard coded in the <code>ray_color()</code> function. We should clean that up, probably by passing something into color about the lights. Unlike BVH construction, we should be careful about memory leaks as there are an unbounded number of samples.</p></blockquote><p>PDFç»“æ„æ˜¯åœ¨ <code>ray_color()</code> å‡½æ•°ä¸­ç¡¬ç¼–ç çš„ã€‚æˆ‘ä»¬åº”è¯¥æŠŠå®ƒæ¸…ç†ä¸€ä¸‹ï¼Œä¹Ÿè®¸é€šè¿‡æŠŠä¸€äº›å…³äºç¯å…‰çš„ä¸œè¥¿å˜æˆé¢œè‰²ã€‚ä¸BVHæ„é€ ä¸åŒï¼Œæˆ‘ä»¬åº”è¯¥å°å¿ƒå†…å­˜æ³„æ¼ï¼Œå› ä¸ºæ ·æœ¬çš„æ•°é‡æ˜¯æ— é™çš„ã€‚</p><blockquote><p>The specular rays (glass and metal) are no longer supported. The math would work out if we just made their scattering function a delta function. But that would be floating point disaster. We could either separate out specular reflections, or have surface roughness never be zero and have almost-mirrors that look perfectly smooth but donâ€™t generate NaNs. I donâ€™t have an opinion on which way to do it (I have tried both and they both have their advantages), but we have smooth metal and glass code anyway, so I add perfect specular surfaces that do not do explicit f()/p() calculations.</p></blockquote><p>é•œé¢å…‰çº¿(ç»ç’ƒå’Œé‡‘å±)ä¸å†è¢«æ”¯æŒã€‚å¦‚æœæˆ‘ä»¬æŠŠå®ƒä»¬çš„æ•£å°„å‡½æ•°è®¾ä¸ºè„‰å†²å‡½æ•°ï¼Œæ•°å­¦å°±èƒ½ç®—å‡ºæ¥ã€‚ä½†é‚£å°†æ˜¯æµ®ç‚¹ç¾éš¾ã€‚æˆ‘ä»¬å¯ä»¥å°†é•œé¢åå°„åˆ†ç¦»å‡ºæ¥ï¼Œæˆ–è€…è®©è¡¨é¢ç²—ç³™åº¦æ°¸è¿œä¸ä¸ºé›¶ï¼Œæ‹¥æœ‰çœ‹èµ·æ¥å®Œç¾å…‰æ»‘ä½†ä¸ä¼šäº§ç”Ÿ <code>NaN</code>çš„å‡†é•œé¢ã€‚æˆ‘å¯¹è¿™ç§æ–¹æ³•æ²¡æœ‰æ„è§(æˆ‘éƒ½è¯•è¿‡äº†ï¼Œä»–ä»¬éƒ½æœ‰ä»–ä»¬çš„ä¼˜åŠ¿)ï¼Œä½†æˆ‘ä»¬æœ‰å…‰æ»‘çš„é‡‘å±å’Œç»ç’ƒä»£ç ï¼Œæ‰€ä»¥æˆ‘æ·»åŠ äº†å®Œç¾çš„é•œé¢ï¼Œä¸åšæ˜¾å¼çš„f()/p()è®¡ç®—ã€‚</p><blockquote><p>We also lack a real background function infrastructure in case we want to add an environment map or more interesting functional background. Some environment maps are HDR (the RGB components are floats rather than 0â€“255 bytes usually interpreted as 0-1). Our output has been HDR all along; weâ€™ve just been truncating it.</p></blockquote><p>å¦‚æœæˆ‘ä»¬æƒ³è¦æ·»åŠ ç¯å¢ƒæ˜ å°„æˆ–æ›´æœ‰è¶£çš„åŠŸèƒ½èƒŒæ™¯ï¼Œæˆ‘ä»¬è¿˜ç¼ºå°‘çœŸæ­£çš„åå°åŠŸèƒ½åŸºç¡€è®¾æ–½ã€‚æœ‰äº›ç¯å¢ƒæ˜ å°„æ˜¯HDR (RGBç»„ä»¶æ˜¯æµ®ç‚¹æ•°ï¼Œè€Œä¸æ˜¯0-255å­—èŠ‚ï¼Œé€šå¸¸è¢«è§£é‡Šä¸º0-1)ã€‚æˆ‘ä»¬çš„è¾“å‡ºä¸€ç›´æ˜¯HDR;æˆ‘ä»¬åªæ˜¯åœ¨æˆªçŸ­å®ƒã€‚</p><blockquote><p>Finally, our renderer is RGB and a more physically based one â€” like an automobile manufacturer might use â€” would probably need to use spectral colors and maybe even polarization. For a movie renderer, you would probably want RGB. You can make a hybrid renderer that has both modes, but that is of course harder. Iâ€™m going to stick to RGB for now, but I will revisit this near the end of the book.</p></blockquote><p>æœ€åï¼Œæˆ‘ä»¬çš„æ¸²æŸ“å™¨æ˜¯RGBï¼Œä¸€ä¸ªæ›´åŸºäºç‰©ç†çš„æ¸²æŸ“å™¨-å°±åƒæ±½è½¦åˆ¶é€ å•†å¯èƒ½ä½¿ç”¨çš„-å¯èƒ½éœ€è¦ä½¿ç”¨å…‰è°±é¢œè‰²ï¼Œç”šè‡³æåŒ–ã€‚å¯¹äºç”µå½±æ¸²æŸ“å™¨ï¼Œæ‚¨å¯èƒ½éœ€è¦RGBã€‚ä½ å¯ä»¥åˆ¶ä½œä¸€ä¸ªæ··åˆæ¸²æŸ“å™¨ï¼Œå®ƒæœ‰ä¸¤ç§æ¨¡å¼ï¼Œä½†è¿™å½“ç„¶æ¯”è¾ƒå›°éš¾ã€‚ç°åœ¨æˆ‘å°†åšæŒRGBæ¨¡å¼ï¼Œä½†æ˜¯æˆ‘ä¼šåœ¨æœ¬ä¹¦çš„æœ«å°¾é‡æ–°è®¨è®ºè¿™ä¸ªé—®é¢˜ã€‚</p><h3 id="ä¼˜åŒ–PDFæ¶æ„"><a href="#ä¼˜åŒ–PDFæ¶æ„" class="headerlink" title="ä¼˜åŒ–PDFæ¶æ„"></a>ä¼˜åŒ–PDFæ¶æ„</h3><blockquote><p>So far I have the <code>ray_color()</code> function create two hard-coded PDFs:</p><ol><li><code>p0()</code> related to the shape of the light</li><li><code>p1()</code> related to the normal vector and type of surface</li></ol><p>We can pass information about the light (or whatever <code>hittable</code> we want to sample) into the <code>ray_color()</code> function, and we can ask the <code>material</code> function for a PDF (we would have to instrument it to do that). We can also either ask <code>hit</code> function or the <code>material</code> class to supply whether there is a specular vector.</p></blockquote><p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘çš„ <code>ray_color()</code> å‡½æ•°åˆ›å»ºä¸¤ä¸ªç¡¬ç¼–ç çš„ PDF:</p><ol><li><code>p0()</code> ä¸å…‰çš„å½¢çŠ¶æœ‰å…³</li><li><code>p1()</code> ä¸æ›²é¢çš„æ³•å‘é‡å’Œç±»å‹æœ‰å…³</li></ol><p>æˆ‘ä»¬å¯ä»¥å°†å…³äºå…‰çš„ä¿¡æ¯(æˆ–è€…ä»»ä½•æˆ‘ä»¬æƒ³è¦é‡‡æ ·çš„ <code>hittable</code>)ä¼ é€’åˆ° <code>ray_color()</code> å‡½æ•°ä¸­ï¼Œå¹¶ä¸”æˆ‘ä»¬å¯ä»¥è¦æ±‚æè´¨å‡½æ•°æä¾›ä¸€ä¸ªPDFæ–‡ä»¶(æˆ‘ä»¬å°†ä¸å¾—ä¸ä¸ºæ­¤è®¾ç½®å®ƒ)ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥è¯¢é—® <code>hit</code> å‡½æ•°æˆ– <code>material</code> ç±»æ˜¯å¦æœ‰ä¸€ä¸ªé«˜å…‰çŸ¢é‡ã€‚</p><h4 id="Diffuse-Versus-Specular"><a href="#Diffuse-Versus-Specular" class="headerlink" title="Diffuse Versus Specular"></a>Diffuse Versus Specular</h4><blockquote><p>One thing we would like to allow for is a material like varnished wood that is partially ideal specular (the polish) and partially diffuse (the wood). Some renderers have the material generate two rays: one specular and one diffuse. I am not fond of branching, so I would rather have the material randomly decide whether it is diffuse or specular. The catch with that approach is that we need to be careful when we ask for the PDF value and be aware of whether for this evaluation of <code>ray_color()</code> it is diffuse or specular. Fortunately, we know that we should only call the <code>pdf_value()</code> if it is diffuse so we can handle that implicitly.</p></blockquote><p>æˆ‘ä»¬æƒ³è¦å…è®¸çš„ä¸€ä»¶äº‹æ˜¯ä¸€ä¸ªææ–™ï¼Œå¦‚æ¶‚æ¼†çš„æœ¨æï¼Œéƒ¨åˆ†æ˜¯ç†æƒ³çš„é•œé¢åå°„(æŠ›å…‰)å’Œéƒ¨åˆ†æ‰©æ•£(æœ¨æ)ã€‚ä¸€äº›æ¸²æŸ“å™¨è®©æè´¨äº§ç”Ÿä¸¤æ¡å…‰çº¿:ä¸€æ¡é«˜å…‰ï¼Œä¸€æ¡æ¼«åå°„ã€‚æˆ‘ä¸å–œæ¬¢åˆ†æ”¯ï¼Œæ‰€ä»¥æˆ‘å®æ„¿è®©ææ–™éšæœºå†³å®šæ˜¯æ¼«åå°„è¿˜æ˜¯é•œé¢åå°„ã€‚è¿™ç§æ–¹æ³•çš„é™·é˜±æ˜¯ï¼Œå½“æˆ‘ä»¬è¦æ±‚PDFå€¼æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°å¿ƒï¼Œå¹¶çŸ¥é“å¯¹äº <code>ray_color()</code> çš„è¯„ä¼°ï¼Œå®ƒæ˜¯æ¼«åå°„è¿˜æ˜¯é•œé¢åå°„ã€‚å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬çŸ¥é“åªæœ‰å½“ <code>pdf_value()</code> æ˜¯diffuseæ—¶æ‰åº”è¯¥è°ƒç”¨å®ƒï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥éšå¼åœ°å¤„ç†å®ƒã€‚</p><blockquote><p>We can redesign <code>material</code> and stuff all the new arguments into a <code>struct</code> like we did for <code>hittable</code>:</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">scatter_record</span> {</span><br><span class="line">    ray specular_ray;</span><br><span class="line">    <span class="type">bool</span> is_specular;</span><br><span class="line">    vec3 attenuation;</span><br><span class="line">    shared_ptr&lt;pdf&gt; pdf_ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">emitted</span><span class="params">(<span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in,<span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The Lambertian material becomes simpler:</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> vec3&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;constant_texture&gt;(a)) {}</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>{</span><br><span class="line">        srec.is_specular = <span class="literal">false</span>;</span><br><span class="line">        srec.attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        srec.pdf_ptr = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">unit_vector</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And <code>ray_color()</code> changes are small:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">color ray_color(</span><br><span class="line">    const ray&amp; r,</span><br><span class="line">    const color&amp; background,</span><br><span class="line">    const hittable&amp; world,</span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt;&amp; lights,</span></span><br><span class="line">    int depth</span><br><span class="line">) {</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    // If we've exceeded the ray bounce limit, no more light is gathered.</span><br><span class="line">    if (depth &lt;= 0)</span><br><span class="line">        return color(0,0,0);</span><br><span class="line"></span><br><span class="line">    // If the ray hits nothing, return the background color.</span><br><span class="line">    if (!world.hit(r, 0.001, infinity, rec))</span><br><span class="line">        return background;</span><br><span class="line"><span class="addition">+   scatter_record srec;</span></span><br><span class="line"><span class="addition">+   color emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span></span><br><span class="line"><span class="addition">+   if (!rec.mat_ptr-&gt;scatter(r, rec, srec))</span></span><br><span class="line"><span class="addition">+       return emitted;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto light_ptr = make_shared&lt;hittable_pdf&gt;(lights, rec.p);</span></span><br><span class="line"><span class="addition">+   mixture_pdf p(light_ptr, srec.pdf_ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   ray scattered = ray(rec.p, p.generate(), r.time());</span></span><br><span class="line"><span class="addition">+   auto pdf_val = p.value(scattered.direction());</span></span><br><span class="line"></span><br><span class="line">    return emitted</span><br><span class="line"><span class="addition">+       + srec.attenuation * rec.mat_ptr-&gt;scattering_pdf(r, rec, scattered)</span></span><br><span class="line">                           * ray_color(scattered, background, world, lights, depth-1) / pdf_val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    ...</span><br><span class="line">    // World</span><br><span class="line"></span><br><span class="line">    auto world = cornell_box();</span><br><span class="line"><span class="addition">+   auto lights = make_shared&lt;hittable_list&gt;();</span></span><br><span class="line"><span class="addition">+   lights-&gt;add(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, shared_ptr&lt;material&gt;()));</span></span><br><span class="line"><span class="addition">+   lights-&gt;add(make_shared&lt;sphere&gt;(point3(190, 90, 190), 90, shared_ptr&lt;material&gt;()));</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><h4 id="Handling-Specular"><a href="#Handling-Specular" class="headerlink" title="Handling Specular"></a>Handling Specular</h4><blockquote><p>We have not yet dealt with specular surfaces, nor instances that mess with the surface normal. But this design is clean overall, and those are all fixable. For now, I will just fix <code>specular</code>. Metal and dielectric materials are easy to fix.</p></blockquote><p>æˆ‘ä»¬è¿˜æ²¡æœ‰å¤„ç†è¿‡é•œé¢ï¼Œä¹Ÿæ²¡æœ‰å¤„ç†è¿‡ç ´åè¡¨é¢æ³•çº¿çš„æƒ…å†µã€‚ä½†è¿™ä¸ªè®¾è®¡æ€»ä½“ä¸Šæ˜¯å¹²å‡€çš„ï¼Œè€Œä¸”è¿™äº›éƒ½æ˜¯å¯ä»¥ä¿®å¤çš„ã€‚ç°åœ¨ï¼Œæˆ‘åªä¿®å¤é•œé¢åå°„ã€‚é‡‘å±å’Œä»‹ç”µææ–™å¾ˆå®¹æ˜“å›ºå®šã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class metal : public material {</span><br><span class="line">    public:</span><br><span class="line">        metal(const color&amp; a, double f) : albedo(a), fuzz(f &lt; 1 ? f : 1) {}</span><br><span class="line">        virtual bool scatter(</span><br><span class="line"><span class="addition">+           const ray&amp; r_in, const hit_record&amp; rec, scatter_record&amp; srec</span></span><br><span class="line">        ) const override {</span><br><span class="line"><span class="addition">+           vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);</span></span><br><span class="line"><span class="addition">+           srec.specular_ray = ray(rec.p, reflected+fuzz*random_in_unit_sphere());</span></span><br><span class="line"><span class="addition">+           srec.attenuation = albedo;</span></span><br><span class="line"><span class="addition">+           srec.is_specular = true;</span></span><br><span class="line"><span class="addition">+           srec.pdf_ptr = 0;</span></span><br><span class="line"><span class="addition">+           return true;</span></span><br><span class="line">        }</span><br><span class="line">    public:</span><br><span class="line">        vec3 albedo;</span><br><span class="line">        double fuzz;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">class dielectric : public material {</span><br><span class="line">    public:</span><br><span class="line">        ...</span><br><span class="line">        virtual bool scatter(</span><br><span class="line">            const ray&amp; r_in, const hit_record&amp; rec, scatter_record&amp; srec</span><br><span class="line">        ) const override {</span><br><span class="line"><span class="addition">+           srec.is_specular = true;</span></span><br><span class="line"><span class="addition">+           srec.pdf_ptr = nullptr;</span></span><br><span class="line"><span class="addition">+           srec.attenuation = color(1.0, 1.0, 1.0);</span></span><br><span class="line">            double refraction_ratio = rec.front_face ? (1.0/ir) : ir;</span><br><span class="line">            ...</span><br><span class="line"><span class="addition">+           srec.specular_ray = ray(rec.p, direction, r_in.time());</span></span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Note that if fuzziness is high, this surface isnâ€™t ideally specular, but the implicit sampling works just like it did before.</p><p><code>ray_color()</code> just needs a new case to generate an implicitly sampled ray:</p></blockquote><p>è¯·æ³¨æ„ï¼Œå¦‚æœæ¨¡ç³Šåº¦å¾ˆé«˜ï¼Œè¿™ä¸ªè¡¨é¢ä¸æ˜¯ç†æƒ³çš„é•œé¢ï¼Œä½†éšå¼é‡‡æ ·å·¥ä½œå°±åƒä»¥å‰ä¸€æ ·ã€‚</p><p><code>ray_color()</code> åªéœ€è¦ä¸€ä¸ªæ–°çš„æƒ…å†µæ¥ç”Ÿæˆä¸€ä¸ªéšå¼é‡‡æ ·å°„çº¿:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">vec3 ray_color(</span><br><span class="line">    const ray&amp; r,</span><br><span class="line">    const vec3&amp; background,</span><br><span class="line">    const hittable&amp; world,</span><br><span class="line">    shared_ptr&lt;hittable&gt;&amp; lights,</span><br><span class="line">    int depth</span><br><span class="line">) {</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    scatter_record srec;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;emitted(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    if (!rec.mat_ptr-&gt;scatter(r, rec, srec))</span><br><span class="line">        return emitted;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (srec.is_specular) {</span></span><br><span class="line"><span class="addition">+       return srec.attenuation</span></span><br><span class="line"><span class="addition">+            * ray_color(srec.specular_ray, background, world, lights, depth-1);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We also need to change the block to metal. Weâ€™ll also swap out the short block for a glass sphere.</p></blockquote><p>æˆ‘ä»¬è¿˜éœ€è¦æŠŠç§¯æœ¨æ¢æˆé‡‘å±ã€‚æˆ‘ä»¬ä¹Ÿä¼šæŠŠçŸ­å—æ¢æˆç»ç’ƒçƒã€‚</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list cornell_box_plus() {</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    auto red = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.65, 0.05, 0.05)));</span><br><span class="line">    auto white = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.73, 0.73, 0.73)));</span><br><span class="line">    auto green = make_shared&lt;lambertian&gt;(make_shared&lt;constant_texture&gt;(vec3(0.12, 0.45, 0.15)));</span><br><span class="line">    auto light = make_shared&lt;diffuse_light&gt;(make_shared&lt;constant_texture&gt;(vec3(15, 15, 15)));</span><br><span class="line"></span><br><span class="line">    objects.add(make_shared&lt;yz_rect&gt;(0, 555, 0, 555, 555, green));</span><br><span class="line">    objects.add(make_shared&lt;yz_rect&gt;(0, 555, 0, 555, 0, red));</span><br><span class="line">    objects.add(make_shared&lt;flip_face&gt;(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, light)));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, light));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(0, 555, 0, 555, 555, white));</span><br><span class="line">    objects.add(make_shared&lt;xz_rect&gt;(0, 555, 0, 555, 0, white));</span><br><span class="line">    objects.add(make_shared&lt;xy_rect&gt;(0, 555, 0, 555, 555, white));</span><br><span class="line"></span><br><span class="line"><span class="addition">+   shared_ptr&lt;material&gt; aluminum = make_shared&lt;metal&gt;(vec3(0.8, 0.85, 0.88), 0.0);</span></span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt; box1 = make_shared&lt;box&gt;(vec3(0,0,0), vec3(165,330,165), aluminum);</span></span><br><span class="line">    box1 = make_shared&lt;rotate_y&gt;(box1, 15);</span><br><span class="line">    box1 = make_shared&lt;translate&gt;(box1, vec3(265,0,295));</span><br><span class="line">    objects.add(box1);</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = make_shared&lt;box&gt;(vec3(0,0,0), vec3(165,165,165), white);</span><br><span class="line">    box2 = make_shared&lt;rotate_y&gt;(box2, -18);</span><br><span class="line">    box2 = make_shared&lt;translate&gt;(box2, vec3(130,0,65));</span><br><span class="line">    objects.add(box2);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   auto glass = make_shared&lt;dielectric&gt;(1.5);</span></span><br><span class="line"><span class="addition">+   objects.add(make_shared&lt;sphere&gt;(vec3(190,90,190), 90 , glass));</span></span><br><span class="line"></span><br><span class="line">    return objects;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The resulting image has a noisy reflection on the ceiling because the directions toward the box are not sampled with more density.</p></blockquote><p>ç»“æœå›¾åƒåœ¨å¤©èŠ±æ¿ä¸Šæœ‰ä¸€ä¸ªå™ªå£°åå°„ï¼Œå› ä¸ºæœå‘ç›’å­çš„æ–¹å‘æ²¡æœ‰ä»¥æ›´å¤šçš„å¯†åº¦è¿›è¡Œé‡‡æ ·ã€‚</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.09-arbitrary-pdf.jpg"></p><blockquote><p>We could make the PDF include the block. Letâ€™s do that instead with a glass sphere because itâ€™s easier.</p></blockquote><h4 id="Sampling-a-Sphere-Object"><a href="#Sampling-a-Sphere-Object" class="headerlink" title="Sampling a Sphere Object"></a>Sampling a Sphere Object</h4><blockquote><p>When we sample a sphereâ€™s solid angle uniformly from a point outside the sphere, we are really just sampling a cone uniformly (the cone is tangent to the sphere). Letâ€™s say the code has <code>theta_max</code>. Recall from the <a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#generatingrandomdirections">Generating Random Directions</a> chapter that to sample ğœƒÎ¸ we have:</p></blockquote><p>å½“æˆ‘ä»¬ä»çƒå¤–ä¸€ç‚¹å‡åŒ€åœ°é‡‡æ ·ä¸€ä¸ªçƒçš„ç«‹ä½“è§’æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨å‡åŒ€åœ°é‡‡æ ·ä¸€ä¸ªé”¥(é”¥ä¸çƒç›¸åˆ‡)ã€‚å‡è®¾ä»£ç æœ‰ <code>theta_max</code>ã€‚å›æƒ³ä¸€ä¸‹ç”Ÿæˆéšæœºæ–¹å‘é‚£ä¸€ç« ï¼Œæˆ‘ä»¬æœ‰:<br>$$<br>r_2 = \int_0^{\theta}{2\pi \cdot f(t) \cdot \sin(t)dt}<br>$$</p><blockquote><p>Here ğ‘“(ğ‘¡) is an as yet uncalculated constant ğ¶, so:</p></blockquote><p>$$<br>r_2 = \int_0^{\theta}{2\pi \cdot C \cdot \sin(t)dt}<br>$$</p><blockquote><p>Doing some algebra/calculus this yields:</p></blockquote><p>åšä¸€äº›ä»£æ•°/å¾®ç§¯åˆ†å¯ä»¥å¾—åˆ°:<br>$$<br>r_2 =2\pi \cdot C \cdot (1-\cos(\theta))<br>$$</p><blockquote><p>So</p></blockquote><p>$$<br>\cos(\theta) = 1 - \frac{r_2}{2\pi \cdot C}<br>$$</p><blockquote><p>We know that for $ğ‘Ÿ_2=1$ we should get $ğœƒ_ğ‘šğ‘ğ‘¥$, so we can solve for ğ¶:</p></blockquote><p>æˆ‘ä»¬çŸ¥é“å¯¹äº $r_2 = 1$ æˆ‘ä»¬åº”è¯¥å¾—åˆ° $\theta_{max}$ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æ±‚è§£ $C$:<br>$$<br>\cos(\theta) = 1 + r_2 \cdot (\cos(\theta_{max}) - 1)<br>$$</p><blockquote><p>ğœ™ we sample like before, so:</p></blockquote><p>$\phi$ æˆ‘ä»¬åƒä»¥å‰ä¸€æ ·é‡‡æ ·ï¼Œæ‰€ä»¥:<br>$$<br>z = \cos(\theta) = 1 + r_2 \cdot (\cos(\theta_{max}) - 1)<br>$$</p><p>$$<br>x = \cos(\phi)\cdot \sin(\theta)=\cos(2\pi \cdot r_1) \cdot \sqrt{1 - z^2}<br>$$</p><p>$$<br>y = \sin(\phi) \cdot \sin(\theta) = \sin(2\pi \cdot r_1) \cdot \sqrt{1 - z^2}<br>$$</p><blockquote><p>Now what is ğœƒğ‘šğ‘ğ‘¥?</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/fig-3.08-sphere-enclosing-cone.jpg"></p><blockquote><p>We can see from the figure that sin(ğœƒğ‘šğ‘ğ‘¥)=ğ‘…/ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„(<strong>ğœ</strong>âˆ’<strong>ğ©</strong>). So:</p></blockquote><p>$$<br>\cos(\theta_{max}) = \sqrt{1 - \frac{R^2}{length^2(\mathbf c - \mathbf p)}}<br>$$</p><blockquote><p>We also need to evaluate the PDF of directions. For directions toward the sphere this is 1/ğ‘ ğ‘œğ‘™ğ‘–ğ‘‘_ğ‘ğ‘›ğ‘”ğ‘™ğ‘’. What is the solid angle of the sphere? It has something to do with the ğ¶ above. It, by definition, is the area on the unit sphere, so the integral is</p></blockquote><p>æˆ‘ä»¬è¿˜éœ€è¦è¯„ä¼°è¯´æ˜ä¹¦çš„PDFã€‚å¯¹äºæœå‘çƒä½“çš„æ–¹å‘ï¼Œè¿™æ˜¯ 1/ğ‘ ğ‘œğ‘™ğ‘–ğ‘‘<em>ğ‘ğ‘›ğ‘”ğ‘™ğ‘’ã€‚çƒçš„ç«‹ä½“è§’æ˜¯å¤šå°‘?å®ƒä¸ä¸Šé¢çš„ C æœ‰å…³ã€‚æ ¹æ®å®šä¹‰ï¼Œå®ƒæ˜¯å•ä½çƒä¸Šçš„é¢ç§¯ï¼Œæ‰€ä»¥ç§¯åˆ†æ˜¯<br>$$<br>solid_angle = \int_0^{2\pi}\int_0^{\theta</em>{max}}\sin(\theta) = 2\pi \cdot (1 - \cos(\theta_{max}))<br>$$</p><blockquote><p>Itâ€™s good to check the math on all such calculations. I usually plug in the extreme cases (thank you for that concept, Mr. Horton â€” my high school physics teacher). For a zero radius sphere cos(ğœƒğ‘šğ‘ğ‘¥)=0 and that works. For a sphere tangent at <strong>ğ©</strong>, cos(ğœƒğ‘šğ‘ğ‘¥)=0, and 2ğœ‹ is the area of a hemisphere, so that works too.</p></blockquote><p>åœ¨æ‰€æœ‰è¿™æ ·çš„è®¡ç®—ä¸­æ£€æŸ¥æ•°å­¦æ˜¯å¾ˆå¥½çš„ã€‚æˆ‘é€šå¸¸ä¼šæ’å…¥ä¸€äº›æç«¯çš„ä¾‹å­(è°¢è°¢ä½ çš„æ¦‚å¿µï¼Œéœé¡¿å…ˆç”Ÿï¼Œæˆ‘çš„é«˜ä¸­ç‰©ç†è€å¸ˆ)ã€‚å¯¹äºä¸€ä¸ªé›¶åŠå¾„çš„çƒä½“$\cos \theta_{max} = 0$ï¼Œè¿™æ˜¯å¯è¡Œçš„ã€‚å¯¹äºä¸€ä¸ªçƒé¢ï¼Œæ­£åˆ‡åœ¨ $\mathbf{p}$ï¼Œ $\cos \theta_{max} = 0$ï¼Œå¹¶ä¸” $2\pi$ æ˜¯ä¸€ä¸ªåŠçƒçš„é¢ç§¯ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥è¿™æ ·åšã€‚</p><h4 id="Updating-the-Sphere-Code"><a href="#Updating-the-Sphere-Code" class="headerlink" title="Updating the Sphere Code"></a>Updating the Sphere Code</h4><blockquote><p>The sphere class needs the two PDF-related functions:</p></blockquote><p>çƒä½“ç±»éœ€è¦ä¸¤ä¸ªpdfç›¸å…³çš„å‡½æ•°:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sphere::pdf_value</span><span class="params">(<span class="type">const</span> vec3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>{</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(o, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cos_theta_max = <span class="built_in">sqrt</span>(<span class="number">1</span> - radius*radius/(center-o).<span class="built_in">length_squared</span>());</span><br><span class="line">    <span class="keyword">auto</span> solid_angle = <span class="number">2</span>*pi*(<span class="number">1</span>-cos_theta_max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">1</span> / solid_angle;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">sphere::random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>{</span><br><span class="line">    vec3 direction = center - o;</span><br><span class="line">    <span class="keyword">auto</span> distance_squared = direction.<span class="built_in">length_squared</span>();</span><br><span class="line">    onb uvw;</span><br><span class="line">    uvw.<span class="built_in">build_from_w</span>(direction);</span><br><span class="line">    <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_to_sphere</span>(radius, distance_squared));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>With the utility function:</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_to_sphere</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> distance_squared)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="number">1</span> + r2*(<span class="built_in">sqrt</span>(<span class="number">1</span>-radius*radius/distance_squared) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="number">2</span>*pi*r1;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi)*<span class="built_in">sqrt</span>(<span class="number">1</span>-z*z);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi)*<span class="built_in">sqrt</span>(<span class="number">1</span>-z*z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can first try just sampling the sphere rather than the light:</p></blockquote><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main() {</span><br><span class="line">    ...</span><br><span class="line">    // World</span><br><span class="line"></span><br><span class="line">    auto world = cornell_box();</span><br><span class="line"><span class="addition">+   shared_ptr&lt;hittable&gt; lights =</span></span><br><span class="line"><span class="addition">+   //  make_shared&lt;xz_rect&gt;(213, 343, 227, 332, 554, shared_ptr&lt;material&gt;());</span></span><br><span class="line"><span class="addition">+       make_shared&lt;sphere&gt;(point3(190, 90, 190), 90, shared_ptr&lt;material&gt;());</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This yields a noisy box, but the caustic under the sphere is good. It took five times as long as sampling the light did for my code. This is probably because those rays that hit the glass are expensive!</p></blockquote><p>è¿™äº§ç”Ÿäº†ä¸€ä¸ªæœ‰å™ªå£°çš„ç›’å­ï¼Œä½†çƒä¸‹é¢çš„ç„¦æ•£æ˜¯å¥½çš„ã€‚å®ƒæ‰€èŠ±è´¹çš„æ—¶é—´æ˜¯æˆ‘ä»£ç ä¸­ç¯å…‰é‡‡æ ·æ—¶é—´çš„5å€ã€‚è¿™å¯èƒ½æ˜¯å› ä¸ºæ’å‡»ç»ç’ƒçš„å…‰çº¿ä»£ä»·å¾ˆæ˜‚è´µ!</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.10-cornell-glass-sphere.jpg"></p><h4 id="Adding-PDF-Functions-to-Hittable-Lists"><a href="#Adding-PDF-Functions-to-Hittable-Lists" class="headerlink" title="Adding PDF Functions to Hittable Lists"></a>Adding PDF Functions to Hittable Lists</h4><blockquote><p>We should probably just sample both the sphere and the light. We can do that by creating a mixture density of their two densities. We could do that in the <code>ray_color()</code> function by passing a list of hittables in and building a mixture PDF, or we could add PDF functions to <code>hittable_list</code>. I think both tactics would work fine, but I will go with instrumenting <code>hittable_list</code>.</p></blockquote><p>æˆ‘ä»¬åº”è¯¥åŒæ—¶å¯¹çƒä½“å’Œå…‰è¿›è¡Œé‡‡æ ·ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ›å»ºå®ƒä»¬ä¸¤ä¸ªå¯†åº¦çš„æ··åˆå¯†åº¦æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ <code>ray_color()</code> å‡½æ•°ä¸­ä¼ é€’ä¸€ä¸ª hittables åˆ—è¡¨å¹¶æ„å»ºä¸€ä¸ªæ··åˆ PDF æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥åœ¨ <code>hittable_list</code> ä¸­æ·»åŠ PDFå‡½æ•°ã€‚æˆ‘è®¤ä¸ºè¿™ä¸¤ç§ç­–ç•¥éƒ½å¯ä»¥ï¼Œä½†æˆ‘è¿˜æ˜¯é€‰æ‹© <code>hittable_list</code> å·¥å…·ã€‚</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">hittable_list::pdf_value</span><span class="params">(<span class="type">const</span> vec3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> weight = <span class="number">1.0</span>/objects.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects)</span><br><span class="line">        sum += weight * object-&gt;<span class="built_in">pdf_value</span>(o, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">hittable_list::random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> int_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(objects.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> objects[<span class="built_in">random_int</span>(<span class="number">0</span>, int_size<span class="number">-1</span>)]-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We assemble a list to pass to <code>ray_color()</code> <code>from main()</code>:</p></blockquote><p>æˆ‘ä»¬ç»„è£…äº†ä¸€ä¸ªåˆ—è¡¨ï¼Œä» <code>main()</code> ä¼ é€’ç»™ <code>ray_color()</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">hittable_list lights;</span><br><span class="line">lights.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="number">0</span>));</span><br><span class="line">lights.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">90</span>, <span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><blockquote><p>And we get a decent image with 1000 samples as before:</p></blockquote><p>å’Œä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬ç”¨1000ä¸ªæ ·æœ¬å¾—åˆ°äº†ä¸€ä¸ªä¸é”™çš„å›¾åƒ:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.11-glass-and-light-20210816114843095.jpg"></p><h4 id="Handling-Surface-Acne"><a href="#Handling-Surface-Acne" class="headerlink" title="Handling Surface Acne"></a>Handling Surface Acne</h4><blockquote><p>An astute reader pointed out there are some black specks in the image above. All Monte Carlo Ray Tracers have this as a main loop:</p></blockquote><p>ä¸€ä½ç²¾æ˜çš„è¯»è€…æŒ‡å‡ºï¼Œä¸Šå›¾ä¸­æœ‰ä¸€äº›é»‘ç‚¹ã€‚æ‰€æœ‰è’™ç‰¹å¡ç½—å°„çº¿è¿½è¸ªå™¨éƒ½æœ‰è¿™æ ·ä¸€ä¸ªä¸»å¾ªç¯:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pixel_color = <span class="built_in">average</span>(many many samples)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>If you find yourself getting some form of acne in the images, and this acne is white or black, so one â€œbadâ€ sample seems to kill the whole pixel, that sample is probably a huge number or a <code>NaN</code> (Not A Number). This particular acne is probably a <code>NaN</code>. Mine seems to come up once in every 10â€“100 million rays or so.</p></blockquote><p>å¦‚æœä½ å‘ç°è‡ªå·±åœ¨å›¾åƒä¸­å‡ºç°äº†æŸç§å½¢å¼çš„ç—¤ç–®ï¼Œè€Œä¸”è¿™ä¸ªç—¤ç–®æ˜¯ç™½è‰²æˆ–é»‘è‰²çš„ï¼Œæ‰€ä»¥ä¸€ä¸ªâ€œåâ€æ ·æœ¬ä¼¼ä¹ä¼šæ¯æ‰æ•´ä¸ªåƒç´ ï¼Œè¿™ä¸ªæ ·æœ¬å¯èƒ½æ˜¯ä¸€ä¸ªå·¨å¤§çš„æ•°å­—æˆ– <code>NaN</code>(ä¸æ˜¯ä¸€ä¸ªæ•°å­—)ã€‚è¿™ä¸ªç‰¹æ®Šçš„ç—¤ç–®å¯èƒ½æ˜¯ <code>NaN</code>ã€‚æˆ‘çš„å…‰ä¼¼ä¹æ¯1000ä¸‡åˆ°1äº¿æ¬¡å·¦å³å°±ä¼šå‡ºç°ä¸€æ¬¡ã€‚</p><blockquote><p>So big decision: sweep this bug under the rug and check for <code>NaN</code>s, or just kill <code>NaN</code>s and hope this doesnâ€™t come back to bite us later. I will always opt for the lazy strategy, especially when I know floating point is hard. First, how do we check for a <code>NaN</code>? The one thing I always remember for <code>NaN</code>s is that a <code>NaN</code> does not equal itself. Using this trick, we update the <code>write_color()</code> function to replace any NaN components with zero:</p></blockquote><p>æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªé‡å¤§çš„å†³å®š:æŠŠè¿™ä¸ªbugæ©ç›–èµ·æ¥ï¼Œæ£€æŸ¥ <code>NaN</code>ï¼Œæˆ–è€…å¹²è„†æ¶ˆç­<code>NaN</code>ï¼Œå¸Œæœ›å®ƒä»¥åä¸ä¼šå†æ¥å’¬æˆ‘ä»¬ã€‚æˆ‘æ€»æ˜¯é€‰æ‹©æƒ°æ€§ç­–ç•¥ï¼Œç‰¹åˆ«æ˜¯å½“æˆ‘çŸ¥é“æµ®ç‚¹æ•°å¾ˆéš¾çš„æ—¶å€™ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¦‚ä½•æ£€æŸ¥ <code>NaN</code>?å¯¹äº <code>NaN</code>ï¼Œæˆ‘æ€»æ˜¯è®°å¾—çš„ä¸€ä»¶äº‹æ˜¯ <code>NaN</code> ä¸ç­‰äºå®ƒè‡ªå·±ã€‚ä½¿ç”¨è¿™ä¸ªæŠ€å·§ï¼Œæˆ‘ä»¬æ›´æ–° <code>write_color()</code> å‡½æ•°ï¼Œå°†ä»»ä½• <code>NaN</code> ç»„ä»¶æ›¿æ¢ä¸º0:</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">void write_color(std::ostream &amp;out, vec3 pixel_color, int samples_per_pixel) {</span><br><span class="line">    auto r = pixel_color.x();</span><br><span class="line">    auto g = pixel_color.y();</span><br><span class="line">    auto b = pixel_color.z();</span><br><span class="line"></span><br><span class="line"><span class="addition">+   // Replace NaN components with zero. See explanation in Ray Tracing: The Rest of Your Life.</span></span><br><span class="line"><span class="addition">+   if (r != r) r = 0.0;</span></span><br><span class="line"><span class="addition">+   if (g != g) g = 0.0;</span></span><br><span class="line"><span class="addition">+   if (b != b) b = 0.0;</span></span><br><span class="line"></span><br><span class="line">    // Divide the color by the number of samples and gamma-correct for gamma=2.0.</span><br><span class="line">    auto scale = 1.0 / samples_per_pixel;</span><br><span class="line">    r = sqrt(scale * r);</span><br><span class="line">    g = sqrt(scale * g);</span><br><span class="line">    b = sqrt(scale * b);</span><br><span class="line"></span><br><span class="line">    // Write the translated [0,255] value of each color component.</span><br><span class="line">    out &lt;&lt; static_cast&lt;int&gt;(256 * clamp(r, 0.0, 0.999)) &lt;&lt; ' '</span><br><span class="line">        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(g, 0.0, 0.999)) &lt;&lt; ' '</span><br><span class="line">        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(b, 0.0, 0.999)) &lt;&lt; '\n';</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Happily, the black specks are gone:</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img-3.12-book3-final.jpg"></p><h3 id="ä½ çš„ä½™ç”Ÿ"><a href="#ä½ çš„ä½™ç”Ÿ" class="headerlink" title="ä½ çš„ä½™ç”Ÿ"></a>ä½ çš„ä½™ç”Ÿ</h3><blockquote><p>The purpose of this book was to show the details of dotting all the iâ€™s of the math on one way of organizing a physically based rendererâ€™s sampling approach. Now you can explore a lot of different potential paths.</p><p>If you want to explore Monte Carlo methods, look into bidirectional and path spaced approaches such as Metropolis. Your probability space wonâ€™t be over solid angle, but will instead be over path space, where a path is a multidimensional point in a high-dimensional space. Donâ€™t let that scare you â€” if you can describe an object with an array of numbers, mathematicians call it a point in the space of all possible arrays of such points. Thatâ€™s not just for show. Once you get a clean abstraction like that, your code can get clean too. Clean abstractions are what programming is all about!</p><p>If you want to do movie renderers, look at the papers out of studios and Solid Angle. They are surprisingly open about their craft.</p><p>If you want to do high-performance ray tracing, look first at papers from Intel and NVIDIA. Again, they are surprisingly open.</p><p>If you want to do hard-core physically based renderers, convert your renderer from RGB to spectral. I am a big fan of each ray having a random wavelength and almost all the RGBs in your program turning into floats. It sounds inefficient, but it isnâ€™t!</p><p>Regardless of what direction you take, add a glossy BRDF model. There are many to choose from, and each has its advantages.</p><p>Have fun!</p><p><a target="_blank" rel="noopener" href="https://github.com/petershirley">Peter Shirley</a><br>Salt Lake City, March, 2016</p></blockquote><p>è¿™æœ¬ä¹¦çš„ç›®çš„æ˜¯å±•ç¤ºå¦‚ä½•ç”¨ä¸€ç§æ–¹æ³•ç»„ç»‡åŸºäºç‰©ç†çš„æ¸²æŸ“å™¨çš„é‡‡æ ·æ–¹æ³•æ¥ç‚¹ç”»æ‰€æœ‰çš„æ•°å­¦içš„ç»†èŠ‚ã€‚ç°åœ¨ä½ å¯ä»¥æ¢ç´¢è®¸å¤šä¸åŒçš„æ½œåœ¨è·¯å¾„ã€‚</p><p>å¦‚æœä½ æƒ³æ¢ç´¢è’™ç‰¹å¡ç½—æ–¹æ³•ï¼Œçœ‹çœ‹åŒå‘å’Œè·¯å¾„é—´éš”çš„æ–¹æ³•ï¼Œå¦‚Metropolisã€‚ä½ çš„æ¦‚ç‡ç©ºé—´ä¸ä¼šåœ¨ç«‹ä½“è§’ä¸Šï¼Œè€Œæ˜¯åœ¨è·¯å¾„ç©ºé—´ä¸Šï¼Œè·¯å¾„æ˜¯é«˜ç»´ç©ºé—´ä¸­çš„ä¸€ä¸ªå¤šç»´ç‚¹ã€‚ä¸è¦è¢«è¿™å“å€’â€”â€”å¦‚æœä½ èƒ½ç”¨ä¸€ç»„æ•°å­—æ¥æè¿°ä¸€ä¸ªå¯¹è±¡ï¼Œæ•°å­¦å®¶ä»¬å°±ç§°å®ƒä¸ºç©ºé—´ä¸­æ‰€æœ‰è¿™äº›ç‚¹çš„å¯èƒ½æ•°ç»„ä¸­çš„ä¸€ä¸ªç‚¹ã€‚è¿™ä¸æ˜¯ä½œç§€ã€‚ä¸€æ—¦ä½ å¾—åˆ°äº†è¿™æ ·ä¸€ä¸ªæ¸…æ™°çš„æŠ½è±¡ï¼Œä½ çš„ä»£ç ä¹Ÿå¯ä»¥å˜å¾—æ¸…æ™°ã€‚å¹²å‡€çš„æŠ½è±¡å°±æ˜¯ç¼–ç¨‹çš„å…¨éƒ¨!</p><p>å¦‚æœä½ æƒ³åšç”µå½±æ¸²æŸ“ï¼Œçœ‹çœ‹å·¥ä½œå®¤å’Œç«‹ä½“è§’çš„æ–‡ä»¶ã€‚ä»–ä»¬å¯¹è‡ªå·±çš„æ‰‹è‰ºå‡ºå¥‡åœ°å¼€æ”¾ã€‚</p><p>å¦‚æœä½ æƒ³åšé«˜æ€§èƒ½çš„å…‰çº¿è¿½è¸ªï¼Œé¦–å…ˆçœ‹ä¸€ä¸‹æ¥è‡ªIntelå’ŒNVIDIAçš„è®ºæ–‡ã€‚åŒæ ·ï¼Œå®ƒä»¬å‡ºäººæ„æ–™åœ°å¼€æ”¾ã€‚</p><p>å¦‚æœä½ æƒ³åšç¡¬æ ¸çš„åŸºäºç‰©ç†çš„æ¸²æŸ“å™¨ï¼ŒæŠŠä½ çš„æ¸²æŸ“å™¨ä»RGBè½¬æ¢æˆå…‰è°±ã€‚æˆ‘éå¸¸å–œæ¬¢æ¯ä¸ªå°„çº¿éƒ½æœ‰ä¸€ä¸ªéšæœºçš„æ³¢é•¿ï¼Œå‡ ä¹æ‰€æœ‰çš„rgbåœ¨ä½ çš„ç¨‹åºå˜æˆæµ®åŠ¨ã€‚è¿™å¬èµ·æ¥æ•ˆç‡å¾ˆä½ï¼Œä½†äº‹å®å¹¶éå¦‚æ­¤!</p><p>æ— è®ºä½ é€‰æ‹©ä»€ä¹ˆæ–¹å‘ï¼Œæ·»åŠ ä¸€ä¸ªå…‰æ»‘çš„BRDFæ¨¡å‹ã€‚æœ‰å¾ˆå¤šé€‰æ‹©ï¼Œè€Œä¸”æ¯ç§éƒ½æœ‰å…¶ä¼˜ç‚¹ã€‚</p><p>ç©å¾—å¼€å¿ƒ!</p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/7dbe30e4.html" rel="bookmark">Blockwise Multi-Order Feature Regression for Real-Time Path Tracing Reconstruction</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/971404c0.html" rel="bookmark">Rendering Course by Wangningbei</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/e82c1146.html" rel="prev" title="Pipeline and Shading"><i class="fa fa-chevron-left"></i> Pipeline and Shading</a></div><div class="post-nav-item"><a href="/archives/8069546e.html" rel="next" title="Stack">Stack <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">å¼•è¨€</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">æ¦‚è¿°</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">ä¸€ä¸ªç®€å•çš„è’™ç‰¹å¡ç½—ç¨‹åº</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Estimating-Pi"><span class="nav-number">3.1.</span> <span class="nav-text">Estimating Pi</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Showing-Convergence"><span class="nav-number">3.2.</span> <span class="nav-text">Showing Convergence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stratified-Samples-Jittering"><span class="nav-number">3.3.</span> <span class="nav-text">Stratified Samples (Jittering)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4MC%E9%9B%86%E6%88%90"><span class="nav-number">4.</span> <span class="nav-text">ä¸€ç»´MCé›†æˆ</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integrating-x%C2%B2"><span class="nav-number">4.1.</span> <span class="nav-text">Integrating xÂ²</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Density-Functions"><span class="nav-number">4.2.</span> <span class="nav-text">Density Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructing-a-PDF"><span class="nav-number">4.3.</span> <span class="nav-text">Constructing a PDF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Importance-Sampling"><span class="nav-number">4.4.</span> <span class="nav-text">Importance Sampling</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%90%91%E7%90%83%E4%B8%8A%E7%9A%84MC%E9%9B%86%E6%88%90"><span class="nav-number">5.</span> <span class="nav-text">æ–¹å‘çƒä¸Šçš„MCé›†æˆ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%89%E6%95%A3%E5%B0%84"><span class="nav-number">6.</span> <span class="nav-text">å…‰æ•£å°„</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Albedo"><span class="nav-number">6.1.</span> <span class="nav-text">Albedo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scattering"><span class="nav-number">6.2.</span> <span class="nav-text">Scattering</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Scattering-PDF"><span class="nav-number">6.3.</span> <span class="nav-text">The Scattering PDF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E9%87%87%E6%A0%B7%E6%9D%90%E8%B4%A8"><span class="nav-number">7.</span> <span class="nav-text">é‡è¦é‡‡æ ·æè´¨</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Returning-to-the-Cornell-Box"><span class="nav-number">7.1.</span> <span class="nav-text">Returning to the Cornell Box</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Random-Hemisphere-Sampling"><span class="nav-number">7.2.</span> <span class="nav-text">Random Hemisphere Sampling</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91"><span class="nav-number">8.</span> <span class="nav-text">ç”Ÿæˆéšæœºæ–¹å‘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Random-Directions-Relative-to-the-Z-Axis"><span class="nav-number">8.1.</span> <span class="nav-text">Random Directions Relative to the Z Axis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Uniform-Sampling-a-Hemisphere"><span class="nav-number">8.2.</span> <span class="nav-text">Uniform Sampling a Hemisphere</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA"><span class="nav-number">9.</span> <span class="nav-text">æ ‡å‡†æ­£äº¤åŸº</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Relative-Coordinates"><span class="nav-number">9.1.</span> <span class="nav-text">Relative Coordinates</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generating-an-Orthonormal-Basis"><span class="nav-number">9.2.</span> <span class="nav-text">Generating an Orthonormal Basis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-ONB-Class"><span class="nav-number">9.3.</span> <span class="nav-text">The ONB Class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7"><span class="nav-number">10.</span> <span class="nav-text">ç›´æ¥å…‰æºé‡‡æ ·</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Getting-the-PDF-of-a-Light"><span class="nav-number">10.1.</span> <span class="nav-text">Getting the PDF of a Light</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Light-Sampling"><span class="nav-number">10.2.</span> <span class="nav-text">Light Sampling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Switching-to-Unidirectional-Light"><span class="nav-number">10.3.</span> <span class="nav-text">Switching to Unidirectional Light</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%AF%86%E5%BA%A6"><span class="nav-number">11.</span> <span class="nav-text">æ··åˆå¯†åº¦</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#An-Average-of-Lighting-and-Reflection"><span class="nav-number">11.1.</span> <span class="nav-text">An Average of Lighting and Reflection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sampling-Directions-towards-a-Hittable"><span class="nav-number">11.2.</span> <span class="nav-text">Sampling Directions towards a Hittable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Mixture-PDF-Class"><span class="nav-number">11.3.</span> <span class="nav-text">The Mixture PDF Class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%9E%B6%E6%9E%84%E5%86%B3%E7%AD%96"><span class="nav-number">12.</span> <span class="nav-text">ä¸€äº›æ¶æ„å†³ç­–</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96PDF%E6%9E%B6%E6%9E%84"><span class="nav-number">13.</span> <span class="nav-text">ä¼˜åŒ–PDFæ¶æ„</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Diffuse-Versus-Specular"><span class="nav-number">13.1.</span> <span class="nav-text">Diffuse Versus Specular</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Handling-Specular"><span class="nav-number">13.2.</span> <span class="nav-text">Handling Specular</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sampling-a-Sphere-Object"><span class="nav-number">13.3.</span> <span class="nav-text">Sampling a Sphere Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Updating-the-Sphere-Code"><span class="nav-number">13.4.</span> <span class="nav-text">Updating the Sphere Code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adding-PDF-Functions-to-Hittable-Lists"><span class="nav-number">13.5.</span> <span class="nav-text">Adding PDF Functions to Hittable Lists</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Handling-Surface-Acne"><span class="nav-number">13.6.</span> <span class="nav-text">Handling Surface Acne</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E7%9A%84%E4%BD%99%E7%94%9F"><span class="nav-number">14.</span> <span class="nav-text">ä½ çš„ä½™ç”Ÿ</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">297</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">47</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail â†’ mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub â†’ https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter â†’ https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo â†’ https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam â†’ https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess â†’ https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS â†’ /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify â†’ https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">ç¹/ç®€ï¼š<a id="translateLink" href="javascript:translatePage();">ç¹ä½“</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="ç¹ä½“",msgToSimplifiedChinese="ç®€ä½“",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">æ™‹ICPå¤‡2021009930å· </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">Â© 2020 â€“ <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.5m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>ä»Šæ—©é›¾éœ¾è”½æ—¥ï¼Œä½†æ˜¯ä¸è¦å®³æ€•ï¼Œå¤ªé˜³ä¾æ—§åœ¨äº‘ç«¯</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}ï¼‰
#åœ¨è¿™åé¢å¯ä»¥åŠ å…¥ç¨‹åºçš„å…¶ä»–ä»£ç   


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
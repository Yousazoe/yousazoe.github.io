<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Twitter@Rusty90592852            引言游戏开发一直是热门的领域，掌握良好的游戏编程模式是开发人员的应备技能，本书细致地讲解了游戏开发需要用到的各种编程模式，并提供了丰富的示例。本章关于解耦模式的介绍。"><meta property="og:type" content="article"><meta property="og:title" content="解耦模式"><meta property="og:url" content="https://yousazoe.top/archives/b608d2fb.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Twitter@Rusty90592852            引言游戏开发一直是热门的领域，掌握良好的游戏编程模式是开发人员的应备技能，本书细致地讲解了游戏开发需要用到的各种编程模式，并提供了丰富的示例。本章关于解耦模式的介绍。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/FIrMJqMWQAE0uTy.jpeg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/component-uml.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-loop.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-central.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-queue.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-crawl.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-ring.png"><meta property="article:published_time" content="2022-01-16T09:03:46.000Z"><meta property="article:modified_time" content="2022-06-08T13:01:46.468Z"><meta property="article:author" content="Yousazoe"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/FIrMJqMWQAE0uTy.jpeg"><link rel="canonical" href="https://yousazoe.top/archives/b608d2fb.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>解耦模式 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/b608d2fb.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">解耦模式</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-01-16 17:03:46" itemprop="dateCreated datePublished" datetime="2022-01-16T17:03:46+08:00">2022-01-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Game-Programming-Patterns/" itemprop="url" rel="index"><span itemprop="name">游戏设计模式 (Game Programming Patterns)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>33k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>1:01</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/FIrMJqMWQAE0uTy.jpeg"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://twitter.com/Rusty90592852/status/1480219910387163145">Twitter@Rusty90592852</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>游戏开发一直是热门的领域，掌握良好的游戏编程模式是开发人员的应备技能，本书细致地讲解了游戏开发需要用到的各种编程模式，并提供了丰富的示例。本章关于解耦模式的介绍。</p><span id="more"></span><p>一旦你掌握了编程语言，编写想要写的东西就会变得相当容易。 困难的是编写适应需求变化的代码，在我们用文本编辑器开火之前，通常没有完美的特性表供我们使用。</p><p>能让我们更好地适应变化的工具是解耦。 当我们说两块代码“解耦”时，是指修改一块代码一般不会需要修改另一块代码。 当我们修改游戏中的特性时，需要修改的代码越少，就越容易。</p><p>组件模式将一个实体拆成多个，解耦不同的领域。 事件序列解耦了两个互相通信的事物，稳定而且及时。 服务定位器让代码使用服务而无需绑定到提供服务的代码。</p><h3 id="组件模式"><a href="#组件模式" class="headerlink" title="组件模式"></a>组件模式</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p>允许单一的实体跨越多个领域而不会导致这些领域彼此耦合。</p><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>让我们假设我们正在制作平台跳跃游戏。 意大利水管工已经有人做了，因此我们将出动丹麦面包师，Bjorn。 照理说，会有一个类来表示友好的糕点厨师，包含他在游戏中做的一切。</p><blockquote><p>像这样的游戏创意导致了我是程序员而不是设计师。</p></blockquote><p>由于玩家控制着他，这意味着需要读取控制器的输入然后转化为动作。 而且他当然需要与关卡进行互动，所以要引入物理和碰撞。 一旦这样做了，他就必须在屏幕上出现，所以要引入动画和渲染。 他可能还会播放一些声音。</p><p>等一下，这一切正在失控。软件体系结构101课程告诉我们，程序的不同领域应保持分离。 如果我们做一个文字处理器，处理打印的代码不应该受加载和保存文件的代码影响。 游戏和企业应用程序的领域不尽相同，但该规则仍然适用。</p><p>我们希望AI，物理，渲染，声音和其他领域域尽可能相互不了解， 但现在我们将所有这一切挤在一个类中。 我们已经看到了这条路通往何处：5000行的巨大代码文件，哪怕是你们团队中最勇敢的程序员也不敢打开。</p><p>这工作对能驯服他的少数人来说是有趣的，但对其他人而言是地狱。 这么大的类意味着，即使是看似微不足道的变化亦可有深远的影响。 很快，为类添加错误的速度会明显快于添加功能的速度。</p><h5 id="一团乱麻"><a href="#一团乱麻" class="headerlink" title="一团乱麻"></a>一团乱麻</h5><p>比起单纯的规模问题，更糟糕的是耦合。 在游戏中，所有不同的系统被绑成了一个巨大的代码球：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">collidingWithFloor</span>() &amp;&amp; (<span class="built_in">getRenderState</span>() != INVISIBLE))</span><br><span class="line">{</span><br><span class="line">  <span class="built_in">playSound</span>(HIT_FLOOR);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>任何试图改变上面代码的程序员，都需要物理，图形和声音的相关知识，以确保没破坏什么。</p><blockquote><p>这样的耦合在<em>任何</em>游戏中出现都是个问题，但是在使用并发的现代游戏中尤其糟糕。 在多核硬件上，让代码同时在多个线程上运行是至关重要的。 将游戏分割为多线程的一种通用方法是通过领域划分——在一个核上运行AI代码，在另一个上播放声音，在第三个上渲染，等等。</p></blockquote><p>这两个问题互相混合；这个类涉及太多的域，每个程序员都得接触它， 但它又太过巨大，这就变成了一场噩梦。 如果变得够糟糕，程序员会黑入代码库的其他部分，仅仅为了躲开这个像毛球一样的<code>Bjorn</code>类。</p><h5 id="快刀斩乱麻"><a href="#快刀斩乱麻" class="headerlink" title="快刀斩乱麻"></a>快刀斩乱麻</h5><p>我们可以像亚历山大大帝一样解决这个问题——快刀斩乱麻。 按领域将 <code>Bjorn</code> 类割成相互独立的部分。 例如，抽出所有处理用户输入的代码，将其移动到一个单独的 <code>InputComponent</code> 类。 <code>Bjorn</code> 拥有这个部件的一个实例。我们将对 <code>Bjorn</code> 接触的每个领域重复这一过程。</p><blockquote><p>一旦你这么做了，在领域间保持解耦就是至关重要的，这是为了避免死锁或者其他噩梦般的并发问题。 如果某个函数从一个线程上调用<code>UpdateSounds()</code>方法，从另一个线程上调用<code>RenderGraphics()</code>方法，那它是在自找麻烦。</p></blockquote><p>当完成后，我们就将 <code>Bjorn</code> 大多数的东西都抽走了。 剩下的是一个薄壳包着所有的组件。 通过将类划分为多个小类，我们已经解决了这个问题。但我们所完成的远不止如此。</p><h5 id="宽松的结果"><a href="#宽松的结果" class="headerlink" title="宽松的结果"></a>宽松的结果</h5><p>我们的组件类现在解耦了。 尽管<code>Bjorn</code>有<code>PhysicsComponent</code>和<code>GraphicsComponent</code>， 但这两部分都不知道对方的存在。 这意味着处理物理的人可以修改组件而不需要了解图形，反之亦然。</p><p>在实践中，这些部件之间需要有一些相互作用。 例如，AI组件可能需要告诉物理组件Bjorn试图去哪里。 然而，我们可以将这种交互限制在<em>确实</em>需要交互的组件之间， 而不是把它们围在同一个围栏里。</p><h5 id="绑到一起"><a href="#绑到一起" class="headerlink" title="绑到一起"></a>绑到一起</h5><p>这种设计的另一特性是，组件现在是可复用的包。 到目前为止，我们专注于面包师，但是让我们考虑几个游戏世界中其他类型的对象。 装饰 是玩家看到但不能交互的事物：灌木，杂物等视觉细节。 道具 像装饰，但可以交互：箱，巨石，树木。 区域 与装饰相反——无形但可互动。 它们是很好的触发器，比如在Bjorn进入区域时触发过场动画。</p><blockquote><p>当面向对象语言第一次接触这个场景时，继承是它箱子里最闪耀的工具。 它被认为是代码无限重用之锤，编程者常常挥舞着它。 然而我们痛苦地学到，事实上它是一把重锤。 继承有它的用处，但对简单的代码重用来说太过复杂。</p><p>相反，在今日软件设计的趋势是尽可能使用组件代替继承。 不是让两个类<strong>继承</strong>同一类来分享代码，而是让它们<strong>拥有同一个类的实例</strong>。</p></blockquote><p>现在，考虑如果不用组件，我们将如何建立这些类的继承层次。第一遍可能是这样的：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/component-uml.png"></p><p>我们有<code>GameObject</code>基类，包含位置和方向之类的通用部分。 <code>Zone</code>继承它，增加了碰撞检测。 同样，<code>Decoration</code>继承<code>GameObject</code>，并增加了渲染。 <code>Prop</code>继承<code>Zone</code>，因此它可以重用碰撞代码。 然而，<code>Prop</code>不能<em>同时</em>继承<code>Decoration</code>来重用<em>渲染</em>， 否则就会造成致命菱形结构。</p><blockquote><p>“致命菱形”发生在类继承了多个类，而这多个类中有两个继承同一基类时。 介绍它造成的痛苦超过了本书的范围，但它被说成“致命”是有原因的。</p></blockquote><p>我们可以反过来让<code>Prop</code>继承<code>Decoration</code>，但随后不得不重复<em>碰撞检测</em>代码。 无论哪种方式，没有干净的办法重用碰撞和渲染代码而不诉诸多重继承。 唯一的其他选择是一切都继承<code>GameObject</code>， 但随后<code>Zone</code>会浪费内存在并不需要的渲染数据上， <code>Decoration</code>在物理效果上有同样的浪费。</p><p>现在，让我们尝试用组件。子类将彻底消失。 取而代之的是一个<code>GameObject</code>类和两个组件类：<code>PhysicsComponent</code>和<code>GraphicsComponent</code>。 装饰是个简单的<code>GameObject</code>，包含<code>GraphicsComponent</code>但没有<code>PhysicsComponent</code>。 区域与其恰好相反，而道具包含两种组件。 没有代码重复，没有多重继承，只有三个类，而不是四个。</p><blockquote><p>可以拿饭店菜单打比方。如果每个实体是一个类，那就只能订套餐。 我们需要为每种<em>可能</em>的组合定义各自的类。 为了满足每位用户，我们需要十几种套餐。</p><p>组件是照单点菜——每位顾客都可以选他们想要的，菜单记录可选的菜式。</p></blockquote><p>对对象而言，组件是即插即用的。 将不同的可重用部件插入对象，我们就能构建复杂且具有丰富行为的实体。 就像软件中的战神金刚。</p><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p><strong>单一实体跨越了多个领域</strong>。为了保持领域之间相互分离，将每部分代码放入<strong>各自的组件类</strong>中。 实体被简化为组件的容器。</p><blockquote><p>“组件”，就像“对象”，在编程中意味任何东西也不意味任何东西。 正因如此，它被用来描述一些概念。 在商业软件中，“组件”设计模式描述通过网络解耦的服务。</p></blockquote><h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><blockquote><p>我试图从游戏中找到无关这个设计模式的另一个名字，但“组件”看来是最常用的术语。 由于设计模式是记录已存的实践，我没有创建新术语的余地。 所以，跟着XNA，Delta3D和其他人的脚步，我称之为“组件”。</p></blockquote><p>组件通常在定义游戏实体的核心部分中使用，但它们在其他地方也有用。 这个模式应用在在如下情况中：</p><ul><li>有一个涉及了多个领域的类，而你想保持这些领域互相隔离。</li><li>一个类正在变大而且越来越难以使用。</li><li>想要能定义一系列分享不同能力的类，但是使用继承无法让你精确选取要重用的部分。</li></ul><h4 id="记住"><a href="#记住" class="headerlink" title="记住"></a>记住</h4><p>组件模式比简单地向类中添加代码增加了一点点复杂性。 每个概念上的“对象”要组成真正的对象需要实例化，初始化，然后正确地连接。 不同组件间沟通会有些困难，而控制它们如何使用内存就更加复杂。</p><p>对于大型代码库，为了解耦和重用而付出这样的复杂度是值得的。 但是在使用这种模式之前，保证你没有为了不存在的问题而“过度设计”。</p><blockquote><p>这是硬币的两面。组件模式通常可以<em>增进</em>性能和缓存一致性。 组件让使用<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/data-locality.html">数据局部性</a>模式的CPU更容易组织数据。</p></blockquote><p>使用组件的另一后果是，需要多一层跳转才能做要做的事。 拿到容器对象，获得相应的组件，然后你才能做想做的事情。 在性能攸关的内部循环中，这种跳转也许会导致糟糕的性能。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>我写这本书的最大挑战之一就是搞明白如何隔离各个模式。 许多设计模式包含了不属于这种模式的代码。 为了将提取模式的本质，我尽可能地消减代码， 但是在某种程度上，这就像是没有衣服还要说明如何整理衣柜。</p><p>说明组件模式尤其困难。 如果看不到它解耦的各个领域的代码，你就不能获得正确的体会， 因此我会多写一些有关于Bjorn的代码。 这个模式事实上只关于将组件变为<em>类</em>，但类中的代码可以帮助表明类是做什么用的。 它是伪代码——它调用了其他不存在的类——但这应该可以让你理解我们正在做什么。</p><h5 id="单块类"><a href="#单块类" class="headerlink" title="单块类"></a>单块类</h5><p>为了清晰的看到这个模式是如何应用的， 我们先展示一个<code>Bjorn</code>类， 它包含了所有我们需要的事物，但是没有使用这个模式：</p><blockquote><p>我应指出在代码中使用角色的名字总是个坏主意。市场部有在发售之前改名字的坏习惯。 “焦点测试表明，在11岁到15岁之间的男性不喜欢‘Bjorn’，请改为‘Sven‘”。</p><p>这就是为什么很多软件项目使用内部代码名。 而且比起告诉人们你在完成“Photoshop的下一版本”，告诉他们你在完成“大电猫”更有趣。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bjorn</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Bjorn</span>()</span><br><span class="line">  : <span class="built_in">velocity_</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">x_</span>(<span class="number">0</span>), <span class="built_in">y_</span>(<span class="number">0</span>)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World&amp; world, Graphics&amp; graphics)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> WALK_ACCELERATION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> velocity_;</span><br><span class="line">  <span class="type">int</span> x_, y_;</span><br><span class="line"></span><br><span class="line">  Volume volume_;</span><br><span class="line"></span><br><span class="line">  Sprite spriteStand_;</span><br><span class="line">  Sprite spriteWalkLeft_;</span><br><span class="line">  Sprite spriteWalkRight_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>Bjorn</code>有个每帧调用的<code>update()</code>方法。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bjorn::update</span><span class="params">(World&amp; world, Graphics&amp; graphics)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 根据用户输入修改英雄的速度</span></span><br><span class="line">  <span class="keyword">switch</span> (Controller::<span class="built_in">getJoystickDirection</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">case</span> DIR_LEFT:</span><br><span class="line">      velocity_ -= WALK_ACCELERATION;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DIR_RIGHT:</span><br><span class="line">      velocity_ += WALK_ACCELERATION;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据速度修改位置</span></span><br><span class="line">  x_ += velocity_;</span><br><span class="line">  world.<span class="built_in">resolveCollision</span>(volume_, x_, y_, velocity_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制合适的图形</span></span><br><span class="line">  Sprite* sprite = &amp;spriteStand_;</span><br><span class="line">  <span class="keyword">if</span> (velocity_ &lt; <span class="number">0</span>)</span><br><span class="line">  {</span><br><span class="line">    sprite = &amp;spriteWalkLeft_;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (velocity_ &gt; <span class="number">0</span>)</span><br><span class="line">  {</span><br><span class="line">    sprite = &amp;spriteWalkRight_;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  graphics.<span class="built_in">draw</span>(*sprite, x_, y_);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它读取操纵杆以确定如何加速面包师。 然后，用物理引擎解析新位置。 最后，将Bjorn渲染至屏幕。</p><p>这里的示例实现平凡而简单。 没有重力，动画，或任何让人物有趣的其他细节。 即便如此，我们可以看到，已经出现了同时消耗多个程序员时间的函数，而它开始变得有点混乱。 想象增加到一千行，你就知道这会有多难受了。</p><h5 id="分离领域"><a href="#分离领域" class="headerlink" title="分离领域"></a>分离领域</h5><p>从一个领域开始，将<code>Bjorn</code>的代码去除一部分，归入分离的组件类。 我们从首个执行的领域开始：输入。 <code>Bjorn</code>做的头件事就是读取玩家的输入，然后基于此调整它的速度。 让我们将这部分逻辑移入一个分离的类：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InputComponent</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Bjorn&amp; bjorn)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">switch</span> (Controller::<span class="built_in">getJoystickDirection</span>())</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">case</span> DIR_LEFT:</span><br><span class="line">        bjorn.velocity -= WALK_ACCELERATION;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DIR_RIGHT:</span><br><span class="line">        bjorn.velocity += WALK_ACCELERATION;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> WALK_ACCELERATION = <span class="number">1</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>很简单吧。我们将<code>Bjorn</code>的<code>update()</code>的第一部分取出，放入这个类中。 对<code>Bjorn</code>的改变也很直接：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bjorn</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> velocity;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World&amp; world, Graphics&amp; graphics)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    input_.<span class="built_in">update</span>(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据速度修改位置</span></span><br><span class="line">    x += velocity;</span><br><span class="line">    world.<span class="built_in">resolveCollision</span>(volume_, x, y, velocity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制合适的图形</span></span><br><span class="line">    Sprite* sprite = &amp;spriteStand_;</span><br><span class="line">    <span class="keyword">if</span> (velocity &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      sprite = &amp;spriteWalkLeft_;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (velocity &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      sprite = &amp;spriteWalkRight_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    graphics.<span class="built_in">draw</span>(*sprite, x, y);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  InputComponent input_;</span><br><span class="line"></span><br><span class="line">  Volume volume_;</span><br><span class="line"></span><br><span class="line">  Sprite spriteStand_;</span><br><span class="line">  Sprite spriteWalkLeft_;</span><br><span class="line">  Sprite spriteWalkRight_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>Bjorn</code>现在拥有了一个<code>InputComponent</code>对象。 之前它在<code>update()</code>方法中直接处理用户输入，现在委托给组件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">input_.<span class="built_in">update</span>(*<span class="keyword">this</span>);</span><br></pre></td></tr></tbody></table></figure><p>我们才刚开始，但已经摆脱了一些耦合——<code>Bjorn</code>主体现在已经与<code>Controller</code>无关了。这会派上用场的。</p><h5 id="将剩下的分割出来"><a href="#将剩下的分割出来" class="headerlink" title="将剩下的分割出来"></a>将剩下的分割出来</h5><p>现在让我们对物理和图像代码继续这种剪切粘贴的工作。 这是我们新的 <code>PhysicsComponent</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhysicsComponent</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Bjorn&amp; bjorn, World&amp; world)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    bjorn.x += bjorn.velocity;</span><br><span class="line">    world.<span class="built_in">resolveCollision</span>(volume_,</span><br><span class="line">        bjorn.x, bjorn.y, bjorn.velocity);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Volume volume_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>为了将物理行为移出<code>Bjorn</code>类，你可以看到我们也移出了数据：<code>Volume</code>对象已经是组件的一部分了。</p><p>最后，这是现在的渲染代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicsComponent</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Bjorn&amp; bjorn, Graphics&amp; graphics)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    Sprite* sprite = &amp;spriteStand_;</span><br><span class="line">    <span class="keyword">if</span> (bjorn.velocity &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      sprite = &amp;spriteWalkLeft_;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bjorn.velocity &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      sprite = &amp;spriteWalkRight_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    graphics.<span class="built_in">draw</span>(*sprite, bjorn.x, bjorn.y);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Sprite spriteStand_;</span><br><span class="line">  Sprite spriteWalkLeft_;</span><br><span class="line">  Sprite spriteWalkRight_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们几乎将所有的东西都移出来了，所以面包师还剩下什么？没什么了：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bjorn</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> velocity;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World&amp; world, Graphics&amp; graphics)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    input_.<span class="built_in">update</span>(*<span class="keyword">this</span>);</span><br><span class="line">    physics_.<span class="built_in">update</span>(*<span class="keyword">this</span>, world);</span><br><span class="line">    graphics_.<span class="built_in">update</span>(*<span class="keyword">this</span>, graphics);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  InputComponent input_;</span><br><span class="line">  PhysicsComponent physics_;</span><br><span class="line">  GraphicsComponent graphics_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>Bjorn</code>类现在基本上就做两件事：拥有定义它的组件，以及在不同域间分享的数据。 有两个原因导致位置和速度仍然在<code>Bjorn</code>的核心类中： 首先，它们是“泛领域”状态——几乎每个组件都需要使用它们， 所以我们想要提取它出来时，哪个组件<em>应该</em>拥有它们并不明确。</p><p>第二，也是更重要的一点，它给了我们无需让组件耦合就能沟通的简易方法。 让我们看看能不能利用这一点。</p><h5 id="机器人Bjorn"><a href="#机器人Bjorn" class="headerlink" title="机器人Bjorn"></a>机器人Bjorn</h5><p>到目前为止，我们将行为归入了不同的组件类，但还没将行为<em>抽象</em>出来。 <code>Bjorn</code>仍知道每个类的具体定义的行为。让我们改变这一点。</p><p>取出处理输入的部件，将其藏在接口之后，将<code>InputComponent</code>变为抽象基类。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InputComponent</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">InputComponent</span>() {}</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Bjorn&amp; bjorn)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然后，将现有的处理输入的代码取出，放进一个实现接口的类中。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerInputComponent</span> : <span class="keyword">public</span> InputComponent</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Bjorn&amp; bjorn)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">switch</span> (Controller::<span class="built_in">getJoystickDirection</span>())</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">case</span> DIR_LEFT:</span><br><span class="line">        bjorn.velocity -= WALK_ACCELERATION;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DIR_RIGHT:</span><br><span class="line">        bjorn.velocity += WALK_ACCELERATION;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> WALK_ACCELERATION = <span class="number">1</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们将<code>Bjorn</code>改为只拥有一个指向输入组件的指针，而不是拥有一个内联的实例。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bjorn</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> velocity;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Bjorn</span>(InputComponent* input)</span><br><span class="line">  : <span class="built_in">input_</span>(input)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World&amp; world, Graphics&amp; graphics)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    input_-&gt;<span class="built_in">update</span>(*<span class="keyword">this</span>);</span><br><span class="line">    physics_.<span class="built_in">update</span>(*<span class="keyword">this</span>, world);</span><br><span class="line">    graphics_.<span class="built_in">update</span>(*<span class="keyword">this</span>, graphics);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  InputComponent* input_;</span><br><span class="line">  PhysicsComponent physics_;</span><br><span class="line">  GraphicsComponent graphics_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在当我们实例化<code>Bjorn</code>，我们可以传入输入组件使用，就像下面这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Bjorn* bjorn = <span class="keyword">new</span> <span class="built_in">Bjorn</span>(<span class="keyword">new</span> <span class="built_in">PlayerInputComponent</span>());</span><br></pre></td></tr></tbody></table></figure><p>这个实例可以是任何实现了抽象<code>InputComponent</code>接口的类型。 我们为此付出了代价——<code>update()</code>现在是虚方法调用了，这会慢一些。这一代价的回报是什么？</p><p>大多数的主机需要游戏支持“演示模式”。 如果玩家停在主菜单没有做任何事情，游戏就会自动开始运行，直到接入一个玩家。 这让屏幕上的主菜单看上去更有生机，同时也是销售商店里很好的展示。</p><p>隐藏在输入组件后的类帮我们实现了这点， 我们已经有了具体的<code>PlayerInputComponent</code>供玩游戏时使用。 现在让我们完成另一个：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoInputComponent</span> : <span class="keyword">public</span> InputComponent</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Bjorn&amp; bjorn)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 自动控制Bjorn的AI……</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>当游戏进入演示模式，我们将Bjorn和一个新组件连接起来，而不像之前演示的那样构造它：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Bjorn* bjorn = <span class="keyword">new</span> <span class="built_in">Bjorn</span>(<span class="keyword">new</span> <span class="built_in">DemoInputComponent</span>());</span><br></pre></td></tr></tbody></table></figure><p>现在，只需要更改组件，我们就有了为演示模式而设计的电脑控制的玩家。 我们可以重用所有Bjorn的代码——物理和图像都不知道这里有了变化。 也许我有些奇怪，但这就是每天能让我起床的事物。</p><blockquote><p>那个，还有咖啡。热气腾腾的咖啡。</p></blockquote><h5 id="删掉Bjorn？"><a href="#删掉Bjorn？" class="headerlink" title="删掉Bjorn？"></a>删掉Bjorn？</h5><p>如果你看看现在的<code>Bjorn</code>类，你会意识到那里完全没有“Bjorn”——那只是个组件包。 事实上，它是个好候选人，能够作为每个游戏中的对象都能继承的“游戏对象”基类。 我们可以像弗兰肯斯坦一样，通过挑选拼装部件构建任何对象。</p><p>让我们将剩下的两个具体组件——物理和图像——像输入那样藏到接口之后。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhysicsComponent</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">PhysicsComponent</span>() {}</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(GameObject&amp; obj, World&amp; world)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicsComponent</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">GraphicsComponent</span>() {}</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(GameObject&amp; obj, Graphics&amp; graphics)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然后将<code>Bjorn</code>改为使用这些接口的通用<code>GameObject</code>类。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> velocity;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GameObject</span>(InputComponent* input,</span><br><span class="line">             PhysicsComponent* physics,</span><br><span class="line">             GraphicsComponent* graphics)</span><br><span class="line">  : <span class="built_in">input_</span>(input),</span><br><span class="line">    <span class="built_in">physics_</span>(physics),</span><br><span class="line">    <span class="built_in">graphics_</span>(graphics)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World&amp; world, Graphics&amp; graphics)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    input_-&gt;<span class="built_in">update</span>(*<span class="keyword">this</span>);</span><br><span class="line">    physics_-&gt;<span class="built_in">update</span>(*<span class="keyword">this</span>, world);</span><br><span class="line">    graphics_-&gt;<span class="built_in">update</span>(*<span class="keyword">this</span>, graphics);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  InputComponent* input_;</span><br><span class="line">  PhysicsComponent* physics_;</span><br><span class="line">  GraphicsComponent* graphics_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>有些人走的更远。 不使用包含组件的<code>GameObject</code>，游戏实体只是一个ID，一个数字。 每个组件都知道它们连接的实体ID，然后管理分离的组件。</p><p>这些<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Entity_component_system">实体组件系统</a>将组件发挥到了极致，让你向实体添加组件而无需通知实体。 <a target="_blank" rel="noopener" href="https://gpp.tkchu.me/data-locality.html">数据局部性</a>一章有更多细节。</p></blockquote><p>我们现有的具体类被重命名并实现这些接口：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BjornPhysicsComponent</span> : <span class="keyword">public</span> PhysicsComponent</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(GameObject&amp; obj, World&amp; world)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 物理代码……</span></span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BjornGraphicsComponent</span> : <span class="keyword">public</span> GraphicsComponent</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(GameObject&amp; obj, Graphics&amp; graphics)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 图形代码……</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在我们无需为Bjorn建立具体类，就能构建拥有所有Bjorn行为的对象。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">GameObject* <span class="title">createBjorn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">GameObject</span>(<span class="keyword">new</span> <span class="built_in">PlayerInputComponent</span>(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">BjornPhysicsComponent</span>(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">BjornGraphicsComponent</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个<code>createBjorn()</code>函数当然就是经典的GoF<a target="_blank" rel="noopener" href="http://c2.com/cgi/wiki?FactoryMethod">工厂模式</a>的例子。</p></blockquote><p>通过用不同组件实例化<code>GameObject</code>，我们可以构建游戏需要的任何对象。</p><h4 id="设计决策"><a href="#设计决策" class="headerlink" title="设计决策"></a>设计决策</h4><p>这章中你最需要回答的设计问题是“我需要什么样的组件？” 回答取决于你游戏的需求和风格。 引擎越大越复杂，你就越想将组件划分得更细。</p><p>除此之外，还有几个更具体的选项要回答：</p><h5 id="对象如何获取组件？"><a href="#对象如何获取组件？" class="headerlink" title="对象如何获取组件？"></a>对象如何获取组件？</h5><p>一旦将单块对象分割为多个分离的组件，就需要决定谁将它们拼到一起。</p><p><strong>如果对象创建组件</strong>：</p><ul><li><strong>这保证了对象总是能拿到需要的组件</strong>。 你永远不必担心某人忘记连接正确的组件然后破坏了整个游戏。容器类自己会处理这个问题。</li><li><strong>重新设置对象比较困难</strong>。 这个模式的强力特性之一就是只需重新组合组件就可以创建新的对象。 如果对象总是用硬编码的组件组装自己，我们就无法利用这个特性。</li></ul><p><strong>如果外部代码提供组件</strong>：</p><ul><li><strong>对象更加灵活</strong>。 我们可以提供不同的组件，这样就能改变对象的行为。 通过共用组件，对象变成了组件容器，我们可以为不同目的一遍又一遍地重用它。</li><li><strong>对象可以与具体的组件类型解耦</strong>。</li></ul><p>如果我们允许外部代码提供组件，好处是也可以传递派生的组件类型。 这样，对象只知道组件接口而不知道组件的具体类型。这是一个很好的封装结构。</p><h5 id="组件之间如何通信？"><a href="#组件之间如何通信？" class="headerlink" title="组件之间如何通信？"></a>组件之间如何通信？</h5><p>完美解耦的组件不需要考虑这个问题，但在真正的实践中行不通。 事实上组件属于<em>同一</em>对象暗示它们属于需要相互协同的更大整体的一部分。 这就意味着通信。</p><p>所以组件如何相互通信呢？ 这里有很多选项，但不像这本书中其他的“选项”，它们相互并不冲突——你可以在一个设计中支持多种方案。</p><p><strong>通过修改容器对象的状态</strong>：</p><ul><li><p><strong>保持了组件解耦</strong>。 当我们的<code>InputComponent</code>设置了Bjorn的速度，而后<code>PhysicsComponent</code>使用它， 这两个组件都不知道对方的存在。在它们的理解中，Bjorn的速度是被黑魔法改变的。</p></li><li><p><strong>需要将组件分享的任何数据存储在容器类中</strong>。 通常状态只在几个组件间共享。比如，动画组件和渲染组件需要共享图形专用的信息。 将信息存入容器类会让<em>所有</em>组件都获得这样的信息。</p><p>更糟的是，如果我们为不同组件配置使用相同的容器类，最终会浪费内存存储不被<em>任何</em>对象组件需要的状态。 如果我们将渲染专用的数据放入容器对象中，任何隐形对象都会无益地消耗内存。</p></li><li><p><strong>这让组件的通信基于组件运行的顺序</strong>。 在同样的代码中，原先一整块的<code>update()</code>代码小心地排列这些操作。 玩家的输入修改了速度，速度被物理代码使用并修改位置，位置被渲染代码使用将Bjorn绘制到所在之处。 当我们将这些代码划入组件时，还是得小心翼翼地保持这种操作顺序。</p><p>如果我们不那么做，就引入了微妙而难以追踪的漏洞。 比如，我们先更新图形组件，就错误地将Bjorn渲染在他<em>上一帧</em>而不是这一帧所处的位置上。 如果你考虑更多的组件和更多的代码，那你可以想象要避免这样的错误有多么困难了。</p></li></ul><p><strong>通过它们之间相互引用</strong>：</p><p>这里的思路是组件有要交流的组件的引用，这样它们直接交流，无需通过容器类。</p><blockquote><p>这样被大量代码读写相同数据的共享状态很难保持正确。 这就是为什么学术界花时间研究完全函数式语言，比如Haskell，那里根本没有可变状态。</p></blockquote><p>假设我们想让Bjorn跳跃。图形代码想知道它需要用跳跃图像还是不用。 这可以通过询问物理引擎它当前是否在地上来确定。一种简单的方式是图形组件直接知道物理组件的存在：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BjornGraphicsComponent</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BjornGraphicsComponent</span>(BjornPhysicsComponent* physics)</span><br><span class="line">  : <span class="built_in">physics_</span>(physics)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(GameObject&amp; obj, Graphics&amp; graphics)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    Sprite* sprite;</span><br><span class="line">    <span class="keyword">if</span> (!physics_-&gt;<span class="built_in">isOnGround</span>())</span><br><span class="line">    {</span><br><span class="line">      sprite = &amp;spriteJump_;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 现存的图形代码……</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    graphics.<span class="built_in">draw</span>(*sprite, obj.x, obj.y);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  BjornPhysicsComponent* physics_;</span><br><span class="line"></span><br><span class="line">  Sprite spriteStand_;</span><br><span class="line">  Sprite spriteWalkLeft_;</span><br><span class="line">  Sprite spriteWalkRight_;</span><br><span class="line">  Sprite spriteJump_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>当构建Bjorn的<code>GraphicsComponent</code>时，我们给它相应的<code>PhysicsComponent</code>引用。</p><ul><li><strong>简单快捷</strong>。 通信是一个对象到另一个的直接方法调用。组件可以调用任一引用对象的方法。做什么都可以。</li><li><strong>两个组件紧绑在一起</strong>。 这是做什么都可以带来的坏处。我们向使用整块类又退回了一步。 这比只用单一类好一点，至少我们现在只是把需要通信的类绑在一起。</li></ul><p><strong>通过发送消息</strong>：</p><ul><li><p>这是最复杂的选项。我们可以在容器类中建小小的消息系统，允许组件相互发送消息。</p><p>下面是一种可能的实现。我们从每个组件都会实现的<code>Component</code>接口开始：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() {}</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receive</span><span class="params">(<span class="type">int</span> message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>它有一个简单的<code>receive()</code>方法，每个需要接受消息的组件类都要实现它。 这里，我们使用一个<code>int</code>来定义消息，但更完整的消息实现应该可以附加数据。</p><p>然后，向容器类添加发送消息的方法。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerObject</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">int</span> message)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_COMPONENTS; i++)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> (components_[i] != <span class="literal">NULL</span>)</span><br><span class="line">      {</span><br><span class="line">        components_[i]-&gt;<span class="built_in">receive</span>(message);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_COMPONENTS = <span class="number">10</span>;</span><br><span class="line">  Component* components_[MAX_COMPONENTS];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在，如果组件能够接触容器，它就能向容器发送消息，直接向所有的组件广播。 （包括了原先发送消息的组件，小心别陷入无限的消息循环中！）这会造成一些结果：</p></li><li><p><strong>同级组件解耦</strong>。 通过父级容器对象，就像共享状态的方案一样，我们保证了组件之间仍然是解耦的。 使用了这套系统，组件之间唯一的耦合是它们发送的消息。</p></li></ul><blockquote><p>如果你真的乐意，甚至可以将消息存储在队列中，晚些发送。 要知道更多，看看<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/event-queue.html">事件队列</a>。</p></blockquote><ul><li><strong>容器类很简单</strong>。 不像使用共享状态那样，容器类无需知道组件使用了什么数据，它只是将消息发送出去。 这可以让组件发送领域特有的数据而无需打扰容器对象。</li></ul><blockquote><p>GoF称之为<a target="_blank" rel="noopener" href="http://c2.com/cgi-bin/wiki?MediatorPattern">中介</a>模式——两个或更多的对象通过中介对象通信。 现在这种情况下，容器对象本身就是中介。</p></blockquote><p>不出意料的，这里没有最好的答案。这些方法你最终可能都会使用一些。 共享状态对于每个对象都有的数据是很好用的——比如位置和大小。</p><p>有些不同领域仍然紧密相关。想想动画和渲染，输入和AI，或物理和粒子。 如果你有这样一对分离的组件，你会发现直接相互引用也许更加容易。</p><p>消息对于“不那么重要”的通信很有用。对物理组件发现事物碰撞后发送消息让音乐组件播放声音这种事情来说，发送后不管的特性是很有效的。</p><p>就像以前一样，我建议你从简单的开始，然后如果需要的话，加入其他的通信路径。</p><h4 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h4><ul><li><p><a target="_blank" rel="noopener" href="http://unity3d.com/">Unity</a>核心架构中<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/Manual/GameObjects.html"><code>GameObject</code></a>类完全根据这样的原则设计<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Manual/UsingComponents.html">components</a>。</p></li><li><p>开源的<a target="_blank" rel="noopener" href="http://www.delta3d.org/">Delta3D</a>引擎有<code>GameActor</code>基类通过<code>ActorComponent</code>实现了这种模式。</p></li><li><p>微软的<a target="_blank" rel="noopener" href="http://creators.xna.com/en-US/">XNA</a>游戏框架有一个核心的<code>Game</code>类。它拥有一系列<code>GameComponent</code>对象。我们在游戏实体层使用组件，XNA在游戏主对象上实现了这种模式，但意图是一样的。</p></li><li><p>这种模式与GoF的<a target="_blank" rel="noopener" href="http://c2.com/cgi-bin/wiki?StrategyPattern">策略模式</a>类似。 两种模式都是将对象的行为取出，划入单独的重述对象。 与对象模式不同的是，分离的策略模式通常是无状态的——它封装了算法，而没有数据。 它定义了对象<em>如何</em>行动，但没有定义对象<em>是</em>什么。</p><p>组件更加重要。它们经常保存了对象的状态，这有助于确定其真正的身份。 但是，这条界限很模糊。有一些组件也许根本没有任何状态。 在这种情况下，你可以在不同的容器对象中使用相同的组件<em>实例</em>。这样看来，它的行为确实更像一种策略。</p></li></ul><h3 id="事件序列"><a href="#事件序列" class="headerlink" title="事件序列"></a>事件序列</h3><h4 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h4><p>解耦发出消息或事件的时间和处理它的时间。</p><h4 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h4><p>除非还呆在一两个没有互联网接入的犄角旮旯，否则你很可能已经听说过“事件序列”了。 如果没有，也许“消息队列”或“事件循环”或“消息泵”可以让你想起些什么。 为了唤醒你的记忆，让我们了解几个此模式的常见应用吧。</p><blockquote><p>这章的大部分里，我交替使用“事件”和“消息”。 在两者的意义有区别时，我会表明的。</p></blockquote><h5 id="GUI事件循环"><a href="#GUI事件循环" class="headerlink" title="GUI事件循环"></a>GUI事件循环</h5><p>如果你曾做过任何用户界面编程，你就会很熟悉<strong>事件</strong>。 每当用户与你的程序交互——点击按钮，拉出菜单，或者按个键——操作系统就会生成一个事件。 它会将这个对象扔给你的应用程序，你的工作就是获取它然后将其与有趣的行为相挂钩。</p><blockquote><p>这个程序风格非常普遍，被认为是一种编程范式：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Event-driven_programming">事件驱动编程</a>。</p></blockquote><p>为了获取这些事件，代码底层是<strong>事件循环</strong>。它大体上是这样的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (running)</span><br><span class="line">{</span><br><span class="line">  Event event = <span class="built_in">getNextEvent</span>();</span><br><span class="line">  <span class="comment">// 处理事件……</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用<code>getNextEvent()</code>将一堆未处理的用户输入传到应用程序中。 你将它导向事件处理器，之后应用魔术般获得了生命。 有趣的部分是应用在<em>它</em>想要的时候获取事件。 操作系统在用户操作时不是直接跳转到你应用的某处代码。</p><blockquote><p>相反，操作系统的<strong>中断</strong>确实是直接跳转的。 当中断发生时，操作系统中断应用在做的事，强制它跳到中断处理。 这种唐突的做法是中断很难使用的原因。</p></blockquote><p>这就意味着当用户输入进来时，它需要到某处去， 这样操作系统在设备驱动报告输入和应用去调用<code>getNextEvent()</code>之间不会漏掉它。 这个“某处”是一个队列。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-loop.png"></p><p>当用户输入抵达时，操作系统将其添加到未处理事件的队列中。 当你调用<code>getNextEvent()</code>时，它从队列中获取最旧的事件然后交给应用程序。</p><h5 id="中心事件总线"><a href="#中心事件总线" class="headerlink" title="中心事件总线"></a>中心事件总线</h5><p>大多数游戏不是像这样事件驱动的，但是在游戏中使用事件循环来支撑中枢系统是很常见的。 你通常听到用“中心”“全局”“主体”描述它。 它通常被用于想要相互保持解耦的高层模块间通信。</p><blockquote><p>如果你想知道为什么它们不是事件驱动的，看看<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/game-loop.html">游戏循环</a>一章。</p></blockquote><p>假设游戏有新手教程系统，在某些特定游戏事件后显示帮助框。 举个例子，当玩家第一次击败了邪恶野兽，你想要一个显示着“按X拿起战利品！”的小气泡。</p><blockquote><p>新手教程系统很难优雅地实现，大多数玩家很少使用游戏内的帮助，所以这感觉上吃力不讨好。 但对那些<em>使用</em>教程的玩家，这是无价之宝。</p></blockquote><p>游戏玩法和战斗代码也许像上面一样复杂。 你最不想做的就是检查一堆教程的触发器。 相反，你可以使用中心事件队列。 任何游戏系统都可以发事件给队列，这样战斗代码可以在砍倒敌人时发出“敌人死亡”事件。</p><p>类似地，任何游戏系统都能从队列<em>接受</em>事件。 教程引擎在队列中注册自己，然后表明它想要收到“敌人死亡”事件。 用这种方式，敌人死了的消息从战斗系统传到了教程引擎，而不需要这两个系统直接知道对方的存在。</p><blockquote><p>实体可以发送和收到消息的模型很像AI界的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Blackboard_system">blackboard systems</a>。</p></blockquote><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-central.png"></p><p>我本想将这个作为这章其他部分的例子，但是我真的不喜欢这样巨大的全局系统。 事件队列不需要在整个游戏引擎中沟通。在一个类或者领域中沟通就足够有用了。</p><h5 id="你说什么？"><a href="#你说什么？" class="headerlink" title="你说什么？"></a>你说什么？</h5><p>所以说点别的，让我们给游戏添加一些声音。 人类是视觉动物，但是听觉强烈影响到情感系统和空间感觉。 正确模拟的回声可以让漆黑的屏幕感觉上是巨大的洞穴，而适时的小提琴慢板可以让心弦拉响同样的旋律。</p><p>为了获得优秀的音效表现，我们从最简单的解决方法开始，看看结果如何。 添加一个“声音引擎”，其中有使用标识符和音量就可以播放音乐的API：</p><blockquote><p>我总是离<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/singleton.html">单例模式</a>远远的。 这是少数它可以使用的领域，因为机器通常只有一个声源系统。 我使用更简单的方法，直接将方法定为静态。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Audio</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">playSound</span><span class="params">(SoundId id, <span class="type">int</span> volume)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>它负责加载合适的声音资源，找到可靠的播放频道，然后启动它。 这章不是关于某个平台真实的音频API，所以我会假设在其他某处魔术般实现了一个。 使用它，我们像这样写方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Audio::playSound</span><span class="params">(SoundId id, <span class="type">int</span> volume)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  ResourceId resource = <span class="built_in">loadSound</span>(id);</span><br><span class="line">  <span class="type">int</span> channel = <span class="built_in">findOpenChannel</span>();</span><br><span class="line">  <span class="keyword">if</span> (channel == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">startSound</span>(resource, channel, volume);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们签入以上代码，创建一些声音文件，然后在代码中加入一些对<code>playSound()</code>的调用。 举个例子，在UI代码中，我们在选择菜单项变化时播放一点小音效：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Menu</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onSelect</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    Audio::<span class="built_in">playSound</span>(SOUND_BLOOP, VOL_MAX);</span><br><span class="line">    <span class="comment">// 其他代码……</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这样做了之后，我们注意到有时候你改变菜单项目，整个屏幕就会冻住几帧。 我们遇到了第一个问题：</p><p><strong>问题一：API在音频引擎完成对请求的处理前阻塞了调用者。</strong></p><p>我们的<code>playSound()</code>方法是<em>同步</em>的——它在从播放器放出声音前不会返回调用者。 如果声音文件要从光盘上加载，那就得花费一定时间。 与此同时，游戏的其他部分被卡住了。</p><p>现在忽视这一点，我们继续。 在AI代码中，我们增加了一个调用，在敌人承受玩家伤害时发出痛苦的低号。 没有什么比在虚拟的生物身上施加痛苦更能温暖玩家心灵的了。</p><p>这能行，但是有时玩家打出暴击，他在同一帧可以打到两个敌人。 这让游戏同时要播放两遍哀嚎。 如果你了解一些音频的知识，那么就知道要把两个不同的声音混合在一起，就要加和它们的波形。 当这两个是同一波形时，它与一个声音播放两倍响是一样的。那会很刺耳。</p><blockquote><p>我在完成<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Henry_Hatsworth_in_the_Puzzling_Adventure">Henry Hatsworth in the Puzzling Adventure</a>时遇到了同样的问题。解决方法和这里的很相似。</p></blockquote><p>在Boss战中有个相关的问题，当有一堆小怪跑动并制造伤害时。 硬件只能同时播放一定数量的音频。当数量超过限度时，声音就被忽视或者切断了。</p><p>为了处理这些问题，我们需要获得音频调用的整个<em>集合</em>，用来整合和排序。 不幸的是，音频API独立处理每一个<code>playSound()</code>调用。 看起来这些请求像是从针眼穿过一样，一次只能有一个。</p><p><strong>问题二：请求无法合并处理。</strong></p><p>这个问题与下面的问题相比只是小烦恼。 现在，我们在很多不同的游戏系统中散布了<code>playSound()</code>调用。 但是游戏引擎是在现代多核机器上运行的。 为了使用多核带来的优势，我们将系统分散在不同线程上——渲染在一个，AI在另一个，诸如此类。</p><p>由于我们的API是同步的，它在调用者的线程上运行。 当从不同的游戏系统调用时，我们从多个线程同时使用API。 看看示例代码，看到任何线程同步性吗？我也没看到。</p><p>当我们想要分配一个单独的线程给音频，这个问题就更加严重。 当其他线程都忙于互相跟随和制造事物，它只是傻傻待在那里。</p><p><strong>问题三：请求在错误的线程上执行。</strong></p><p>音频引擎调用<code>playSound()</code>意味着，“放下任何东西，现在就播放声音！”立即就是问题。 游戏系统在它们方便时调用<code>playSound()</code>，但是音频引擎不一定能方便去处理这个请求。 为了解决这点，我们需要将接受请求和<em>处理</em>请求解耦。</p><h4 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h4><p>事件队列在队列中按先入先出的顺序存储一系列通知或请求。 发送通知时，将请求放入队列并返回。 处理请求的系统之后稍晚从队列中获取请求并处理。 这解耦了发送者和接收者，既静态又及时。</p><h4 id="何时使用-1"><a href="#何时使用-1" class="headerlink" title="何时使用"></a>何时使用</h4><p>如果你只是想解耦接收者和发送者，像<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/observer.html">观察者模式</a> 和<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/command.html">命令模式</a>都可以用较小的复杂度进行处理。 在解耦某些需要<em>及时</em>处理的东西时使用队列。</p><blockquote><p>我在之前的几乎每章都提到了，但这值得反复提。 复杂度会拖慢你，所以要将简单视为珍贵的财宝。</p></blockquote><p>用推和拉来考虑。 有一块代码A需要另一块代码B去做些事情。 对A自然的处理方式是将请求推给B。</p><p>同时，对B自然的处理方式是在<em>B</em>方便时将请求拉入。 当一端有推模型另一端有拉模型，你需要在它们之间设置缓存。 这就是队列比简单的解耦模式多提供的部分。</p><p>队列给了代码对拉取的控制权——接收者可以延迟处理，合并或者忽视请求。 但队列做这些事是通过将控制权从发送者那里拿走完成的。 发送者能做的就是向队列发送请求然后祈祷。 当发送者需要回复时，队列不是好的选择。</p><h4 id="记住-1"><a href="#记住-1" class="headerlink" title="记住"></a>记住</h4><p>不像本书中的其他模式，事件队列很复杂，会对游戏架构产生广泛影响。 这就意味着你得仔细考虑如何——或者要不要——使用它。</p><h5 id="中心事件队列是一个全局变量"><a href="#中心事件队列是一个全局变量" class="headerlink" title="中心事件队列是一个全局变量"></a>中心事件队列是一个全局变量</h5><p>这个模式的常用方法是一个大的交换站，游戏中的每个部分都能将消息送到这里。 这是很有用的基础架构，但是有用并不代表好用。</p><p>可能要走一些弯路，但是我们中的大多数最终学到了全局变量是不好的。 当有一小片状态，程序的每部分都能接触到，会产生各种微妙的相关性。 这个模式将状态封装在协议中，但是它还是全局的，仍然有全局变量引发的全部危险。</p><h5 id="世界的状态可以因你改变"><a href="#世界的状态可以因你改变" class="headerlink" title="世界的状态可以因你改变"></a>世界的状态可以因你改变</h5><p>假设在虚拟的小怪结束它一生时，一些AI代码将“实体死亡”事件发送到队列中。 这个事件在队列中等待了谁知有多少帧后才排到了前面，得以处理。</p><p>同时，经验系统想要追踪英雄的杀敌数，并对他的效率加以奖励。 它接受每个“实体死亡”事件，然后决定英雄击杀了何种怪物，以及击杀的难易程度，最终计算出合适的奖励。</p><p>这需要游戏世界的多种不同状态。 我们需要死亡的实体以获取击杀它的难度。 我们也许要看看英雄的周围有什么其他的障碍物或者怪物。 但是如果事件没有及时处理，这些东西都会消失。 实体可能被清除，周围的东西也有可能移开。</p><p>当你接到事件时，得小心，不能假设现在的状态反映了事件发生时的世界。 这就意味着队列中的事件比同步系统中的事件需要存储更多数据。 在后者中，通知只需说“某事发生了”然后接收者可以找到细节。 使用队列时，这些短暂的细节必须在事件发送时就被捕获，以方便之后使用。</p><h5 id="会陷于反馈系统环路中"><a href="#会陷于反馈系统环路中" class="headerlink" title="会陷于反馈系统环路中"></a>会陷于反馈系统环路中</h5><p>任何事件系统和消息系统都得担心环路：</p><ol><li>A发送了一个事件</li><li>B接收然后发送事件作为回应。</li><li>这个事件恰好是A关注的，所以它收到了。为了回应，它发送了一个事件。</li><li>回到2.</li></ol><p>当消息系统是同步的，你很快就能找到环路——它们造成了栈溢出并让游戏崩溃。 使用队列，它会异步地使用栈，即使虚假事件晃来晃去，游戏仍然可以继续运行。 避免这个的通用方法就是避免在处理事件的代码中发送事件。</p><blockquote><p>在你的事件系统中加一个小小的漏洞日志也是一个好主意。</p></blockquote><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>我们已经看到一些代码了。它不完美，但是有基本的正确功能——公用的API和正确的底层音频调用。 剩下需要做的就是修复它的问题。</p><p>第一个问题是我们的API是阻塞的。 当代码播放声音时，它不能做任何其他事情，直到<code>playSound()</code>加载完音频然后真正地开始播放。</p><p>我们想要推迟这项工作，这样 <code>playSound()</code> 可以很快地返回。 为了达到这一点，我们需要具体化播放声音的请求。 我们需要一个小结构存储发送请求时的细节，这样我们晚些时候可以使用：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayMessage</span></span><br><span class="line">{</span><br><span class="line">  SoundId id;</span><br><span class="line">  <span class="type">int</span> volume;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>下面我们需要给<code>Audio</code>一些存储空间来追踪正在播放的声音。 现在，你的算法专家也许会告诉你使用激动人心的数据结构， 比如<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Fibonacci_heap">Fibonacci heap</a>或者<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Skip_list">skip list</a>或者最起码<em>链表</em>。 但是在实践中，存储一堆同类事物最好的办法是使用一个平凡无奇的经典数组：</p><p>算法研究者通过发表对新奇数据结构的研究获得收入。 他们不鼓励使用基本的结构。</p><ul><li>没有动态分配。</li><li>没有为记录信息造成的额外的开销或者多余的指针。</li><li>对缓存友好的连续存储空间。</li></ul><blockquote><p>更多“缓存友好”的内容，见<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/data-locality.html">数据局部性</a>一章。</p></blockquote><p>所以让我们开干吧：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Audio</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    numPending_ = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码……</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_PENDING = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> PlayMessage pending_[MAX_PENDING];</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> numPending_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们可以将数组大小设置为最糟情况下的大小。 为了播放声音，简单地将新消息插到最后：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Audio::playSound</span><span class="params">(SoundId id, <span class="type">int</span> volume)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">assert</span>(numPending_ &lt; MAX_PENDING);</span><br><span class="line"></span><br><span class="line">  pending_[numPending_].id = id;</span><br><span class="line">  pending_[numPending_].volume = volume;</span><br><span class="line">  numPending_++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这让<code>playSound()</code>几乎是立即返回，当然我们仍得播放声音。 那块代码在某处，即<code>update()</code>方法中：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Audio</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numPending_; i++)</span><br><span class="line">    {</span><br><span class="line">      ResourceId resource = <span class="built_in">loadSound</span>(pending_[i].id);</span><br><span class="line">      <span class="type">int</span> channel = <span class="built_in">findOpenChannel</span>();</span><br><span class="line">      <span class="keyword">if</span> (channel == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">startSound</span>(resource, channel, pending_[i].volume);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    numPending_ = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码……</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在我们需要在方便时候调用。 这个“方便”取决于你的游戏。 它也许要从主<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/game-loop.html">游戏循环</a>中或者专注于音频的线程中调用。</p><blockquote><p>就像名字暗示的，这是<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/update-method.html">更新方法</a>模式。</p></blockquote><p>这可行，但是这假定了我们在对<code>update()</code>的单一调用中可以处理<em>每个</em>声音请求。 如果你做了像在声音资源加载后处理异步请求的事情，这就没法工作了。 <code>update()</code>一次处理一个请求，它需要有完成一个请求后从缓存中再拉取一个请求的能力。 换言之，我们需要一个真实的队列。</p><h5 id="环状缓存"><a href="#环状缓存" class="headerlink" title="环状缓存"></a>环状缓存</h5><p>有很多种方式能实现队列，但我最喜欢的是环状缓存。 它保留了数组的所有优点，同时能让我们不断从队列的前方移除事物。</p><p>现在，我知道你在想什么。 如果我们从数组的前方移除东西，不是需要将所有剩下的部分都移动一次吗？这不是很慢吗？</p><p>这就是为什么要学习链表——你可以从中移除一个节点，而无需移动东西。 好吧，其实你可以用数组实现一个队列而无需移动东西。 我会展示给你看，但是首先预习一些术语：</p><ul><li>队列的<strong>头部</strong>是读取请求的地方。头部存储最早发出的请求。</li><li><strong>尾部</strong>是另一端。它是数组中下个写入请求的地方。注意它指向队列终点的下一个位置。你可以将其理解为一个半开半闭区间，如果这有帮助的话。</li></ul><p>由于 <code>playSound()</code> 向数组的末尾添加了新的请求，头部开始指向元素0而尾部向右增长。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-queue.png"></p><p>让我们开始编码。首先，我们显式定义这两个标记在类中的意义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Audio</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    head_ = <span class="number">0</span>;</span><br><span class="line">    tail_ = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法……</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> head_;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> tail_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组……</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在 <code>playSound()</code> 的实现中，<code>numPending_</code>被<code>tail_</code>取代，但是其他都是一样的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Audio::playSound</span><span class="params">(SoundId id, <span class="type">int</span> volume)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">assert</span>(tail_ &lt; MAX_PENDING);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add to the end of the list.</span></span><br><span class="line">  pending_[tail_].id = id;</span><br><span class="line">  pending_[tail_].volume = volume;</span><br><span class="line">  tail_++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>更有趣的变化在<code>update()</code>中：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Audio::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 如果这里没有待处理的请求</span></span><br><span class="line">  <span class="comment">// 那就什么也不做。</span></span><br><span class="line">  <span class="keyword">if</span> (head_ == tail_) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ResourceId resource = <span class="built_in">loadSound</span>(pending_[head_].id);</span><br><span class="line">  <span class="type">int</span> channel = <span class="built_in">findOpenChannel</span>();</span><br><span class="line">  <span class="keyword">if</span> (channel == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">startSound</span>(resource, channel, pending_[head_].volume);</span><br><span class="line"></span><br><span class="line">  head_++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们在头部处理，然后通过将头部指针向右移动来消除它。 我们定义头尾之间没有距离的队列为空队列。</p><blockquote><p>这就是为什么我们让尾部指向最后元素<em>之后</em>的那个位置。 这意味着头尾相等则队列为空。</p></blockquote><p>现在，我们获得了一个队列——我们可以向尾部添加元素，从头部移除元素。 这里有很明显的问题。在我们让队列跑起来后，头部和尾部继续向右移动。 最终<code>tail_</code>碰到了数组的尾部，欢乐时光结束了。 接下来是这个方法的灵巧之处。</p><blockquote><p>你想结束欢乐时光吗？不，你不想。</p></blockquote><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-crawl.png"></p><p>注意当尾部移动时，头部 也是如此。 这就意味着在数组开始部分的元素不再被使用了。 所以我们做的就是，当抵达末尾时，将尾部折回到数组的头部。 这就是为什么它被称为环状缓存，它表现得像是一个环状的数组。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/event-queue-ring.png"></p><p>这个的实现非常简单。 当我们入队一个事物时，只需要保证尾部在抵达末尾的时候折回到数组的开头：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Audio::playSound</span><span class="params">(SoundId id, <span class="type">int</span> volume)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">assert</span>((tail_ + <span class="number">1</span>) % MAX_PENDING != head_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加到列表的尾部</span></span><br><span class="line">  pending_[tail_].id = id;</span><br><span class="line">  pending_[tail_].volume = volume;</span><br><span class="line">  tail_ = (tail_ + <span class="number">1</span>) % MAX_PENDING;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>替代<code>tail++</code>，将增量设为数组长度的模，这样可将尾部回折回来。 另一个改变是断言。我们得保证队列不会溢出。 只要这里有少于<code>MAX_PENDING</code>的请求在队列中，在头部和尾部之间就有没有使用的间隔。 如果队列满了，那就不会有间隔了，就像古怪的衔尾蛇一样，尾部会遇到头部然后覆盖它。 断言保证了这不会发生。</p><p>在<code>update()</code>中，头部也折回了：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Audio::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 如果没有待处理的请求，就啥也不做</span></span><br><span class="line">  <span class="keyword">if</span> (head_ == tail_) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ResourceId resource = <span class="built_in">loadSound</span>(pending_[head_].id);</span><br><span class="line">  <span class="type">int</span> channel = <span class="built_in">findOpenChannel</span>();</span><br><span class="line">  <span class="keyword">if</span> (channel == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">startSound</span>(resource, channel, pending_[head_].volume);</span><br><span class="line"></span><br><span class="line">  head_ = (head_ + <span class="number">1</span>) % MAX_PENDING;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就好——没有动态分配，没有数据拷贝，缓存友好的简单数组实现的队列完成了。</p><blockquote><p>如果最大容量影响了你，你可以使用增长的数组。 当队列满了后，分配一块当前数组两倍大的数组（或者更多倍），然后将对象拷进去。</p><p>哪怕你在队列增长时拷贝，入队仍然有常数级的摊销复杂度。</p></blockquote><h5 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h5><p>现在有队列了，我们可以转向其他问题了。 首先来解决多重请求播放同一音频，最终导致音量过大的问题。 由于我们知道哪些请求在等待处理，需要做的所有事就是将请求和早先等待处理的请求合并：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Audio::playSound</span><span class="params">(SoundId id, <span class="type">int</span> volume)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 遍历待处理的请求</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head_; i != tail_;</span><br><span class="line">       i = (i + <span class="number">1</span>) % MAX_PENDING)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span> (pending_[i].id == id)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 使用较大的音量</span></span><br><span class="line">      pending_[i].volume = <span class="built_in">max</span>(volume, pending_[i].volume);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 无需入队</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 之前的代码……</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当有两个请求播放同一音频时，我们将它们合并成只保留声音最大的请求。 这一“合并”非常简陋，但是我们可以用同样的方法做很多有趣的合并。</p><p>注意在请求入队时合并，而不是处理时。 在队列中处理更加容易，因为不需要在最终会被合并的多余请求上浪费时间。 这也更加容易被实现。</p><p>但是，这确实将处理的职责放在了调用者肩上。 对<code>playSound()</code>的调用返回前会遍历整个队列。 如果队列很长，那么会很慢。 在<code>update()</code>中合并也许更加合理。</p><blockquote><p>避免<em>O(n)</em> 的队列扫描代价的另一种方式是使用不同的数据结构。 如果我们将<code>SoundId</code>作为哈希表的键，那么我们就可以在常量时间内检查重复。</p></blockquote><p>这里有些要记住的要点。 我们能够合并的“同步”请求窗口只有队列长度那么大。 如果我们快速处理请求，队列长度就会保持较短，我们就有更少的机会合并东西。 同样地，如果处理慢了，队列满了，我们能找到更多的东西合并。</p><p>这个模式隔离了请求者和请求何时被处理，但如果你将整个队列交互视为与数组结构交互， 那么发出请求和处理它之间的延迟会显式地影响行为。 确认在这么做之前保证了这不会造成问题。</p><h5 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h5><p>最终，最险恶的问题。 使用同步的音频API，调用<code>playSound()</code>的线程就是处理请求的线程。 这通常不是我们想要的。</p><p>在今日的多核硬件上，你需要不止一个线程来最大程度使用芯片。 有无数的编程范式在线程间分散代码，但是最通用的策略是将每个独立的领域分散到一个线程——音频，渲染，AI等等。</p><p>我们很容易就能做到这一点是因为三个关键点：</p><ol><li>请求音频的代码与播放音频的代码解耦。</li><li>有队列在两者之间整理它们。</li><li>队列与程序其他部分是隔离的。</li></ol><blockquote><p>单线程代码同时只在一个核心上运行。 如果你不使用线程，哪怕做了流行的异步风格编程，能做的极限就是让一个核心繁忙，那也只发挥了CPU能力的一小部分。</p><p>服务器程序员将他们的程序分割成多个独立进程作为弥补。 这让系统在不同的核上同时运行它们。 游戏几乎总是单进程的，所以增加线程真的有用。</p></blockquote><p>剩下要做的事情就是写修改队列的方法——<code>playSound()</code>和<code>update()</code>——使之线程安全。 通常，我会写一写具体代码完成之，但是由于这是一本关于架构的书，我不想着眼于一些特定的API或者锁机制。</p><p>从高层看来，我们只需保证队列不是同时被修改的。 由于<code>playSound()</code>只做了一点点事情——基本上就是声明字段——不会阻塞线程太长时间。 在<code>update()</code>中，我们等待条件变量之类的东西，直到有请求需要处理时才会消耗CPU循环。</p><h4 id="设计决策-1"><a href="#设计决策-1" class="headerlink" title="设计决策"></a>设计决策</h4><p>很多游戏使用事件队列作为交流结构的关键部分，你可以花很多时间设计各种复杂的路径和消息过滤器。 但是在构建洛杉矶电话交换机之类的东西之前，我推荐你从简单的开始。这里是几个需要在开始时思考的问题：</p><h5 id="队列中存储了什么？"><a href="#队列中存储了什么？" class="headerlink" title="队列中存储了什么？"></a>队列中存储了什么？</h5><p>到目前为止，我交替使用“事件”和“消息”，因为大多时候两者的区别并不重要。 无论你在队列中塞了什么都可以获得解耦和合并的能力，但是还是有几个地方不同。</p><p><strong>如果你存储事件：</strong></p><p>“事件”或者“通知”描绘<em>已经</em>发生的事情，比如“怪物死了”。 你入队它，这样其他对象可以对这个事件作出回应，有点像异步的<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/observer.html">观察者</a>模式。</p><ul><li><strong>很可能允许多个监听者</strong>。 由于队列包含的是已经发生的事情，发送者可能不关心谁接受它。 从这个层面来说，事件发生在过去，早已被遗忘。</li><li><strong>访问队列的模块更广</strong>。 事件队列通常广播事件到任何感兴趣的部分。为了尽可能允许所有感兴趣的部分访问，队列一般是全局可见的。</li></ul><p><strong>如果你存储消息：</strong></p><p>“消息”或“请求”描绘了想要发生在未来的事情，比如“播放声音”。可以将其视为服务的异步API。</p><p>更可能只有一个监听者。 在这个例子中，存储的消息只请求音频API播放声音。如果引擎的随便什么部分都能从队列中拿走消息，那可不好。</p><blockquote><p>另一个描述“请求”的词是“命令”，就像在<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/command.html">命令模式</a>中那样，队列也可以在那里使用。</p><p>我在这里说“更可能”，因为只要像期望的<em>那样</em>处理消息，消息入队时可以不必担心哪块代码处理它。 这样的话，你在做的事情类似于<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/service-locator.html">服务定位器</a>。</p></blockquote><h5 id="谁能从队列中读取？"><a href="#谁能从队列中读取？" class="headerlink" title="谁能从队列中读取？"></a>谁能从队列中读取？</h5><p>在例子中，队列是密封的，只有<code>Audio</code>类可以从中读取。 在用户交互的事件系统中，你可以在核心内容中注册监听器。 有时可以听到术语“单播”和“广播”来描述它，两者都很有用。</p><p><strong>单播队列：</strong></p><p>在队列是类API的一部分时，单播是很自然的。 就像我们的音频例子，从调用者的角度来说，它们只能看到可以调用的<code>playSound()</code>方法。</p><ul><li><p><strong>队列变成了读取者的实现细节</strong>。 发送者知道的所有事就是发条消息。</p></li><li><p><strong>队列更封装</strong>。 其他都一样时，越多封装越方便。</p></li><li><p><strong>无须担心监听者之间的竞争</strong>。 使用多个监听者，你需要决定队列中的每个事物<em>一对多</em>分给全部的监听者（广播） 还是队列中的<em>每个</em>事物一对一分给单独的监听者（更加像工作队列）。</p><p>在两种情况下，监听者最终要么做了多余的事情要么在相互干扰，你得谨慎考虑想要的行为。 使用单一的监听者，这种复杂性消失了。</p></li></ul><p><strong>广播队列：</strong></p><p>这是大多数“事件”系统工作的方法。如果你有十个监听者，一个事件进来，所有监听者都能看到这个事件。</p><ul><li><p><strong>事件可能无人接收</strong>。 前面那点的必然推论就是如果有<em>零个</em>监听者，没有谁能看到这个事件。 在大多数广播系统中，如果处理事件时没有监听者，事件就消失了。</p></li><li><p><strong>也许需要过滤事件</strong>。 广播队列经常对程序的所有部分可见，最终你会获得一系列监听者。 很多事件乘以很多监听者，你会获取一大堆事件处理器。</p><p>为了削减大小，大多数广播事件系统让监听者筛出其需要接受的事件。 比如，可能它们只想要接受鼠标事件或者在某一UI区域内的事件。</p></li></ul><p><strong>工作队列：</strong></p><p>类似广播队列，有多个监听器。不同之处在于队列中的每个东西只会投到监听器其中的一个。 常应用于将工作打包给同时运行的线程池。</p><ul><li><strong>你得规划</strong>。 由于一个事物只有一个监听器，队列逻辑需要指出最好的选项。 这也许像round robin算法或者乱序选择一样简单，或者可以使用更加复杂的优先度系统。</li></ul><h5 id="谁能写入队列？"><a href="#谁能写入队列？" class="headerlink" title="谁能写入队列？"></a>谁能写入队列？</h5><p>这是前一个设计决策的另一面。 这个模式兼容所有可能的读/写设置：一对一，一对多，多对一，多对多。</p><blockquote><p>你有时听到用“扇入”描述多对一的沟通系统，而用“扇出”描述一对多的沟通系统。</p></blockquote><p><strong>使用单个写入器：</strong></p><p>这种风格和同步的<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/observer.html">观察者</a>模式很像。 有特定对象收集所有可接受的事件。</p><ul><li><strong>你隐式知道事件是从哪里来的</strong>。 由于这里只有一个对象可向队列添加事件，任何监听器都可以安全地假设那就是发送者。</li><li><strong>通常允许多个读取者</strong>。 你可以使用单发送者对单接收者的队列，但是这样沟通系统更像纯粹的队列数据结构。</li></ul><p><strong>使用多个写入器：</strong></p><p>这是例子中音频引擎工作的方式。 由于<code>playSound()</code>是公开的方法，代码库的任何部分都能给队列添加请求。“全局”或“中心”事件总线像这样工作。</p><ul><li><strong>得更小心环路</strong>。 由于任何东西都有可能向队列中添加东西，这更容易意外地在处理事件时添加事件。 如果你不小心，那可能会触发反馈循环。</li><li><strong>很可能需要在事件中添加对发送者的引用</strong>。 当监听者接到事件时，它不知道是谁发送的，因为可能是任何人。 如果它确实需要知道发送者，你得将发送者打包到事件对象中去，这样监听者才可以使用它。</li></ul><h5 id="对象在队列中的生命周期如何？"><a href="#对象在队列中的生命周期如何？" class="headerlink" title="对象在队列中的生命周期如何？"></a>对象在队列中的生命周期如何？</h5><p>使用同步的通知，当所有的接收者完成了消息处理才会返回发送者。 这意味着消息本身可以安全地存在栈的局部变量中。 使用队列，消息比让它入队的调用活得更久。</p><p>如果你使用有垃圾回收的语言，你无需过度担心这个。 消息存到队列中，会在需要它的时候一直存在。 而在C或C++中，得由你来保证对象活得足够长。</p><ul><li><p><strong>传递所有权：</strong></p><p>这是手动管理内存的传统方法。当消息入队时，队列拥有了它，发送者不再拥有它。 当它被处理时，接收者获取了所有权，负责销毁他。</p><blockquote><p>在C++中，<code>unique_ptr&lt;T&gt;</code>给了你同样的语义。</p></blockquote></li><li><p><strong>共享所有权：</strong></p><p>现在，甚至C++程序员都更适应垃圾回收了，分享所有权更加可接受。 这样，消息只要有东西对其有引用就会存在，当被遗忘时自动释放。</p><blockquote><p>同样的，C++的风格是使用<code>shared_ptr&lt;T&gt;</code>。</p></blockquote></li><li><p><strong>队列拥有它：</strong></p><p>另一个选项是让消息<em>永远</em>存在于队列中。 发送者不再自己分配消息的内存，它向内存请求一个“新的”消息。 队列返回一个队列中已经在内存的消息的引用，接收者引用队列中相同的消息。</p><blockquote><p>换言之，队列存储的背后是一个<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/object-pool.html">对象池</a>模式。</p></blockquote></li></ul><h4 id="参见-1"><a href="#参见-1" class="headerlink" title="参见"></a>参见</h4><ul><li><p>我在之前提到了几次，很大程度上， 这个模式是广为人知的<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/observer.html">观察者</a>模式的异步实现。</p></li><li><p>就像其他很多模式一样，事件队列有很多别名。 其中一个是“消息队列”。这通常指代一个更高层次的实现。 事件队列在应用<em>中</em>，消息队列通常在应用<em>间</em>交流。</p><p>另一个术语是“发布/提交”，有时被缩写为“pubsub”。 就像“消息队列”一样，这通常指代更大的分布式系统，而不是现在关注的这个模式。</p></li><li><p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Finite-state_machine">确定状态机</a>，很像GoF的<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/state.html">状态模式</a>，需要一个输入流。如果想要异步响应，可以考虑用队列存储它们。</p><p>当你有一对状态机相互发送消息时，每个状态机都有一个小小的未处理队列（被称为一个<em>信箱</em>）， 然后你需要重新发明<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Actor_model">actor model</a>。</p></li><li><p><a target="_blank" rel="noopener" href="http://golang.org/">Go</a>语言内建的“通道”类型本质上是事件队列或消息队列。</p></li></ul><h3 id="服务定位器"><a href="#服务定位器" class="headerlink" title="服务定位器"></a>服务定位器</h3><p>提供服务的全局接入点，避免使用者和实现服务的具体类耦合。</p><h4 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h4><p>一些游戏中的对象或者系统几乎出现在程序库中的每一个角落。 很难找到游戏中的哪部分永远不需要内存分配，记录日志，或者随机数字。 像这样的东西可以被视为整个游戏都需要的服务。</p><p>我们考虑音频作为例子。 它不需要接触像内存分配这么底层的东西，但是仍然要接触一大堆游戏系统。 滚石撞击地面（物理）。 NPC狙击手开了一枪，射出子弹（AI）。 用户选择菜单项需要响一声确认（用户界面）。</p><p>每处都需要用像下面这样的东西调用音频系统：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用静态类？</span></span><br><span class="line">AudioSystem::<span class="built_in">playSound</span>(VERY_LOUD_BANG);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是使用单例？</span></span><br><span class="line">AudioSystem::<span class="built_in">instance</span>()-&gt;<span class="built_in">playSound</span>(VERY_LOUD_BANG);</span><br></pre></td></tr></tbody></table></figure><p>尽管每种都能获得想要的结果，但是我们会绊倒在一些微妙的耦合上。 每个调用音频系统的游戏部分直接引用了具体的<code>AudioSystem</code>类，和访问它的机制——是静态类还是一个<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/singleton.html">单例</a>。</p><p>这些调用点，当然，需要耦合到<em>某些东西</em>上来播放声音， 但是直接接触到具体的音频实现，就好像给了一百个陌生人你家的地址，只是为了让他们在门口放一封信。 这不仅仅是<em>隐私</em>问题，在你搬家后，需要告诉每个人新地址是个更加痛苦的问题。</p><p>有个更好的解决办法：一本电话薄。 需要联系我们的人可以在上面查找并找到现在的地址。 当我们搬家时，我们通知电话公司。 他们更新电话薄，每个人都知道了新地址。 事实上，我们甚至无需给出真实的地址。 我们可以列一个转发信箱或者其他“代表”我们的东西。 通过让调用者查询电话薄找我们，我们获得了一个控制找我们的方法的方便地方。</p><p>这就是服务定位模式的简短介绍——它解耦了需要服务的代码和服务由<em>谁</em>提供（哪个具体的实现类）以及服务在<em>哪里</em>（我们如何获得它的实例）。</p><h4 id="模式-2"><a href="#模式-2" class="headerlink" title="模式"></a>模式</h4><p><strong>服务</strong> 类定义了一堆操作的抽象接口。 具体的 <strong>服务提供者</strong> 实现这个接口。 分离的 <strong>服务定位器</strong> 提供了通过查询获取服务的方法，同时隐藏了服务提供者的具体细节和定位它的过程。</p><h4 id="何时使用-2"><a href="#何时使用-2" class="headerlink" title="何时使用"></a>何时使用</h4><p>当你需要让某物在程序的各处都能被访问时，你就是在找麻烦。 这是单例模式的主要问题，这个模式也没有什么不同。 我对何时使用服务定位器的最简单建议是：少用。</p><p>与其使用全局机制让某些代码接触到它，不如首先考虑将它传给代码。 这超简单，也明显保持了解耦，能覆盖你大部分的需求。</p><p>但是…… 有时候手动传入对象是不可能的或者会让代码难以阅读。 有些系统，比如日志或内存管理，不该是模块公开API的一部分。 传给渲染代码的参数应该与渲染相关，而不是与日志之类的相关。</p><p>同样，代表外设的系统通常只存在一个。 你的游戏可能只有一个音频设备或者显示设备。 这是周围环境的属性，所以将它传过十个函数让一个底层调用能够使用它会为代码增加不必要的复杂度。</p><p>如果是那样，这个模式可以帮忙。 就像我们将看到的那样，它是更加灵活、更加可配置的单例模式。 如果用得好，它能以很小的运行时开销，换取很大的灵活性。</p><blockquote><p>相反，如果用得不好，它会带来单例模式的所有缺点以及更多的运行时开销。</p></blockquote><h4 id="记住-2"><a href="#记住-2" class="headerlink" title="记住"></a>记住</h4><p>使用服务定位器的核心难点是它将依赖——在两块代码之间的一点耦合——推迟到运行时再连接。 这有了更大的灵活度，但是代价是更难在阅读代码时理解你依赖的是什么。</p><h5 id="服务必须真的可定位"><a href="#服务必须真的可定位" class="headerlink" title="服务必须真的可定位"></a>服务必须真的可定位</h5><p>如果使用单例或者静态类，我们需要的实例不可能不可用。 调用代码保证了它就在那里。但是由于这个模式是在定位服务，我们也许要处理失败的情况。 幸运的是，我们之后会介绍一种处理它的策略，保证我们在需要时总能获得某些服务。</p><h5 id="服务不知道谁在定位它"><a href="#服务不知道谁在定位它" class="headerlink" title="服务不知道谁在定位它"></a>服务不知道谁在定位它</h5><p>由于定位器是全局可访问的，任何游戏中的代码都可以请求服务，然后使用它。 这就意味着服务必须在任何环境下正确工作。 举个例子，如果一个类只能在游戏循环的模拟部分使用，而不能在渲染部分使用，那它不适合作为服务——我们不能保证在正确的时间使用它。 所以，如果你的类只期望在特定上下文中使用，避免模式将它暴露给整个世界更安全。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><p>重回我们的音频系统问题，让我们通过服务定位器将代码暴露给代码库的剩余部分。</p><h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>我们从音频API开始。这是我们服务要暴露的接口：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Audio</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Audio</span>() {}</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">playSound</span><span class="params">(<span class="type">int</span> soundID)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stopSound</span><span class="params">(<span class="type">int</span> soundID)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stopAllSounds</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>当然，一个真实的音频引擎比这复杂得多，但这展示了基本的理念。 要点在于它是个没有实现绑定的抽象接口类。</p><h5 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h5><p>只靠它自己，我们的音频接口不是很有用。 我们需要具体的实现。这本书不是关于如何为游戏主机写音频代码，所以你得想象这些函数中有实际的代码，了解原理就好：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleAudio</span> : <span class="keyword">public</span> Audio</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">playSound</span><span class="params">(<span class="type">int</span> soundID)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 使用主机音频API播放声音……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stopSound</span><span class="params">(<span class="type">int</span> soundID)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 使用主机音频API停止声音……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stopAllSounds</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 使用主机音频API停止所有声音……</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在我们有接口和实现了。 剩下的部分是服务定位器——那个将两者绑在一起的类。</p><h5 id="一个简单的定位器"><a href="#一个简单的定位器" class="headerlink" title="一个简单的定位器"></a>一个简单的定位器</h5><p>下面的实现是你可以定义的最简单的服务定位器：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Locator</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Audio* <span class="title">getAudio</span><span class="params">()</span> </span>{ <span class="keyword">return</span> service_; }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">provide</span><span class="params">(Audio* service)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    service_ = service;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> Audio* service_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>静态函数<code>getAudio()</code>完成了定位工作。 我们可以从代码库的任何地方调用它，它会给我们一个<code>Audio</code>服务实例使用：</p><blockquote><p>这里用的技术被称为<em>依赖注入</em>，一个简单思路的复杂行话表示。 假设你有一个类依赖另一个。 在例子中，是我们的<code>Locator</code>类需要<code>Audio</code>的实例。 通常，定位器负责构造实例。 依赖注入与之相反，它指外部代码负责向对象注入它需要的依赖。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Audio *audio = Locator::<span class="built_in">getAudio</span>();</span><br><span class="line">audio-&gt;<span class="built_in">playSound</span>(VERY_LOUD_BANG);</span><br></pre></td></tr></tbody></table></figure><p>它“定位”的方式十分简单——依靠一些外部代码在任何东西使用服务前已注册了服务提供者。 当游戏开始时，它调用一些这样的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">ConsoleAudio *audio = <span class="keyword">new</span> <span class="built_in">ConsoleAudio</span>();</span><br><span class="line">Locator::<span class="built_in">provide</span>(audio);</span><br></pre></td></tr></tbody></table></figure><p>这里需要注意的关键部分是调用<code>playSound()</code>的代码没有意识到任何具体的<code>ConsoleAudio</code>类； 它只知道抽象的<code>Audio</code>接口。 同样重要的是，定位器 类没有与具体的服务提供者耦合。 代码中只有初始化代码唯一知道哪个具体类提供了服务。</p><p>这里有更高层次的解耦： <code>Audio</code>接口没有意识到它在通过服务定位器来接受访问。 据它所知，它只是常见的抽象基类。 这很有用，因为这意味着我们可以将这个模式应用到<em>现有的</em>类上，而那些类无需为此特殊设计。 这与<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/singleton.html">单例</a>形成了对比，那个会影响“服务”类本身的设计。</p><h5 id="一个空服务"><a href="#一个空服务" class="headerlink" title="一个空服务"></a>一个空服务</h5><p>我们现在的实现很简单，而且也很灵活。 但是它有巨大的缺点：如果我们在服务提供者注册前使用服务，它会返回<code>NULL</code>。 如果调用代码没有检查，游戏就崩溃了。</p><blockquote><p>我有时听说这被称为“时序耦合”——两块分离的代码必须以正确的顺序调用，才能让程序正确运行。 有状态的软件某种程度上都有这种情况，但是就像其他耦合一样，减少时序耦合让代码库更容易管理。</p></blockquote><p>幸运的是，还有一种设计模式叫做“空对象”，我们可用它处理这个。 基本思路是在我们没能找到服务或者程序没以正确的顺序调用时，不返回<code>NULL</code>， 而是返回一个特定的，实现了请求对象一样接口的对象。 它的实现什么也不做，但是它保证调用服务的代码能获取到对象，保证代码就像收到了“真的”服务对象一样安全运行。</p><p>为了使用它，我们定义另一个“空”服务提供者：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NullAudio</span>: <span class="keyword">public</span> Audio</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">playSound</span><span class="params">(<span class="type">int</span> soundID)</span> </span>{ <span class="comment">/* 什么也不做 */</span> }</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stopSound</span><span class="params">(<span class="type">int</span> soundID)</span> </span>{ <span class="comment">/* 什么也不做 */</span> }</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stopAllSounds</span><span class="params">()</span>        </span>{ <span class="comment">/* 什么也不做 */</span> }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>就像你看到的那样，它实现了服务接口，但是没有干任何实事。 现在，我们将服务定位器改成这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Locator</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>{ service_ = &amp;nullService_; }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Audio&amp; <span class="title">getAudio</span><span class="params">()</span> </span>{ <span class="keyword">return</span> *service_; }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">provide</span><span class="params">(Audio* service)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 退回空服务</span></span><br><span class="line">      service_ = &amp;nullService_;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      service_ = service;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> Audio* service_;</span><br><span class="line">  <span class="type">static</span> NullAudio nullService_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>调用代码永远不知道“真正的”服务没找到，也不必担心处理<code>NULL</code>。 这保证了它永远能获得有效的对象。</p><blockquote><p>你也许注意到我们用引用而非指针返回服务。 由于C++中的引用（理论上）永远不是<code>NULL</code>，返回引用是提示用户：总可以期待获得一个合法的对象。</p></blockquote><p>这对<em>故意</em>找不到服务也很有用。 如果我们想暂时停用系统，现在有更简单的方式来实现这点了： 很简单，不要在定位器中注册服务，定位器会默认使用空服务提供器。</p><h5 id="日志装饰器"><a href="#日志装饰器" class="headerlink" title="日志装饰器"></a>日志装饰器</h5><p>现在我们的系统非常强健了，让我们讨论这个模式允许的另一个好处——装饰服务。 我会举例说明。</p><p>在开发过程中，记录有趣事情发生的小小日志系统可助你查出游戏引擎正处于何种状态。 如果你在处理AI，你要知道哪个实体改变了AI状态。 如果你是音频程序员，你也许想记录每个播放的声音，这样你可以检查它们是否是以正确的顺序触发。</p><p>通常的解决方案是向代码中丢些对<code>log()</code>函数的调用。 不幸的是，这是用一个问题取代了另一个——现在我们有<em>太多</em>日志了。 AI程序员不关心声音在什么时候播放，声音程序员也不在乎AI状态转换，但是现在都得在对方的日志中跋涉。</p><p>理念上，我们应该可以选择性地为关心的事物启动日志，而游戏成品中，不应该有任何日志。 如果将不同的系统条件日志改写为服务，那么我们就可以用<a target="_blank" rel="noopener" href="http://www.c2.com/cgi/wiki?DecoratorPattern">装饰器</a>模式。 让我们定义另一个音频服务提供者的实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggedAudio</span> : <span class="keyword">public</span> Audio</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LoggedAudio</span>(Audio &amp;wrapped)</span><br><span class="line">  : <span class="built_in">wrapped_</span>(wrapped)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">playSound</span><span class="params">(<span class="type">int</span> soundID)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"play sound"</span>);</span><br><span class="line">    wrapped_.<span class="built_in">playSound</span>(soundID);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stopSound</span><span class="params">(<span class="type">int</span> soundID)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"stop sound"</span>);</span><br><span class="line">    wrapped_.<span class="built_in">stopSound</span>(soundID);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stopAllSounds</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"stop all sounds"</span>);</span><br><span class="line">    wrapped_.<span class="built_in">stopAllSounds</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 记录日志的代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Audio &amp;wrapped_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如你所见，它包装了另一个音频提供者，暴露同样的接口。 它将实际的音频行为转发给内部的提供者，但它也同时记录每个音频调用。 如果程序员需要启动音频日志，他们可以这样调用：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableAudioLogging</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 装饰现有的服务</span></span><br><span class="line">  Audio *service = <span class="keyword">new</span> <span class="built_in">LoggedAudio</span>(Locator::<span class="built_in">getAudio</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将它换进来</span></span><br><span class="line">  Locator::<span class="built_in">provide</span>(service);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在，对音频服务的任何调用在运行前都会记录下去。 同时，当然，它和我们的空服务也能很好地相处，你能启用音频，也能继续记录音频被启用时将会播放的声音。</p><h4 id="设计决策-2"><a href="#设计决策-2" class="headerlink" title="设计决策"></a>设计决策</h4><p>我们讨论了一种典型的实现，但是对核心问题的不同回答有着不同的实现方式：</p><h5 id="服务是如何被定位的？"><a href="#服务是如何被定位的？" class="headerlink" title="服务是如何被定位的？"></a>服务是如何被定位的？</h5><p><strong>外部代码注册：</strong></p><p>这是样例代码中定位服务使用的机制，这也是我在游戏中最常见的设计方式：</p><ul><li><p><strong>简单快捷</strong>。 <code>getAudio()</code>函数简单地返回指针。这通常会被编译器内联，所以我们几乎没有付出性能损失就获得了很好的抽象层。</p></li><li><p><strong>可以控制如何构建提供者</strong>。 想想一个接触游戏控制器的服务。我们使用两个具体的提供者：一个是给常规游戏，另一个给在线游戏。 在线游戏跨过网络提供控制器的输入，这样，对游戏的其他部分，远程玩家好像是在使用本地控制器。</p><p>为了能正常工作，在线的服务提供者需要知道其他远程玩家的IP。 如果定位器本身构建对象，它怎么知道传进来什么？ <code>Locator</code>类对在线的情况一无所知，更不用说其他用户的IP地址了。</p><p>外部注册的提供者闪避了这个问题。定位器不再构造类，游戏的网络代码实例化特定的在线服务提供器， 传给它需要的IP地址。然后把服务提供给定位器，而定位器只知道服务的抽象接口。</p></li><li><p><strong>可以在游戏运行时改变服务</strong>。 我们也许在最终的游戏版本中不会用到这个，但是这是个在开发过程中有效的技巧。 举个例子，在测试时，即使游戏正在运行，我们也可以切换音频服务为早先提到的空服务来临时地关闭声音。</p></li><li><p><strong>定位器依赖外部代码</strong>。 这是缺点。任何访问服务的代码必须假定在某处的代码已经注册过服务了。 如果没有做初始化，要么游戏会崩溃，要么服务会神秘地不工作。</p></li></ul><p><strong>在编译时绑定：</strong></p><p>这里的思路是使用预处理器，在编译时间处理“定位”。就像这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Locator</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Audio&amp; <span class="title">getAudio</span><span class="params">()</span> </span>{ <span class="keyword">return</span> service_; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="type">static</span> DebugAudio service_;</span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">static</span> ReleaseAudio service_;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>像这样定位服务暗示了一些事情：</p><ul><li><strong>快速</strong>。 所有的工作都在编译时完成，在运行时无需完成任何东西。 编译器很可能会内联<code>getAudio()</code>调用，这是我们能达到的最快方案。</li><li><strong>能保证服务是可用的</strong>。 由于定位器现在拥有服务，在编译时就进行了定位，我们可以保证游戏如果能完成编译，就不必担心服务不可用。</li><li><strong>无法轻易改变服务</strong>。 这是主要的缺点。由于绑定发生在编译时，任何时候你想要改变服务，都得重新编译并重启游戏。</li></ul><p><strong>在运行时设置：</strong></p><p>企业级软件中，如果你说“服务定位器”，他们脑中第一反应就是这个方法。 当服务被请求时，定位器在运行时做一些魔法般的事情来追踪请求的真实实现。</p><blockquote><p><strong>反射</strong> 是一些编程语言在运行时与类型系统打交道的能力。 举个例子，我们可以通过名字找到类，找到它的构造器，然后创建实例。</p></blockquote><blockquote><p>像Lisp，Smalltalk和Python这样的动态类型语言自然有这样的特性，但新的静态语言比如C#和Java同样支持它。</p></blockquote><p>通常而言，这意味着加载设置文件确认提供者，然后使用反射在运行时实例化这个类。这为我们做了一些事情：</p><ul><li><p><strong>我们可以更换服务而无需重新编译</strong>。 这比编译时绑定多了小小的灵活性，但是不像注册那样灵活，那里你可以真正地在运行游戏的时候改变服务。</p></li><li><p><strong>非程序员也可改变服务</strong>。 这对于设计师是很好的，他们想要开关某项游戏特性，但修改源代码并不舒服。 （或者，更可能的，<em>编程者</em> 对设计者介入感到不舒服。）</p></li><li><p><strong>同样的代码库可以同时支持多种设置</strong>。 由于从代码库中完全移出了定位处理，我们可以使用相同的代码来同时支持多种服务设置。</p><p>这就是这个模型在企业网站上广泛应用的原因之一： 只需要修改设置，你就可以在不同的服务器上发布相同的应用。 历史上看来，这在游戏中没什么用，因为主机硬件本身是好好标准化了的， 但是很多游戏的目标是大杂烩般的移动设备，这点就很有关系了。</p></li><li><p><strong>复杂</strong>。 不像前面的解决方案，这个方案是重量级的。 你得创建设置系统，也许要写代码来加载和粘贴文件，通常要做些事情来定位服务。 花时间写这些代码，就没法花时间写其他的游戏特性。</p></li><li><p><strong>加载服务需要时间</strong>。 现在你会眉头紧蹙了。在运行时设置意味着你在消耗CPU循环加载服务。 缓存可以最小化消耗，但是仍暗示着在首次使用服务时，游戏需要暂停花点时间完成。 游戏开发者讨厌消耗CPU循环在不能提高游戏体验的地方。</p></li></ul><h5 id="如果服务不能被定位怎么办？"><a href="#如果服务不能被定位怎么办？" class="headerlink" title="如果服务不能被定位怎么办？"></a>如果服务不能被定位怎么办？</h5><p><strong>让使用者处理它：</strong></p><p>最简单的解决方案就是把责任推回去。如果定位器不能找到服务，只需返回<code>NULL</code>。这暗示着：</p><ul><li><strong>让使用者决定如何掌控失败</strong>。 使用者也许在收到找不到服务的关键错误时应该暂停游戏。 其他时候可能可以安全地忽视并继续。 如果定位器不能定义全面的策略应对所有的情况，那么就将失败传回去，让每个使用者决定什么是正确的回应。</li><li><strong>使用服务的用户必须处理失败</strong>。 当然，这个的必然结果是每个使用者都<em>必须</em>检查服务的失败。 如果它们都以相同方式来处理，在代码库中就有很多重复的代码。 如果一百个中有一个忘了检查，游戏就会崩溃。</li></ul><p><strong>挂起游戏：</strong></p><p>我说过，我们不能<em>保证</em>服务在编译时总是可用的，但是不意味着我们不能声明可用性是游戏定位器运行的一部分。 最简单的方法就是使用断言：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Locator</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Audio&amp; <span class="title">getAudio</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    Audio* service = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Code here to locate service...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(service != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> *service;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如果服务没有被找到，游戏停在试图使用它的后续代码之前。 这里的<code>assert()</code>调用没有解决无法定位服务的问题，但是它确实明确了问题是什么。 通过这里的断言，我们表明，“无法定位服务是定位器的漏洞。”</p><blockquote><p>如果你没见过<code>assert()</code>函数，<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/singleton.html">单例</a>模式一章中有解释。</p></blockquote><p>那么这为我们做了什么呢？</p><ul><li><strong>使用者不必处理缺失的服务</strong>。 简单的服务可能在成百上千的地方被使用，这节约了很多代码。 通过声明定位器永远能够提供服务，我们节约了使用者处理它的精力。</li><li><strong>如果服务没有找到，游戏会挂起</strong>。 在极少的情况下，服务真的找不到，游戏就会挂起。 强迫我们解决定位服务的漏洞是好事（比如一些本该调用的初始化代码没有被调用）， 但被阻塞的所有人都得等到漏洞修复时。与大型开发团队工作时，当这种事情发生，会增加痛苦的停工时间。</li></ul><p><strong>返回空服务：</strong></p><p>我们在样例中实现中展示了这种修复。使用它意味着：</p><ul><li><p><strong>使用者不必处理缺失的服务</strong>。 就像前面的选项一样，我们保证了总是会返回可用的服务，简化了使用服务的代码。</p></li><li><p><strong>如果服务不可用，游戏仍将继续</strong>。 这有利有弊。让我们在没有服务的情况下依然能运行游戏是很有用的。 在大团队中，当我们工作依赖的其他特性或者依赖的其他系统还没有就位时，这也是很有用的。</p><p>缺点在于，较难查找无意缺失服务的漏洞。 假设游戏用服务去获取数据，然后基于数据做出决策。 如果我们无法注册真正的服务，代码获得了空服务，游戏也许不会像期望的那样行动。 需要在这个问题上花一些时间，才能发现我们以为可用的服务是不存在的。</p></li></ul><p>在这些选项中，我看到最常使用的是会找到服务的简单断言。 在游戏发布的时候，它经历了严格的测试，会在可信赖的硬件上运行。 无法找到服务的机会非常小。</p><blockquote><p>我们可以让空服务被调用时打印一些debug信息来缓和这点。</p></blockquote><p>在更大的团队中，我推荐使用空服务。 这不会花太多时间实现，可以减少开发中服务不可用的缺陷。 这也给你了一个简单的方式去关闭服务，无论它是有漏洞还是干扰到了现在的工作。</p><h5 id="服务的服务范围有多大？"><a href="#服务的服务范围有多大？" class="headerlink" title="服务的服务范围有多大？"></a>服务的服务范围有多大？</h5><p>到目前为止，我们假设定位器给任何需要服务的地方提供服务。 当然这是这个模式的典型的使用方式，另一选项是服务范围限制到类和它的依赖类中，就像这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// 定位和设置服务的代码……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 派生类可以使用服务</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Audio&amp; <span class="title">getAudio</span><span class="params">()</span> </span>{ <span class="keyword">return</span> *service_; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> Audio* service_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>通过这样，对服务的访问被收缩到了继承<code>Base</code>的类。这两种各有千秋：</p><p><strong>如果全局可访问：</strong></p><ul><li><strong>鼓励整个代码库使用同样的服务</strong>。 大多数服务都被设计成单一的。 通过允许整个代码库接触到相同的服务，我们可以避免代码因不能获取“真正的”服务而到处实例化提供者。</li><li><strong>我们失去了何时何地使用服务的控制权</strong>。 这是让某物全局化的明显代价——任何东西都能接触它。<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/singleton.html">单例</a>模式一章讲了全局变量是多么的糟糕。</li></ul><p><strong>如果接触被限制在某个类中：</strong></p><ul><li><p><strong>我们控制了耦合</strong>。 这是主要的优点。通过显式限制服务到继承树的一个分支上，应该解耦的系统保持了解耦。</p></li><li><p><strong>可能导致重复的付出</strong>。 潜在的缺点是如果一对无关的类<em>确实</em>需要接触服务，每个类都要拥有服务的引用。 无论是谁定位或者注册服务，它也需要在这些类之间重复处理。</p><p>另一个选项是改变类的继承层次，给这些类一个公共的基类，但这引起的麻烦也许多于收益。）</p></li></ul><p>我的通用准则是，如果服务局限在游戏的一个领域中，那么限制它的服务范围在一个类上面。 举个例子，获取网络接口的服务可能限制于在线联网类中。 像日志这样应用更加广泛的服务应该是全局的。</p><h4 id="参见-2"><a href="#参见-2" class="headerlink" title="参见"></a>参见</h4><ul><li>服务定位模式在很多方面是<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/singleton.html">单例</a>模式的兄弟，在应用前值得看看哪个更适合你的需求。</li><li><a target="_blank" rel="noopener" href="http://unity3d.com/">Unity</a>框架在它的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/412/Documentation/ScriptReference/Component.GetComponent.html?from=index"><code>GetComponent()</code></a>方法中使用这个模式，协调它的<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/component.html">组件</a>模式</li><li>微软的<a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.game.services.aspx">XNA</a>游戏开发框架在它的核心<code>Game</code>类中内建了这种模式。 每个实体都有一个<code>GameServices</code>对象可以用来注册和定位任何种类的服务。</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/archives/decab052.html" rel="prev" title="材质着色与光照"><i class="fa fa-chevron-left"></i> 材质着色与光照</a></div><div class="post-nav-item"><a href="/archives/a045f270.html" rel="next" title="优化模式">优化模式 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">组件模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%8F%E5%9B%BE"><span class="nav-number">2.1.</span> <span class="nav-text">意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%9C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">动机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E5%9B%A2%E4%B9%B1%E9%BA%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">一团乱麻</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E5%88%80%E6%96%A9%E4%B9%B1%E9%BA%BB"><span class="nav-number">2.2.2.</span> <span class="nav-text">快刀斩乱麻</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%BD%E6%9D%BE%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">2.2.3.</span> <span class="nav-text">宽松的结果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%88%B0%E4%B8%80%E8%B5%B7"><span class="nav-number">2.2.4.</span> <span class="nav-text">绑到一起</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8"><span class="nav-number">2.4.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E4%BD%8F"><span class="nav-number">2.5.</span> <span class="nav-text">记住</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">2.6.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%9D%97%E7%B1%BB"><span class="nav-number">2.6.1.</span> <span class="nav-text">单块类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%A2%86%E5%9F%9F"><span class="nav-number">2.6.2.</span> <span class="nav-text">分离领域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E5%89%A9%E4%B8%8B%E7%9A%84%E5%88%86%E5%89%B2%E5%87%BA%E6%9D%A5"><span class="nav-number">2.6.3.</span> <span class="nav-text">将剩下的分割出来</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BABjorn"><span class="nav-number">2.6.4.</span> <span class="nav-text">机器人Bjorn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E6%8E%89Bjorn%EF%BC%9F"><span class="nav-number">2.6.5.</span> <span class="nav-text">删掉Bjorn？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96"><span class="nav-number">2.7.</span> <span class="nav-text">设计决策</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">2.7.1.</span> <span class="nav-text">对象如何获取组件？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="nav-number">2.7.2.</span> <span class="nav-text">组件之间如何通信？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%A7%81"><span class="nav-number">2.8.</span> <span class="nav-text">参见</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">事件序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%8F%E5%9B%BE-1"><span class="nav-number">3.1.</span> <span class="nav-text">意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%9C%BA-1"><span class="nav-number">3.2.</span> <span class="nav-text">动机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GUI%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.2.1.</span> <span class="nav-text">GUI事件循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BF%83%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="nav-number">3.2.2.</span> <span class="nav-text">中心事件总线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%A0%E8%AF%B4%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.3.</span> <span class="nav-text">你说什么？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">3.3.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-1"><span class="nav-number">3.4.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E4%BD%8F-1"><span class="nav-number">3.5.</span> <span class="nav-text">记住</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BF%83%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">3.5.1.</span> <span class="nav-text">中心事件队列是一个全局变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%96%E7%95%8C%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%AF%E4%BB%A5%E5%9B%A0%E4%BD%A0%E6%94%B9%E5%8F%98"><span class="nav-number">3.5.2.</span> <span class="nav-text">世界的状态可以因你改变</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%9A%E9%99%B7%E4%BA%8E%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F%E7%8E%AF%E8%B7%AF%E4%B8%AD"><span class="nav-number">3.5.3.</span> <span class="nav-text">会陷于反馈系统环路中</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">3.6.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8E%AF%E7%8A%B6%E7%BC%93%E5%AD%98"><span class="nav-number">3.6.1.</span> <span class="nav-text">环状缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82"><span class="nav-number">3.6.2.</span> <span class="nav-text">合并请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.6.3.</span> <span class="nav-text">分离线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96-1"><span class="nav-number">3.7.</span> <span class="nav-text">设计决策</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.7.1.</span> <span class="nav-text">队列中存储了什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%81%E8%83%BD%E4%BB%8E%E9%98%9F%E5%88%97%E4%B8%AD%E8%AF%BB%E5%8F%96%EF%BC%9F"><span class="nav-number">3.7.2.</span> <span class="nav-text">谁能从队列中读取？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%81%E8%83%BD%E5%86%99%E5%85%A5%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-number">3.7.3.</span> <span class="nav-text">谁能写入队列？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="nav-number">3.7.4.</span> <span class="nav-text">对象在队列中的生命周期如何？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%A7%81-1"><span class="nav-number">3.8.</span> <span class="nav-text">参见</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">服务定位器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%9C%BA-2"><span class="nav-number">4.1.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F-2"><span class="nav-number">4.2.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-2"><span class="nav-number">4.3.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E4%BD%8F-2"><span class="nav-number">4.4.</span> <span class="nav-text">记住</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%BF%85%E9%A1%BB%E7%9C%9F%E7%9A%84%E5%8F%AF%E5%AE%9A%E4%BD%8D"><span class="nav-number">4.4.1.</span> <span class="nav-text">服务必须真的可定位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E4%B8%8D%E7%9F%A5%E9%81%93%E8%B0%81%E5%9C%A8%E5%AE%9A%E4%BD%8D%E5%AE%83"><span class="nav-number">4.4.2.</span> <span class="nav-text">服务不知道谁在定位它</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">4.5.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.5.1.</span> <span class="nav-text">服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85"><span class="nav-number">4.5.2.</span> <span class="nav-text">服务提供者</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%99%A8"><span class="nav-number">4.5.3.</span> <span class="nav-text">一个简单的定位器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.5.4.</span> <span class="nav-text">一个空服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">4.5.5.</span> <span class="nav-text">日志装饰器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96-2"><span class="nav-number">4.6.</span> <span class="nav-text">设计决策</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E5%AE%9A%E4%BD%8D%E7%9A%84%EF%BC%9F"><span class="nav-number">4.6.1.</span> <span class="nav-text">服务是如何被定位的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%AE%9A%E4%BD%8D%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">4.6.2.</span> <span class="nav-text">如果服务不能被定位怎么办？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%8C%83%E5%9B%B4%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%9F"><span class="nav-number">4.6.3.</span> <span class="nav-text">服务的服务范围有多大？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%A7%81-2"><span class="nav-number">4.7.</span> <span class="nav-text">参见</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">271</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4m</span></div><div class="powered-by">今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//fastly.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//fastly.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//fastly.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script async="" src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script>!function(t,h,e,j){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:2272201,hjsv:6},e=h.getElementsByTagName("head")[0],(j=h.createElement("script")).async=1,j.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,e.appendChild(j)}(window,document)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
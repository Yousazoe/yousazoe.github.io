<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言本节是基础知识，使用 HLSL 像素着色器创建简单的光栅全屏通道"><meta property="og:type" content="article"><meta property="og:title" content="A Gentle Introduction to DirectX Raytracing 2"><meta property="og:url" content="https://yousazoe.top/archives/d114a1ff.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言本节是基础知识，使用 HLSL 像素着色器创建简单的光栅全屏通道"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor02-Output.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor02-Output-20211207231348237.png"><meta property="article:published_time" content="2021-12-07T15:10:32.000Z"><meta property="article:modified_time" content="2022-07-15T09:46:52.695Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor02-Output.png"><link rel="canonical" href="https://yousazoe.top/archives/d114a1ff.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>A Gentle Introduction to DirectX Raytracing 2 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/d114a1ff.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">A Gentle Introduction to DirectX Raytracing 2</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-12-07 23:10:32" itemprop="dateCreated datePublished" datetime="2021-12-07T23:10:32+08:00">2021-12-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">光线追踪 (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>10k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>18 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor02-Output.png"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本节是基础知识，使用 HLSL 像素着色器创建简单的光栅全屏通道</p><span id="more"></span><blockquote><p>As <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/dxr_tutors.md.html">discussed in our tutorial introduction</a>, our goal is to provide a simple infrastructure for getting a DirectX Raytracing application up and running without digging around in low-level API specification documents. Tutorial 2 continues with our sequence covering some infrastructure basics before we get to the meat of implementing a path tracer. If you wish to move on to a tutorial with actual DirectX Raytracing programming, <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor4/tutorial04.md.html">jump ahead to Tutorial 4</a>.</p></blockquote><p>正如我们的<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/dxr_tutors.md.html">教程简介</a>中所讨论的，我们的目标是提供一个简单的基础结构来启动和运行 DirectX Raytracing 应用程序，而无需在底层 API 规范文档中进行挖掘。教程 2 继续介绍一些基础结构和基本知识，然后再介绍如何实现路径跟踪器。如果您希望继续学习包含实际 DirectX 光线追踪编程的教程，<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor4/tutorial04.md.html">请跳到教程 4</a>.</p><h3 id="Adding-a-More-Complex-RenderPass"><a href="#Adding-a-More-Complex-RenderPass" class="headerlink" title="Adding a More Complex RenderPass"></a>Adding a More Complex RenderPass</h3><blockquote><p><a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor1/tutorial01.md.html">Tutorial 1</a> showed you how to get a basic window open and inset a simplistic <code>RenderPass</code> to clear your screen to a user-controllable color. This tutorial shows how to setup and use a more complex rasterization pass with a programmable HLSL shader.</p></blockquote><p><a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor1/tutorial01.md.html">教程 1</a>向您展示了如何打开一个基本窗口并加入一个简单的 <code>RenderPass</code> 让用户调整屏幕颜色。本教程介绍如何设置和使用具有可编程 HLSL 着色器的更复杂的栅格化通道。</p><blockquote><p>The specific shader is not particularly important, rather the point of this tutorial is to demonstrate the wrappers we have for encapsulating programmable shaders of various kinds and how you interact and pass parameters to these shaders from your C++ based <code>RenderPasses</code>.</p></blockquote><p>特定的着色器并不是特别重要，但本教程的重点是演示我们用于封装各种可编程着色器，以及如何从使用 C++ <code>RenderPasses</code> 交互并将参数传递到这些着色器。</p><blockquote><p>If you open up <code>Tutor02-SimpleRasterShader.cpp</code>, you will find it looks remarkably similar to the main program from Tutorial 1. The key difference is in what <code>RenderPass</code> we add to our pipeline:</p></blockquote><p>如果您打开 <code>Tutor02-SimpleRasterShader.cpp</code>，您会发现它看起来与教程 1 中的主程序非常相似。关键的区别在于我们添加到管道中的 <code>RenderPass</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create our rendering pipeline</span></span><br><span class="line">RenderingPipeline *pipeline = <span class="keyword">new</span> <span class="built_in">RenderingPipeline</span>();</span><br><span class="line">pipeline-&gt;<span class="built_in">setPass</span>(<span class="number">0</span>, SinusoidRasterPass::<span class="built_in">create</span>());</span><br></pre></td></tr></tbody></table></figure><blockquote><p>In this tutorial, we simply swap out the <code>ConstantColorPass</code> for our more complex <code>SinusoidRasterPass</code>. The key files to look at are then:</p><ul><li><code>Passes\SinusoidRasterPass.h</code></li><li><code>Passes\SinusoidRasterPass.cpp</code></li><li><code>Data\Tutorial02\sinusoid.ps.hlsl</code></li></ul></blockquote><p>在本教程中，我们只需将 <code>ConstantColorPass</code> 换成更复杂的 <code>SinusoidRasterPass</code>。然后，要查看的关键文件是：</p><ul><li><code>Passes\SinusoidRasterPass.h</code></li><li><code>Passes\SinusoidRasterPass.cpp</code></li><li><code>Data\Tutorial02\sinusoid.ps.hlsl</code></li></ul><blockquote><p>Looking at the <code>SinusoidRasterPass.h</code> header, you will largely see the same class declaration boilerplate from the <code>ConstantColorPass</code>, and in fact the only differences are in the member variables:</p></blockquote><p>查看 <code>SinusoidRasterPass.h</code> 头文件，您会在很大程度上看到 <code>ConstantColorPass</code> 的相同类声明样板，实际上唯一的区别在于成员变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Internal pass state</span></span><br><span class="line">FullscreenLaunch::SharedPtr   mpSinusoidPass;         <span class="comment">///&lt; Our accumulation shader state</span></span><br><span class="line">GraphicsState::SharedPtr      mpGfxState;             <span class="comment">///&lt; Our graphics pipeline state</span></span><br><span class="line"><span class="type">uint32_t</span>                      mFrameCount = <span class="number">0</span>;        <span class="comment">///&lt; A frame counter to let our sinusoid animate</span></span><br><span class="line"><span class="type">float</span>                         mScaleValue = <span class="number">0.1f</span>;     <span class="comment">///&lt; A scale value for our sinusoid</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>For now ignore <code>mFrameCount</code> and <code>mScaleValue</code>, which are parameters to control the image displayed by our shader.</p></blockquote><p>现在忽略 <code>mFrameCount</code> 和 <code>mScaleValue</code>，它们是控制着色器显示的图像的参数。</p><blockquote><p>The <code>GraphicsState</code> is a Falcor class that wraps up the pipeline state of a DirectX rasterization pipeline. This includes things like culling, depth testing, blending, rasterization parameters, etc. For our ray tracing tutorials, we only need a simple <em>default</em> graphics state, so the key to remember is we need <em>some</em> graphics state to setup a DirectX pipeline. Don’t worry too much about what settings it controls.</p></blockquote><p><code>GraphicsState</code> 是一个 Falcor 类，用于封装 DirectX 栅格化管道的管道状态。它包括剔除、深度测试、混合、栅格化参数等。对于光线追踪教程，我们只需要一个简单的<em>默认</em>图形状态，因此要记住的关键是我们需要<em>一些</em>图形状态来设置 DirectX 管道。不要太担心它控制什么设置。</p><blockquote><p>The <code>FullscreenLaunch</code> class is an abstraction in the <code>SharedUtils\</code> directory that easily allows you to launch very simple full-screen rasterization draw calls. Similar abstractions, <code>RasterLaunch</code> and <code>RayLaunch</code>, exist for drawing more complex raster and ray calls using loaded scene geometry. We’ll use those in future tutorials, and they behave quite similar to our <code>FullscreenLaunch</code>.</p></blockquote><p><code>FullscreenLaunch</code> 类是 <code>SharedUtils\</code> 目录中的一个抽象，它允许您轻松启动非常简单的全屏光栅化绘制调用。类似的抽象如 <code>RasterLaunch</code> 和 <code>RayLaunch</code>，存在使用加载的场景几何图形绘制更复杂的栅格和光线调用。我们将在以后的教程中使用它们，它们的行为与我们的 <code>FullscreenLaunch</code> 非常相似。</p><h3 id="Defining-the-SinusoidRasterPass"><a href="#Defining-the-SinusoidRasterPass" class="headerlink" title="Defining the SinusoidRasterPass"></a>Defining the SinusoidRasterPass</h3><blockquote><p>As in the case of our simpler <code>ConstantColorPass</code>, we need to define the <code>initialize</code>, <em><code>renderGui</code></em>, and <em><code>execute</code></em> methods. Looking in <code>SinusoidRasterPass.cpp</code>, the <em><code>renderGui</code></em> should be self explanatory:</p></blockquote><p>就像我们简单的 <code>ConstantColorPass</code> 一样，我们需要定义 <code>initialize</code>、<code>renderGui</code> 和 <code>execute</code> 方法。在 <code>SinusoidRasterPass.cpp</code> 中 <code>renderGui</code> 应该是不言自明的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pGui-&gt;<span class="built_in">addFloatVar</span>(<span class="string">"Sin multiplier"</span>, mScaleValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.00001f</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>It simply adds a GUI widget that allows control over a single floating point value, allowing variations in the range [0…1] in increments of 0.00001.</p></blockquote><p>它只是添加了一个 GUI 小部件，允许控制单个浮点值，允许从 0 到 1 以 0.00001 为增量的变化。</p><blockquote><p>Our <code>initialize</code> pass adds two new lines that were not part of <code>ConstantColorPass</code>:</p></blockquote><p>我们的 <code>initialize</code> 传递添加了两行不属于 <code>ConstantColorPass</code> 的新行:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">mpGfxState = GraphicsState::<span class="built_in">create</span>();</span><br><span class="line">mpSinusoidPass = FullscreenLaunch::<span class="built_in">create</span>( <span class="string">"Tutorial02\\sinusoid.ps.hlsl"</span> );</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The first creates a default DirectX raster pipeline state we’ll use when rendering. The second line says we’ll be doing a full-screen draw call using the specified HLSL shader. Falcor’s full-screen pass uses a default vertex shader, so you only need to specify a pixel shader.</p></blockquote><p>第一行创建我们将在渲染时使用的默认 DirectX 栅格管道状态。第二行表示我们将使用指定的 HLSL 着色器执行全屏绘制调用。Falcor 的全屏通道使用默认顶点着色器，因此您只需指定像素着色器即可。</p><blockquote><p>The <code>execute</code> method is more complex, so let’s step through the entire function:</p></blockquote><p><code>execute</code> 方法更复杂，因此让我们逐步执行整个函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SinusoidRasterPass::execute</span><span class="params">(RenderContext::SharedPtr pRenderContext)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// Create a framebuffer object to render into.  </span></span><br><span class="line">  Fbo::SharedPtr outputFbo = </span><br><span class="line">      mpResManager-&gt;<span class="built_in">createManagedFbo</span>({ ResourceManager::kOutputChannel });</span><br><span class="line">  mpGfxState-&gt;<span class="built_in">setFbo</span>(outputFbo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set shader parameters for our shader</span></span><br><span class="line">  <span class="keyword">auto</span> shaderVars = mpSinusoidPass-&gt;<span class="built_in">getVars</span>();</span><br><span class="line">  shaderVars[<span class="string">"PerFrameCB"</span>][<span class="string">"gFrameCount"</span>] = mFrameCount++;</span><br><span class="line">  shaderVars[<span class="string">"PerFrameCB"</span>][<span class="string">"gMultValue"</span>]  = mScaleValue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute our shader</span></span><br><span class="line">  mpSinusoidPass-&gt;<span class="built_in">execute</span>(pRenderContext, mpGfxState);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>In this case, we’re executing a raster shader. This means we need a framebuffer to draw into, and we can’t simply clear our texture (as we did in <code>ConstantColorPass</code>).</p></blockquote><p>在本例中，我们将执行栅格着色器。这意味着我们需要一个帧缓冲器来绘制，并且我们不能简单地清除纹理（就像我们在 <code>ConstantColorPass</code> 中所做的那样）。</p><blockquote><p>Our first line asks our <code>ResourceManager</code> to create a framebuffer for us, and to bind the <code>kOutputChannel</code> as the framebuffer object’s color channel. Ideally, you would not create a new framebuffer each frame, but this is left as an exercise for more advanced readers. We then update our DirectX pipeline state to send results to this new FBO when we run our shader.</p></blockquote><p>我们的第一行要求我们的 <code>ResourceManager</code> 为我们创建一个帧缓冲器，并将 <code>kOutputChannel</code> 绑定为帧缓冲器对象的颜色通道。理想情况下，您无需为每个帧都创建一个新的帧缓冲器，但这留给更高级的读者作为练习。然后，我们更新 DirectX 管道状态，以便在运行着色器时将结果发送到此新 FBO。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create a framebuffer object to render to.  Done here once per frame for simplicity, not performance.</span></span><br><span class="line"><span class="comment">//     This function allows us provide a list of managed texture names, which get combined into an FBO</span></span><br><span class="line">Fbo::SharedPtr outputFbo = mpResManager-&gt;<span class="built_in">createManagedFbo</span>({ ResourceManager::kOutputChannel });</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The next three lines set shader parameters in the <code>sinusoid.ps.hlsl</code> shader. The first line gets an object that can access and transfer data to the variables in your shader. The next two lines have very simple syntax: on the left of the assignment operator you specify the variable in your shader, on the right is the value you want to transfer to HLSL. The assignment operator is overloaded and (in a Debug build) will do some basic type checking (at runtime) to ensure the value is the right type to assign to the specified HLSL variable.</p></blockquote><p>接下来的三行在 <code>sinusoid.ps.hlsl</code> 着色器中设置着色器参数。第一行获取一个对象，该对象可以访问着色器中的变量并将其传输到着色器中的变量。接下来的两行则是非常简单的语法：在赋值运算符的左侧，在着色器中指定变量，右侧是要传输到 HLSL 的值。赋值运算符已重载，并且（在调试版本中）将执行一些基本类型检查（在运行时），以确保该值是分配给指定 HLSL 变量的正确类型。</p><p>（译注：这段不是很懂，我的理解大概就是说这里重载了等于符号可以直接赋值。）</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Set shader parameters.  PerFrameCB is a named constant buffer in our HLSL shader</span></span><br><span class="line"><span class="keyword">auto</span> shaderVars = mpSinusoidPass-&gt;<span class="built_in">getVars</span>();</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The syntax <code>shaderVars["PerFrameCB"]["gMultValue"] = mScaleValue</code> reads as: in the specified shader, find the variable <code>gMultValue</code> in the constant buffer <code>PerFrameCB</code> and set the value to <code>mScaleValue</code>. This is a very simple and clear assignment between CPU and GPU variables. It is not the most efficient way to update shader values, but for the purposes of these tutorials (and most of my research prototypes), this overhead is not significant enough to favor more efficient, but cryptic, data transfers.</p></blockquote><p>语法 <code>shaderVars["PerFrameCB"]["gMultValue"] = mScaleValue</code> 读作：在指定的着色器中，在常量缓冲区 <code>PerFrameCB</code> 中找到变量 <code>gMultValue</code> 并将该值设置为 <code>mScaleValue</code>。这是 CPU 和 GPU 变量之间非常简单明了的分配。这不是更新着色器值的最有效方法，但对于这些教程（以及我的大多数研究原型）的目的，这种开销还不足以支持更有效但更隐晦的数据传输。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">shaderVars[<span class="string">"PerFrameCB"</span>][<span class="string">"gFrameCount"</span>] = mFrameCount++;</span><br><span class="line">shaderVars[<span class="string">"PerFrameCB"</span>][<span class="string">"gMultValue"</span>]  = mScaleValue;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Finally, we execute our full-screen shader. This requires two parameters: the current DirectX render context and the graphics state to use for rendering.</p></blockquote><p>最后，我们执行全屏着色器。这需要两个参数：当前 DirectX 呈现上下文和用于呈现的图形状态。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Execute our shader</span></span><br><span class="line">mpSinusoidPass-&gt;<span class="built_in">execute</span>(pRenderContext, mpGfxState);</span><br></pre></td></tr></tbody></table></figure><h3 id="Interacting-with-the-Sinusoidal-HLSL-Shader"><a href="#Interacting-with-the-Sinusoidal-HLSL-Shader" class="headerlink" title="Interacting with the Sinusoidal HLSL Shader"></a>Interacting with the Sinusoidal HLSL Shader</h3><blockquote><p>The final step to understanding this tutorial is to look at our GPU shader in <code>sinusoid.ps.hlsl</code>:</p></blockquote><p>本教程的最后一步是查看 <code>sinusoid.ps.hlsl</code> 中的 GPU 着色器：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// A constant buffer of shader parameters populated from our C++ code</span></span><br><span class="line">cbuffer PerFrameCB</span><br><span class="line">{</span><br><span class="line">  uint gFrameCount;</span><br><span class="line">  <span class="type">float</span> gMultValue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">main</span><span class="params">(float2 texC : TEXCOORD, float4 pos : SV_Position)</span> : SV_Target0</span></span><br><span class="line"><span class="function">{</span></span><br><span class="line">  <span class="comment">// Get integer screen coordinates (e.g., in [0..1920] x [0..1080])</span></span><br><span class="line">  uint2 pixelPos = (uint2)pos.xy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute a per-pixel sinusoidal value</span></span><br><span class="line">  <span class="type">float</span> sinusoid = <span class="number">0.5</span> * (<span class="number">1.0f</span> + <span class="built_in">sin</span>( <span class="number">0.001f</span> * gMultValue * </span><br><span class="line">                                      <span class="built_in">dot</span>(pixelPos, pixelPos) + </span><br><span class="line">                                      gFrameCount ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save our color out to our framebuffer  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">float4</span>(sinusoid, sinusoid, sinusoid, <span class="number">1.0f</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The first couple lines define our constant buffer with the parameters we set from the <code>execute</code> method of our <code>SinusoidRenderPass</code>.</p></blockquote><p>前几行使用我们从 <code>SinusoidRenderPass</code> 的 <code>execute</code> 方法中设置的参数来定义我们的常量缓冲区。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// A constant buffer of shader parameters populated from our C++ code</span></span><br><span class="line">cbuffer PerFrameCB</span><br><span class="line">{</span><br><span class="line">    uint gFrameCount;</span><br><span class="line">	<span class="type">float</span> gMultValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We then define our shader <code>main</code> that takes two variables (<code>texC</code> and <code>pos</code>) from Falcor’s default vertex shader and writes out to our framebuffer’s color buffer 0 (i.e., <code>SV_Target0</code>).</p></blockquote><p>然后，我们定义着色器 <code>main</code>，从 Falcor 的默认顶点着色器中获取两个变量 <code>texC</code> 和 <code>pos</code> 并写出到帧缓冲器的颜色缓冲区 0（即 <code>SV_Target0</code> ).</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Our main pixel shader.  It writes a float4 to the output color buffer. </span></span><br><span class="line"><span class="function">float4 <span class="title">main</span><span class="params">(float2 texC : TEXCOORD, float4 pos : SV_Position)</span> : SV_Target0</span></span><br><span class="line"><span class="function">{</span></span><br><span class="line">	<span class="comment">// Compute a per-pixel sinusoidal value</span></span><br><span class="line">	<span class="type">float</span> sinusoid = <span class="number">0.5</span> * (<span class="number">1.0f</span> + <span class="built_in">sin</span>(<span class="number">0.001f</span> * gMultValue * (<span class="built_in">dot</span>(pos.xy, pos.xy) + gFrameCount / gMultValue) ));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save our color out to our framebuffer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float4</span>(sinusoid, sinusoid, sinusoid, <span class="number">1.0f</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The math is fairly unimportant, but generates a grayscale sinuosoid that slowly changes over time (since <code>gFrameCount</code> gets incremented each frame) and whose scale is controllable by the <code>gMultValue</code> variable.</p></blockquote><p>数学运算相当不重要，但会生成一个灰度 sinuosoid，该灰度会随时间缓慢变化（因为 <code>gFrameCount</code> 每帧都会递增），并且其比例可由 <code>gMultValue</code> 变量控制。</p><h3 id="What-Does-it-Look-Like"><a href="#What-Does-it-Look-Like" class="headerlink" title="What Does it Look Like?"></a>What Does it Look Like?</h3><blockquote><p>That covers the important points of this tutorial. Now if you run it, you get a result similar to this:</p></blockquote><p>这涵盖了本教程的要点。现在，如果您运行它，您将获得类似于以下内容的结果：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor02-Output-20211207231348237.png"></p><blockquote><p>Hopefully, this tutorial demonstrated how to use a very basic raster shader and send it parameters from our simple RenderPass architecture.</p></blockquote><p>希望本教程演示了如何使用非常基本的栅格着色器，以及从简单的 RenderPass 架构向其传递参数。</p><blockquote><p>When you are ready, continue on to <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">Tutorial 3</a>, where we use a more traditional rasterization pass to generate a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/G-buffer#G">G-Buffer</a> and allow the user to selectively display different G-Buffer parameters.</p></blockquote><p>准备就绪后，请继续学习<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">教程3</a>，其中我们使用更传统的栅格化通道来生成 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/G-buffer#G">G缓冲区</a>，并允许用户有选择地显示不同的 G缓冲区参数。</p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/971404c0.html" rel="bookmark">Rendering Course by Wangningbei</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/1503bc5d.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 13</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/592c1a1d.html" rel="prev" title="性别、边缘、斗争、妥协，我们在政治正确的路上走得太远了吗？"><i class="fa fa-chevron-left"></i> 性别、边缘、斗争、妥协，我们在政治正确的路上走得太远了吗？</a></div><div class="post-nav-item"><a href="/archives/a6139169.html" rel="next" title="A Gentle Introduction to DirectX Raytracing 3">A Gentle Introduction to DirectX Raytracing 3 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adding-a-More-Complex-RenderPass"><span class="nav-number">2.</span> <span class="nav-text">Adding a More Complex RenderPass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Defining-the-SinusoidRasterPass"><span class="nav-number">3.</span> <span class="nav-text">Defining the SinusoidRasterPass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interacting-with-the-Sinusoidal-HLSL-Shader"><span class="nav-number">4.</span> <span class="nav-text">Interacting with the Sinusoidal HLSL Shader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-Does-it-Look-Like"><span class="nav-number">5.</span> <span class="nav-text">What Does it Look Like?</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">279</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.1m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="BT Agency by        Mohamed Chahin             引言本书全面、系统地总结了在准备程序员面试过程中必备的数据结构与算法。无论是计算机相关专业的应届毕业生还是初入职场的程序员，本书总结的数据结构和算法的基础知识及解题经验都不仅可以帮助他们提高准备面试的效率，还可以增加他们通过面试的成功率。"><meta property="og:type" content="article"><meta property="og:title" content="剑指Offer(专项突破版)"><meta property="og:url" content="https://yousazoe.top/archives/8add02f4.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="BT Agency by        Mohamed Chahin             引言本书全面、系统地总结了在准备程序员面试过程中必备的数据结构与算法。无论是计算机相关专业的应届毕业生还是初入职场的程序员，本书总结的数据结构和算法的基础知识及解题经验都不仅可以帮助他们提高准备面试的效率，还可以增加他们通过面试的成功率。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/57a78f91015335.5e26dc1d22d28.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626332422-wUpUHT-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628949136-zQFMmB-e740f25c4850f72eae2482bb42cfc36.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628949854-YEDxST-5424205ebc953c73cf8381aa53f7bc2.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628958996-hWmHxz-10139da0979df36b9067b22886a0890.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/remove_ex1-20211216181507546.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p3.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/jianzhi_II_022_fig1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_statement-20211217215753375.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_1-20211217215741037.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_2-20211217215712485.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_3-20211217215658254.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123481-fdeApj-image-20211218222217465.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123467-zeofGx-image-20211218222141874.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123497-pwIiFq-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev1ex1-20211218223412424.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev1ex2-20211218223406816.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626420025-fZfzMX-image-20211218224204036.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626420320-YUiulT-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626420320-YUiulT-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626421737-LjXceN-image-20211220162328016.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626422231-wgvnWh-image-20211220162344045.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1-20211220192101041.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/example_1_before_65p.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/example_1_after_65p.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png-20211221123721524.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629345113-XXdGKZ-f1dbb5feb6708bc5ec400d978eea73a.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/a24107cefeff7239068268099db90671254c2d357857232f19dc21bdaace5774-image.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/histogram-20211225222544405.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/histogram-1-20211225222538918.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/maximal.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629473154-gKRqvU-ce27c552f3c1d653d97978cf52b4b0d.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629514102-NbQgoB-477afe8550c13a4e1e3c0e726bdf67a.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree1-20220107161106888.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree2-20220107161151618.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629516028-QgimFe-2ec6bf9d0c6a8c23ba023583bfeacf6-20220107161951636.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree-20220107162047026.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629516721-xcbSKy-2bdd85f029f86f2e9708a61edccdc1a.jpg"><meta property="article:published_time" content="2021-12-08T14:57:40.000Z"><meta property="article:modified_time" content="2022-09-16T11:53:56.576Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="LeetCode"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Online Judge"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/57a78f91015335.5e26dc1d22d28.png"><link rel="canonical" href="https://yousazoe.top/archives/8add02f4.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>剑指Offer(专项突破版) | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/8add02f4.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">剑指Offer(专项突破版)</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-12-08 22:57:40" itemprop="dateCreated datePublished" datetime="2021-12-08T22:57:40+08:00">2021-12-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/LeetCode%E9%A2%98%E8%A7%A3-LeetCode-Solution/" itemprop="url" rel="index"><span itemprop="name">LeetCode题解 (LeetCode Solution)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>43k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>1:19</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/57a78f91015335.5e26dc1d22d28.png"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://www.behance.net/gallery/91015335/BT-Agency">BT Agency</a> by <a target="_blank" rel="noopener" href="https://www.behance.net/MChahin">Mohamed Chahin</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本书全面、系统地总结了在准备程序员面试过程中必备的数据结构与算法。无论是计算机相关专业的应届毕业生还是初入职场的程序员，本书总结的数据结构和算法的基础知识及解题经验都不仅可以帮助他们提高准备面试的效率，还可以增加他们通过面试的成功率。</p><span id="more"></span><blockquote><p>以下所有题目均来源 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/e8X3pBZi">LeetCode 中国官网</a>，题解由 <a target="_blank" rel="noopener" href="https://github.com/doocs/leetcode/graphs/contributors">doocs/leetcode 贡献者</a> 提供，正在完善中，欢迎贡献你的题解！</p><p>快速搜索题号、题解、标签等，请善用 <code>Control+F</code>（或者 <code>Command+F</code>）。</p></blockquote><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><h4 id="整数除法-1"><a href="#整数除法-1" class="headerlink" title="整数除法[1]"></a>整数除法[1]</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个整数 <code>a</code> 和 <code>b</code> ，求它们的除法的商 <code>a/b</code> ，要求不得使用乘号 <code>'*'</code>、除号 <code>'/'</code> 以及求余符号 <code>'%'</code> 。</p><p><strong>注意：</strong></p><ul><li>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code></li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 <code>[−231, 231−1]</code>。本题中，如果除法结果溢出，则返回 <code>231 − 1</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：a = 15, b = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：15/2 = truncate(7.5) = 7</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：a = 7, b = -3</span><br><span class="line">输出：0</span><br><span class="line">解释：7/-3 = truncate(-2.33333..) = -2</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：a = 0, b = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：a = 1, b = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>$-2^{31}$ &lt;= a, b &lt;= $2^{31} - 1$</li><li><code>b != 0</code></li></ul><blockquote><p>注意：本题与主站 29 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-two-integers/">https://leetcode-cn.com/problems/divide-two-integers/</a></p></blockquote><h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>一个很直观的想法是基于减法实现除法。例如，为了求 19/2 可以从 19 中不断减去 2，那么减去 9 个 2 以后就剩下 1，可以得到 19/2 = 9，但是效率很低，当被除数是 n,除数是 1 的时候，算法复杂度最差为 O(n)。如果将上述解法做一些调整，当被除数大于除数时，继续判断是不是大于除数的 2 倍？ 4 倍？ 8 倍？….如果被除数大于除数的 $2^k$ 倍，那么将被除数减去除数的 $2^k$ 倍，之后再重复以上步骤。</p><p>举个例子 19/2，19 大于 2，也大于 4 (2 * $2 ^ 1$)，也大于 8 (2 * $2 ^ 2$)，也大于 16 (2 * $2 ^ 3$)，但是小于 32 (2 * $2 ^ {4}$)，于是将 19 - 16 得到 3，并记录此时的答案 8，此时被除数变为 3，除数还是 2，重复上述结果得到此时答案为 1，剩下被除数 1，已经小于 2，最终结果为 8 + 1 = 9。算法复杂度为 O(logn)。</p><p>上述分析过程都是基于被除数和除数都是正整数，如果存在负整数则可以将他们先转化为正整数进行计算，最后根据符号调整结果。但是对于 32 位 int 来讲，最大的正数为 $2^{31}-1$,最小的负数为 $-2^{31}$,如果将负数转化为正数会溢出，所以可以将正数都转化为负数计算，核心部分就是对两个负数进行除法，返回的结果可以用无符号数返回，最后进行正负号调整。另外所有的结果中存在一种情况无法用 int 表示结果，那就是被除数为 $-2^{31}$，除数为 -1，这时候直接特殊判断输出 INT_MAX 就行。</p><p>通过下面这段伪代码，不难理解除法本质上就是减法，但是一次循环只能做一次减法，效率太低会导致超时，所以再加上快速幂的思想优化即可：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">sign = <span class="number">-1</span> <span class="keyword">if</span> a * b &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">a = <span class="built_in">abs</span>(a)</span><br><span class="line">b = <span class="built_in">abs</span>(b)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> a &gt;= b:</span><br><span class="line">    a -= b</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> sign * cnt</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (a == INT_MIN &amp;&amp; b == <span class="number">-1</span>) {</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) {</span><br><span class="line">            sign--;</span><br><span class="line">            a = -a; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) {</span><br><span class="line">            sign--;</span><br><span class="line">            b = -b;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> res = <span class="built_in">divideCore</span>(a, b);</span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span>? -res: res;        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divideCore</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a &lt;= b) {</span><br><span class="line">            <span class="type">int</span> value = b;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(value &gt;= <span class="number">0xc0000000</span> &amp;&amp; a &lt;= value + value) {</span><br><span class="line">                cnt += cnt;</span><br><span class="line">                value += value;</span><br><span class="line">            }</span><br><span class="line">            res += cnt;</span><br><span class="line">            a -= value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这里 <code>divideCore()</code> 中 <code>a &lt;= b</code> 是因为全部转换为负数，数值大的反而小。</p><h4 id="二进制加法-2"><a href="#二进制加法-2" class="headerlink" title="二进制加法[2]"></a>二进制加法[2]</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个 01 字符串 <code>a</code> 和 <code>b</code> ，请计算它们的和，并以二进制字符串的形式输出。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: a = "11", b = "10"</span><br><span class="line">输出: "101"</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: a = "1010", b = "1011"</span><br><span class="line">输出: "10101"</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>每个字符串仅由字符 <code>'0'</code> 或 <code>'1'</code> 组成。</li><li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li><li>字符串如果不是 <code>"0"</code> ，就都不含前导零。</li></ul><blockquote><p>注意：本题与主站 67 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary/">https://leetcode-cn.com/problems/add-binary/</a></p></blockquote><h5 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h5><p>模拟笔算加法的过程，注意进位：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>{</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> digitA = i &gt;= <span class="number">0</span> ? a.<span class="built_in">at</span>(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> digitB = j &gt;= <span class="number">0</span> ? b.<span class="built_in">at</span>(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = digitA + digitB + carry;</span><br><span class="line">            carry = sum &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            sum = sum &gt;= <span class="number">2</span> ? sum - <span class="number">2</span> : sum;</span><br><span class="line">            res += <span class="built_in">to_string</span>(sum);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) res.<span class="built_in">push_back</span>(<span class="string">'1'</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="前-n-个数字二进制中-1-的个数-3"><a href="#前-n-个数字二进制中-1-的个数-3" class="headerlink" title="前 n 个数字二进制中 1 的个数[3]"></a>前 n 个数字二进制中 1 的个数[3]</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个非负整数 <code>n</code> ，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = 2</span><br><span class="line">输出: [0,1,1]</span><br><span class="line">解释: </span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br><span class="line">解释:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></tbody></table></figure><p><strong>说明 :</strong></p><ul><li><code>0 &lt;= n &lt;= 10^5</code></li></ul><p><strong>进阶:</strong></p><ul><li>给出时间复杂度为 <code>O(n*sizeof(integer))</code> 的解答非常容易。但你可以在线性时间 <code>O(n)</code> 内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为 <code>O(n)</code></li><li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <code>__builtin_popcount</code> ）来执行此操作</li></ul><blockquote><p>注意：本题与主站 338 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">https://leetcode-cn.com/problems/counting-bits/</a></p></blockquote><h5 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h5><p>最直观的做法是对从 $0$ 到 $n$ 的每个整数直接计算「一比特数」。每个 $\texttt{int}$ 型的数都可以用 32 位二进制数表示，只要遍历其二进制表示的每一位即可得到 1 的数目。</p><p>利用 $\text{Brian Kernighan}$ 算法，可以在一定程度上进一步提升计算速度。$\text{Brian Kernighan}$ 算法的原理是：对于任意整数 $x$，令 $x=x<del>&amp;</del>(x-1)$，该运算将 $x$ 的二进制表示的最后一个 1 变成 0。因此，对 $x$ 重复该操作，直到 $x$ 变成 $0$，则操作次数即为 $x$ 的「一比特数」。</p><p>对于给定的 $n$，计算从 $0$ 到 $n$ 的每个整数的「一比特数」的时间都不会超过 $O(\log n)$，因此总时间复杂度为 $O(n \log n)$。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            res[i] = res[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="只出现一次的数字-4"><a href="#只出现一次的数字-4" class="headerlink" title="只出现一次的数字[4]"></a>只出现一次的数字[4]</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,1,0,1,100]</span><br><span class="line">输出：100</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li></ul><p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><blockquote><p>注意：本题与主站 137 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-ii/">https://leetcode-cn.com/problems/single-number-ii/</a></p></blockquote><h5 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h5><p>统计所有数字每个位中 1 出现的次数，对于某个位，1 出现的次数一定是 3 的倍数 +1 或 0。对这个数 %3 得到的结果就是那个出现一次的数字在该位上的值：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bit</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">                bit[i] += (num &gt;&gt; (<span class="number">31</span> - i)) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) + bit[i] % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="单词长度的最大乘积-5"><a href="#单词长度的最大乘积-5" class="headerlink" title="单词长度的最大乘积[5]"></a>单词长度的最大乘积[5]</h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个字符串数组 <code>words</code>，请计算当两个字符串 <code>words[i]</code> 和 <code>words[j]</code> 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: words = ["abcw","baz","foo","bar","fxyz","abcdef"]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 "abcw", "fxyz"。它们不包含相同字符，且长度的乘积最大。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: words = ["a","ab","abc","d","cd","bcd","abcd"]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 这两个单词为 "ab", "cd"。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: words = ["a","aa","aaa","aaaa"]</span><br><span class="line">输出: 0 </span><br><span class="line">解释: 不存在这样的两个单词。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= words.length &lt;= 1000</code></li><li><code>1 &lt;= words[i].length &lt;= 1000</code></li><li><code>words[i]</code> 仅包含小写字母</li></ul><blockquote><p>注意：本题与主站 318 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">https://leetcode-cn.com/problems/maximum-product-of-word-lengths/</a></p></blockquote><h5 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h5><p>因为只有 26 个小写字符，所以可以用一个哈希表存储字符的出现情况，然后枚举最大乘积：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>{</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">hash</span>(words.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">26</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c: words[i])</span><br><span class="line">                hash[i][c - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; words.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; <span class="number">26</span>; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (hash[i][k] &amp;&amp; hash[j][k])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">26</span>) {</span><br><span class="line">                    <span class="type">int</span> prod = words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>();</span><br><span class="line">                    res = <span class="built_in">max</span>(res, prod);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="排序数组中两个数字之和-6"><a href="#排序数组中两个数字之和-6" class="headerlink" title="排序数组中两个数字之和[6]"></a>排序数组中两个数字之和[6]</h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个已按照 <strong>升序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p><p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 0 开始计数</strong> ，所以答案数组应当满足 <code>0 &lt;= answer[0] &lt; answer[1] &lt; numbers.length</code> 。</p><p>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numbers = [1,2,4,6,10], target = 8</span><br><span class="line">输出：[1,3]</span><br><span class="line">解释：2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numbers = [2,3,4], target = 6</span><br><span class="line">输出：[0,2]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numbers = [-1,0], target = -1</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= numbers.length &lt;= 3 * 104</code></li><li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li><li><code>numbers</code> 按 <strong>递增顺序</strong> 排列</li><li><code>-1000 &lt;= target &lt;= 1000</code></li><li>仅存在一个有效答案</li></ul><blockquote><p>注意：本题与主站 167 题相似（下标起点不同）：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p></blockquote><h5 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h5><p>双指针：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; numbers[i] + numbers[j] != target) {</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        res.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="数组中和为-0-的三个数-7"><a href="#数组中和为-0-的三个数-7" class="headerlink" title="数组中和为 0 的三个数[7]"></a>数组中和为 0 的三个数[7]</h4><h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a</code> ，<code>b</code> ，<code>c</code> <em>，</em>使得 <code>a + b + c = 0</code> ？请找出所有和为 <code>0</code> 且 <strong>不重复</strong> 的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><blockquote><p>注意：本题与主站 15 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p></blockquote><h5 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h5><p>枚举第一个数，然后用双指针确定另外两个数。注意去重：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) {</span><br><span class="line">            <span class="type">int</span> i = k + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) {</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) {</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[k], nums[i], nums[j]});</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) i++;</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) j--;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) {</span><br><span class="line">                    i++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    j--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="和大于等于-target-的最短子数组-8"><a href="#和大于等于-target-的最短子数组-8" class="headerlink" title="和大于等于 target 的最短子数组[8]"></a>和大于等于 target 的最短子数组[8]</h4><h5 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><p>提示：</p><ul><li><code>1 &lt;= target &lt;= 10^9</code></li><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>进阶：</p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><blockquote><p>注意：本题与主站 209 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p></blockquote><h5 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h5><p>同向双指针，注意边界条件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> minlen = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) {</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; sum &gt;= target) {</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minlen == INT_MAX? <span class="number">0</span>: minlen;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="乘积小于-K-的子数组-9"><a href="#乘积小于-K-的子数组-9" class="headerlink" title="乘积小于 K 的子数组[9]"></a>乘积小于 K 的子数组[9]</h4><h5 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> ，请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [10,5,2,6], k = 100</span><br><span class="line">输出: 8</span><br><span class="line">解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br><span class="line">需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3], k = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 10^6</code></li></ul><blockquote><p>注意：本题与主站 713 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">https://leetcode-cn.com/problems/subarray-product-less-than-k/</a></p></blockquote><h5 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h5><p>利用滑动窗口，我们能求出每个不同 <code>right</code> 结尾的合法子数组的个数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right;</span><br><span class="line">        <span class="type">long</span> mul = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) {</span><br><span class="line">            mul *= nums[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; mul &gt;= k) {</span><br><span class="line">                mul /= nums[left++];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            count += right &gt;= left? right - left + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="和为-k-的子数组-10"><a href="#和为-k-的子数组-10" class="headerlink" title="和为 k 的子数组[10]"></a>和为 k 的子数组[10]</h4><h5 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个正整数数组和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p><p><strong>示例 1 :</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2 :</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入:nums = [1,2,3], k = 3</span><br><span class="line">输出: 2</span><br></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-10^7 &lt;= k &lt;= 10^7</code></li></ul><blockquote><p>注意：本题与主站 560 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p></blockquote><h5 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h5><p>数组中既有正数又有负数，无法使用双指针。可以利用前缀和思想，快速判断子数组的和。前缀和思想。遍历数组求前缀和，把前缀和以及这个和出现的次数作为键值对存入哈希表中。</p><p>举例理解：数组的前 i 个数字之和记为 sum，如果存在一个 j（j &lt; i），数组的前 j 个数字之和为sum - k，那么数组中从第 j + 1个数字开始到第 i 个数字结束的子数组之和为 k。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) {</span><br><span class="line">            presum += nums[right];</span><br><span class="line">            count += mp[presum - k];</span><br><span class="line">            mp[presum]++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="0-和-1-个数相同的子数组-11"><a href="#0-和-1-个数相同的子数组-11" class="headerlink" title="0 和 1 个数相同的子数组[11]"></a>0 和 1 个数相同的子数组[11]</h4><h5 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li></ul><blockquote><p>注意：本题与主站 525 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contiguous-array/">https://leetcode-cn.com/problems/contiguous-array/</a></p></blockquote><h5 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h5><p>前缀和加哈希表，把 0 当作 -1 处理，题目变成求和为 0 的子数组：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            presum += nums[i] == <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(presum) != mp.<span class="built_in">end</span>())</span><br><span class="line">                maxlen = <span class="built_in">max</span>(maxlen, i - mp[presum]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mp[presum] = i;    </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="左右两边子数组的和相等-12"><a href="#左右两边子数组的和相等-12" class="headerlink" title="左右两边子数组的和相等[12]"></a>左右两边子数组的和相等[12]</h4><h5 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1,7,3,6,5,6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心下标。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [2, 1, -1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">中心下标是 0 。</span><br><span class="line">左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），</span><br><span class="line">右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><blockquote><p>注意：本题与主站 724 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-pivot-index/">https://leetcode-cn.com/problems/find-pivot-index/</a></p></blockquote><h5 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h5><p>用前缀和进行预处理，避免重复计算。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums)</span><br><span class="line">            sum += num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            total += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (total - nums[i] == sum - total)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="二维子矩阵的和-13"><a href="#二维子矩阵的和-13" class="headerlink" title="二维子矩阵的和[13]"></a>二维子矩阵的和[13]</h4><h5 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个二维矩阵 <code>matrix</code>，以下类型的多个请求：</p><ul><li>计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。</li></ul><p>实现 <code>NumMatrix</code> 类：</p><ul><li><code>NumMatrix(int[][] matrix)</code> 给定整数矩阵 <code>matrix</code> 进行初始化</li><li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> 返回左上角 <code>(row1, col1)</code> 、右下角 <code>(row2, col2)</code> 的子矩阵的元素总和。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626332422-wUpUHT-image.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">["NumMatrix","sumRegion","sumRegion","sumRegion"]</span><br><span class="line">[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]</span><br><span class="line">输出:</span><br><span class="line">[null, 8, 11, 12]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);</span><br><span class="line">numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)</span><br><span class="line">numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)</span><br><span class="line">numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-10^5 &lt;= matrix[i][j] &lt;= 10^5</code></li><li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li><li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li><li>最多调用 <code>10^4</code> 次 <code>sumRegion</code> 方法</li></ul><blockquote><p>注意：本题与主站 304 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">https://leetcode-cn.com/problems/range-sum-query-2d-immutable/</a></p></blockquote><h5 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h5><p>动态规划-二维前缀和。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628949136-zQFMmB-e740f25c4850f72eae2482bb42cfc36.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628949854-YEDxST-5424205ebc953c73cf8381aa53f7bc2.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; presum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) {</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">size</span>() || !matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        presum.<span class="built_in">resize</span>(matrix.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(matrix[<span class="number">0</span>].<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> rowsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j++) {</span><br><span class="line">                rowsum += matrix[i][j];</span><br><span class="line">                presum[i + <span class="number">1</span>][j + <span class="number">1</span>] = presum[i][j + <span class="number">1</span>] + rowsum;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> presum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - presum[row1][col2 + <span class="number">1</span>]</span><br><span class="line">                                          - presum[row2 + <span class="number">1</span>][col1]</span><br><span class="line">                                          + presum[row1][col1];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix* obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="字符串中的变位词-14"><a href="#字符串中的变位词-14" class="headerlink" title="字符串中的变位词[14]"></a>字符串中的变位词[14]</h4><h5 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的某个变位词。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s1 = "ab" s2 = "eidbaooo"</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 ("ba").</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s1= "ab" s2 = "eidboaoo"</span><br><span class="line">输出: False</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 104</code></li><li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li></ul><blockquote><p>注意：本题与主站 567 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">https://leetcode-cn.com/problems/permutation-in-string/</a></p></blockquote><h5 id="解法-13"><a href="#解法-13" class="headerlink" title="解法"></a>解法</h5><ol><li>记录 s1 的哈希数组</li><li>确定左右指针的初始位置，并将当前所夹的子数组的字符出现情况与 s1 的哈希表进行比较</li><li>同时右移左右指针，左指针右移导致 ‘c’ 不在所夹的子数组中，所以将比较后的哈希数组中 ‘c’ 对应的值加 1，右指针右移导致 ‘b’ 进入所夹的子数组中，所以将比较后的哈希数组中 ‘b’ 对应的值减 1</li><li>重复步骤 3，直至找到答案或者遍历完 s2 均未找到答案</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1628958996-hWmHxz-10139da0979df36b9067b22886a0890.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">zero</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[s1[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            hash[s2[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash == zero)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s1.<span class="built_in">size</span>(); i &lt; s2.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[s2[i] - <span class="string">'a'</span>]--;</span><br><span class="line">            hash[s2[i - s1.<span class="built_in">size</span>()] - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (hash == zero) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="字符串中的所有变位词-15"><a href="#字符串中的所有变位词-15" class="headerlink" title="字符串中的所有变位词[15]"></a>字符串中的所有变位词[15]</h4><h5 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>变位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>变位词</strong> 指字母相同，但排列不同的字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "cbaebabacd", p = "abc"</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。</span><br><span class="line">起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "abab", p = "ab"</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 "ab", 它是 "ab" 的变位词。</span><br><span class="line">起始索引等于 1 的子串是 "ba", 它是 "ab" 的变位词。</span><br><span class="line">起始索引等于 2 的子串是 "ab", 它是 "ab" 的变位词。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><blockquote><p>注意：本题与主站 438 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p></blockquote><h5 id="解法-14"><a href="#解法-14" class="headerlink" title="解法"></a>解法</h5><p>和上一题一样的思路，利用固定长度滑动窗口：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">zero</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[p[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            hash[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash == zero)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = p.<span class="built_in">size</span>(); i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">            hash[s[i - p.<span class="built_in">size</span>()] - <span class="string">'a'</span>]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hash == zero)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i - p.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        }    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="不含重复字符的最长子字符串-16"><a href="#不含重复字符的最长子字符串-16" class="headerlink" title="不含重复字符的最长子字符串[16]"></a>不含重复字符的最长子字符串[16]</h4><h5 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长连续子字符串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "abcabcbb"</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子字符串是 "abc"，所以其长度为 3。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "bbbbb"</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子字符串是 "b"，所以其长度为 1。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "pwwkew"</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = ""</span><br><span class="line">输出: 0</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><blockquote><p>注意：本题与主站 3 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p></blockquote><h5 id="解法-15"><a href="#解法-15" class="headerlink" title="解法"></a>解法</h5><p>因为 <code>s</code> 中可能会出现字母、数字、符号和空格，所以可以用哈希表表示窗口：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); right++) {</span><br><span class="line">            <span class="keyword">while</span> (hash.<span class="built_in">find</span>(s[right]) != hash.<span class="built_in">end</span>()) {</span><br><span class="line">                hash.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            hash.<span class="built_in">insert</span>(s[right]);</span><br><span class="line">            maxlen = <span class="built_in">max</span>(maxlen, right - left + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="含有所有字符的最短字符串-17"><a href="#含有所有字符的最短字符串-17" class="headerlink" title="含有所有字符的最短字符串[17]"></a>含有所有字符的最短字符串[17]</h4><h5 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个字符串 <code>s</code> 和 <code>t</code> 。返回 <code>s</code> 中包含 <code>t</code> 的所有字符的最短子字符串。如果 <code>s</code> 中不存在符合条件的子字符串，则返回空字符串 <code>""</code> 。</p><p>如果 <code>s</code> 中存在多个符合条件的子字符串，返回任意一个。</p><p><strong>注意：</strong> 对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "ADOBECODEBANC", t = "ABC"</span><br><span class="line">输出："BANC"</span><br><span class="line">解释：最短子字符串 "BANC" 包含了字符串 t 的所有字符 'A'、'B'、'C'</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "a", t = "a"</span><br><span class="line">输出："a"</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "a", t = "aa"</span><br><span class="line">输出：""</span><br><span class="line">解释：t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><blockquote><p>注意：本题与主站 76 题相似（本题答案不唯一）：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">https://leetcode-cn.com/problems/minimum-window-substring/</a></p></blockquote><h5 id="解法-16"><a href="#解法-16" class="headerlink" title="解法"></a>解法</h5><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="删除链表的倒数第-n-个结点-21"><a href="#删除链表的倒数第-n-个结点-21" class="headerlink" title="删除链表的倒数第 n 个结点[21]"></a>删除链表的倒数第 n 个结点[21]</h4><h5 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/remove_ex1-20211216181507546.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>能尝试使用一趟扫描实现吗？</p><blockquote><p>注意：本题与主站 19 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p></blockquote><h5 id="解法-17"><a href="#解法-17" class="headerlink" title="解法"></a>解法</h5><p>利用快慢指针和虚拟头节点。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p3.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        ListNode* p = dummy;</span><br><span class="line">        ListNode* q = head;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q) {</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="链表中环的入口节点-22"><a href="#链表中环的入口节点-22" class="headerlink" title="链表中环的入口节点[22]"></a>链表中环的入口节点[22]</h4><h5 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <code>next</code> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>示例 1：</strong></p><p>![](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/doocs/leetcode@main/lcof2/%E5%89%91%E6%8C%87">https://cdn.jsdelivr.net/gh/doocs/leetcode@main/lcof2/剑指</a> Offer II 022. 链表中环的入口节点/images/circularlinkedlist.png)</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p>![](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/doocs/leetcode@main/lcof2/%E5%89%91%E6%8C%87">https://cdn.jsdelivr.net/gh/doocs/leetcode@main/lcof2/剑指</a> Offer II 022. 链表中环的入口节点/images/circularlinkedlist_test2.png)</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p>![](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/doocs/leetcode@main/lcof2/%E5%89%91%E6%8C%87">https://cdn.jsdelivr.net/gh/doocs/leetcode@main/lcof2/剑指</a> Offer II 022. 链表中环的入口节点/images/circularlinkedlist_test3.png)</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>是否可以使用 <code>O(1)</code> 空间解决此题？</p><blockquote><p>注意：本题与主站 142 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p></blockquote><h5 id="解法-18"><a href="#解法-18" class="headerlink" title="解法"></a>解法</h5><p>先利用快慢指针判断链表是否有环，没有环则直接返回 <code>null</code>。</p><p>若链表有环，我们分析快慢相遇时走过的距离：<br>$$<br>a + n(b + c) + b = a + (n + 1)b + c \\<br>a + (n + 1)b + c = 2(a + b) \to a = c + (n - 1)(b + c)<br>$$<br><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/jianzhi_II_022_fig1.png"></p><p>我们会发现：从相遇点到入环点的距离加上 $n-1$ 圈的环长，恰好等于从链表头部到入环点的距离。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) {</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="两个链表的第一个重合节点-23"><a href="#两个链表的第一个重合节点-23" class="headerlink" title="两个链表的第一个重合节点[23]"></a>两个链表的第一个重合节点[23]</h4><h5 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_statement-20211217215753375.png"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_1-20211217215741037.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at '8'</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_2-20211217215712485.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at '2'</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/160_example_3-20211217215658254.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p><strong>进阶：</strong>能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><blockquote><p>注意：本题与主站 160 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p></blockquote><h5 id="解法-19"><a href="#解法-19" class="headerlink" title="解法"></a>解法</h5><p>使用<strong>双指针</strong>，细想就会发现很简单很巧妙。</p><p>A 和 B 两个链表长度可能不同，但是 A + B 和 B + A 的长度是相同的，所以遍历 A + B 和遍历 B + A 一定是同时结束：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123481-fdeApj-image-20211218222217465.png"></p><ul><li><p>如果 A、B 相交的话 A 和 B 有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123467-zeofGx-image-20211218222141874.png"></p></li><li><p>如果 A、B 不相交的话两个指针就会同时到达 A + B（B + A）的尾节点（然后同时变成<code>nullptr</code>）</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1635123497-pwIiFq-image.png"></p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        ListNode* pa = headA;</span><br><span class="line">        ListNode* pb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pa != pb) {</span><br><span class="line">            pa = pa? pa-&gt;next: headB;</span><br><span class="line">            pb = pb? pb-&gt;next: headA;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="反转链表-24"><a href="#反转链表-24" class="headerlink" title="反转链表[24]"></a>反转链表[24]</h4><h5 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p><p><strong>示例 1：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev1ex1-20211218223412424.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/rev1ex2-20211218223406816.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><blockquote><p>注意：本题与主站 206 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p></blockquote><h5 id="解法-20"><a href="#解法-20" class="headerlink" title="解法"></a>解法</h5><p>直接背诵了，可以看到几个等式成一个环状收尾相连：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">succ--cur-&gt;next--pre--cur--succ</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* succ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            succ = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = succ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="链表中的两数相加-25"><a href="#链表中的两数相加-25" class="headerlink" title="链表中的两数相加[25]"></a>链表中的两数相加[25]</h4><h5 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个 <strong>非空链表</strong> <code>l1</code>和 <code>l2</code> 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>示例1：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626420025-fZfzMX-image-20211218224204036.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,8,0,7]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[8,0,7]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表的长度范围为<code>[1, 100]</code></li><li><code>0 &lt;= node.val &lt;= 9</code></li><li>输入数据保证链表代表的数字无前导 0</li></ul><p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p><blockquote><p>注意：本题与主站 445 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">https://leetcode-cn.com/problems/add-two-numbers-ii/</a></p></blockquote><h5 id="解法-21"><a href="#解法-21" class="headerlink" title="解法"></a>解法</h5><ul><li>对链表进行翻转</li><li>设置一个空节点 <code>dummy</code>，也就是末尾节点，和一个进位数 <code>carry</code></li><li>遍历链表 <code>l1</code>、<code>l2</code>，条件是链表1，2不为空和进位数大于 0</li><li>求出当前位数，生成节点</li><li>对当前节点的 <code>next</code> 指向上一个节点（逆序）和求进位到下一个的数</li><li>三目运算符对链表进行下一个指向判断</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        l1 = <span class="built_in">reverse</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverse</span>(l2);</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* l = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) {</span><br><span class="line">            <span class="type">int</span> sum = (l1? l1-&gt;val: <span class="number">0</span>) + (l2? l2-&gt;val: <span class="number">0</span>) + carry;</span><br><span class="line">            carry = sum &gt;= <span class="number">10</span>? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">            sum = sum &gt;= <span class="number">10</span>? sum - <span class="number">10</span>: sum;</span><br><span class="line">            </span><br><span class="line">            l-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            </span><br><span class="line">            l1 = l1? l1-&gt;next: <span class="literal">nullptr</span>;</span><br><span class="line">            l2 = l2? l2-&gt;next: <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            l-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(dummy-&gt;next);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* succ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            succ = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = succ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="重排链表-26"><a href="#重排链表-26" class="headerlink" title="重排链表[26]"></a>重排链表[26]</h4><h5 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><p><code>L0 → L1 → … → Ln-1 → Ln</code></p><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</span><br></pre></td></tr></tbody></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626420320-YUiulT-image.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: head = [1,2,3,4]</span><br><span class="line">输出: [1,4,2,3]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626420320-YUiulT-image.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: head = [1,2,3,4,5]</span><br><span class="line">输出: [1,5,2,4,3]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表的长度范围为 <code>[1, 5 * 104]</code></li><li><code>1 &lt;= node.val &lt;= 1000</code></li></ul><blockquote><p>注意：本题与主站 143 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">https://leetcode-cn.com/problems/reorder-list/</a></p></blockquote><h5 id="解法-22"><a href="#解法-22" class="headerlink" title="解法"></a>解法</h5><p>相当于这 3 道问题，只需要 5 行代码将它们组合：</p><ul><li>[链表的中间结点](<a target="_blank" rel="noopener" href="https://doocs.github.io/leetcode/#/solution/0800-0899/0876.Middle">https://doocs.github.io/leetcode/#/solution/0800-0899/0876.Middle</a> of the Linked List/README)</li><li>[反转链表](<a target="_blank" rel="noopener" href="https://doocs.github.io/leetcode/#/solution/0200-0299/0206.Reverse">https://doocs.github.io/leetcode/#/solution/0200-0299/0206.Reverse</a> Linked List/README)</li><li>合并两个链表</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummy;</span><br><span class="line">        ListNode* fast = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) {</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummy-&gt;next;</span><br><span class="line">        ListNode* mid = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        mid = <span class="built_in">reverseList</span>(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mid) {</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = mid;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* succ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            succ = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = succ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="回文链表-27"><a href="#回文链表-27" class="headerlink" title="回文链表[27]"></a>回文链表[27]</h4><h5 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个链表的 <strong>头节点</strong> <code>head</code> <strong>，</strong>请判断其是否为回文链表。</p><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p><p><strong>示例 1：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626421737-LjXceN-image-20211220162328016.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: head = [1,2,3,3,2,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1626422231-wgvnWh-image-20211220162344045.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: head = [1,2]</span><br><span class="line">输出: fasle</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表 L 的长度范围为 <code>[1, 10^5]</code></li><li><code>0 &lt;= node.val &lt;= 9</code></li></ul><p><strong>进阶：</strong>能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><blockquote><p>注意：本题与主站 234 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p></blockquote><h5 id="解法-23"><a href="#解法-23" class="headerlink" title="解法"></a>解法</h5><p>先用快慢指针找到链表的中点，接着反转右半部分的链表。然后同时遍历前后两段链表，若前后两段链表节点对应的值不等，说明不是回文链表，否则说明是回文链表。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummy;</span><br><span class="line">        ListNode* fast = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) {</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ListNode* cur = dummy-&gt;next;</span><br><span class="line">        ListNode* mid = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        mid = <span class="built_in">reverseList</span>(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mid) {</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val != mid-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            mid = mid-&gt;next;    </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* succ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            succ = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = succ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="展平多级双向链表-28"><a href="#展平多级双向链表-28" class="headerlink" title="展平多级双向链表[28]"></a>展平多级双向链表[28]</h4><h5 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h5><p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p><p>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">输出：[1,2,3,7,8,11,12,9,10,4,5,6]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,null,3]</span><br><span class="line">输出：[1,3,2]</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">输入的多级列表如下图所示：</span><br><span class="line"></span><br><span class="line">  1---2---NULL</span><br><span class="line">  |</span><br><span class="line">  3---NULL</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>如何表示测试用例中的多级链表？</strong></p><p>以 <strong>示例 1</strong> 为例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1---2---3---4---5---6--NULL</span><br><span class="line">        |</span><br><span class="line">        7---8---9---10--NULL</span><br><span class="line">            |</span><br><span class="line">            11--12--NULL</span><br></pre></td></tr></tbody></table></figure><p>序列化其中的每一级之后：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[7,8,9,10,null]</span><br><span class="line">[11,12,null]</span><br></pre></td></tr></tbody></table></figure><p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[null,null,7,8,9,10,null]</span><br><span class="line">[null,11,12,null]</span><br></pre></td></tr></tbody></table></figure><p>合并所有序列化结果，并去除末尾的 null 。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>节点数目不超过 <code>1000</code></li><li><code>1 &lt;= Node.val &lt;= 10^5</code></li></ul><blockquote><p>注意：本题与主站 430 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/</a></p></blockquote><h5 id="解法-24"><a href="#解法-24" class="headerlink" title="解法"></a>解法</h5><p>仔细观察一下这个结构，不难发现其实就是前序遍历二叉树：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1-20211220192101041.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>{</span><br><span class="line">        <span class="built_in">flattenGetTail</span>(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">flattenGetTail</span><span class="params">(Node* head)</span> </span>{</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        Node* tail = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            Node* next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;child) {</span><br><span class="line">                Node* child = cur-&gt;child;</span><br><span class="line">                Node* childTail = <span class="built_in">flattenGetTail</span>(cur-&gt;child);</span><br><span class="line"></span><br><span class="line">                cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                cur-&gt;next = child;</span><br><span class="line">                child-&gt;prev = cur;</span><br><span class="line">                childTail-&gt;next = next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next)</span><br><span class="line">                    next-&gt;prev = childTail;</span><br><span class="line">                tail = childTail;</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                tail = cur;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            cur = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="排序的循环链表-29"><a href="#排序的循环链表-29" class="headerlink" title="排序的循环链表[29]"></a>排序的循环链表[29]</h4><h5 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定循环升序列表中的一个点，写一个函数向这个列表中插入一个新元素 <code>insertVal</code> ，使这个列表仍然是循环升序的。</p><p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p><p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p><p>如果列表为空（给定的节点是 <code>null</code>），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p><p><strong>示例 1：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/example_1_before_65p.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [3,4,1], insertVal = 2</span><br><span class="line">输出：[3,4,1,2]</span><br><span class="line">解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/example_1_after_65p.jpg"></p><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [], insertVal = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1], insertVal = 0</span><br><span class="line">输出：[1,0]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= Number of Nodes &lt;= 5 * 10^4</code></li><li><code>-10^6 &lt;= Node.val &lt;= 10^6</code></li><li><code>-10^6 &lt;= insertVal &lt;= 10^6</code></li></ul><blockquote><p>注意：本题与主站 708 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/">https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/</a></p></blockquote><h5 id="解法-25"><a href="#解法-25" class="headerlink" title="解法"></a>解法</h5><ol><li>头节点如果为空或仅为一个，直接返回 <code>head</code>或连成环</li><li>如果 <code>insertVal</code> 在链表的最小值和最大值之间，找到合适的位置插入</li><li>如果 <code>insertVal</code> 小于链表的最小值或大于链表的最大值，则在头节点和尾节点之间插入</li></ol><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="type">int</span> insertVal)</span> </span>{</span><br><span class="line">        Node* insert = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) {</span><br><span class="line">            head = insert;</span><br><span class="line">            head-&gt;next = head;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) {</span><br><span class="line">            head-&gt;next = insert;</span><br><span class="line">            insert-&gt;next = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">insertCore</span>(head, insert);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertCore</span><span class="params">(Node* head, Node* insert)</span> </span>{</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        Node* maxNode = head;</span><br><span class="line">        Node* next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!(cur-&gt;val &lt;= insert-&gt;val &amp;&amp; insert-&gt;val &lt;= next-&gt;val) &amp;&amp; next != head) {</span><br><span class="line">            cur = next;</span><br><span class="line">            next = next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt;= maxNode-&gt;val)</span><br><span class="line">                maxNode = cur;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt;= insert-&gt;val &amp;&amp; insert-&gt;val &lt;= next-&gt;val) {</span><br><span class="line">            insert-&gt;next = next;</span><br><span class="line">            cur-&gt;next = insert;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            insert-&gt;next = maxNode-&gt;next;</span><br><span class="line">            maxNode-&gt;next = insert;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="插入、删除和随机访问都是-O-1-的容器-30"><a href="#插入、删除和随机访问都是-O-1-的容器-30" class="headerlink" title="插入、删除和随机访问都是 O(1) 的容器[30]"></a>插入、删除和随机访问都是 O(1) 的容器[30]</h4><h5 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h5><p>设计一个支持在<em>平均</em> 时间复杂度 <strong>O(1)</strong> 下，执行以下操作的数据结构：</p><ul><li><code>insert(val)</code>：当元素 <code>val</code> 不存在时返回 <code>true</code> ，并向集合中插入该项，否则返回 <code>false</code> 。</li><li><code>remove(val)</code>：当元素 <code>val</code> 存在时返回 <code>true</code> ，并从集合中移除该项，否则f返回 <code>true</code> 。</li><li><code>getRandom</code>：随机返回现有集合中的一项。每个元素应该有 <strong>相同的概率</strong> 被返回。</li></ul><p><strong>示例 :</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: inputs = ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出: [null, true, false, true, 2, true, false, 2]</span><br><span class="line">解释:</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();  // 初始化一个空的集合</span><br><span class="line">randomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入</span><br><span class="line"></span><br><span class="line">randomSet.remove(2); // 返回 false，表示集合中不存在 2</span><br><span class="line"></span><br><span class="line">randomSet.insert(2); // 向集合中插入 2 返回 true ，集合现在包含 [1,2]</span><br><span class="line"></span><br><span class="line">randomSet.getRandom(); // getRandom 应随机返回 1 或 2</span><br><span class="line"></span><br><span class="line">randomSet.remove(1); // 从集合中移除 1 返回 true 。集合现在包含 [2]</span><br><span class="line"></span><br><span class="line">randomSet.insert(2); // 2 已在集合中，所以返回 false</span><br><span class="line"></span><br><span class="line">randomSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>-2^31 &lt;= val &lt;= 2^31 - 1</code></li><li>最多进行<code>2 * 10^5</code> 次 <code>insert</code> ， <code>remove</code> 和 <code>getRandom</code> 方法调用</li><li>当调用 <code>getRandom</code> 方法时，集合中至少有一个元素</li></ul><blockquote><p>注意：本题与主站 380 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">https://leetcode-cn.com/problems/insert-delete-getrandom-o1/</a></p></blockquote><h5 id="解法-26"><a href="#解法-26" class="headerlink" title="解法"></a>解法</h5><p>由于题目要求删除和插入的时间复杂度为 O(1)，能够满足要求的只有哈希表，显然此处需要使用哈希表。</p><p>但是使用哈希表无法等概率返回其中的每个数值。若这些数值是保存在数组内，则可以轻松解决。但若只使用数组，那么删除和插入一个值时，都需遍历一遍数组找到数值对应的下标，则会使时间复杂度为 O(n)。</p><p>故可将哈希表和数组结合，数组内存数值实现 <code>getRandom</code>，哈希内存数值和下标的映射实现 <code>insert</code> 和 <code>remove</code> 的索引查找的时间复杂度为 O(1)，之后在数组内操作数值的插入和删除。具体来看操作就是：</p><ol><li><strong>插入</strong></li></ol><p>每次添加新数值时，先使用哈希表判断该数值是否存在，存在则直接返回 false。不存在则进行插入操作，只要将该数值添加到数组尾部即可，并将该数值和其下标的映射存入哈希表。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png.png"></p><ol start="2"><li><strong>删除</strong></li></ol><p>删除同样需使用哈希表判断是否存在，若不存在则返回 false。存在则进行删除操作，在哈希表中删除时间复杂度为 O(1)，但是在数值中删除比较麻烦。若只是直接删除，则为了保证数组内存连续性需将删除数值后面的数值均前移一位，时间复杂度为 O(n)。比较好的处理方式是，用数组的最后一个数值去填充需要删除的数值的内存，其他数值在数组中的位置保持不变，并将这个拿来填充的数值的下标更新即可，最后只要删除数组最后一个数值，同样可以保证时间复杂度为 O(1)。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/format,png-20211221123721524.png"></p><ol start="3"><li><strong>随机返回</strong></li></ol><p>只要随机生成数组下标范围内一个随机下标值，返回该数组下标内的数值即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> {</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        mp[val] = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> removeIndex = mp[val];</span><br><span class="line">        nums[removeIndex] = nums.<span class="built_in">back</span>();</span><br><span class="line">        mp[nums.<span class="built_in">back</span>()] = removeIndex;</span><br><span class="line">        </span><br><span class="line">        mp.<span class="built_in">erase</span>(val);</span><br><span class="line">        nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">rand</span>() % nums.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet* obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="未解决-最近最少使用缓存-31"><a href="#未解决-最近最少使用缓存-31" class="headerlink" title="[未解决]最近最少使用缓存[31]"></a>[未解决]最近最少使用缓存[31]</h4><h4 id="有效的变位词-32"><a href="#有效的变位词-32" class="headerlink" title="有效的变位词[32]"></a>有效的变位词[32]</h4><h5 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断它们是不是一组变位词（字母异位词）。</p><p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同且<strong>字符顺序不完全相同</strong>，则称 <code>*s*</code> 和 <code>*t*</code> 互为变位词（字母异位词）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "anagram", t = "nagaram"</span><br><span class="line">输出: true</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "rat", t = "car"</span><br><span class="line">输出: false</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = "a", t = "a"</span><br><span class="line">输出: false</span><br></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> and <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><blockquote><p>注意：本题与主站 242 题相似（字母异位词定义不同）：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p></blockquote><h5 id="解法-27"><a href="#解法-27" class="headerlink" title="解法"></a>解法</h5><p>数组或哈希表累加 s 中每个字符出现的次数，再减去 t 中对应的每个字符出现的次数。遍历结束后，若字符中出现次数不为 0 的情况，返回 false，否则返回 true。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>() || s == t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">zero</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            hash[t[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            hash[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash == zero)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="变位词组-33"><a href="#变位词组-33" class="headerlink" title="变位词组[33]"></a>变位词组[33]</h4><h5 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个字符串数组 <code>strs</code> ，将 <strong>变位词</strong> 组合在一起。 可以按任意顺序返回结果列表。</p><p><strong>注意：</strong>若两个字符串中每个字符出现的次数都相同且<strong>字符顺序不完全相同</strong>，则称它们互为变位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]</span><br><span class="line">输出: [["bat"],["nat","tan"],["ate","eat","tea"]]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: strs = [""]</span><br><span class="line">输出: [[""]]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: strs = ["a"]</span><br><span class="line">输出: [["a"]]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 10^4</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><blockquote><p>注意：本题与主站 49 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">https://leetcode-cn.com/problems/group-anagrams/</a></p></blockquote><h5 id="解法-28"><a href="#解法-28" class="headerlink" title="解法"></a>解法</h5><p>遍历字符串，将每个字符串按照字符字典序排序后得到一个新的字符串，将相同的新字符串放在哈希表的同一个 key 对应 value 列表中。</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td><code>"aet"</code></td><td><code>["eat", "tea", "ate"]</code></td></tr><tr><td><code>"ant"</code></td><td><code>["tan", "nat"]</code></td></tr><tr><td><code>"abt"</code></td><td><code>["bat"]</code></td></tr></tbody></table><p>最后返回哈希表的 value 列表即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) {</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; <span class="built_in">hash</span>(strs.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs) {</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            hash[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = hash.<span class="built_in">begin</span>(); it != hash.<span class="built_in">end</span>(); it++) {</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="外星语言是否排序-34"><a href="#外星语言是否排序-34" class="headerlink" title="外星语言是否排序[34]"></a>外星语言是否排序[34]</h4><h5 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h5><p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p><p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"</span><br><span class="line">输出：true</span><br><span class="line">解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"</span><br><span class="line">输出：false</span><br><span class="line">解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"</span><br><span class="line">输出：false</span><br><span class="line">解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" &gt; "app"，因为 'l' &gt; '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 20</code></li><li><code>order.length == 26</code></li><li>在 <code>words[i]</code> 和 <code>order</code> 中的所有字符都是英文小写字母。</li></ul><blockquote><p>注意：本题与主站 953 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/verifying-an-alien-dictionary/">https://leetcode-cn.com/problems/verifying-an-alien-dictionary/</a></p></blockquote><h5 id="解法-29"><a href="#解法-29" class="headerlink" title="解法"></a>解法</h5><p>用数组或哈希表存放字母顺序。依次遍历单词列表，检测相邻两单词是否满足字典序。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAlienSorted</span><span class="params">(vector&lt;string&gt;&amp; words, string order)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>() - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isOrdered</span>(words[i], words[i + <span class="number">1</span>], order))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isOrdered</span><span class="params">(string word1, string word2, string order)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) {</span><br><span class="line">            hash[order[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>() &amp;&amp; i &lt; word2.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">char</span> ch1 = word1[i];</span><br><span class="line">            <span class="type">char</span> ch2 = word2[i];</span><br><span class="line">            <span class="keyword">if</span> (hash[ch1 - <span class="string">'a'</span>] &lt; hash[ch2 - <span class="string">'a'</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (hash[ch1 - <span class="string">'a'</span>] &gt; hash[ch2 - <span class="string">'a'</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i == word1.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="最小时间差-35"><a href="#最小时间差-35" class="headerlink" title="最小时间差[35]"></a>最小时间差[35]</h4><h5 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：timePoints = ["23:59","00:00"]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：timePoints = ["00:00","23:59","00:00"]</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= timePoints &lt;= 2 * 10^4</code></li><li><code>timePoints[i]</code> 格式为 <strong>“HH:MM”</strong></li></ul><blockquote><p>注意：本题与主站 539 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-time-difference/">https://leetcode-cn.com/problems/minimum-time-difference/</a></p></blockquote><h5 id="解法-30"><a href="#解法-30" class="headerlink" title="解法"></a>解法</h5><p>首先，遍历时间列表，将其转换为“分钟制”列表 <code>mins</code>，比如，对于时间点 <code>13:14</code>，将其转换为 <code>13 * 60 + 14</code>。</p><p>接着将“分钟制”列表按升序排列，然后将此列表的最小时间 <code>mins[0]</code> 加上 <code>24 * 60</code> 追加至列表尾部，用于处理最大值、最小值的差值这种特殊情况。</p><p>最后遍历“分钟制”列表，找出相邻两个时间的最小值即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt;&amp; timePoints)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (timePoints.<span class="built_in">size</span>() &gt; <span class="number">24</span> * <span class="number">60</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mins;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t: timePoints)</span><br><span class="line">            mins.<span class="built_in">emplace_back</span>(<span class="built_in">stoi</span>(t.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>)) * <span class="number">60</span></span><br><span class="line">                            + <span class="built_in">stoi</span>(t.<span class="built_in">substr</span>(<span class="number">3</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(mins.<span class="built_in">begin</span>(), mins.<span class="built_in">end</span>());</span><br><span class="line">        mins.<span class="built_in">emplace_back</span>(mins[<span class="number">0</span>] + <span class="number">24</span> * <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; mins.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res = <span class="built_in">min</span>(res, mins[i] - mins[i - <span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="后缀表达式-36"><a href="#后缀表达式-36" class="headerlink" title="后缀表达式[36]"></a>后缀表达式[36]</h4><h5 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h5><p>根据<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求该后缀表达式的计算结果。</p><p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：tokens = ["2","1","+","3","*"]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：tokens = ["4","13","5","/","+"]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]</span><br><span class="line">输出：22</span><br><span class="line">解释：</span><br><span class="line">该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 要么是一个算符（<code>"+"</code>、<code>"-"</code>、<code>"*"</code> 或 <code>"/"</code>），要么是一个在范围 <code>[-200, 200]</code> 内的整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ul><blockquote><p>注意：本题与主站 150 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p></blockquote><h5 id="解法-31"><a href="#解法-31" class="headerlink" title="解法"></a>解法</h5><p>利用栈存储运算数，每次遇到符号，对栈顶两个元素进行运算。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>{</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (string&amp; t: tokens) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isNumber</span>(t)) {</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(t));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">int</span> a = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">                    s.<span class="built_in">push</span>(a + b);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">                    s.<span class="built_in">push</span>(b - a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'*'</span>)</span><br><span class="line">                    s.<span class="built_in">push</span>(a * b);</span><br><span class="line">                <span class="keyword">else</span>            </span><br><span class="line">                    s.<span class="built_in">push</span>(b / a);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span> || (s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;=<span class="string">'9'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="小行星碰撞-37"><a href="#小行星碰撞-37" class="headerlink" title="小行星碰撞[37]"></a>小行星碰撞[37]</h4><h5 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。</p><p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p><p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：asteroids = [5,10,-5]</span><br><span class="line">输出：[5,10]</span><br><span class="line">解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：asteroids = [8,-8]</span><br><span class="line">输出：[]</span><br><span class="line">解释：8 和 -8 碰撞后，两者都发生爆炸。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：asteroids = [10,2,-5]</span><br><span class="line">输出：[10]</span><br><span class="line">解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：asteroids = [-2,-1,1,2]</span><br><span class="line">输出：[-2,-1,1,2]</span><br><span class="line">解释：-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 </span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= asteroids.length &lt;= 10^4</code></li><li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li><li><code>asteroids[i] != 0</code></li></ul><blockquote><p>注意：本题与主站 735 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/asteroid-collision/">https://leetcode-cn.com/problems/asteroid-collision/</a></p></blockquote><h5 id="解法-32"><a href="#解法-32" class="headerlink" title="解法"></a>解法</h5><p>可以类比成左右括号匹配：</p><ul><li>向右移动的小行星（左括号）：不会引发碰撞，直接入栈</li><li>向左移动的小行星（右括号）：可能会和之前向右移动的小行星发生碰撞，特殊处理</li></ul><p>因为答案需要碰撞后剩下的所有小行星，相当于栈里最后剩下的元素，所以可以直接用数组表示栈。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629345113-XXdGKZ-f1dbb5feb6708bc5ec400d978eea73a.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">asteroidCollision</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; asteroids)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a: asteroids) {</span><br><span class="line">            <span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(a);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">while</span> (!res.<span class="built_in">empty</span>() &amp;&amp; res.<span class="built_in">back</span>() &gt; <span class="number">0</span> &amp;&amp; res.<span class="built_in">back</span>() &lt; -a)</span><br><span class="line">                    res.<span class="built_in">pop_back</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() &amp;&amp; res.<span class="built_in">back</span>() == -a)</span><br><span class="line">                    res.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="built_in">empty</span>() || res.<span class="built_in">back</span>() &lt; -a)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(a);    </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="每日温度-38"><a href="#每日温度-38" class="headerlink" title="每日温度[38]"></a>每日温度[38]</h4><h5 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h5><p>请根据每日 <code>气温</code> 列表 <code>temperatures</code> ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 10^5</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><blockquote><p>注意：本题与主站 739 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">https://leetcode-cn.com/problems/daily-temperatures/</a></p></blockquote><h5 id="解法-33"><a href="#解法-33" class="headerlink" title="解法"></a>解法</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/a24107cefeff7239068268099db90671254c2d357857232f19dc21bdaace5774-image.png"></p><ul><li>如果当前元素比栈顶大，则让小项逐个出栈，直到当前元素比栈顶小，停止出栈</li><li>此时的栈顶元素就是当前项右边的第一个比自己大的元素索引，计算距离</li><li>当前项入栈</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>{</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = temperatures.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt;= temperatures[s.<span class="built_in">top</span>()])</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i] = s.<span class="built_in">top</span>() - i;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="直方图最大矩形面积-39"><a href="#直方图最大矩形面积-39" class="headerlink" title="直方图最大矩形面积[39]"></a>直方图最大矩形面积[39]</h4><h5 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定非负整数数组 <code>heights</code> ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/histogram-20211225222544405.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/histogram-1-20211225222538918.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=10^5</code></li><li><code>0 &lt;= heights[i] &lt;= 10^4</code></li></ul><blockquote><p>注意：本题与主站 84 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p></blockquote><h5 id="解法-34"><a href="#解法-34" class="headerlink" title="解法"></a>解法</h5><p>我们可以遍历每根柱子，以当前柱子 i 的高度作为矩形的高，那么矩形的宽度边界即为向左找到第一个高度小于当前柱体 i 的柱体，向右找到第一个高度小于当前柱体 i 的柱体。</p><p>对于每个柱子我们都如上计算一遍以当前柱子作为高的矩形面积，最终比较出最大的矩形面积即可。</p><p>我们遍历每个柱体，若当前的柱体高度大于等于栈顶柱体的高度，就直接将当前柱体入栈，否则若当前的柱体高度小于栈顶柱体的高度，说明当前栈顶柱体找到了右边的第一个小于自身的柱体，那么就可以将栈顶柱体出栈来计算以其为高的矩形的面积了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>{</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = temperatures.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt;= temperatures[s.<span class="built_in">top</span>()])</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i] = s.<span class="built_in">top</span>() - i;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="未解决-矩阵中最大的矩形-40"><a href="#未解决-矩阵中最大的矩形-40" class="headerlink" title="[未解决]矩阵中最大的矩形[40]"></a>[未解决]矩阵中最大的矩形[40]</h4><h5 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>matrix</code> ，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>注意：</strong>此题 <code>matrix</code> 输入格式为一维 <code>01</code> 字符串数组。</p><p><strong>示例 1：</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/maximal.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：matrix = ["10100","10111","11111","10010"]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：matrix = []</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：matrix = ["0"]</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：matrix = ["1"]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：matrix = ["00"]</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>0 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li></ul><blockquote><p>注意：本题与主站 85 题相同（输入参数格式不同）： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-rectangle/">https://leetcode-cn.com/problems/maximal-rectangle/</a></p></blockquote><h5 id="解法-35"><a href="#解法-35" class="headerlink" title="解法"></a>解法</h5><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="滑动窗口的平均值-41"><a href="#滑动窗口的平均值-41" class="headerlink" title="滑动窗口的平均值[41]"></a>滑动窗口的平均值[41]</h4><h5 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。</p><p>实现 <code>MovingAverage</code> 类：</p><ul><li><code>MovingAverage(int size)</code> 用窗口大小 <code>size</code> 初始化对象。</li><li><code>double next(int val)</code> 成员函数 <code>next</code> 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 <code>size</code> 个值的移动平均值，即滑动窗口里所有数字的平均值。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">inputs = ["MovingAverage", "next", "next", "next", "next"]</span><br><span class="line">inputs = [[3], [1], [10], [3], [5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1.0, 5.5, 4.66667, 6.0]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MovingAverage movingAverage = new MovingAverage(3);</span><br><span class="line">movingAverage.next(1); // 返回 1.0 = 1 / 1</span><br><span class="line">movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2</span><br><span class="line">movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3</span><br><span class="line">movingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= size &lt;= 1000</code></li><li><code>-10^5 &lt;= val &lt;= 10^5</code></li><li>最多调用 <code>next</code> 方法 <code>10^4</code> 次</li></ul><blockquote><p>注意：本题与主站 346 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/moving-average-from-data-stream/">https://leetcode-cn.com/problems/moving-average-from-data-stream/</a></p></blockquote><h5 id="解法-36"><a href="#解法-36" class="headerlink" title="解法"></a>解法</h5><p>“循环数组/队列”实现。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MovingAverage</span> {</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MovingAverage</span>(<span class="type">int</span> size) {</span><br><span class="line">        capacity = size;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">next</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        sum += val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; capacity) {</span><br><span class="line">            sum -= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">double</span>(sum)/ q.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage* obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj-&gt;next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="最近请求次数-42"><a href="#最近请求次数-42" class="headerlink" title="最近请求次数[42]"></a>最近请求次数[42]</h4><h5 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h5><p>写一个 <code>RecentCounter</code> 类来计算特定时间范围内最近的请求。</p><p>请实现 <code>RecentCounter</code> 类：</p><ul><li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li><li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li></ul><p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">inputs = ["RecentCounter", "ping", "ping", "ping", "ping"]</span><br><span class="line">inputs = [[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">RecentCounter recentCounter = new RecentCounter();</span><br><span class="line">recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1</span><br><span class="line">recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2</span><br><span class="line">recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3</span><br><span class="line">recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= t &lt;= 10^9</code></li><li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li><li>至多调用 <code>ping</code> 方法 <code>10^4</code> 次</li></ul><blockquote><p>注意：本题与主站 933 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-recent-calls/">https://leetcode-cn.com/problems/number-of-recent-calls/</a></p></blockquote><h5 id="解法-37"><a href="#解法-37" class="headerlink" title="解法"></a>解法</h5><p>在第 1、100、3001、3002 这四个时间点分别进行了 ping 请求， 在 3001 秒的时候， 它前面的 3000 秒指的是区间 <code>[1,3001]</code>， 所以一共是有 <code>1、100、3001</code> 三个请求， t = 3002 的前 3000 秒指的是区间 <code>[2,3002]</code>, 所以有 <code>100、3001、3002</code> 三次请求。</p><p>可以用队列实现。每次将 t 进入队尾，同时从队头开始依次移除小于 <code>t-3000</code> 的元素。然后返回队列的大小 <code>q.size()</code> 即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> {</span><br><span class="line">    queue&lt;<span class="type">long</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RecentCounter</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ping</span><span class="params">(<span class="type">int</span> t)</span> </span>{</span><br><span class="line">        q.<span class="built_in">push</span>(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">front</span>() + <span class="number">3000</span> &lt; t) {</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="往完全二叉树添加节点-43"><a href="#往完全二叉树添加节点-43" class="headerlink" title="往完全二叉树添加节点[43]"></a>往完全二叉树添加节点[43]</h4><h5 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h5><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 <code>n</code> 层有 <code>2n-1</code> 个节点）的，并且所有的节点都尽可能地集中在左侧。</p><p>设计一个用完全二叉树初始化的数据结构 <code>CBTInserter</code>，它支持以下几种操作：</p><ul><li><code>CBTInserter(TreeNode root)</code> 使用根节点为 <code>root</code> 的给定树初始化该数据结构；</li><li><code>CBTInserter.insert(int v)</code> 向树中插入一个新节点，节点类型为 <code>TreeNode</code>，值为 <code>v</code> 。使树保持完全二叉树的状态，<strong>并返回插入的新节点的父节点的值</strong>；</li><li><code>CBTInserter.get_root()</code> 将返回树的根节点。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]]</span><br><span class="line">输出：[null,1,[1,2]]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]</span><br><span class="line">输出：[null,3,4,[1,2,3,4,5,6,7,8]]</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>最初给定的树是完全二叉树，且包含 <code>1</code> 到 <code>1000</code> 个节点。</li><li>每个测试用例最多调用 <code>CBTInserter.insert</code> 操作 <code>10000</code> 次。</li><li>给定节点或插入节点的每个值都在 <code>0</code> 到 <code>5000</code> 之间。</li></ul><blockquote><p>注意：本题与主站 919 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/complete-binary-tree-inserter/">https://leetcode-cn.com/problems/complete-binary-tree-inserter/</a></p></blockquote><h5 id="解法-38"><a href="#解法-38" class="headerlink" title="解法"></a>解法</h5><p>完全二叉树只有最后一层是不满的，通过层序遍历就能找到应该插入的节点位置的父节点，然后将新节点插到该父节点下面即可。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629473154-gKRqvU-ce27c552f3c1d653d97978cf52b4b0d.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBTInserter</span> {</span><br><span class="line">    TreeNode* rt;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CBTInserter</span>(TreeNode* root) {</span><br><span class="line">        rt = root;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">front</span>()-&gt;left &amp;&amp; q.<span class="built_in">front</span>()-&gt;right) {</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span> </span>{</span><br><span class="line">        TreeNode* parent = q.<span class="built_in">front</span>();</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;left == <span class="literal">nullptr</span>) {</span><br><span class="line">            parent-&gt;left = node;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent-&gt;right = node;</span><br><span class="line">            </span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(parent-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(parent-&gt;right);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parent-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">get_root</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CBTInserter* obj = new CBTInserter(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;insert(v);</span></span><br><span class="line"><span class="comment"> * TreeNode* param_2 = obj-&gt;get_root();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="二叉树每层的最大值-44"><a href="#二叉树每层的最大值-44" class="headerlink" title="二叉树每层的最大值[44]"></a>二叉树每层的最大值[44]</h4><h5 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [1,3,2,5,3,null,9]</span><br><span class="line">输出: [1,3,9]</span><br><span class="line">解释:</span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        3   2</span><br><span class="line">       / \   \  </span><br><span class="line">      5   3   9 </span><br></pre></td></tr></tbody></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [1,2,3]</span><br><span class="line">输出: [1,3]</span><br><span class="line">解释:</span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br></pre></td></tr></tbody></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [1]</span><br><span class="line">输出: [1]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例4：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [1,null,2]</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释:      </span><br><span class="line">           1 </span><br><span class="line">            \</span><br><span class="line">             2     </span><br></pre></td></tr></tbody></table></figure><p><strong>示例5：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = []</span><br><span class="line">输出: []</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,104]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><blockquote><p>注意：本题与主站 515 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/</a></p></blockquote><h5 id="解法-39"><a href="#解法-39" class="headerlink" title="解法"></a>解法</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629514102-NbQgoB-477afe8550c13a4e1e3c0e726bdf67a.jpg"></p><p>“BFS 层次遍历”实现。</p><p>因为要求解二叉树每一层的最大值，所以使用二叉树的层次遍历是最适合不过的。但是因为需要求二叉树的每一层的最大值，所以需要确定哪些节点属于同一层。一种简单的方式就是，在遍历完当前层的最后一个节点之后，队列中所保存的节点数就是下一层的节点数。如图所示，红色节点为当前层的最后一个节点，绿色为处于队列中的下一层的所有节点。因为队列的初始状态是只有一个不为空的根节点，所以第一层就是一个节点，第二次就是遍历完根节点之后的队列中的节点，以此类推。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max = INT_MIN;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root) {</span><br><span class="line">            q.<span class="built_in">push</span>(root);</span><br><span class="line">            cur = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            cur--;</span><br><span class="line">            max = std::<span class="built_in">max</span>(max, node-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) {</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                next++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) {</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                next++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) {</span><br><span class="line">                res.<span class="built_in">push_back</span>(max);</span><br><span class="line">                max = INT_MIN;</span><br><span class="line"></span><br><span class="line">                cur = next;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="二叉树最底层最左边的值-45"><a href="#二叉树最底层最左边的值-45" class="headerlink" title="二叉树最底层最左边的值[45]"></a>二叉树最底层最左边的值[45]</h4><h5 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree1-20220107161106888.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree2-20220107161151618.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,10^4]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><blockquote><p>注意：本题与主站 513 题相同： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p></blockquote><h5 id="解法-40"><a href="#解法-40" class="headerlink" title="解法"></a>解法</h5><p>若每次都记录当前层的最左端值，那么等遍历完二叉树，记录的当前层的最左端节点值就是最底层的最左端节点值，如图所示。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629516028-QgimFe-2ec6bf9d0c6a8c23ba023583bfeacf6-20220107161951636.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bottomLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    bottomLeft = node-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bottomLeft;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="二叉树的右侧视图-46"><a href="#二叉树的右侧视图-46" class="headerlink" title="二叉树的右侧视图[46]"></a>二叉树的右侧视图[46]</h4><h5 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree-20220107162047026.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><blockquote><p>注意：本题与主站 199 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p></blockquote><h5 id="解法-41"><a href="#解法-41" class="headerlink" title="解法"></a>解法</h5><p>只需将面试题 45 中保存每一层最左端的节点值，改为保存每一层最右端的节点值并保存即可。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1629516721-xcbSKy-2bdd85f029f86f2e9708a61edccdc1a.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/dd921d98.html" rel="bookmark">剑指Offer</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8069546e.html" rel="bookmark">Stack</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/67a14acd.html" rel="bookmark">Data Structures and Algorithms</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Cpp/" rel="tag"># Cpp</a> <a href="/tags/LeetCode/" rel="tag"># LeetCode</a> <a href="/tags/Algorithm/" rel="tag"># Algorithm</a> <a href="/tags/Online-Judge/" rel="tag"># Online Judge</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/a6139169.html" rel="prev" title="A Gentle Introduction to DirectX Raytracing 3"><i class="fa fa-chevron-left"></i> A Gentle Introduction to DirectX Raytracing 3</a></div><div class="post-nav-item"><a href="/archives/5e049055.html" rel="next" title="双城需要海克斯，而不是马克思">双城需要海克斯，而不是马克思 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">整数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95-1"><span class="nav-number">2.1.</span> <span class="nav-text">整数除法[1]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95-2"><span class="nav-number">2.2.</span> <span class="nav-text">二进制加法[2]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D-n-%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0-3"><span class="nav-number">2.3.</span> <span class="nav-text">前 n 个数字二进制中 1 的个数[3]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-4"><span class="nav-number">2.4.</span> <span class="nav-text">只出现一次的数字[4]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF-5"><span class="nav-number">2.5.</span> <span class="nav-text">单词长度的最大乘积[5]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="nav-number">2.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-4"><span class="nav-number">2.5.2.</span> <span class="nav-text">解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C-6"><span class="nav-number">3.1.</span> <span class="nav-text">排序数组中两个数字之和[6]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="nav-number">3.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-5"><span class="nav-number">3.1.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA-0-%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0-7"><span class="nav-number">3.2.</span> <span class="nav-text">数组中和为 0 的三个数[7]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="nav-number">3.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-6"><span class="nav-number">3.2.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-target-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84-8"><span class="nav-number">3.3.</span> <span class="nav-text">和大于等于 target 的最短子数组[8]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="nav-number">3.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-7"><span class="nav-number">3.3.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-9"><span class="nav-number">3.4.</span> <span class="nav-text">乘积小于 K 的子数组[9]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="nav-number">3.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-8"><span class="nav-number">3.4.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-10"><span class="nav-number">3.5.</span> <span class="nav-text">和为 k 的子数组[10]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="nav-number">3.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-9"><span class="nav-number">3.5.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#0-%E5%92%8C-1-%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-11"><span class="nav-number">3.6.</span> <span class="nav-text">0 和 1 个数相同的子数组[11]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="nav-number">3.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-10"><span class="nav-number">3.6.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89-12"><span class="nav-number">3.7.</span> <span class="nav-text">左右两边子数组的和相等[12]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11"><span class="nav-number">3.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-11"><span class="nav-number">3.7.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C-13"><span class="nav-number">3.8.</span> <span class="nav-text">二维子矩阵的和[13]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-12"><span class="nav-number">3.8.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-12"><span class="nav-number">3.8.2.</span> <span class="nav-text">解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D-14"><span class="nav-number">4.1.</span> <span class="nav-text">字符串中的变位词[14]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-13"><span class="nav-number">4.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-13"><span class="nav-number">4.1.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D-15"><span class="nav-number">4.2.</span> <span class="nav-text">字符串中的所有变位词[15]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-14"><span class="nav-number">4.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-14"><span class="nav-number">4.2.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-16"><span class="nav-number">4.3.</span> <span class="nav-text">不含重复字符的最长子字符串[16]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-15"><span class="nav-number">4.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-15"><span class="nav-number">4.3.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AB%E6%9C%89%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2-17"><span class="nav-number">4.4.</span> <span class="nav-text">含有所有字符的最短字符串[17]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-16"><span class="nav-number">4.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-16"><span class="nav-number">4.4.2.</span> <span class="nav-text">解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9-21"><span class="nav-number">5.1.</span> <span class="nav-text">删除链表的倒数第 n 个结点[21]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-17"><span class="nav-number">5.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-17"><span class="nav-number">5.1.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9-22"><span class="nav-number">5.2.</span> <span class="nav-text">链表中环的入口节点[22]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-18"><span class="nav-number">5.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-18"><span class="nav-number">5.2.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%87%8D%E5%90%88%E8%8A%82%E7%82%B9-23"><span class="nav-number">5.3.</span> <span class="nav-text">两个链表的第一个重合节点[23]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-19"><span class="nav-number">5.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-19"><span class="nav-number">5.3.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-24"><span class="nav-number">5.4.</span> <span class="nav-text">反转链表[24]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-20"><span class="nav-number">5.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-20"><span class="nav-number">5.4.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-25"><span class="nav-number">5.5.</span> <span class="nav-text">链表中的两数相加[25]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-21"><span class="nav-number">5.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-21"><span class="nav-number">5.5.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-26"><span class="nav-number">5.6.</span> <span class="nav-text">重排链表[26]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-22"><span class="nav-number">5.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-22"><span class="nav-number">5.6.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-27"><span class="nav-number">5.7.</span> <span class="nav-text">回文链表[27]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-23"><span class="nav-number">5.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-23"><span class="nav-number">5.7.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%95%E5%B9%B3%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-28"><span class="nav-number">5.8.</span> <span class="nav-text">展平多级双向链表[28]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-24"><span class="nav-number">5.8.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-24"><span class="nav-number">5.8.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-29"><span class="nav-number">5.9.</span> <span class="nav-text">排序的循环链表[29]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-25"><span class="nav-number">5.9.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-25"><span class="nav-number">5.9.2.</span> <span class="nav-text">解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AF-O-1-%E7%9A%84%E5%AE%B9%E5%99%A8-30"><span class="nav-number">6.1.</span> <span class="nav-text">插入、删除和随机访问都是 O(1) 的容器[30]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-26"><span class="nav-number">6.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-26"><span class="nav-number">6.1.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E8%A7%A3%E5%86%B3-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98-31"><span class="nav-number">6.2.</span> <span class="nav-text">[未解决]最近最少使用缓存[31]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D-32"><span class="nav-number">6.3.</span> <span class="nav-text">有效的变位词[32]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-27"><span class="nav-number">6.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-27"><span class="nav-number">6.3.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84-33"><span class="nav-number">6.4.</span> <span class="nav-text">变位词组[33]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-28"><span class="nav-number">6.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-28"><span class="nav-number">6.4.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E6%98%9F%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%8E%92%E5%BA%8F-34"><span class="nav-number">6.5.</span> <span class="nav-text">外星语言是否排序[34]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-29"><span class="nav-number">6.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-29"><span class="nav-number">6.5.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE-35"><span class="nav-number">6.6.</span> <span class="nav-text">最小时间差[35]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-30"><span class="nav-number">6.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-30"><span class="nav-number">6.6.2.</span> <span class="nav-text">解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">7.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-36"><span class="nav-number">7.1.</span> <span class="nav-text">后缀表达式[36]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-31"><span class="nav-number">7.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-31"><span class="nav-number">7.1.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E-37"><span class="nav-number">7.2.</span> <span class="nav-text">小行星碰撞[37]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-32"><span class="nav-number">7.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-32"><span class="nav-number">7.2.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-38"><span class="nav-number">7.3.</span> <span class="nav-text">每日温度[38]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-33"><span class="nav-number">7.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-33"><span class="nav-number">7.3.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-39"><span class="nav-number">7.4.</span> <span class="nav-text">直方图最大矩形面积[39]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-34"><span class="nav-number">7.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-34"><span class="nav-number">7.4.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E8%A7%A3%E5%86%B3-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-40"><span class="nav-number">7.5.</span> <span class="nav-text">[未解决]矩阵中最大的矩形[40]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-35"><span class="nav-number">7.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-35"><span class="nav-number">7.5.2.</span> <span class="nav-text">解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">8.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC-41"><span class="nav-number">8.1.</span> <span class="nav-text">滑动窗口的平均值[41]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-36"><span class="nav-number">8.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-36"><span class="nav-number">8.1.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0-42"><span class="nav-number">8.2.</span> <span class="nav-text">最近请求次数[42]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-37"><span class="nav-number">8.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-37"><span class="nav-number">8.2.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%80%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9-43"><span class="nav-number">8.3.</span> <span class="nav-text">往完全二叉树添加节点[43]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-38"><span class="nav-number">8.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-38"><span class="nav-number">8.3.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E5%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC-44"><span class="nav-number">8.4.</span> <span class="nav-text">二叉树每层的最大值[44]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-39"><span class="nav-number">8.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-39"><span class="nav-number">8.4.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%BA%95%E5%B1%82%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%80%BC-45"><span class="nav-number">8.5.</span> <span class="nav-text">二叉树最底层最左边的值[45]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-40"><span class="nav-number">8.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-40"><span class="nav-number">8.5.2.</span> <span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7%E8%A7%86%E5%9B%BE-46"><span class="nav-number">8.6.</span> <span class="nav-text">二叉树的右侧视图[46]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-41"><span class="nav-number">8.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-41"><span class="nav-number">8.6.2.</span> <span class="nav-text">解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">9.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">10.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">11.</span> <span class="nav-text">前缀树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">12.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">13.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="nav-number">14.</span> <span class="nav-text">回溯法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">15.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">16.</span> <span class="nav-text">图</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">291</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">46</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.5m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
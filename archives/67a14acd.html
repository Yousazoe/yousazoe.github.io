<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//img.yousazoe.top/cdn/fontawesome.all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Low poly (8 part) by        Vladimir Bozrikov             引言“数据结构和算法”是学习特定算法前的基础，比如时间空间复杂度，如何实现 List、HashMap、Tree、Heap、Graph，还有各类数据结构中的操作，都是必备的基本功。本文涵盖了各类题型中的常见数据结构和算法，让大家事半功倍。"><meta property="og:type" content="article"><meta property="og:title" content="Data Structures and Algorithms"><meta property="og:url" content="https://yousazoe.top/archives/67a14acd.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Low poly (8 part) by        Vladimir Bozrikov             引言“数据结构和算法”是学习特定算法前的基础，比如时间空间复杂度，如何实现 List、HashMap、Tree、Heap、Graph，还有各类数据结构中的操作，都是必备的基本功。本文涵盖了各类题型中的常见数据结构和算法，让大家事半功倍。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/e9eda8101582379.5f21e8ca32c59.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/big-o-running-time-complexity.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1*ipkeWQ_Lb0lbkhB8rigxTA.png"><meta property="og:image" content="https://i2.wp.com/turingplanet.org/wp-content/uploads/2020/02/InsertionSortGIF.gif?resize=523,325&amp;ssl=1"><meta property="og:image" content="https://i1.wp.com/images.deepai.org/glossary-terms/a5228ea07c794b468efd1b7f758b9ead/Quicksort.png?resize=577,410&amp;ssl=1"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Merge_sort_algorithm_diagram.svg/618px-Merge_sort_algorithm_diagram.svg.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/stack_representation.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph1.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph2.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph3.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph4.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph5.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph6.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph7.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph8-20210808212051082.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph9.png"><meta property="article:published_time" content="2021-08-08T10:00:37.000Z"><meta property="article:modified_time" content="2022-07-08T14:29:59.149Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="LeetCode"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Online Judge"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/e9eda8101582379.5f21e8ca32c59.jpg"><link rel="canonical" href="https://yousazoe.top/archives/67a14acd.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Data Structures and Algorithms | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/67a14acd.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Data Structures and Algorithms</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-08-08 18:00:37" itemprop="dateCreated datePublished" datetime="2021-08-08T18:00:37+08:00">2021-08-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/LeetCode%E9%A2%98%E8%A7%A3-LeetCode-Solution/" itemprop="url" rel="index"><span itemprop="name">LeetCode题解 (LeetCode Solution)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>19k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>34 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/e9eda8101582379.5f21e8ca32c59.jpg"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://www.behance.net/gallery/101582379/Low-poly-%288-part%29?tracking_source=search_projects_recommended%7Clowpoly">Low poly (8 part)</a> by <a target="_blank" rel="noopener" href="https://www.behance.net/bozrikov">Vladimir Bozrikov</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>“数据结构和算法”是学习特定算法前的基础，比如时间空间复杂度，如何实现 List、HashMap、Tree、Heap、Graph，还有各类数据结构中的操作，都是必备的基本功。本文涵盖了各类题型中的常见数据结构和算法，让大家事半功倍。</p><span id="more"></span><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="什么是数据结构？什么是算法？"><a href="#什么是数据结构？什么是算法？" class="headerlink" title="什么是数据结构？什么是算法？"></a>什么是数据结构？什么是算法？</h4><p>什么是”数据结构和算法“？这可能是第一次接触此内容的新朋友最常有的问题。我先给大家一个比较官方的解释：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">数据结构是计算机存储、组织数据的方式。</span><br><span class="line">算法是一系列规定的计算步骤，为了实现特定的计算目的。</span><br></pre></td></tr></tbody></table></figure><p>你可能更困惑了，那我换种简单的说法吧：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">程序 = 数据结构 + 算法</span><br></pre></td></tr></tbody></table></figure><p>这什么意思？我们都知道，电脑最主要功能是储存数据，计算数据，输出数据，而程序无非就是电脑中一部分数据的集合而已，所以程序也是要控制数据的。那么数据结构就是程序用来储存数据的基本单位，而算法就是为了实现特定目的，一系列操作数据的方式。简单来讲，一个程序把数据存储在特定的数据结构中，并使用特定的算法进行数据的计算。</p><p>举例来说，你要在数据库中查找一个特定的数字75，假设这个数据库用数组存储数据，并存好了100个从小打大排好序的数字，那我们可以使用两种方式来找75。第一种方式就是一个一个按顺序找，那就需要找75次才能找到我们的目标。第二种方式就是我们只找一堆数中间的那个数，如果那个数比我们要找的数小，那么我们排除此数之前的所有数，只管那个数之后的数字。如果那个数比我们要找的数大，那么我们知道我们要的数肯定排在它的前面，那就只找它之前的数。所以我们第一次会找到50，50比75小，那我们就只管50~100之间的数，然后再找中间的数75，这下就找到了，可见第二种方法比第一种方法快多了。</p><p>在这个例子中，<strong>数据库用来存储数据的数组就是数据结构</strong>，而<strong>搜索的两种方式则是特定的两种搜索算法</strong>：暴力搜索和二分搜索。如果这个数据库中数据没有排好序，那么二分查找就不适用了，我们只能使用暴力搜索。可见<strong>特定的算法需要通过特定的数据结构来实现</strong>，二分搜索基于数组这种数据结构，且其中的数字必须排好序。算法的设计需要结合数据结构和特征才行。</p><h4 id="数据结构和算法之间的关系"><a href="#数据结构和算法之间的关系" class="headerlink" title="数据结构和算法之间的关系"></a>数据结构和算法之间的关系</h4><p>但数据结构和算法不一定像数组和二分查找这个例子这样是完全分开的单独内容。数组是最简单的数据结构，而很多其他复杂的数据结构往往又集成了很多的算法在其中。</p><p>比如一个优先队列数据结构，每次你向其中加入一个新数据的时候，它都会自动帮你排序好，将优先级最高的数据放在第一个。如果我们用这个数据结构来存储数据，并设定数字大的优先级更高，那么我们每次我们想要查找最大的数字，都不需要查找，直接取优先队列第一个数字即可。可见数据结构和算法的关系密不可分，<strong>每个数据结构中往往集成了很多的算法</strong>，比如这个优先队列中就集合了某种排序算法，我们才能如此快速地拿到最大值。</p><p>这些就是数据结构和算法的基本概念：<strong>数据结构是程序储存信息的基本单位，数组就是常见的数据结构。而算法则是实现特定任务的计算步骤，比如排序算法和搜索算法的目的顾名思义就是排序和搜索。</strong>数据结构和算法之间的关系密不可分，特定算法有时候需要基于特定的数据结构，比如二分查找就要基于排好序的数组。另一方面，数据结构也往往集成了特定的算法，比如优先队列就集成了排序算法在其中。</p><h4 id="“数据结构和算法”有那么重要吗？"><a href="#“数据结构和算法”有那么重要吗？" class="headerlink" title="“数据结构和算法”有那么重要吗？"></a>“数据结构和算法”有那么重要吗？</h4><p>很多小伙伴就问了，如今各种编程语言都有丰富的第三方代码库，不需要自己实现算法，那我们还需要学习”数据结构和算法“吗？这个问题就等价于，搬砖需不需要学习物理。如果只干搬砖砌墙的活，熟练掌握工具那就够了。但是要想设计建筑的话，还是要打好基础的。“数据结构和算法”也是计算机科学的必修课，不学也不行哈哈。</p><p>毫不夸张地说，“数据结构和算法”就是编程的内功，如果能深入掌握这方面的知识，我们就可以设计出计算效率更高的程序，比如Google这一个看起来功能单一的搜索引擎，不仅仅可以搜索相关性极高的内容，其搜索速度也是惊人的，背后的秘密就是各种搜索算法的集合。所以好好学习”数据结构和算法“吧，可能你就能创造出下一个Google哈哈~</p><h4 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h4><p>为了帮助大家快速入门并掌握最重要的知识点，此教程将会重点讲解数据结构，并结合数据结构一一剖析核心的算法，帮助大家建立起系统性的知识框架。我也会将算法和现实生活问题结合起来，帮助大家更好理解算法，更希望朋友们能将这些内功融会贯通到现实编程中。以下是内容大纲：</p><ol><li>时间空间复杂度（Time Complexity, Space Complexity）</li><li>排序算法（Sorting）</li><li>链表（List）</li><li>栈和队列（Stack, Queue)</li><li>优先队列和哈希表（Priority Queue, HashTable）</li><li>树和图（Tree, Graph）</li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>算法本质上是一连串的计算步骤。对于同一个问题，我们可以使用不同的算法来获得相同的结果，可是在计算过程中电脑消耗的时间和资源却有很大的区别。那我们如何来比较不同算法之间的优劣性呢？</p><p>目前分析算法主要从「时间」和「空间」两个维度来进行分析。时间维度顾名思义就是算法需要消耗的时间，「时间复杂度」是常用的分析单位。空间维度代表算法需要占用的内存空间，我们通常用「空间复杂度」来分析。</p><p>所以，分析算法的效率主要从「时间复杂度」和「空间复杂度」来分析。很多时候我们两者不可兼得，有时候要用时间换空间，或者空间换时间。下面我们一起来分别了解「时间复杂度」和「空间复杂度」的计算方式。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>想要从「时间维度」来了解一个算法，最简单的方法就是将算法运行一遍，然后计算花费的时间就可以了。</p><p>此方法可行，可是有很多弊端。只计算运行时间特别容易受到运行环境的影响，高性能和低性能的机器上出来的结果相差甚远。而且与测试时使用的数据规模也有很大的关系。</p><p>所以我们需要一种复杂度计算方式，不受计算机性能和程序数据的影响，「大O符号表示法」(BigO)就是这种计算方式，既 $T(n) = O(f(n))$，它表示一个算法的<strong>渐进时间复杂度</strong>。其中 f(n) 表示代码执行次数之和，O表示正比例关系。我们来看一个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    x++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每个算法需要多少的运行时间呢？我们知道这个for loop有n个循环，假设其中 x++ 计算的消耗是一个单位，那么第一次循环是1单位，第二次循环是2单位，所以整个循环语句就要消耗n个单位。可以发现，消耗的单位时间随着循环的次数而变化，循环次数为1，时间为1单位；循环次数为10，时间为10单位；循环次数为n，时间为n单位。所以这个算法的「时间复杂度」可以表示为：$T (n) = O(n)$。</p><p>有人可能不同意了，因为严格计算下，int i = 1也要消耗1单位时间，i &lt;= n和i++也都需要1单位时间，所以严格来说总时间是 T(n) = 1 + 3n。但是我们依然会简化为n，因为「大O表示法」用与表示计算的增长变化趋势。</p><p>在这个例子中，如果n无限大的时候，$T(n) = 1 + 3n$ 中的常数1就没有意义了，倍数3也影响不大。所以简化为 $T(n) = O(n)$​ 就可以 了。</p><p>我们再来看一个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">        x++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在外层循环中，i 总共需要n层循环，在每一次内层循环中，j 也会循环n次。如果用「大O表示法」来计算，那么两个循环语句的复杂度就是 $O(n^2)$，如果我们将这两个算法合并到一起：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    x++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">        x++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>整个算法复杂度就变为 $O(n + n^2)$，在n无限大的情况下，可以简化为 $O(n^2)$。</p><h4 id="常用的时间复杂度量级"><a href="#常用的时间复杂度量级" class="headerlink" title="常用的时间复杂度量级"></a>常用的时间复杂度量级</h4><p>以下便是常见的时间复杂度量级：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/big-o-running-time-complexity.png"></p><ul><li>常数阶O(1)</li><li>对数阶O(logN)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogN)</li><li>平方阶O(n²)</li><li>立方阶O(n³)</li><li>K次方阶O(n^k)</li><li>指数阶(2^n)</li><li>阶乘O(n!)</li></ul><p>上面的时间复杂从上到下复杂度越来越大，也意味着执行效率越来越低。以下我们来讲解一些常用的量级：</p><h5 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h5><p>只要没有循环或递归等复杂逻辑，无论代码执行多少行，代码复杂度都为 $O(1)$，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br></pre></td></tr></tbody></table></figure><p>上述代码在执行的时候，所消耗的时间不会随着特定变量的增长而增长，即使有几万行这样的代码，我们都可以用 $O(1)$ 来表示它的时间复杂度。</p><h5 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h5><p>我们在上述的例子中讲解过 $O(n)$ 的算法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    x++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这段代码中，for循环会执行n遍，因此计算消耗的时间是随着n的变化而变化，因此这类代码都可以用 $O(n)$ 来表示其时间复杂度。</p><h5 id="对数阶O-logN"><a href="#对数阶O-logN" class="headerlink" title="对数阶O(logN)"></a>对数阶O(logN)</h5><p>来看以下的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n) {</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的循环中，每次i都会被乘以2，也意味着每次 i 都离 n 更进一步。那需要多少次循环 i 才能等于或大于 n 呢，也就是求解2的x次方等于n，答案x=log2^n。也就是说循环 log2^n次之后，i会大于等于n，这段代码就结束了。所以此代码的复杂度为：$O(\log N)$。</p><h5 id="线性对数阶O-nlogN"><a href="#线性对数阶O-nlogN" class="headerlink" title="线性对数阶O(nlogN)"></a>线性对数阶O(nlogN)</h5><p>线性对数阶 $O(n\log N)$​​ 很好理解，也就是将复杂度为 $O(\log N)$ 的代码循环n遍：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n: i++) {</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; n) {</span><br><span class="line">        x = x * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为每次循环的复杂度为 $O(\log N)$，所以 $n * logN = O(n\log N)$</p><h5 id="平方阶O-n²"><a href="#平方阶O-n²" class="headerlink" title="平方阶O(n²)"></a>平方阶O(n²)</h5><p>在之前的例子我们也讲过，$O(n²)$ 就是将循环次数为n的代码再循环n遍：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">        x++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>$O(n²)$ 的本质就是 $n * n$，如果我们将内层的循环次数改为m：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">        x++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>复杂度就变为 $n * m = O(n * m)$。</p><p>关于一些更高的阶级比如 $O(n³)$ 或者 $O(n^k)$，我们可以参考 $O(n²)$ 来理解即可，$O(n³)$ 相当于三层循环，以此类推。</p><p>除了「大O表示法」还有其他「平均时间复杂度」、「均摊时间复杂度」、「最坏时间复杂度」、「最好时间复杂度」等等分析指数，但是最常用的依然是「大O表示法」。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>既然「时间复杂度」不是计算程序具体消耗的时间，「空间复杂度」也不是用来计算程序具体占用的空间。随着问题量级的变大，程序需要分配的内存空间也可能会变得更多，而「空间复杂度」反映的则是内存空间增长的趋势。</p><h4 id="常用的空间复杂度"><a href="#常用的空间复杂度" class="headerlink" title="常用的空间复杂度"></a>常用的空间复杂度</h4><p>比较常用的空间复杂度有：$O(1)$、$O(n)$、$O(n²)$。在下面的例子中，我们用 $S(n)$ 来定义「空间复杂度」。</p><h5 id="O-1-空间复杂度"><a href="#O-1-空间复杂度" class="headerlink" title="O(1)空间复杂度"></a>O(1)空间复杂度</h5><p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，此算法空间复杂度为一个常量，可表示为 $O(1)$：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br></pre></td></tr></tbody></table></figure><p>其中x, y所分配的空间不随着处理数据量变化，因此「空间复杂度」为 $O(1)$</p><h4 id="O-n-空间复杂度"><a href="#O-n-空间复杂度" class="headerlink" title="O(n)空间复杂度"></a>O(n)空间复杂度</h4><p>以下的代码给长度为 n 的数组赋值：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    newArray[i] = i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这段代码中，我们创建了一个长度为 n 的数组，然后在循环中为其中的元素赋值。因此，这段代码的「空间复杂度」取决于 newArray 的长度，也就是 n，所以 $S(n) = O(n)$。</p><p>以上便是「时间复杂度」和「空间复杂度」的简单介绍啦，简单来说，这两个复杂度反映的是，随着问题量级的增大，时间和空间增长的趋势。学会了复杂度的分析，我们就可以对比算法之间的优劣势啦~</p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>搜索是计算机中非常重要的步骤，但是从无序的数据中寻找特定的数字往往很难，我们之前提到的二分查找只能运用在排好序的数组中。所以排序算法是一个很重要的工作，如果我们能够将数值排好序，那么当我们寻找特定数值的时候，能省下不少功夫。</p><p>排序算法有很多，每种排序算法各有优缺点：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/1*ipkeWQ_Lb0lbkhB8rigxTA.png"></p><p>在这章节中，我们就来学习其中最经典的三种排序方法：插入排序Insertion Sort，快排Quick Sort，归并排序Merge Sort。</p><h4 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>插入排序是一种简单直观的排序算法。在插入排序中，我们从前到后依次处理未排好序的元素，对于每个元素，我们将它与之前排好序的元素进行比较，找到对应的位置后并插入。本质上，对于每一个要被处理的元素，我们只关心它与之前元素的关系，当前元素之后的元素我们下一轮才去处理。</p><p><img data-src="./image/loading.gif" data-original="https://i2.wp.com/turingplanet.org/wp-content/uploads/2020/02/InsertionSortGIF.gif?resize=523,325&amp;ssl=1"></p><p>在实现上，每个元素和之前元素比较的过程，是一个从后到前扫描的过程。在扫描时，我们将已排好序的元素先后挪位，为新的元素提供插入位置。这也叫做 in-place 排序，这样我们就不需要额外的内存空间了。</p><h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><ol><li>从第二个元素（第一个要被排序的新元素）开始，从后向前扫描之前的元素序列</li><li>如果当前扫描的元素大于新元素，将扫描元素移动到下一位</li><li>重复步骤2，直到找到一个小于或者等于新元素的位置</li><li>将新元素插入到该位置</li><li>对于之后的元素重复步骤1~4</li></ol><p><strong>伪代码 pseudo code</strong>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">insertion_sort</span><span class="params">(array[])</span>:</span></span><br><span class="line"><span class="function">    for (i =</span> <span class="number">1</span>; i &lt; array.length; i++):</span><br><span class="line">        cur = array[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; cur):</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j]</span><br><span class="line">            j--</span><br><span class="line">        array[j + <span class="number">1</span>] = cur</span><br></pre></td></tr></tbody></table></figure><h5 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span>[] array)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) {</span><br><span class="line">        <span class="type">int</span> cur = array[i];</span><br><span class="line">        <span class="type">int</span> insertionIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(insertionIndex &gt;= <span class="number">0</span> &amp;&amp; array[insertionIndex] &gt; cur) {</span><br><span class="line">            array[insertionIndex + <span class="number">1</span>] = array[insertionIndex];</span><br><span class="line">            insertionIndex--;</span><br><span class="line">        }</span><br><span class="line">        array[insertionIndex + <span class="number">1</span>] = cur;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(n²)$<br>空间复杂度：$O(1)$</p><p>「时间复杂度」在此算法中就是计算比较的次数，第一个元素我们需要比较1次，第二个元素2次，对于第n个元素，我们需要和之前的元素比较n次，比较总数量也就是 1 + 2 + … + n = n(n + 1) / 2<br>≈ n^2。因为我们调换位置时采用「原地操作」(in place)，所以不需要额外空间，既空间复杂度为 $O(1)$。</p><h4 id="快排-QuickSort"><a href="#快排-QuickSort" class="headerlink" title="快排 QuickSort"></a>快排 QuickSort</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>快排是一种分治（Divide and Conquer）算法，在这种算法中，我们把大问题变成小问题，然后将小问题逐个解决，当小问题解决完时，大问题也迎刃而解。</p><p>快排的基本概念就是选取一个目标元素，然后将目标元素放到数组中正确的位置。然后根据排好序后的元素，将数组切分为两个子数组，用相同的方法，在没有排好序的范围使用相同的操作。</p><p><img data-src="./image/loading.gif" data-original="https://i1.wp.com/images.deepai.org/glossary-terms/a5228ea07c794b468efd1b7f758b9ead/Quicksort.png?resize=577,410&amp;ssl=1"></p><h5 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h5><ol><li>对于当前的数组，取最后一个元素当做基准数（pivot）</li><li>将所有比基准数小的元素排到基准数之前，比基准数大的排在基准数之后</li><li>当基准数被放到准确的位置之后，根据基数数的位置将元素切分为前后两个子数组</li><li>对子数组采用步骤1~4的递归操作，直到子数组的长度小于等于1为止</li></ol><p><strong>伪代码（Pseudo code）</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">quickSort</span><span class="params">(array[], left, right)</span>:</span></span><br><span class="line"><span class="function">    partitionIndex =</span> <span class="built_in">partition</span>(array, left, right)</span><br><span class="line">    <span class="built_in">quickSort</span>(array, left, partitionIndex - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">quickSort</span>(array, partitionIndex + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">partition</span><span class="params">(array[], left, right)</span>:</span></span><br><span class="line"><span class="function">    pivot =</span> array[right]</span><br><span class="line">    smallerElementIndex = left</span><br><span class="line">    biggerElementIndex = right - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>):</span><br><span class="line">        <span class="keyword">while</span>(smallerElementIndex &lt; right &amp;&amp; array[smallerElementIndex] &lt;= pivot):</span><br><span class="line">            smallerElementIndex++</span><br><span class="line">        <span class="keyword">while</span>(biggerElementIndex &gt;= left &amp;&amp; array[biggerElementIndex] &gt; pivot):</span><br><span class="line">            rightIndex--</span><br><span class="line">        <span class="keyword">if</span>(smallerElementIndex &gt; biggerElementIndex) <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">swap</span>(array, smallerElementIndex, biggerElementIndex)</span><br><span class="line">    # Now array[smallerElementIndex] is the first element bigger than pivot</span><br><span class="line">    <span class="built_in">swap</span>(array, smallerElementIndex, right)</span><br><span class="line">    <span class="keyword">return</span> smallerElementIndex</span><br></pre></td></tr></tbody></table></figure><h5 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> partitionIndex = <span class="built_in">partition</span>(array, left, right);</span><br><span class="line">    <span class="built_in">quickSort</span>(array, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(array, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">    <span class="type">int</span> pivot = array[right];</span><br><span class="line">    <span class="type">int</span> leftIndex = left;</span><br><span class="line">    <span class="type">int</span> rightIndex = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) { </span><br><span class="line">        <span class="keyword">while</span>(leftIndex &lt; right &amp; array[leftIndex] &lt;= pivot) {</span><br><span class="line">            leftIndex++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(rightIndex &gt;= left &amp;&amp; array[rightIndex] &gt; pivot) {</span><br><span class="line">            rightIndex--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &gt; rightIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(array, leftIndex, rightIndex);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">swap</span>(array, leftIndex, right); <span class="comment">// swap pivot to the right position</span></span><br><span class="line">    <span class="keyword">return</span> leftIndex;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">    <span class="type">int</span> temp = array[left];</span><br><span class="line">    array[left] = array[right];</span><br><span class="line">    array[right] = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(n^2)$​，平均时间复杂度：$O(n\log N）$​<br>空间复杂度：$O(n)$，平均空间复杂度：$O(\log N)$</p><p>在最坏的情况下，如果元素一开始就是从大到小倒序排列的，那么我们每个元素都需要调换，时间复杂度就是 $O(n^2)$。当正常情况下，我们不会总碰到这样的情况，假设我们每次都找到一个中间的基准数，那么我们需要切分logN次，每层的划分(Partition)是 $O(N)$，平均时间复杂度就是 $O(n\log N)$。空间的复杂度取决于递归的层数，最糟糕的情况我们需要 $O(N)$ 层，一般情况下，我们认为平均时间复杂度是 $O(\log N)$​。</p><h4 id="归并排序-MergeSort"><a href="#归并排序-MergeSort" class="headerlink" title="归并排序 MergeSort"></a>归并排序 MergeSort</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>归并排序也是一种基于归并操作的有效排序算法。在此算法中，我们将一个数组分为两个子数组，通过递归重复将数组切分到只剩下一个元素为止。然后将每个子数组中的元素排序后合并，通过不断合并子数组，最后就会拿到一个排好序的大数组。</p><p>归并排序和快排一样，也是一种分而治之算法，简单理解就是将大问题变为小问题，然后把所有小问题都解决掉，大问题就迎刃而解了。其中主要包括两个步骤：</p><ol><li>切分步骤：将大问题变为小问题，通过递归解决更小的子问题。</li><li>解决步骤：将小问题的结果合并，以此找到大问题的答案。</li></ol><p>以数组 [38, 27, 43, 3, 9, 82, 10] 为例，我们通过递归分组，之后原数组被分成长度小于等于2的子数组：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[38, 27], [43, 3], [9, 82], [10]</span><br></pre></td></tr></tbody></table></figure><p>并将子数组中的元素排序好：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[27, 28], [3, 43], [9, 82], [10]</span><br></pre></td></tr></tbody></table></figure><p>然后两两合并，归并成排好序的子数组：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[3, 27, 38, 43], [9, 10, 82]</span><br></pre></td></tr></tbody></table></figure><p>最后将子数组合并为一个排好序的大数组：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[3, 9, 10, 27, 38, 43, 82]</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Merge_sort_algorithm_diagram.svg/618px-Merge_sort_algorithm_diagram.svg.png"></p><h5 id="具体步骤-2"><a href="#具体步骤-2" class="headerlink" title="具体步骤"></a>具体步骤</h5><ol><li>递归切分当前数组</li><li>如果当前数组数量小于等于1，无需排序，直接返回结果</li><li>否则将当前数组分为两个子数组，递归排序这两个子数组</li><li>在子数组排序结束后，将子数组的结果归并成排好序的数组</li></ol><p><strong>伪代码 Pseudocode</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">mergeSort</span><span class="params">(array[], start, end)</span>:</span></span><br><span class="line"><span class="function">    if (end - start &lt; <span class="number">1</span>) return</span></span><br><span class="line"><span class="function">    mid =</span> (start + end) / <span class="number">2</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(array, start, mid)</span><br><span class="line">    <span class="built_in">mergeSort</span>(array, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">merge</span>(array, start, mid, end)</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">merge</span><span class="params">(array[], start, mid, end)</span>:</span></span><br><span class="line"><span class="function">    helper[] =</span> array.<span class="built_in">copy</span>()</span><br><span class="line">    leftStart = start, rightStart = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(leftStart &lt;= mid || rightStart &lt;= end):</span><br><span class="line">        <span class="keyword">if</span>(helper[leftStart] &lt;= helper[rightStart]):</span><br><span class="line">            array[start++] = helper[leftStart++]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            array[start++] = helper[rightStart++]</span><br><span class="line">    <span class="keyword">if</span>(leftStart &lt;= mid): </span><br><span class="line">        <span class="keyword">while</span>(leftStart &lt;= mid):</span><br><span class="line">            array[start++] = helper[leftStart++]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span>(rightStart &lt;= end):</span><br><span class="line">            array[start++] = helper[rightStart++]</span><br></pre></td></tr></tbody></table></figure><h5 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++实现"></a>C++实现</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> </span>{</span><br><span class="line">    <span class="type">int</span>[] helper = <span class="built_in">copy</span>(array);</span><br><span class="line">    <span class="built_in">mergeSort</span>(array, helper, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span>[] helper, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(right - left &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(array, helper, left, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(array, helper, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">merge</span>(array, helper, left, mid, right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span>[] helper, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++) {</span><br><span class="line">        helper[i] = array[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> leftStart = left;</span><br><span class="line">    <span class="type">int</span> rightStart = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) { </span><br><span class="line">        <span class="keyword">if</span> (leftStart &gt; mid) {   </span><br><span class="line">            array[i] = helper[rightStart++];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (rightStart &gt; right) {</span><br><span class="line">            array[i] = helper[leftStart++];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (helper[leftStart] &lt; helper[rightStart]) {</span><br><span class="line">            array[i] = helper[leftStart++];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            array[i] = helper[rightStart++];</span><br><span class="line">        }</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] <span class="built_in">copy</span>(<span class="type">int</span>[] array) {</span><br><span class="line">     <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="type">int</span>[array.length];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) { </span><br><span class="line">         newArray[i] = array[i];</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> newArray;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间：$O(n\log N)$<br>空间：$O(N)$</p><p>在将大问题切分为小问题的过程中，我们每次都将数组切一半，所以需要logN次才能将数组切到一个元素，所以递归的层级就是logN。在每一层中，我们要对子数组进行归并，我们要扫描所有的元素，所以每一层需要N次扫描。那么，时间复杂度就是层级乘以每层的操作 = $\log N * N$ = $O(N \log N)$。在每一层中，我们需要一个临时的数组来存放原先的数据，然后在这个数组中扫描子数组的元素，并将其排好序放回原来的数组，所以空间复杂度就是 $O(N)$。</p><h4 id="实践练习"><a href="#实践练习" class="headerlink" title="实践练习"></a>实践练习</h4><ul><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-an-array/">Sort an Array (912)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-colors/">Sort Colors (75)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">Merge Sorted Array (88)</a></li></ul><h3 id="堆栈和队列"><a href="#堆栈和队列" class="headerlink" title="堆栈和队列"></a>堆栈和队列</h3><p>在这一章我们来了解两个很特殊的数据结构：堆栈 (Stack) 和队列 (Queue)。这两个数据结构类似垃圾桶和队伍，栈是先进后出型，队列是先进先出型。</p><h4 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>堆栈是一种常用的数据结构，这种数据结构的存储方式和垃圾桶一样，后面放进去的元素可以先取出来，而最早放入的元素会被压在最下面，最后才能被拿出来。我们也可以把栈的储存方式简单理解为堆盘子，后面加入的盘子会被堆到最上面，最早堆入的盘子在最下面。</p><p>所以栈是一种后进先出（Last In First Out）的数据结构，后入的元素先出，先入的元素后出。</p><p>堆栈主要支持以下两种操作：</p><ul><li>入栈（Push）：将一个元素放入栈，用来加入数据。</li><li>出栈（Pop）：将一个元素弹出栈，用来删除数据。</li></ul><p>还有以下两种辅助操作：</p><ul><li>Peek：查看最顶部的元素。</li><li>isEmpty：查看栈是否为空。</li></ul><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/stack_representation.jpg"></p><h5 id="数组栈实现"><a href="#数组栈实现" class="headerlink" title="数组栈实现"></a>数组栈实现</h5><p>链表有两种实现方式，一种是数组，另一种是链表。数据的实现方式很简单，以下是数组栈的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> CAPACITY = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> stack[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>{</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="type">int</span>[CAPACITY];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在数组栈中，我们使用数组来储存数据，其中包含一个 <code>CAPACITY</code> 来限制栈的容量，并使用指针 <code>top</code> 来记录最顶端元素的位置，<code>top</code> 初始化为-1，代表数组栈没有任何元素。以下是 <code>push()</code> 和 <code>pop()</code> 方法的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (top &gt;= (CAPACITY - <span class="number">1</span>)) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Stack Overflow."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    stack[++top] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Stack Underflow."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> element = stack[top--];</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 <code>push()</code> 中，我们需要检查顶部元素是否达到容量限制，如果是，输出“溢出栈”错误。否则移动 <code>top</code> 指针，加入新的元素。在 <code>pop()</code> 中，也要查看栈是否为空，如果是，那么输出“栈下溢”错误。否则将 <code>top</code> 指针减一。另外还有 <code>peek()</code> 和 <code>isEmpty()</code> 的实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Stack Underflow"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> element = stack[top];</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> top &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>peek()</code> 也要查看栈是否为空，如果不是，直接返回 <code>top</code> 指向的元素。<code>isEmpty()</code> 只要查看 <code>top</code> 是否小于0即可。</p><h5 id="链式栈实现"><a href="#链式栈实现" class="headerlink" title="链式栈实现"></a>链式栈实现</h5><p>除了数组栈，我们也可以使用链表来实现栈，以下是链式栈的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListStack</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">StackNode</span> {</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        StackNode next;</span><br><span class="line">        <span class="built_in">StackNode</span>(<span class="type">int</span> val) {</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    StackNode top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListStack</span><span class="params">()</span> </span>{</span><br><span class="line">        top = null;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在链式栈中，我们先定义节点 <code>StackNode</code>，节点中包含数值和下一个节点的指针。在链式栈中，我们只需要记录 <code>top</code> 节点，在初始化时定义为 <code>null</code>。以下是 <code>push()</code> 和 <code>pop()</code> 的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">    StackNode newNode = <span class="keyword">new</span> <span class="built_in">StackNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (top == null) {</span><br><span class="line">        top = newNode;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        StackNode temp = top;</span><br><span class="line">        top = newNode;</span><br><span class="line">        newNode.next = temp;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">" is pushed to stack."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (top == null) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Stack is Empty."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> popped = top.val;</span><br><span class="line">    top = top.next;</span><br><span class="line">    <span class="keyword">return</span> popped;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 <code>push()</code> 中，我们先创建新的节点 <code>newNode</code>，如果栈为空，那么直接将 <code>newNode</code> 赋给 <code>top</code>。如果不为空，就将新元素的下一节点指向当前的 <code>top</code>，并将 <code>newNode</code> 更新为 <code>top</code> 节点。在 <code>pop()</code> 中，也要先检查栈是否为空，不为空的话，记录下 <code>top</code> 的数据作为返回值，并将 <code>top</code> 更新为自己的下一个节点。以下是链式栈 <code>peek()</code> 和 <code>isEmpty()</code> 的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (top == null) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Stack is empty."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> top.val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> top == null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在栈不为空的情况下，<code>peek()</code> 只需查看 <code>top</code> 的值即可，<code>isEmpty()</code> 也只要查看 <code>top</code> 是否是 <code>null</code> 就可以了。不管是用数组还是链表来实现栈，我们都只要处理头节点 <code>top</code>，所以栈的所有操作都为 <code>O(1)</code>。</p><h4 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><p>队列是很好理解的一种数据结构，顾名思义，队列数据结构就和我们平时排队一样，先进入的元素先出，后进入的元素后出。队列的两端都是开的，一段负责插入新元素，另一端负责删除元素。</p><p>队列主要支持以下两种操作：</p><ul><li>入队（enqueue）：增加一个新的元素</li><li>出队（dequeue）：删除一个元素</li></ul><p>还支持其他辅助操作：</p><ul><li>peek – 查看队列最前端的元素</li><li>isFull – 查看队列是否满了</li><li>isEmpty – 查看队列是否为空</li></ul><h5 id="数组队列实现"><a href="#数组队列实现" class="headerlink" title="数组队列实现"></a>数组队列实现</h5><p>队列和堆栈一样，也可以使用两种实现方式，一种是使用数组，叫做顺序队列，另一种是使用链表实现，叫做链式队列。以下我们会先实现一种更常见的数组队列，叫做循环队列，它和基础的顺序队列相比较，更能有效地利用数组空间。以下是循环队列的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> {</span><br><span class="line">    <span class="type">int</span> front, rear, size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> array[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        front = rear = size = <span class="number">0</span>;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在循环队列中，我们需要 <code>capacity</code> 来限制队列的长度，并创建两个指针 <code>front</code> 和 <code>rear</code>，<code>front</code> 用来指向队列的头部，而 <code>rear</code> 指向队列的尾部。队列总是从头部取出元素，从尾部插入新元素，在操作队列时，我们只需要移动 <code>front</code> 和 <code>rear</code> 两个指针即可。我们还需要一个额外的size变量来记录元素的数量， <code>front</code>，<code>rear</code> 和 <code>size</code> 都初始化为0 。</p><p>以下是 <code>enqueue()</code> 和 <code>dequeue()</code> 的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> item)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFull</span>()) <span class="keyword">return</span>;</span><br><span class="line">    array[rear] = item;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">    size++;</span><br><span class="line">    cout &lt;&lt; item &lt;&lt; <span class="string">" is enqueued."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> item = array[front];</span><br><span class="line">    front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">    size --;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在新元素入队的时候，我们需要先判断队列是否已满（<code>isFull()</code> 的代码在下一段）。如果未满，那么就把元素插入 <code>rear</code> 的位置，并将 <code>rear</code> 加1，并与 <code>capacity</code> 取模，然后增加 <code>size</code>。在出队的时候，先要检查队列是否为空（<code>isEmpty()</code> 的代码在下一段），记录下删除元素的值后，我们将 <code>front</code> 指针增加1，与 <code>capacity</code> 取模，然后将 <code>size</code> 减少1。以下是辅助操作的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">return</span> array[front];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> size == capacity;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>peek()</code> 只要查看 <code>front</code> 指针指向的值即可，<code>isFull()</code> 要检查 <code>size</code> 是否和容量 <code>capacity</code> 相同，<code>isEmpty()</code> 直接查看 <code>size</code> 是否等于0。</p><h5 id="链式队列实现"><a href="#链式队列实现" class="headerlink" title="链式队列实现"></a>链式队列实现</h5><p>用链表实现队列也很简单，和数组实现相似，也需要两个指针（<code>front</code> 和 <code>rear</code>）来实现。以下是 <code>ListQueue</code> 和 <code>QueueNode</code> 的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListQueue</span> {</span><br><span class="line"></span><br><span class="line">    QueueNode front;</span><br><span class="line">    QueueNode rear;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">QueueNode</span> {</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        QueueNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QueueNode</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在链式队列中，我们需要定义节点 <code>QueueNode</code>，<code>QueueNode</code> 中含有两个值：一个是节点的数值 <code>value</code>，另一个是指向下一个节点的 <code>next</code> 指针。在链式队列 <code>ListQueue</code> 中，我们只需要两个节点 <code>front</code> 和 <code>rear</code>，<code>front</code> 用来指向队列最前端的节点，而 <code>rear</code> 用来指向尾节点。以下是两个重要操作 <code>enqueue()</code> 和<code>deuque()</code> 的实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">    QueueNode newNode = <span class="keyword">new</span> <span class="built_in">QueueNode</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rear == null) { <span class="comment">// Queue is empty</span></span><br><span class="line">        <span class="keyword">this</span>.front = <span class="keyword">this</span>.rear = newNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.rear.next = newNode;</span><br><span class="line">    <span class="keyword">this</span>.rear = newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.front == null) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"The queue is empty."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    }</span><br><span class="line">    QueueNode frontNode = <span class="keyword">this</span>.front;</span><br><span class="line">    <span class="keyword">this</span>.front = <span class="keyword">this</span>.front.next;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.front == null) {</span><br><span class="line">        <span class="keyword">this</span>.rear = null;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> frontNode.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 <code>enqueue()</code>中，我们先创建一个新的节点，如果队列为空，那么将头节点和尾节点同时指向新节点，结束操作。如果队列不为空，只要尾节点的 <code>next</code> 指针指向新节点，然后将尾节点指向新节点。在 <code>dequeue()</code> 中，如果头节点 <code>front</code> 为空，直接返回默认数值。队列不为空的情况下，记录下 <code>front</code> 的数值作为返回值，并将头节点更新为下一节点。</p><h4 id="实践练习-1"><a href="#实践练习-1" class="headerlink" title="实践练习"></a>实践练习</h4><p><strong>Stack相关</strong>：</p><ul><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">Valid Parentheses (20)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicate-letters/">Remove Duplicate Letters (316)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/">Trapping Rain Water (42)</a></li></ul><p><strong>Queue相关</strong>：</p><ul><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/task-scheduler/">Task Scheduler (621)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-circular-queue/">Design Circular Queue (622)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-circular-deque/">Design Circular Deque (641)</a></li></ul><h3 id="优先队列和堆"><a href="#优先队列和堆" class="headerlink" title="优先队列和堆"></a>优先队列和堆</h3><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><p>树是一种非常有用的数据结构，数据库的实现大部分都是基于树结构的，比如在一种特殊的树结构“红黑树”中，寻找任意元素的复杂度仅仅只需要 $\log(N)$​。树是一种由节点组成的数据结构，但它比链表更加高级，在链表中，一个节点连接着另一个节点，树也是由许多的节点构成的，唯一的区别就是一个树节点可以连接多个树节点，一颗树只有一个根节点，根节点作为起源，由它展开一个树状的数据结构。</p><p>在实现树之前，我们来了解一下树的基本定义：</p><p>在树中，每个节点都含有自己的数值，以及与之相连的子节点，连接节点的线叫做相连线（edge）。如下图所示，A是根节点（root），也是B和C的父节点（parent node），也就是说B、C都是A的子节点（child node）。同理，B是D和E的父节点，以此类推。要注意H、I、J、F、G都是尾节点（leaf node），因为它们位于树的最底部，没有任何子节点。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tree.jpg"></p><p>一个树由许许多多的子树（sub-tree）构成，每个节点加上它所有的子节点（包括子节点的子节点们）就是一个子树，如上图，D、H、和I就是能构成sub tree，B、D、E、H、I、和J也是一个子树。</p><p>树中还有两个重要的名词要记住，一个是节点的高度（height），意味着此节点到尾节点之间相连线的数量，B的高度就是2，因为B到尾节点H之间的edge数量为2。另一个名词就是节点的深度（depth），意味着此节点到根节点的edge数量，D的深度是2，因为D到根节点A之间的edge数量是2。</p><h4 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h4><p>树的种类有很多，其中排序二叉树会是我们的重点，在后面也会学习如何用Java将其实现，至于其他的树类型，大家目前只要大概理解就好：</p><ul><li>二叉树（Binary Tree）：每个节点最多含有两个子节点，上面图示中的树就是二叉树。</li><li>完全二叉树（Complete Binary Tree）：假设一个二叉树深度（depth）为d（d &gt; 1），除了第d层外，其它各层的节点数量均已达到最大值，且第d层所有节点从左向右紧密排列，这样的二叉树就是完全二叉树。</li><li>满二叉树（Full Binary Tee）：在满二叉树中，每个不是尾节点的节点都有两个子节点。</li><li>排序二叉树（Binary Search Tree）：在此树中，每个节点的数值比左子树上的每个节点都大，比所有右子树上的节点都小。</li><li>平衡二叉树（AVL Tree）：任何节点的两颗子树的高度差不大于1的二叉树。</li><li>B树（B-Tree）：B树和平衡二插树一样，只不过它是一种多叉树（一个节点的子节点数量可以超过二）。</li><li>红黑树（Red—Black Tree）：是一种自平衡二叉寻找树。</li></ul><h4 id="二分查找树（Binary-Search-Tree）的实现"><a href="#二分查找树（Binary-Search-Tree）的实现" class="headerlink" title="二分查找树（Binary Search Tree）的实现"></a>二分查找树（Binary Search Tree）的实现</h4><p>接下来，我们就来实现二分查找树（Binary Search Tree），也叫做排序二叉树。在这种树中，我们寻找一个特定的数值非常容易，因为二分查找树满足以下的特性：每个节点都比自己左子树上的节点大，并比右子树上的节点小。如果我们想要寻找一个特定的元素，只需要依赖其特性，顺着特定的路径就能找到目标。</p><p>在此树中，搜索、插入和删除的复杂度等于树高，往往就是 $O(\log N)$，非常合适用来存储数据。接下来我们就使用Java来实现这个数据结构，首先我们定义好树和节点：</p><h4 id="树的遍历-Tree-Traversal"><a href="#树的遍历-Tree-Traversal" class="headerlink" title="树的遍历 Tree Traversal"></a>树的遍历 Tree Traversal</h4><h5 id="前序遍历-Preorder-Traversal"><a href="#前序遍历-Preorder-Traversal" class="headerlink" title="前序遍历 Preorder Traversal"></a>前序遍历 Preorder Traversal</h5><h5 id="中序遍历-Inorder-Traversal"><a href="#中序遍历-Inorder-Traversal" class="headerlink" title="中序遍历 Inorder Traversal"></a>中序遍历 Inorder Traversal</h5><h5 id="后序遍历-Postorder-Traversal"><a href="#后序遍历-Postorder-Traversal" class="headerlink" title="后序遍历 Postorder Traversal"></a>后序遍历 Postorder Traversal</h5><h4 id="实践练习-2"><a href="#实践练习-2" class="headerlink" title="实践练习"></a>实践练习</h4><ul><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/">Check Completeness of a Binary Tree (958)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">Balanced Binary Tree (110)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">Symmetric Tree (101)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">Insert into a Binary Search Tree (701)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree (104)</a></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>今天我们就来学习“数据结构入门系列”中最后一个数据结构“图”。图是很常用的数据结构，比如计算机网络、社交网络、谷歌地图都需要用到此数据结构，掌握图的知识可以完善我们的数据结构知识体系，也能帮助我们解决算法中更为复杂的问题。</p><p>简单来说，图是一种用来表示相连数据的数据结构，类似我们的社交网络，图中有很多的节点，每个节点代表一个数据，每个节点可以和其他节点相连。其中每个节点叫做顶点（vertice），连接顶点之间的线叫做相连线（edge）。下图就是一个用来表示社交网络的图数据结构：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph1.jpg"></p><p>在此图中，我们含有5个顶点和6条相连线，每个顶点包含了人名，而连接线代表相连人名之间是朋友关系。如果我们要更正式地表示图，那么图就可以用一对（V，E）集合来表示，其中V是一堆顶点的集合，而E是一堆相连线的集合，请看下图：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph2.jpg"></p><p>在此图中：V = {a, b, c, d, e}，E = {ab, ac, bd, cd, de}</p><p>上面提到的图是无向图，而常见的图有以下三种：</p><ol><li>无向图（Undirected Graph）：在无向图中，每个顶点和其他顶点通过相连线连接。</li><li>有向图（Directed Graph）：有向图中的相连线是有方向的。</li><li>权重图（Weighted Graph）：在权重图中，每条相连线有各自的权重。</li></ol><p>下图是有向图：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph3.jpg"></p><p>此图可以用来表示用户之间相互关注的情况，如果Mark指向Alice，则代表Mark关注了Alice。下图是权重图：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph4.jpg"></p><p>此图可以用来表示两个好友之间的亲密程度，数值越高代表越亲密。可见不同的图可以用来表示不同的关系，而有向图是最常见的图，我们接下来就来实现有向图。</p><h4 id="有向图的实现（Directed-Graph）"><a href="#有向图的实现（Directed-Graph）" class="headerlink" title="有向图的实现（Directed Graph）"></a>有向图的实现（Directed Graph）</h4><p>有向图的实现有两种，一种是用矩阵（Matrix）的形式来实现，另一种是用链表（List）的形式来实现。</p><p>如果我们使用矩阵来实现有向图，来看一个例子：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph5.png"></p><p>每行代表相应的顶点，如果M[i][j] = 1，那么就代表顶点 i 连向 j，如果是0，则表达顶点间没有联系。用矩阵的方式来实现图的优势很明显，我们可以很快地判断两个顶点之间是否相连，可是用矩阵实现的空间复杂度很高，我们需要O(V^2)来记录所有的数据，不管顶点之间是否有相连线。为了解决空间复杂度的问题，我们可以使用链表的方式来实现图：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph6.png"></p><p>在链表实现中，我们实际上使用了储存链表的数组来表示图，图的左侧用数组来实现，代表我们的所有顶点，而每个顶点含有一个链表，链表上储存了该顶点指向的顶点。</p><h4 id="图的遍历（Graph-Traversal）"><a href="#图的遍历（Graph-Traversal）" class="headerlink" title="图的遍历（Graph Traversal）"></a>图的遍历（Graph Traversal）</h4><p>遍历图有两种常见的方式，一种是深度优先搜索（Depth-first Search），另一种是宽度优先搜索（Breadth-first search）。首先我们来学习深度优先搜索：</p><h5 id="深度优先搜索（Depth-First-Search）"><a href="#深度优先搜索（Depth-First-Search）" class="headerlink" title="深度优先搜索（Depth-First Search）"></a>深度优先搜索（Depth-First Search）</h5><p>图的深度优先和树的前序遍历（Pre-order Traversal）有点类似。在深度优先遍历中，我们假设初始状态所有顶点都没被访问，然后从每一顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发，深度优先遍历图，直到图中所有和v相通的顶点都被访问到。若遍历完后，还有其他顶点没被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，直到所有顶点都被访问完为止。</p><p>下面以“有向图”为例，来对深度优先搜索进行演示：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph7.png"></p><p>对于上面的图，我们从顶点A开始搜索：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph8-20210808212051082.png"></p><p>以下是具体的遍历步骤：</p><ol><li>访问A</li><li>访问B（在访问A之后，接下来应该访问的是A出发的另一个顶点，既顶点B）</li><li>访问C（在访问B之后，接下来访问的是从B出发的另一个顶点，既C，E，F。在此图中，我们按照字母排序顺序访问，因此先访问C。）</li><li>访问E（接下来访问与C连接的另一个顶点E。）</li><li>访问D（接下来访问从E出发的顶点B和D，因为B已被访问过，所以访问顶点D。）</li><li>访问F（接下来回溯“访问A的另一个连接顶点F”）</li><li>访问G</li></ol><p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G。</p><h5 id="广度优先搜索（Breadth-First-Search"><a href="#广度优先搜索（Breadth-First-Search" class="headerlink" title="广度优先搜索（Breadth-First Search)"></a>广度优先搜索（Breadth-First Search)</h5><p>广度优先搜索算法也叫做“宽度优先搜索”或“横向优先搜索”，其方法是从图中的某一顶点v出发，在访问了v之后依次访问v的各个没有访问到的邻接点，然后分别从这些邻接点出发依次访问他们的邻接点，使得先被访问的顶点的邻接点先与后被访问顶点的邻接点被访问，直到图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问到的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1，2，…的顶点。</p><p>下面以“有向图”为例，对广度优先搜索进行演示：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Graph9.png"></p><p>以下是访问步骤：</p><ol><li>访问A</li><li>访问B</li><li>依次访问C，E，F（在B被访问之后，接下来访问B的邻接点，既C，E，F。）</li><li>依次访问D，G（在访问完C，E，F之后，再依次访问他们出发的另一个顶点。还是按照C，E，F的顺序访问，C的已经全部访问过了，那么就只剩下E，E；先访问E的邻接点D，再访问F的邻接点G。</li></ol><p>访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G。</p><p>以上就是图的两种遍历方法：深度优先遍历和广度优先遍历。简单来说，深度优先遍历就是选择一条路径走到头再回来，而广度深度优先就是将最近的邻接点先访问完，再向更远的顶点延伸。</p><h4 id="实践练习-3"><a href="#实践练习-3" class="headerlink" title="实践练习"></a>实践练习</h4><ul><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/island-perimeter/">Island Perimeter (463)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/">Number of Islands (200)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-area-of-island/">Max Area of Island (695)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-closed-islands/">Number of Closed Islands (1254)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotting-oranges/">Rotting Oranges (994)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sliding-puzzle/">Sliding Puzzle (773)</a></li></ul></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8add02f4.html" rel="bookmark">剑指Offer(专项突破版)</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/dd921d98.html" rel="bookmark">剑指Offer</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8069546e.html" rel="bookmark">Stack</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Cpp/" rel="tag"># Cpp</a> <a href="/tags/LeetCode/" rel="tag"># LeetCode</a> <a href="/tags/Algorithm/" rel="tag"># Algorithm</a> <a href="/tags/Online-Judge/" rel="tag"># Online Judge</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/cd937a95.html" rel="prev" title="Linked List"><i class="fa fa-chevron-left"></i> Linked List</a></div><div class="post-nav-item"><a href="/archives/ae471f92.html" rel="next" title="一场华丽盛大的地下世界演出--Hollow Knight">一场华丽盛大的地下世界演出--Hollow Knight <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">什么是数据结构？什么是算法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.</span> <span class="nav-text">数据结构和算法之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E2%80%9D%E6%9C%89%E9%82%A3%E4%B9%88%E9%87%8D%E8%A6%81%E5%90%97%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">“数据结构和算法”有那么重要吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2"><span class="nav-number">2.4.</span> <span class="nav-text">课程大纲</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7"><span class="nav-number">3.2.</span> <span class="nav-text">常用的时间复杂度量级</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E6%95%B0%E9%98%B6O-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">常数阶O(1)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E9%98%B6O-n"><span class="nav-number">3.2.2.</span> <span class="nav-text">线性阶O(n)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E9%98%B6O-logN"><span class="nav-number">3.2.3.</span> <span class="nav-text">对数阶O(logN)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%AF%B9%E6%95%B0%E9%98%B6O-nlogN"><span class="nav-number">3.2.4.</span> <span class="nav-text">线性对数阶O(nlogN)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B3%E6%96%B9%E9%98%B6O-n%C2%B2"><span class="nav-number">3.2.5.</span> <span class="nav-text">平方阶O(n²)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.3.</span> <span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.4.</span> <span class="nav-text">常用的空间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#O-1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.4.1.</span> <span class="nav-text">O(1)空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#O-n-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.5.</span> <span class="nav-text">O(n)空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertion-Sort"><span class="nav-number">4.1.</span> <span class="nav-text">插入排序 Insertion Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.1.2.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.3.</span> <span class="nav-text">C++实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="nav-number">4.1.4.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92-QuickSort"><span class="nav-number">4.2.</span> <span class="nav-text">快排 QuickSort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">4.2.3.</span> <span class="nav-text">C++实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="nav-number">4.2.4.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-MergeSort"><span class="nav-number">4.3.</span> <span class="nav-text">归并排序 MergeSort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="nav-number">4.3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4-2"><span class="nav-number">4.3.2.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">4.3.3.</span> <span class="nav-text">C++实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="nav-number">4.3.4.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0"><span class="nav-number">4.4.</span> <span class="nav-text">实践练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">堆栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">堆栈（Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="nav-number">5.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.2.</span> <span class="nav-text">数组栈实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.3.</span> <span class="nav-text">链式栈实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">队列（Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="nav-number">5.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.2.</span> <span class="nav-text">数组队列实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.3.</span> <span class="nav-text">链式队列实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0-1"><span class="nav-number">5.3.</span> <span class="nav-text">实践练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86"><span class="nav-number">6.</span> <span class="nav-text">优先队列和堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">7.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">8.1.</span> <span class="nav-text">树的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">8.2.</span> <span class="nav-text">树的种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88Binary-Search-Tree%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.</span> <span class="nav-text">二分查找树（Binary Search Tree）的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-Tree-Traversal"><span class="nav-number">8.4.</span> <span class="nav-text">树的遍历 Tree Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-Preorder-Traversal"><span class="nav-number">8.4.1.</span> <span class="nav-text">前序遍历 Preorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-Inorder-Traversal"><span class="nav-number">8.4.2.</span> <span class="nav-text">中序遍历 Inorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-Postorder-Traversal"><span class="nav-number">8.4.3.</span> <span class="nav-text">后序遍历 Postorder Traversal</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0-2"><span class="nav-number">8.5.</span> <span class="nav-text">实践练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">9.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88Directed-Graph%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">有向图的实现（Directed Graph）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88Graph-Traversal%EF%BC%89"><span class="nav-number">9.2.</span> <span class="nav-text">图的遍历（Graph Traversal）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88Depth-First-Search%EF%BC%89"><span class="nav-number">9.2.1.</span> <span class="nav-text">深度优先搜索（Depth-First Search）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88Breadth-First-Search"><span class="nav-number">9.2.2.</span> <span class="nav-text">广度优先搜索（Breadth-First Search)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0-3"><span class="nav-number">9.3.</span> <span class="nav-text">实践练习</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">277</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.1m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//img.yousazoe.top/cdn/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//img.yousazoe.top/cdn/lazyload.min.js"></script><script src="//img.yousazoe.top/cdn/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="/lib/three/three.min.js"></script><script defer="" src="img.yousazoe.top/cdn/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//img.yousazoe.top/cdn/mathjax.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script async="" src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script>!function(t,h,e,j){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:2272201,hjsv:6},e=h.getElementsByTagName("head")[0],(j=h.createElement("script")).async=1,j.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,e.appendChild(j)}(window,document)</script><script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
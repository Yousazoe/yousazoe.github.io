<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Twitter@IncursioArt            引言游戏开发一直是热门的领域，掌握良好的游戏编程模式是开发人员的应备技能，本书细致地讲解了游戏开发需要用到的各种编程模式，并提供了丰富的示例。本章关于行为模式的介绍。"><meta property="og:type" content="article"><meta property="og:title" content="行为模式"><meta property="og:url" content="https://yousazoe.top/archives/f0890d83.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Twitter@IncursioArt            引言游戏开发一直是热门的领域，掌握良好的游戏编程模式是开发人员的应备技能，本书细致地讲解了游戏开发需要用到的各种编程模式，并提供了丰富的示例。本章关于行为模式的介绍。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/E7TbYqhXEAsz7tt.jpeg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-numbers.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-ast.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-code.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-literal.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-stack-1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-stack-2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-stack-3.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-ui.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/type-object-subclasses.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/arrow-inherits-20210801094623523.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/type-object-breed.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/arrow-references.png"><meta property="article:published_time" content="2021-07-31T16:41:44.000Z"><meta property="article:modified_time" content="2024-09-20T06:41:14.094Z"><meta property="article:author" content="Yousazoe"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/E7TbYqhXEAsz7tt.jpeg"><link rel="canonical" href="https://yousazoe.top/archives/f0890d83.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>行为模式 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/f0890d83.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">行为模式</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-08-01 00:41:44" itemprop="dateCreated datePublished" datetime="2021-08-01T00:41:44+08:00">2021-08-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Game-Programming-Patterns/" itemprop="url" rel="index"><span itemprop="name">游戏设计模式 (Game Programming Patterns)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>33k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>1:01</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/E7TbYqhXEAsz7tt.jpeg"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://twitter.com/IncursioArt/status/1420001227522379799">Twitter@IncursioArt</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>游戏开发一直是热门的领域，掌握良好的游戏编程模式是开发人员的应备技能，本书细致地讲解了游戏开发需要用到的各种编程模式，并提供了丰富的示例。本章关于行为模式的介绍。</p><span id="more"></span><p>一旦做好游戏设定，在里面装满了角色和道具，剩下的就是启动场景。 为了完成这点，你需要行为——告诉游戏中每个实体做什么的剧本。</p><p>当然，所有代码都是“行为”，并且所有软件都是定义行为的， 但在游戏中有所不同的是，行为通常很多。 文字处理器也许有很长的特性清单， 但特性的数量与角色扮演游戏中的居民，物品和任务数量相比，那就相形见绌了。</p><p>本章的模式有助于快速定义和完善大量的行为。 类型对象定义行为的类别而无需完成真正的类。 子类沙盒定义各种行为的安全原语。 最先进的是字节码，将行为从代码中分离，放入数据文件中。</p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p>将行为编码为虚拟机器上的指令，赋予其数据的灵活性。</p><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>制作游戏也许很有趣，但绝不容易。 现代游戏的代码库很是庞杂。 主机厂商和应用市场有严格的质量要求， 小小的崩溃漏洞就能阻止游戏发售。</p><blockquote><p>我曾参与制作有六百万行C++代码的游戏。作为对比，控制好奇号火星探测器的软件还没有其一半大小。</p></blockquote><p>与此同时，我们希望榨干平台的每一点性能。 游戏对硬件发展的推动首屈一指，只有坚持不懈地优化才能跟上竞争。</p><p>为了保证稳定和性能的需求，我们使用如C++这样的重量级的编程语言，它既有能兼容多数硬件的底层表达能力，又拥有防止漏洞的强类型系统。</p><p>我们对自己的专业技能充满自信，但其亦有代价。 专业程序员需要多年的训练，之后又要对抗代码规模的增长。 构建大型游戏的时间长度可以在“喝杯咖啡”和 “烤咖啡豆，手磨咖啡豆，弄杯espresso，打奶泡，在拿铁咖啡里拉花。”之间变动。</p><p>除开这些挑战，游戏还多了个苛刻的限制：“乐趣”。 玩家需要仔细权衡过的新奇体验。 这需要不断的迭代，但是如果每个调整都需要让工程师修改底层代码，然后等待漫长的编译结束，那就毁掉了创作流程。</p><h5 id="法术战斗！"><a href="#法术战斗！" class="headerlink" title="法术战斗！"></a>法术战斗！</h5><p>假设我们在完成一个基于法术的格斗游戏。 两个敌对的巫师互相丢法术，直到分出胜负。 我们可以将这些法术都定义在代码中，但这就意味着每次修改法术都会牵扯到工程师。 当设计者想修改几个数字感觉一下效果，就要重新编译整个工程，重启，然后进入战斗。</p><p>像现在的许多游戏一样，我们也需要在发售之后更新游戏，修复漏洞或是添加新内容。 如果所有法术都是硬编码的，那么每次修改都意味着要给游戏的可执行文件打补丁。</p><p>再扯远一点，假设我们还想支持模组。我们想让玩家创造自己的法术。 如果这些法术都是硬编码的，那就意味着每个模组制造者都得拥有编译游戏的整套工具链， 我们也就不得不开放源代码，如果他们的自创法术上有个漏洞，那么就会把其他人的游戏也搞崩溃。</p><h5 id="数据-gt-代码"><a href="#数据-gt-代码" class="headerlink" title="数据 > 代码"></a>数据 &gt; 代码</h5><p>很明显实现引擎的编程语言不是个好选择。 我们需要将法术放在与游戏核心隔绝的沙箱中。 我们想要它们易于修改，易于加载，并与其他可执行部分相隔离。</p><p>我不知道你怎么想，但这听上去让我觉得有点像是数据。 如果能在分离的数据文件中定义行为，游戏引擎还能加载并“执行”它们，就可以实现所有目标。</p><p>这里需要指出“执行”对于数据的意思。如何让文件中的数据表示为行为呢？这里有几种方式。 与解释器模式对比着看会好理解些。</p><h5 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h5><p>关于这个模式我就能写整整一章，但是有四个家伙的工作早涵盖了这一切， 所以，这里给一些简短的介绍。</p><p>它源于一种你想要执行的语言——想想编程语言。</p><p>比如，它支持这样的算术表达式</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(1 + 2) * (3 - 4)</span><br></pre></td></tr></tbody></table></figure><p>然后，把每块表达式，每条语言规则，都装到对象中去。数字字面量都变成对象：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-numbers.png"></p><p>简单地说，它们在原始值上做了个小封装。 运算符也是对象，它们拥有操作数的引用。 如果你考虑了括号和优先级，那么表达式就魔术般变成这样的小树：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-ast.png"></p><p>解释器模式与创建这棵树无关，它只关于执行这棵树。 它工作的方式非常巧妙。树中的每个对象都是表达式或子表达式。 用真正面向对象的方式描述，我们会让表达式自己对自己求值。</p><blockquote><p>这里的“魔术”是什么？很简单——语法分析。 语法分析器接受一串字符作为输入，将其转为抽象语法树，即一个包含了表示文本语法结构的对象集合。</p><p>完成这个你就得到了半个编译器。</p></blockquote><p>首先，我们定义所有表达式都实现的基本接口：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() {}</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">evaluate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然后，为我们语言中的每种语法定义一个实现这个接口的类。最简单的是数字：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExpression</span> : <span class="keyword">public</span> Expression</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NumberExpression</span>(<span class="type">double</span> value)</span><br><span class="line">  : <span class="built_in">value_</span>(value)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">evaluate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> value_;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> value_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>一个数字表达式就等于它的值。加法和乘法有点复杂，因为它们包含子表达式。在一个表达式计算自己的值之前，必须先递归地计算其子表达式的值。像这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdditionExpression</span> : <span class="keyword">public</span> Expression</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AdditionExpression</span>(Expression* left, Expression* right)</span><br><span class="line">  : <span class="built_in">left_</span>(left),</span><br><span class="line">    <span class="built_in">right_</span>(right)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">evaluate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 计算操作数</span></span><br><span class="line">    <span class="type">double</span> left = left_-&gt;<span class="built_in">evaluate</span>();</span><br><span class="line">    <span class="type">double</span> right = right_-&gt;<span class="built_in">evaluate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把它们加起来</span></span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Expression* left_;</span><br><span class="line">  Expression* right_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>很优雅对吧？只需几个简单的类，现在我们可以表示和计算任意复杂的算术表达式。 只需要创建正确的对象，并正确地连起来。</p><blockquote><p>你肯定能想明白乘法的实现是什么样的。</p></blockquote><p>这是个优美、简单的模式，但它有一些问题。 看看插图，看到了什么？大量的小盒子，以及它们之间大量的箭头。 代码被表示为小物体组成的巨大分形树。这会带来些令人不快的后果：</p><blockquote><p>Ruby用了这种实现方法差不多15年。在1.9版本，他们转换到了本章所介绍的字节码。看看我给你节省了多少时间！</p></blockquote><ul><li><p>从磁盘上加载它需要实例化并连接成吨的小对象。</p></li><li><p>这些对象和它们之间的指针会占据大量的内存。在32位机上，那个小的算术表达式至少要占据68字节，这还没考虑内存对其呢。</p></li></ul><blockquote><p>如果你想自己算算，别忘了算上虚函数表指针。</p></blockquote><ul><li>顺着那些指针遍历子表达式是对数据缓存的谋杀。同时，虚函数调用是对指令缓存的屠戮。</li></ul><blockquote><p>参见数据局部性一章以了解什么是缓存以及它是如何影响游戏性能的。</p></blockquote><p>将这些拼到一起，怎么念？S-L-O-W。 这就是为什么大多数广泛应用的编程语言不基于解释器模式： 太慢了，也太消耗内存了。</p><h5 id="虚拟的机器码"><a href="#虚拟的机器码" class="headerlink" title="虚拟的机器码"></a>虚拟的机器码</h5><p>想想我们的游戏。玩家电脑在运行游戏时并不会遍历一堆C++语法结构树。 我们提前将其编译成了机器码，CPU基于机器码运行。机器码有什么好处呢？</p><ul><li>密集。 它是一块坚实连续的二进制数据块，没有一位被浪费。</li><li>线性。 指令被打成包，一条接一条地执行。不会在内存里到处乱跳（除非你的控制流代码真真这么干了）。</li><li>底层。 每条指令都做一件小事，有趣的行为从组合中诞生。</li><li>速度快。 综合所有这些条件（当然，也包括它直接由硬件实现这一事实），机器码跑得跟风一样快。</li></ul><p>这听起来很好，但我们不希望真的用机器代码来写咒语。 让玩家提供游戏运行时的机器码简直是在自找麻烦。我们需要的是机器代码的性能和解释器模式的安全的折中。</p><p>如果不是加载机器码并直接执行，而是定义自己的虚拟机器码呢？ 然后，在游戏中写个小模拟器。 这与机器码类似——密集，线性，相对底层——但也由游戏直接掌控，所以可以放心地将其放入沙箱。</p><p>我们将小模拟器称为虚拟机（或简称“VM”），它运行的二进制机器码叫做字节码。 它有数据的灵活性和易用性，但比解释器模式性能更好。</p><p>这听起来有点吓人。 这章其余部分的目标是为了展示一下，如果把功能列表缩减下来，它实际上相当通俗易懂。 即使最终没有使用这个模式，你也至少可以对Lua和其他使用了这一模式的语言有个更好的理解。</p><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>指令集 定义了可执行的底层操作。 一系列的指令被编码为字节序列。 虚拟机 使用 中间值栈 依次执行这些指令。 通过组合指令，可以定义复杂的高层行为。</p><h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><p>这是本书中最复杂的模式，无法轻易地加入游戏中。这个模式应当用在你有许多行为需要定义，而游戏实现语言因为如下原因不适用时：</p><ul><li>过于底层，繁琐易错。</li><li>编译慢或者其他工具因素导致迭代缓慢。</li><li>安全性依赖编程者。如果想保证行为不会破坏游戏，你需要将其与代码的其他部分隔开。</li></ul><p>当然，该列表描述了一堆特性。谁不希望有更快的迭代循环和更多的安全性？ 然而，世上没有免费的午餐。字节码比本地代码慢，所以不适合引擎的性能攸关的部分。</p><h4 id="记住"><a href="#记住" class="headerlink" title="记住"></a>记住</h4><p>创建自己的语言或者建立系统中的系统是很有趣的。 我在这里做的是小演示，但在现实项目中，这些东西会像藤蔓一样蔓延。</p><blockquote><p>对我来说，游戏开发也正因此而有趣。 不管哪种情况，我都创建了虚拟空间让他人游玩。</p></blockquote><p>每当我看到有人定义小语言或脚本系统，他们都说，“别担心，它很小。” 于是，不可避免地，他们增加更多小功能，直到完成了一个完整的语言。 除了，和其它语言不同，它是定制的并拥有棚户区的建筑风格。</p><blockquote><p>例如每一种模板语言。</p></blockquote><p>当然，完成完整的语言并没有什么<em>错</em>。只是要确定你做得慎重。 否则，你就要小心地控制你的字节码所能表达的范围。在野马脱缰之前把它拴住。</p><h5 id="你需要一个前端"><a href="#你需要一个前端" class="headerlink" title="你需要一个前端"></a>你需要一个前端</h5><p>底层的字节码指令性能优越，但是二进制的字节码格式不是用户能写的。 我们将行为移出代码的一个原因是想要以更高层的形式表示它。 如果说写C++太过底层，那么让用户写汇编可不是一个改进方案——就算是你设计的！</p><blockquote><p>一个反例的是令人尊敬的游戏<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/RoboWar">RoboWar</a>。 在游戏中，<em>玩家</em> 编写类似汇编的语言控制机器人，我们这里也会讨论这种指令集。</p></blockquote><p>这是我介绍类似汇编的语言的首选。</p><p>就像GoF的解释器模式，它假设你有某些方法来生成字节码。 通常情况下，用户在更高层编写行为，再用工具将其翻译为虚拟机能理解的字节码。 这里的工具就是编译器。</p><p>我知道，这听起来很吓人。丑话说在前头， 如果没有资源制作编辑器，那么字节码不适合你。 但是，接下来你会看到，也可能没你想的那么糟。</p><h5 id="你会想念调试器"><a href="#你会想念调试器" class="headerlink" title="你会想念调试器"></a>你会想念调试器</h5><p>编程很难。我们知道想要机器做什么，但并不总能正确地传达——所以我们会写出漏洞。 为了查找和修复漏洞，我们已经积累了一堆工具来了解代码做错了什么，以及如何修正。 我们有调试器，静态分析器，反编译工具等。 所有这些工具都是为现有的语言设计的：无论是机器码还是某些更高层次的东西。</p><p>当你定义自己的字节码虚拟机时，你就得把这些工具抛在脑后了。 当然，可以通过调试器调试虚拟机，但它告诉你虚拟机本身在做什么，而不是正在被翻译的字节码是干什么的。</p><p>它当然也不会把字节码映射回编译前的高层次的形式。</p><p>如果你定义的行为很简单，可能无需太多工具帮忙调试就能勉强坚持下来。 但随着内容规模增长，还是应该花些时间完成些功能，让用户看到字节码在做什么。 这些功能也许不随游戏发布，但它们至关重要，它们能确保你的游戏能被发布。</p><blockquote><p>当然，如果你想要让游戏支持模组，那你会发布这些特性，它们就更加重要了。</p></blockquote><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>经历了前面几个章节后，你也许会惊讶于它的实现是多么直接。 首先需要为虚拟机设定一套指令集。 在开始考虑字节码之类的东西前，先像思考API一样思考它。</p><h5 id="法术的API"><a href="#法术的API" class="headerlink" title="法术的API"></a>法术的API</h5><p>如果直接使用C++代码定义法术，代码需要调用何种API呢？ 在游戏引擎中，构成法术的基本操作是什么样的？</p><p>大多数法术最终改变一个巫师的状态，因此先从这样的代码开始。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHealth</span><span class="params">(<span class="type">int</span> wizard, <span class="type">int</span> amount)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWisdom</span><span class="params">(<span class="type">int</span> wizard, <span class="type">int</span> amount)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAgility</span><span class="params">(<span class="type">int</span> wizard, <span class="type">int</span> amount)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>第一个参数指定哪个巫师被影响，<code>0</code>代表玩家而<code>1</code>代表对手。 以这种方式，治愈法术可以治疗玩家的巫师，而伤害法术伤害他的敌人。 这三个小方法能覆盖的法术出人意料地多。</p><p>如果法术只是默默地调整数据，游戏逻辑就已经完成了， 但玩这样的游戏会让玩家无聊得要哭。让我们修复这点：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">playSound</span><span class="params">(<span class="type">int</span> soundId)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spawnParticles</span><span class="params">(<span class="type">int</span> particleType)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>这并不影响游戏玩法，但它们增强了游戏的体验。 我们可以增加一些镜头晃动，动画之类的，但这足够我们开始了。</p><h5 id="法术指令集"><a href="#法术指令集" class="headerlink" title="法术指令集"></a>法术指令集</h5><p>现在让我们把这种程序化的API转化为可被数据控制的东西。 从小处开始，然后慢慢拓展到整体。 现在，要去除方法的所有参数。 假设<code>set__()</code>方法总影响玩家的巫师，总直接将状态设为最大值。 同样，FX操作总是播放一个硬编码的声音和粒子效果。</p><p>这样，一个法术就只是一系列指令了。 每条指令都代表了想要呈现的操作。我们可以枚举如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Instruction</span></span><br><span class="line">{</span><br><span class="line">  INST_SET_HEALTH      = <span class="number">0x00</span>,</span><br><span class="line">  INST_SET_WISDOM      = <span class="number">0x01</span>,</span><br><span class="line">  INST_SET_AGILITY     = <span class="number">0x02</span>,</span><br><span class="line">  INST_PLAY_SOUND      = <span class="number">0x03</span>,</span><br><span class="line">  INST_SPAWN_PARTICLES = <span class="number">0x04</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>为了将法术编码进数据，我们存储了一数组<code>enum</code>值。 只有几个不同的基本操作原语，因此<code>enum</code>值的范围可以存储到一个字节中。 这就意味着法术的代码就是一系列字节——也就是“字节码”。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-code.png"></p><p>为了执行一条指令，我们看看它的基本操作原语是什么，然后调用正确的API方法。</p><blockquote><p>有些字节码虚拟机为每条指令使用多个字节，解码规则也更复杂。 事实上，在x86这样的常见芯片上的机器码更加复杂。</p><p>但单字节对于<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Java_virtual_machine">Java虚拟机</a>和支撑了.NET平台的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime</a>已经足够了，对我们来说也一样。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (instruction)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">case</span> INST_SET_HEALTH:</span><br><span class="line">    <span class="built_in">setHealth</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> INST_SET_WISDOM:</span><br><span class="line">    <span class="built_in">setWisdom</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> INST_SET_AGILITY:</span><br><span class="line">    <span class="built_in">setAgility</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> INST_PLAY_SOUND:</span><br><span class="line">    <span class="built_in">playSound</span>(SOUND_BANG);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> INST_SPAWN_PARTICLES:</span><br><span class="line">    <span class="built_in">spawnParticles</span>(PARTICLE_FLAME);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用这种方式，解释器建立了沟通代码世界和数据世界的桥梁。我们可以像这样将其放进执行法术的虚拟机：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VM</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">interpret</span><span class="params">(<span class="type">char</span> bytecode[], <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    {</span><br><span class="line">      <span class="type">char</span> instruction = bytecode[i];</span><br><span class="line">      <span class="keyword">switch</span> (instruction)</span><br><span class="line">      {</span><br><span class="line">        <span class="comment">// 每条指令的跳转分支……</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>输入这些，你就完成了你的首个虚拟机。 不幸的是，它并不灵活。 我们不能设定攻击对手的法术，也不能减少状态上限。我们只能播放声音！</p><p>为了获得像一个真正的语言那样的表达能力，我们需要在这里引入参数。</p><h5 id="栈式机器"><a href="#栈式机器" class="headerlink" title="栈式机器"></a>栈式机器</h5><p>要执行复杂的嵌套表达式，得先从最里面的子表达式开始。 计算完里面的，将结果作为参数向外流向包含它们的表达式， 直到得出最终结果，整个表达式就算完了。</p><p>解释器模式将其明确地表现为嵌套对象组成的树，但我们需要指令速度达到列表的速度。我们仍然需要确保子表达式的结果正确地向外传递给包括它的表达式。</p><p>但由于数据是扁平的，我们得使用指令的顺序来控制这一点。我们的做法和CPU一样——使用栈。</p><blockquote><p>这种架构不出所料地被称为<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Stack_machine"><em>栈式计算机</em></a>。像<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a>，<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/PostScript">PostScript</a>，和<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Factor_(programming_language)">Factor</a> 这些语言直接将这点暴露给用户。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VM</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VM</span>()</span><br><span class="line">  : <span class="built_in">stackSize_</span>(<span class="number">0</span>)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_STACK = <span class="number">128</span>;</span><br><span class="line">  <span class="type">int</span> stackSize_;</span><br><span class="line">  <span class="type">int</span> stack_[MAX_STACK];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>虚拟机用内部栈保存值。在例子中，指令交互的值只有一种，那就是数字， 所以可以使用简单的<code>int</code>数组。 每当数据需要从一条指令传到另一条，它就得通过栈。</p><p>顾名思义，值可以压入栈或者从栈弹出，所以让我们添加一对方法。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VM</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 检查栈溢出</span></span><br><span class="line">    <span class="built_in">assert</span>(stackSize_ &lt; MAX_STACK);</span><br><span class="line">    stack_[stackSize_++] = value;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 保证栈不是空的</span></span><br><span class="line">    <span class="built_in">assert</span>(stackSize_ &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> stack_[--stackSize_];</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其余的代码</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>当一条指令需要接受参数，就将参数从栈弹出，如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (instruction)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">case</span> INST_SET_HEALTH:</span><br><span class="line">  {</span><br><span class="line">    <span class="type">int</span> amount = <span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> wizard = <span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">setHealth</span>(wizard, amount);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> INST_SET_WISDOM:</span><br><span class="line">  <span class="keyword">case</span> INST_SET_AGILITY:</span><br><span class="line">    <span class="comment">// 像上面一样……</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> INST_PLAY_SOUND:</span><br><span class="line">    <span class="built_in">playSound</span>(<span class="built_in">pop</span>());</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> INST_SPAWN_PARTICLES:</span><br><span class="line">    <span class="built_in">spawnParticles</span>(<span class="built_in">pop</span>());</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了将一些值<em>存入</em>栈中，需要另一条指令：字面量。 它代表了原始的整数值。但是<em>它</em>的值又是从哪里来的呢？ 我们怎么样避免这样追根溯源到无穷无尽呢？</p><p>技巧是利用指令是字节序列这一事实——我们可以直接将数值存储在字节数组中。 如下，我们为数值字面量定义了另一条指令类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> INST_LITERAL:</span><br><span class="line">{</span><br><span class="line">  <span class="comment">// 从字节码中读取下一个字节</span></span><br><span class="line">  <span class="type">int</span> value = bytecode[++i];</span><br><span class="line">  <span class="built_in">push</span>(value);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里，从单个字节中读取值，从而避免了解码多字节整数需要的代码， 但在真实实现中，你会需要支持整个数域的字面量。</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-literal.png"></p><p>它读取字节码流中的字节作为数值并将其压入栈。</p><p>让我们把一些这样的指令串起来看看解释器的执行，感受下栈是如何工作的。 从空栈开始，解释器指向第一个指令：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-stack-1.png"></p><p>首先，它执行第一条<code>INST_LITERAL</code>，读取字节码流的下一个字节(<code>0</code>)并压入栈中。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-stack-2.png"></p><p>然后，它执行第二条<code>INST_LITERAL</code>，读取<code>10</code>然后压入。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-stack-3.png"></p><p>最后，执行<code>INST_SET_HEALTH</code>。这会弹出<code>10</code>存进<code>amount</code>，弹出<code>0</code>存进<code>wizard</code>。然后用这两个参数调用<code>setHealth()</code>。</p><p>完成！我们获得了将玩家巫师血量设为10点的法术。 现在我们拥有了足够的灵活度，来定义修改任一巫师的状态到任意值的法术。 我们还可以放出不同的声音和粒子效果。</p><p>但是……这感觉还是像数据格式。比如，不能将巫师的血量提升为他智力的一半。 设计师希望法术能表达规则，而不仅仅是数值。</p><h5 id="行为-x3D-组合"><a href="#行为-x3D-组合" class="headerlink" title="行为 = 组合"></a>行为 = 组合</h5><p>如果我们视小虚拟机为编程语言，现在它能支持的只有一些内置函数，以及常量参数。 为了让字节码感觉像行为，我们缺少的是组合。</p><p>设计师需要能以有趣的方式组合不同的值，来创建表达式。 举个简单的例子，他们想让法术变化一个数值而不是变到一个数值。</p><p>这需要考虑到状态的当前值。 我们有指令来修改状态，现在需要添加方法读取状态：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> INST_GET_HEALTH:</span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> wizard = <span class="built_in">pop</span>();</span><br><span class="line">  <span class="built_in">push</span>(<span class="built_in">getHealth</span>(wizard));</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> INST_GET_WISDOM:</span><br><span class="line"><span class="keyword">case</span> INST_GET_AGILITY:</span><br><span class="line">  <span class="comment">// 你知道思路了吧……</span></span><br></pre></td></tr></tbody></table></figure><p>正如你所看到的，这要与栈双向交互。 弹出一个参数来确定获取哪个巫师的状态，然后查找状态的值并压入栈中。</p><p>这允许我们创造复制状态的法术。 我们可以创建一个法术，根据巫师的智慧设定敏捷度，或者让巫师的血量等于对方的血量。</p><p>有所改善，但仍很受限制。接下来，我们需要算术。 是时候让小虚拟机学习如何计算1 + 1了，我们将添加更多的指令。 现在，你可能已经知道如何去做，猜到了大概的模样。我只展示加法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> INST_ADD:</span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> b = <span class="built_in">pop</span>();</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">pop</span>();</span><br><span class="line">  <span class="built_in">push</span>(a + b);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>像其他指令一样，它弹出数值，做点工作，然后压入结果。 直到现在，每个新指令似乎都只是有所改善而已，但其实我们已完成大飞跃。 这并不显而易见，但现在我们可以处理各种复杂的，深层嵌套的算术表达式了。</p><p>来看个稍微复杂点的例子。 假设我们希望有个法术，能让巫师的血量增加敏捷和智慧的平均值。 用代码表示如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">setHealth</span>(<span class="number">0</span>, <span class="built_in">getHealth</span>(<span class="number">0</span>) +</span><br><span class="line">    (<span class="built_in">getAgility</span>(<span class="number">0</span>) + <span class="built_in">getWisdom</span>(<span class="number">0</span>)) / <span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">case INST_GET_HEALTH:</span><br><span class="line">{</span><br><span class="line">  int wizard = pop();</span><br><span class="line">  push(getHealth(wizard));</span><br><span class="line">  break;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">case INST_GET_WISDOM:</span><br><span class="line">case INST_GET_AGILITY:</span><br><span class="line">  // 你知道思路了吧……</span><br></pre></td></tr></tbody></table></figure><p>正如你所看到的，这要与栈双向交互。 弹出一个参数来确定获取哪个巫师的状态，然后查找状态的值并压入栈中。</p><p>这允许我们创造复制状态的法术。 我们可以创建一个法术，根据巫师的智慧设定敏捷度，或者让巫师的血量等于对方的血量。</p><p>有所改善，但仍很受限制。接下来，我们需要算术。 是时候让小虚拟机学习如何计算1 + 1了，我们将添加更多的指令。 现在，你可能已经知道如何去做，猜到了大概的模样。我只展示加法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> INST_ADD:</span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> b = <span class="built_in">pop</span>();</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">pop</span>();</span><br><span class="line">  <span class="built_in">push</span>(a + b);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>像其他指令一样，它弹出数值，做点工作，然后压入结果。 直到现在，每个新指令似乎都只是有所改善而已，但其实我们已完成大飞跃。 这并不显而易见，但现在我们可以处理各种复杂的，深层嵌套的算术表达式了。</p><p>来看个稍微复杂点的例子。 假设我们希望有个法术，能让巫师的血量增加敏捷和智慧的平均值。 用代码表示如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">setHealth</span>(<span class="number">0</span>, <span class="built_in">getHealth</span>(<span class="number">0</span>) +</span><br><span class="line">    (<span class="built_in">getAgility</span>(<span class="number">0</span>) + <span class="built_in">getWisdom</span>(<span class="number">0</span>)) / <span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">LITERAL <span class="number">0</span></span><br><span class="line">GET_HEALTH</span><br></pre></td></tr></tbody></table></figure><p>这些字节码将巫师的血量压入堆栈。 如果我们机械地将每行都这样转化，最终得到一大块等价于原来表达式的字节码。 为了让你感觉这些指令是如何组合的，我在下面给你做个示范。</p><p>为了展示堆栈如何随着时间推移而变化，我们举个代码执行的例子。 巫师目前有45点血量，7点敏捷，和11点智慧。 每条指令的右边是栈在执行指令之后的模样，再右边是解释指令意图的注释：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">LITERAL <span class="number">0</span>    [<span class="number">0</span>]            # 巫师索引</span><br><span class="line">LITERAL <span class="number">0</span>    [<span class="number">0</span>, <span class="number">0</span>]         # 巫师索引</span><br><span class="line">GET_HEALTH   [<span class="number">0</span>, <span class="number">45</span>]        # 获取血量()</span><br><span class="line">LITERAL <span class="number">0</span>    [<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>]     # 巫师索引</span><br><span class="line">GET_AGILITY  [<span class="number">0</span>, <span class="number">45</span>, <span class="number">7</span>]     # 获取敏捷()</span><br><span class="line">LITERAL <span class="number">0</span>    [<span class="number">0</span>, <span class="number">45</span>, <span class="number">7</span>, <span class="number">0</span>]  # 巫师索引</span><br><span class="line">GET_WISDOM   [<span class="number">0</span>, <span class="number">45</span>, <span class="number">7</span>, <span class="number">11</span>] # 获取智慧()</span><br><span class="line">ADD          [<span class="number">0</span>, <span class="number">45</span>, <span class="number">18</span>]    # 将敏捷和智慧加起来</span><br><span class="line">LITERAL <span class="number">2</span>    [<span class="number">0</span>, <span class="number">45</span>, <span class="number">18</span>, <span class="number">2</span>] # 被除数：<span class="number">2</span></span><br><span class="line">DIVIDE       [<span class="number">0</span>, <span class="number">45</span>, <span class="number">9</span>]     # 计算敏捷和智慧的平均值</span><br><span class="line">ADD          [<span class="number">0</span>, <span class="number">54</span>]        # 将平均值加到现有血量上。</span><br><span class="line">SET_HEALTH   []             # 将结果设为血量</span><br></pre></td></tr></tbody></table></figure><p>如果你注意每步的栈，你可以看到数据如何魔法一般地在其中流动。 我们最开始压入<code>0</code>来查找巫师，然后它一直挂在栈的底部，直到最终的<code>SET_HEALTH</code>才用到它。</p><blockquote><p>也许“魔法”在这里的门槛太低了。</p></blockquote><h5 id="一台虚拟机"><a href="#一台虚拟机" class="headerlink" title="一台虚拟机"></a>一台虚拟机</h5><p>我可以继续下去，添加越来越多的指令，但是时候适可而止了。 如上所述，我们已经有了一个可爱的小虚拟机，可以使用简单，紧凑的数据格式，定义开放的行为。 虽然“字节码”和“虚拟机”的听起来很吓人，但你可以看到它们往往简单到只需栈，循环，和switch语句。</p><p>还记得我们最初的让行为呆在沙盒中的目标吗？ 现在，你已经看到虚拟机是如何实现的，很明显，那个目标已经完成。 字节码不能把恶意触角伸到游戏引擎的其他部分，因为我们只定义了几个与其他部分接触的指令。</p><p>我们通过控制栈的大小来控制内存使用量，并很小心地确保它不会溢出。 我们甚至可以控制它使用多少时间。 在指令循环里，可以追踪已经执行了多少指令，如果遇到了问题也可以摆脱困境。</p><blockquote><p>控制运行时间在例子中没有必要，因为没有任何循环的指令。 可以限制字节码的总体大小来限制运行时间。 这也意味着我们的字节码不是图灵完备的。</p></blockquote><p>现在就剩一个问题了：创建字节码。 到目前为止，我们使用伪代码，再手工编写为字节码。 除非你有很多的空闲时间，否则这种方式并不实用。</p><h5 id="语法转换工具"><a href="#语法转换工具" class="headerlink" title="语法转换工具"></a>语法转换工具</h5><p>我们最初的目标是创造更高层的方式来控制行为，但是，我们却创造了比C++更底层的东西。 它具有我们想要的运行性能和安全性，但绝对没有对设计师友好的可用性。</p><p>为了填补这一空白，我们需要一些工具。 我们需要一个程序，让用户定义法术的高层次行为，然后生成对应的低层栈式机字节码。</p><p>这可能听起来比虚拟机更难。 许多程序员都在大学参加编译器课程，除了被龙书或者”<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Lex_(software)">lex</a>“和”<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Yacc">yacc</a>”引发了PTSD外，什么也没真正学到。</p><blockquote><p>我指的，当然，是经典教材<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"><em>Compilers: Principles, Techniques, and Tools</em></a>。</p></blockquote><p>事实上，编译一个基于文本的语言并不那么糟糕，尽管把这个话题放进这里来要牵扯的东西有点多。但是，你不是非得那么做。 我说，我们需要的是工具——它并不一定是个输入格式是文本文件的编译器。</p><p>相反，我建议你考虑构建图形界面让用户定义自己的行为， 尤其是在使用它的人没有很高的技术水平时。 没有花几年时间习惯编译器怒吼的人很难写出没有语法错误的文本。</p><p>你可以建立一个应用程序，用户通过单击拖动小盒子，下拉菜单项，或任何有意义的行为创建“脚本”，从而创建行为。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bytecode-ui.png"></p><blockquote><p>我为<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Henry_Hatsworth_in_the_Puzzling_Adventure">Henry Hatsworth in the Puzzling Adventure</a>编写的脚本系统就是这么工作的。</p></blockquote><p>这样做的好处是，你的UI可以保证用户无法创建“无效的”程序。 与其向他们吐一大堆错误警告，不如主动禁用按钮或提供默认值， 以确保他们创造的东西在任何时间点上都有效。</p><blockquote><p>我想要强调错误处理是多么重要。作为程序员，我们趋向于将人为错误视为应当极力避免的的个人耻辱。</p></blockquote><blockquote><p>为了制作用户喜欢的系统，你需要接受人性，包括他们的失败。是人都会犯错误，但错误同时也是创作的固有基础。 用撤销这样的特性优雅地处理它们，这能让用户更有创意，创作出更好的成果。</p></blockquote><p>这免去了设计语法和编写解析器的工作。 但是我知道，你可能会发现UI设计同样令人不快。 好吧，如果这样，我就没啥办法啦。</p><p>毕竟，这种模式是关于使用对用户友好的高层方式表达行为。 你必须精心设计用户体验。 要有效地执行行为，又需要将其转换成底层形式。这是必做的，但如果你准备好迎接挑战，这终会有所回报。</p><h4 id="设计决策"><a href="#设计决策" class="headerlink" title="设计决策"></a>设计决策</h4><p>我想尽可能让本章简短，但我们所做的事情实际上可是创造语言啊。 那可是个宽泛的设计领域，你可以从中获得很多乐趣，所以别沉迷于此反而忘了完成你的游戏。</p><h5 id="指令如何访问堆栈？"><a href="#指令如何访问堆栈？" class="headerlink" title="指令如何访问堆栈？"></a>指令如何访问堆栈？</h5><p>字节码虚拟机主要有两种：基于栈的和基于寄存器的。 栈式虚拟机中，指令总是操作栈顶，如同我们的示例代码所示。 例如，<code>INST_ADD</code>弹出两个值，将它们相加，将结果压入。</p><p>基于寄存器的虚拟机也有栈。唯一不同的是指令可以从栈的深处读取值。 不像<code>INST_ADD</code>始终弹出其操作数， 它在字节码中存储两个索引，指示了从栈的何处读取操作数。</p><ul><li><p><strong>基于栈的虚拟机：</strong></p><ul><li>指令短小。 由于每个指令隐式认定在栈顶寻找参数，不需要为任何数据编码。 这意味着每条指令可能会非常短，一般只需一个字节。</li><li>易于生成代码。 当你需要为生成字节码编写编译器或工具时，你会发现基于栈的字节码更容易生成。 由于每个指令隐式地在栈顶工作，你只需要以正确的顺序输出指令就可以在它们之间传递参数。</li><li>会生成更多的指令。 每条指令只能看到栈顶。这意味着，产生像<code>a = b + c</code>这样的代码， 你需要单独的指令将<code>b</code>和<code>c</code>压入栈顶，执行操作，再将结果压入<code>a</code>。</li></ul></li><li><p><strong>基于寄存器的虚拟机：</strong></p><ul><li>指令较长。 由于指令需要参数记录栈偏移量，单个指令需要更多的位。 例如，一个Lua指令占用完整的32位——它可能是最著名的基于寄存器的虚拟机了。 它采用6位做指令类型，其余的是参数。</li></ul></li></ul><blockquote><p>Lua作者没有指定Lua的字节码格式，它每个版本都会改变。现在描述的是Lua 5.1。 要深究Lua的内部构造， 读读<a target="_blank" rel="noopener" href="http://luaforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf">这个</a>。</p></blockquote><ul><li>指令较少。 由于每个指令可以做更多的工作，你不需要那么多的指令。 有人说，性能会得以提升，因为不需要将值在栈中移来移去了。</li></ul><p>所以，应该选一种？我的建议是坚持使用基于栈的虚拟机。 它们更容易实现，也更容易生成代码。 Lua转换为基于寄存器的虚拟机从而变得更快，这为寄存器虚拟机博得了声誉， 但是这<em>强烈</em>依赖于实际的指令和虚拟机的其他大量细节。</p><h5 id="你有什么指令？"><a href="#你有什么指令？" class="headerlink" title="你有什么指令？"></a>你有什么指令？</h5><p>指令集定义了在字节码中可以干什么，不能干什么，对虚拟机性能也有很大的影响。 这里有个清单，记录了你可能需要的不同种类的指令：</p><ul><li><p><strong>外部基本操作原语。</strong> 这是虚拟机与引擎其他部分交互，影响玩家所见的部分。 它们控制了字节码可以表达的真实行为。 如果没有这些，你的虚拟机除了消耗CPU循环以外一无所得。</p></li><li><p><strong>内部基本操作原语</strong> 这些语句在虚拟机内操作数值——文字，算术，比较操作，以及操纵栈的指令。</p></li><li><p><strong>控制流。</strong> 我们的例子没有包含这些，但当你需要有条件执行或循环执行，你就会需要控制流。 在字节码这样底层的语言中，它们出奇地简单：跳转。</p><p>在我们的指令循环中，需要索引来跟踪执行到了字节码的哪里。 跳转指令做的是修改这个索引并改变将要执行的指令。 换言之，这就是<code>goto</code>。你可以基于它制定各种更高级别的控制流。</p></li><li><p><strong>抽象。</strong> 如果用户开始在数据中定义<em>很多</em>的东西，最终要重用字节码的部分位，而不是复制和粘贴。 你也许会需要可调用过程这样的东西。</p><p>最简单的形式中，过程并不比跳转复杂。 唯一不同的是，虚拟机需要管理另一个<em>返回</em>栈。 当执行“call”指令时，将当前指令索引压入栈中，然后跳转到被调用的字节码。 当它到了“return”，虚拟机从堆栈弹出索引，然后跳回索引指示的位置。</p></li></ul><h5 id="数值是如何表示的？"><a href="#数值是如何表示的？" class="headerlink" title="数值是如何表示的？"></a>数值是如何表示的？</h5><p>我们的虚拟机示例只与一种数值打交道：整数。 回答这个问题很简单——栈只是一栈的<code>int</code>。 更加完整的虚拟机支持不同的数据类型：字符串，对象，列表等。 你必须决定在内部如何存储这些值。</p><ul><li><p><strong>单一数据类型：</strong></p><ul><li><strong>简单易用</strong> 你不必担心标记，转换，或类型检查。</li><li><strong>无法使用不同的数据类型。</strong> 这是明显的缺点。将不同类型成塞进单一的表示方式——比如将数字存储为字符串——这是自找麻烦。</li></ul></li><li><p><strong>带标记的类型：</strong></p><p>这是动态类型语言中常见的表示法。 所有的值有两部分。 第一部分是类型标识——一个存储了数据的类型的<code>enum</code>。其余部分会被解释为这种类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ValueType</span></span><br><span class="line">{</span><br><span class="line">  TYPE_INT,</span><br><span class="line">  TYPE_DOUBLE,</span><br><span class="line">  TYPE_STRING</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Value</span></span><br><span class="line">{</span><br><span class="line">  ValueType type;</span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  {</span><br><span class="line">    <span class="type">int</span>    intValue;</span><br><span class="line">    <span class="type">double</span> doubleValue;</span><br><span class="line">    <span class="type">char</span>*  stringValue;</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>数值知道其类型。</strong> 这个表示法的好处是可在运行时检查值的类型。 这对动态调用很重要，可以确保没有在类型上面执行其不支持的操作。</li><li><strong>消耗更多内存。</strong> 每个值都要带一些额外的位来标识类型。在像虚拟机这样的底层，这里几位，那里几位，总量就会快速增加。</li></ul></li><li><p><strong>无标识的union：</strong></p><p>像前面一样使用union，但是<em>没有</em>类型标识。 你可以将这些位表示为不同的类型，由你确保没有搞错值的类型。</p><p>这是静态类型语言在内存中表示事物的方式。 由于类型系统在编译时保证没弄错值的类型，不需要在运行时对其进行验证。</p></li></ul><blockquote><p>这也是无类型语言，像汇编和Forth存储值的方式。 这些语言让用户保证不会写出误认值的类型的代码。毫无服务态度！</p></blockquote><ul><li><p><strong>结构紧凑。</strong> 找不到比只存储需要的值更加有效率的存储方式。</p></li><li><p><strong>速度快。</strong> 没有类型标识意味着在运行时无需消耗周期检查它们的类型。这是静态类型语言往往比动态类型语言快的原因之一。</p></li><li><p><strong>不安全。</strong> 这是真正的代价。一块错误的字节码，会让你误解一个值，把数字误解为指针，会破坏游戏安全性从而导致崩溃。</p></li></ul><blockquote><p>如果你的字节码是由静态类型语言编译而来，你也许认为它是安全的，因为编译不会生成不安全的字节码。 那也许是真的，但记住恶意用户也许会手写恶意代码而不经过你的编译器。</p></blockquote><blockquote><p>举个例子，这就是为什么Java虚拟机在加载程序时要做字节码验证。</p></blockquote><ul><li><p><strong>接口：</strong></p><p>多种类型值的面向对象解决方案是通过多态。接口为不同的类型的测试和转换提供虚方法，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Value</span>() {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ValueType <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">asInt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 只能在int上调用</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他转换方法……</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然后你为每个特定的数据类型设计特定的类，如：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntValue</span> : <span class="keyword">public</span> Value</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IntValue</span>(<span class="type">int</span> value)</span><br><span class="line">  : <span class="built_in">value_</span>(value)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ValueType <span class="title">type</span><span class="params">()</span> </span>{ <span class="keyword">return</span> TYPE_INT; }</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">asInt</span><span class="params">()</span> </span>{ <span class="keyword">return</span> value_; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> value_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>开放。</strong> 可在虚拟机的核心之外定义新的值类型，只要它们实现了基本接口就行。</p></li><li><p><strong>面向对象。</strong> 如果你坚持OOP原则，这是“正确”的做法，为特定类型使用多态分配行为，而不是在标签上做switch之类的。</p></li><li><p><strong>冗长。</strong> 必须定义单独的类，包含了每个数据类型的相关行为。 注意在前面的例子中，这样的类定义了所有的类型。在这里，只包含了一个！</p></li><li><p><strong>低效。</strong> 为了使用多态，必须使用指针，这意味着即使是短小的值，如布尔和数字，也得裹在堆中分配的对象里。 每使用一个值，你就得做一次虚方法调用。</p><p>在虚拟机核心之类的地方，像这样的性能影响会迅速叠加。 事实上，这引起了许多我们试图在解释器模式中避免的问题。 只是现在的问题不在代码中，而是在值中。</p></li></ul></li></ul><p>我的建议是：如果可以，只用单一数据类型。 除此以外，使用带标识的union。这是世界上几乎每个语言解释器的选择。</p><h5 id="如何生成字节码？"><a href="#如何生成字节码？" class="headerlink" title="如何生成字节码？"></a>如何生成字节码？</h5><p>我将最重要的问题留到最后。我们已经完成了消耗和解释字节码的部分， 但需你要写制造字节码的工具。 典型的解决方案是写个编译器，但它不是唯一的选择。</p><ul><li><p><strong>如果你定义了基于文本的语言：</strong></p><ul><li><p>必须定义语法。 业余和专业的语言设计师小看这件事情的难度。让解析器高兴很简单，让用户快乐很难。</p><p>语法设计是用户界面设计，当你将用户界面限制到字符构成的字符串，这可没把事情变简单。</p></li><li><p>必须实现解析器。 不管名声如何，这部分其实非常简单。无论使用ANTLR或Bison，还是——像我一样——手写递归下降，都可以完成。</p></li><li><p>必须处理语法错误。 这是最重要和最困难的部分。 当用户制造了语法和语义错误——他们总会这么干——引导他们返回到正确的道路是你的任务。 解析器只知道接到了意外的符号，给予有用的的反馈并不容易。</p></li><li><p>可能会对非技术用户关上大门。 我们程序员喜欢文本文件。结合强大的命令行工具，我们把它们当作计算机的乐高积木——简单，有百万种方式组合。</p><p>大部分非程序员不这样想。 对他们来说，输入文本文件就像为愤怒机器人审核员填写税表，如果忘记了一个分号就会遭到痛斥。</p></li></ul></li><li><p><strong>如果你定义了一个图形化创作工具：</strong></p><ul><li><p>必须实现用户界面。 按钮，点击，拖动，诸如此类。 有些人畏惧它，但我喜欢它。 如果沿着这条路走下去，设计用户界面和工作核心部分同等重要——而不是硬着头皮完成的乱七八糟工作。</p><p>每点额外工作都会让工具更容易更舒适地使用，并直接导致了游戏中更好的内容。 如果你看看很多游戏制作过程的内部解密，经常会发现制作有趣的创造工具是秘诀之一。</p></li><li><p>有较少的错误情况。 由于用户通过交互式一步一步地设计行为，应用程序可以尽快引导他们走出错误。</p><p>而使用基于文本的语言时，直到用户输完整个文件才能看到用户的内容，预防和处理错误更加困难。</p></li><li><p>更难移植。 文本编译器的好处是，文本文件是通用的。编译器简单地读入文件并写出。跨平台移植的工作实在微不足道。</p><p>当你构建用户界面，你必须选择要使用的架构，其中很多是基于某个操作系统。 也有跨平台的用户界面工具包，但他们往往要为对所有平台同样适用付出代价——它们在不同的平台上同样差异很大。</p></li></ul></li></ul><h4 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h4><ul><li><p>这一章节的近亲是GoF的解释器模式。两种方式都能让你用数据组合行为。</p><p>事实上，最终你两种模式<em>都</em>会使用。你用来构造字节码的工具会有内部的对象树。这也是解释器模式所能做的。</p><p>为了编译到字节码，你需要递归回溯整棵树，就像用解释器模式去解释它一样。 唯一的 不同在于，不是立即执行一段行为，而是生成整个字节码再执行。</p></li><li><p><a target="_blank" rel="noopener" href="http://www.lua.org/">Lua</a>是游戏中最广泛应用的脚本语言。 它的内部被实现为一个非常紧凑的，基于寄存器的字节码虚拟机。</p></li><li><p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/UnrealEd#Kismet">Kismet</a>是个可视化脚本编辑工具，应用于Unreal引擎的编辑器UnrealEd。</p></li><li><p>我的脚本语言<a target="_blank" rel="noopener" href="https://github.com/munificent/wren">Wren</a>，是一个简单的，基于栈的字节码解释器。</p></li></ul><h3 id="子类沙盒"><a href="#子类沙盒" class="headerlink" title="子类沙盒"></a>子类沙盒</h3><h4 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h4><p>用一系列由基类提供的操作定义子类中的行为。</p><h4 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h4><p>每个孩子都梦想过变成超级英雄，但是不幸的是，高能射线在地球上很短缺。 游戏是让你扮演超级英雄最简单的方法。 因为我们的游戏设计者从来没有学会说“不”，我们的超级英雄游戏中有成百上千种不同的超级能力可供选择。</p><p>我们的计划是创建一个<code>Superpower</code>基类。然后由它派生出各种超级能力的实现类。 我们在程序员队伍中分发设计文档，然后开始编程。 当我们完成时，我们就会有上百种超级能力类。</p><blockquote><p>当你发现像这个例子一样有很多子类时，那通常意味着数据驱动的方式更好。 不再用代码定义不同的能力，用数据吧。</p></blockquote><blockquote><p>像类型对象，字节码，和解释器模式都能帮忙。</p></blockquote><p>我们想让玩家处于拥有无限可能的世界中。无论他们在孩童时想象过什么能力，我们都要在游戏中展现。 这就意味着这些超能力子类需要做任何事情： 播放声音，产生视觉刺激，与AI交互，创建和销毁其他游戏实体，与物理打交道。没有哪处代码是它们不会接触的。</p><p>假设我们让团队信马由缰地写超能力类。会发生什么？</p><ul><li><strong>会有很多冗余代码。</strong> 当超能力种类繁多，我们可以预期有很多重叠。 很多超能力都会用相同的方式产生视觉效果并播放声音。 当你坐下来看看，冷冻光线，热能光线，芥末酱光线都很相似。 如果人们实现这些的时候没有协同，那就会有很多冗余的代码和重复劳动。</li><li><strong>游戏引擎中的每一部分都会与这些类耦合。</strong> 没有深入了解的话，任何人都能写出直接调用子系统的代码，但子系统从来没打算直接与超能力类绑定。 就算渲染系统被好好组织成多个层次，只有一个能被外部的图形引擎使用， 我们可以打赌，最终超能力代码会与每一个接触。</li><li><strong>当外部代码需要改变时，一些随机超能力代码有很大几率会损坏。</strong> 一旦我们有了不同的超能力类绑定到游戏引擎的多个部分，改变那些部分必然影响超能力类。 这可不合理，因为图形，音频，UI程序员很可能不想也成为玩法程序员。</li><li><strong>很难定义所有超能力遵守的不变量。</strong> 假设我们想保证超能力播放的所有音频都有正确的顺序和优先级。 如果我们的几百个类都直接调用音频引擎，就没什么好办法来完成这点。</li></ul><p>我们要的是给每个实现超能力的玩法程序员一系列可使用的基本单元。 你想要播放声音？这是你的<code>playSound()</code>函数。 你想要粒子效果？这是你的<code>spawnParticles()</code>函数。 我们保证了这些操作覆盖了你要做的事情，所以你不需要<code>#include</code>随机的头文件，干扰到代码库的其他部分。</p><p>我们实现的方法是通过定义这些操作为<code>Superpower</code>基类的protected方法。 将它们放在基类给了每个子类直接便捷的途径获取方法。 让它们成为protected（很可能不是虚方法）方法暗示了它们存在就是为了被子类调用。</p><p>一旦有了这些东西来使用，我们需要一个地方使用他们。 为了做到这点，我们定义<em>沙箱方法</em>，这是子类必须实现的抽象的protected方法。 有了这些，要实现一种新的能力，你需要：</p><ol><li>创建从<code>Superpower</code>继承的新类。</li><li>重载沙箱方法<code>activate()</code>。</li><li>通过调用<code>Superpower</code>提供的protected方法实现主体。</li></ol><p>我们现在可以使用这些高层次的操作来解决冗余代码问题了。 当我们看到代码在多个子类间重复，我们总可以将其打包到<code>Superpower</code>中，作为它们都可以使用的新操作。</p><p>我们通过将耦合约束到一个地方解决了耦合问题。 <code>Superpower</code>最终与不同的系统耦合，但是继承它的几百个类不会。 相反，它们<em>只</em>耦合基类。 当游戏系统的某部分改变时，修改<code>Superpower</code>也许是必须的，但是众多的子类不需要修改。</p><p>这个模式带来浅层但是广泛的类层次。 你的继承链不<em>深</em>，但是有很多类与<code>Superpower</code>挂钩。 通过使用有很多直接子类的基类，我们在代码库中创造了一个支撑点。 我们投入到<code>Superpower</code>的时间和爱可以让游戏中众多类获益。</p><blockquote><p>最近，你会发现很多人批评面向对象语言中的继承。 继承是有问题——在代码库中没有比父类子类之间的耦合更深的了——但我发现扁平的继承树比起深的继承树更好处理。</p></blockquote><h4 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h4><p>基类定义抽象的沙箱方法和几个提供的操作。 将操作标为protected，表明它们只为子类所使用。 每个推导出的沙箱子类用提供的操作实现了沙箱函数。</p><h4 id="何时使用-1"><a href="#何时使用-1" class="headerlink" title="何时使用"></a>何时使用</h4><p>子类沙箱模式是潜伏在代码库中简单常用的模式，哪怕是在游戏之外的地方亦有应用。 如果你有一个非虚的protected方法，你可能已经在用类似的东西了。 沙箱方法在以下情况适用：</p><ul><li>你有一个能推导很多子类的基类。</li><li>基类可以提供子类需要的所有操作。</li><li>在子类中有行为重复，你想要更容易地在它们间分享代码。</li><li>你想要最小化子类和程序的其他部分的耦合。</li></ul><h4 id="记住-1"><a href="#记住-1" class="headerlink" title="记住"></a>记住</h4><p>“继承”近来在很多编程圈子为人诟病，原因之一是基类趋向于增加越来越多的代码 这个模式特别容易染上这个毛病。</p><p>由于子类通过基类接触游戏的剩余部分，基类最后和子类需要的每个系统耦合。 当然，子类也紧密地与基类相绑定。这种蛛网耦合让你很难在不破坏什么的情况下改变基类——你得到了（脆弱的基类问题）<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Fragile_base_class">brittle base class problem</a>。</p><p>硬币的另一面是由于你耦合的大部分都被推到了基类，子类现在与世界的其他部分分离。 理想的情况下，你大多数的行为都在子类中。这意味着你的代码库大部分是孤立的，很容易管理。</p><p>如果你发现这个模式正把你的基类变成一锅代码糊糊， 考虑将它提供的一些操作放入分离的类中， 这样基类可以分散它的责任。组件模式可以在这里帮上忙。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>因为这个模式太简单了，示例代码中没有太多东西。 这不是说它没用——这个模式关键在于“意图”，而不是它实现的复杂度。</p><p>我们从<code>Superpower</code>基类开始：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Superpower</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Superpower</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">activate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> z)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">playSound</span><span class="params">(SoundId sound, <span class="type">double</span> volume)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">spawnParticles</span><span class="params">(ParticleType type, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>activate()</code>方法是沙箱方法。由于它是抽象虚函数，子类<em>必须</em>重载它。 这让那些需要创建子类的人知道要做哪些工作。</p><p>其他的protected函数<code>move()</code>，<code>playSound()</code>，和<code>spawnParticles()</code>都是提供的操作。 它们是子类在实现<code>activate()</code>时要调用的。</p><p>在这个例子中，我们没有实现提供的操作，但真正的游戏在那里有真正的代码。 那些代码中，<code>Superpower</code>与游戏中其他部分的耦合——<code>move()</code>也许调用物理代码，<code>playSound()</code>会与音频引擎交互，等等。 由于这都在基类的<em>实现</em>中，保证了耦合封闭在<code>Superpower</code>中。</p><p>好了，拿出我们的放射蜘蛛，创建个能力。像这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkyLaunch</span> : <span class="keyword">public</span> Superpower</span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">activate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 空中滑行</span></span><br><span class="line">    <span class="built_in">playSound</span>(SOUND_SPROING, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">spawnParticles</span>(PARTICLE_DUST, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">move</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>好吧，也许跳跃不是超级能力，但我在这里讲的是基础知识。</p></blockquote><p>这种能力将超级英雄射向天空，播放合适的声音，扬起尘土。 如果所有的超能力都这样简单——只是声音，粒子效果，动作的组合——那么就根本不需要这个模式了。 相反，<code>Superpower</code>有内置的<code>activate()</code>能获取声音ID，粒子类型和运动的字段。 但是这只在所有能力运行方式相同，只在数据上不同时才可行。让我们精细一些：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Superpower</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getHeroX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getHeroY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getHeroZ</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退出之类的……</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这里我们增加了些方法获取英雄的位置。我们的<code>SkyLaunch</code>现在可以使用它们了：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkyLaunch</span> : <span class="keyword">public</span> Superpower</span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">activate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getHeroZ</span>() == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 在地面上，冲向空中</span></span><br><span class="line">      <span class="built_in">playSound</span>(SOUND_SPROING, <span class="number">1.0f</span>);</span><br><span class="line">      <span class="built_in">spawnParticles</span>(PARTICLE_DUST, <span class="number">10</span>);</span><br><span class="line">      <span class="built_in">move</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getHeroZ</span>() &lt; <span class="number">10.0f</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 接近地面，再跳一次</span></span><br><span class="line">      <span class="built_in">playSound</span>(SOUND_SWOOP, <span class="number">1.0f</span>);</span><br><span class="line">      <span class="built_in">move</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">getHeroZ</span>() + <span class="number">20</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 正在空中，跳劈攻击</span></span><br><span class="line">      <span class="built_in">playSound</span>(SOUND_DIVE, <span class="number">0.7f</span>);</span><br><span class="line">      <span class="built_in">spawnParticles</span>(PARTICLE_SPARKLES, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">move</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="built_in">getHeroZ</span>());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>由于我们现在可以访问状态，沙箱方法可以做有用有趣的控制流了。 这还需要几个简单的<code>if</code>声明， 但你可以做任何你想做的东西。 使用包含任意代码的成熟沙箱方法，天高任鸟飞了。</p><blockquote><p>早先，我建议以数据驱动的方式建立超能力。 这里是你可能<em>不</em>想那么做的原因之一。 如果你的行为复杂而使用命令式风格，它更难在数据中定义。</p></blockquote><h4 id="决策设计"><a href="#决策设计" class="headerlink" title="决策设计"></a>决策设计</h4><p>如你所见，子类沙箱是一个“软”模式。它表述了一个基本思路，但是没有很多细节机制。 这意味着每次使用都面临着一些有趣的选择。这里是一些需要思考的问题。</p><h5 id="应该提供什么操作？"><a href="#应该提供什么操作？" class="headerlink" title="应该提供什么操作？"></a>应该提供什么操作？</h5><p>这是最大的问题。这深深影响了模式感觉上和实际上有多好。 在一个极端，基类几乎不提供任何操作。只有一个沙箱方法。 为了实现功能，总是需要调用基类外部的系统。如果你这样做，很难说你在使用这个模式。</p><p>另一个极端，基类提供了所有子类也许需要的操作。 子类只与基类耦合，不调用任何外部系统的东西。</p><blockquote><p>具体来说，这意味着每个子类的源文件只需要<code>#include</code>它的基类头文件。</p></blockquote><p>在这两个极端之间，操作由基类提供还是向外部直接调用有很大的操作余地。 你提供的操作越多，外部系统与子类耦合越少，但是与基类耦合越多。 从子类中移除了耦合是通过将耦合推给基类完成的。</p><p>如果你有一堆与外部系统耦合的子类的话，这很好。 通过将耦合移到提供的操作中，你将其移动到了一个地方：基类。但是你越这么做，基类就越大越难管理。</p><p>所以分界线在哪里？这里是一些首要原则：</p><p>-<br>如果提供的操作只被一个或几个子类使用，将操作加入基类获益不会太多。 你向基类添加了会影响所有事物的复杂性，但是只有少数几个类受益。</p><p>让该操作与其他提供的操作保持一致或许有价值，但让使用操作的子类直接调用外部系统也许更简单明了。</p><ul><li>当你调用游戏中其他地方的方法，如果方法没有修改状态就有更少的干扰。 它仍然制造耦合，但是这是“安全的”耦合，因为它没有破坏游戏中的任何东西。</li></ul><blockquote><p>“安全的”在这里打了引号是因为严格来说，接触数据也能造成问题。 如果你的游戏是多线程的，读取的数据可能正在被修改。如果你不小心，就会读入错误的数据。</p></blockquote><blockquote><p>另一个不愉快的情况是，如果你的游戏状态是严格确定性的（很多在线游戏为了保持玩家同步都是这样的）。 接触了游戏同步状态之外的东西会造成极糟的不确定性漏洞。</p></blockquote><p>另一方面，修改状态的调用会和代码库的其他方面紧密绑定，你需要三思。打包他们成基类提供的操作是个好的候选项。</p><ul><li><p>如果操作只是增加了向外部系统的转发调用，那它就没增加太多价值。那种情况下，也许直接调用外部系统的方法更简单。</p><p>但是，简单的转发也是有用的——那些方法接触了基类不想直接暴露给子类的状态。 举个例子，假设<code>Superpower</code>提供这个：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">playSound</span><span class="params">(SoundId sound, <span class="type">double</span> volume)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  soundEngine_.<span class="built_in">play</span>(sound, volume);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它只是转发调用给<code>Superpower</code>中<code>soundEngine_</code>字段。 但是，好处是将字段封装在<code>Superpower</code>中，避免子类接触。</p></li></ul><h5 id="方法应该直接提供，还是包在对象中提供？"><a href="#方法应该直接提供，还是包在对象中提供？" class="headerlink" title="方法应该直接提供，还是包在对象中提供？"></a>方法应该直接提供，还是包在对象中提供？</h5><p>这个模式的挑战是基类中最终加入了很多方法。 你可以将一些方法移到其他类中来缓和。基类通过返回对象提供方法。</p><p>举个例子，为了让超能力播放声音，我们可以直接将它们加到<code>Superpower</code>中：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Superpower</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">playSound</span><span class="params">(SoundId sound, <span class="type">double</span> volume)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stopSound</span><span class="params">(SoundId sound)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setVolume</span><span class="params">(SoundId sound)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 沙盒方法和其他操作……</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>但是如果<code>Superpower</code>已经很庞杂了，我们也许想要避免这样。 取而代之的是创建<code>SoundPlayer</code>类暴露该函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SoundPlayer</span></span><br><span class="line">{</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">playSound</span><span class="params">(SoundId sound, <span class="type">double</span> volume)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stopSound</span><span class="params">(SoundId sound)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setVolume</span><span class="params">(SoundId sound)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 实现代码……</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>Superpower</code>提供了对其的接触：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Superpower</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">SoundPlayer&amp; <span class="title">getSoundPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> soundPlayer_;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 沙箱方法和其他操作……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  SoundPlayer soundPlayer_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>将提供的操作分流到辅助类可以为你做一些事情：</p><ul><li><strong>减少了基类中的方法。</strong> 在这里的例子中，将三个方法变成了一个简单的获取函数。</li><li><strong>在辅助类中的代码通常更好管理。</strong> 像<code>Superpower</code>的核心基类，不管意图如何好，它被太多的类依赖而很难改变。 通过将函数移到耦合较少的次要类，代码变得更容易被使用而不破坏任何东西。</li><li><strong>减少了基类和其他系统的耦合度。</strong> 当<code>playSound()</code>方法直接在<code>Superpower</code>时，基类与<code>SoundId</code>以及其他涉及的音频代码直接绑定。 将它移动到<code>SoundPlayer</code>中，减少了<code>Superpower</code>与<code>SoundPlayer</code>类的耦合，这就封装了它其他的依赖。</li></ul><h5 id="基类如何获得它需要的状态？"><a href="#基类如何获得它需要的状态？" class="headerlink" title="基类如何获得它需要的状态？"></a>基类如何获得它需要的状态？</h5><p>你的基类经常需要将对子类隐藏的数据封装起来。 在第一个例子中，<code>Superpower</code>类提供了<code>spawnParticles()</code>方法。 如果方法的实现需要一些粒子系统对象，怎么获得呢？</p><ul><li><p><strong>将它传给基类构造器：</strong></p><p>最简单的解决方案是让基类将其作为构造器变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Superpower</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Superpower</span>(ParticleSystem* particles)</span><br><span class="line">  : <span class="built_in">particles_</span>(particles)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 沙箱方法和其他操作……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ParticleSystem* particles_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这安全地保证了每个超能力在构造时能得到粒子系统。但让我们看看子类：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkyLaunch</span> : <span class="keyword">public</span> Superpower</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SkyLaunch</span>(ParticleSystem* particles)</span><br><span class="line">  : <span class="built_in">Superpower</span>(particles)</span><br><span class="line">  {}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们在这儿看到了问题。每个子类都需要构造器调用基类构造器并传递变量。这让子类接触了我们不想要它知道的状态。</p><p>这也造成了维护的负担。如果我们后续向基类添加了状态，每个子类都需要修改并传递这个状态。</p></li><li><p><strong>使用两阶初始化：</strong></p><p>为了避免通过构造器传递所有东西，我们可以将初始化划分为两个部分。 构造器不接受任何参数，只是创建对象。然后，我们调用定义在基类的分离方法传入必要的数据：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Superpower* power = <span class="keyword">new</span> <span class="built_in">SkyLaunch</span>();</span><br><span class="line">power-&gt;<span class="built_in">init</span>(particles);</span><br></pre></td></tr></tbody></table></figure><p>注意我们没有为<code>SkyLaunch</code>的构造器传入任何东西，它与<code>Superpower</code>中想要保持私有的任何东西都不耦合。 这种方法的问题在于，你要保证永远记得调用<code>init()</code>，如果忘了，你会获得处于半完成的，无法运行的超能力。</p><p>你可以将整个过程封装到一个函数中来修复这一点，就像这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Superpower* <span class="title">createSkyLaunch</span><span class="params">(ParticleSystem* particles)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  Superpower* power = <span class="keyword">new</span> <span class="built_in">SkyLaunch</span>();</span><br><span class="line">  power-&gt;<span class="built_in">init</span>(particles);</span><br><span class="line">  <span class="keyword">return</span> power;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>使用一点像私有构造器和友类的技巧，你可以保证<code>createSkylaunch()</code>函数是唯一能够创建能力的函数。 这样，你不会忘记任何初始化步骤。</p></blockquote><ul><li><p><strong>让状态静态化：</strong></p><p>在先前的例子中，我们用粒子系统初始化每一个<code>Superpower</code>实例。 在每个能力都需要自己独特的状态时这是有意义的。但是如果粒子系统是单例，那么每个能力都会分享相同的状态。</p><p>如果是这样，我们可以让状态是基类私有而静态的。 游戏仍然要保证初始化状态，但是它只需要为整个游戏初始化<code>Superpower</code><em>类</em>一遍，而不是为每个实例初始化一遍。</p><p>记住单例仍然有很多问题。你在很多对象中分享了状态（所有的<code>Superpower</code>实例）。 粒子系统被封装了，因此它不是全局<em>可见的</em>，这很好，但它们都访问同一对象，这让分析更加困难了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Superpower</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">(ParticleSystem* particles)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    particles_ = particles;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 沙箱方法和其他操作……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> ParticleSystem* particles_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注意这里的<code>init()</code>和<code>particles_</code>都是静态的。 只要游戏早先调用过一次<code>Superpower::init()</code>，每种能力都能接触粒子系统。 同时，可以调用正确的推导类构造器来自由创建<code>Superpower</code>实例。</p><p>更棒的是，现在<code>particles_</code>是<em>静态</em>变量， 我们不需要在每个<code>Superpower</code>中存储它，这样我们的类占据的内存更少了。</p></li><li><p><strong>使用服务定位器：</strong></p><p>前一选项中，外部代码要在基类请求前压入基类需要的全部状态。 初始化的责任交给了周围的代码。另一选项是让基类拉取它需要的状态。 而做到这点的一种实现方法是使用服务定位器模式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Superpower</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">spawnParticles</span><span class="params">(ParticleType type, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    ParticleSystem&amp; particles = Locator::<span class="built_in">getParticles</span>();</span><br><span class="line">    particles.<span class="built_in">spawn</span>(type, count);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 沙箱方法和其他操作……</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这儿，<code>spawnParticles()</code>需要粒子系统，不是外部系统<em>给</em>它，而是它自己从服务定位器中拿了一个。</p></li></ul><h4 id="参见-1"><a href="#参见-1" class="headerlink" title="参见"></a>参见</h4><ul><li>当你使用更新模式时，你的更新函数通常也是沙箱方法。</li><li>这个模式与模板方法正相反。 两种模式中，都使用一系列受限操作实现方法。 使用子类沙箱时，方法在推导类中，受限操作在基类中。 使用模板方法时，基类 有方法，而受限操作在推导类中。</li><li>你也可以认为这个模式是外观模式的变形。 外观模式将一系列不同系统藏在简化的API后。使用子类沙箱，基类起到了在子类前隐藏整个游戏引擎的作用。</li></ul><h3 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h3><h4 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h4><p>创造一个类A来允许灵活地创造新“类型”，类A的每个实例都代表了不同的对象类型。</p><h4 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h4><p>想象我们在制作一个奇幻RPG游戏。 我们的任务是为一群想要杀死英雄的恶毒怪物编写代码。 怪物有多个的属性：生命值，攻击力，图形效果，声音表现，等等。 但是为了说明介绍的目的我们先只考虑前面两个。</p><p>游戏中的每个怪物都有当前血值。 开始时是满的，每次怪物受伤，它就下降。 怪物也有一个攻击字符串。 当怪物攻击我们的英雄，那个文本就会以某种方式展示给用户。 （我们不在乎这里怎样实现。）</p><p>设计者告诉我们怪物有不同品种，像“龙”或者“巨魔”。 每个品种都描述了一种存在于游戏中的怪物，同时可能有多个同种怪物在地牢里游荡。</p><p>品种决定了怪物的初始健康——龙开始的血量比巨魔多，它们更难被杀死。 这也决定了攻击字符——同种的所有怪物都以相同的方式进行攻击。</p><h5 id="传统的面向对象方案"><a href="#传统的面向对象方案" class="headerlink" title="传统的面向对象方案"></a>传统的面向对象方案</h5><p>想着这样的设计方案，我们启动了文本编辑器开始编程。 根据设计，龙是一种怪物，巨魔是另一种，其他品种的也一样。 用面向对象的方式思考，这引导我们创建<code>Monster</code>基类。</p><blockquote><p>这是一种“是某物”的关系。 在传统OOP思路中，由于龙“是”怪物，我们用<code>Dragon</code>是<code>Monster</code>的子类来描述这点。 如我们将看到的，继承是一种将这种关系表示为代码的方法。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Monster</span>() {}</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getAttack</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">Monster</span>(<span class="type">int</span> startingHealth)</span><br><span class="line">  : <span class="built_in">health_</span>(startingHealth)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> health_; <span class="comment">// 当前血值</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在怪物攻击英雄时，公开的<code>getAttack()</code>函数让战斗代码能获得需要显示的文字。 每个子类都需要重载它来提供不同的消息。</p><p>构造器是protected的，需要传入怪物的初始血量。 每个品种的子类的公共构造器调用这个构造器，传入对于该品种适合的起始血量。</p><p>现在让我们看看两个品种子类：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dragon</span> : <span class="keyword">public</span> Monster</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dragon</span>() : <span class="built_in">Monster</span>(<span class="number">230</span>) {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"The dragon breathes fire!"</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Troll</span> : <span class="keyword">public</span> Monster</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Troll</span>() : <span class="built_in">Monster</span>(<span class="number">48</span>) {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"The troll clubs you!"</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>每个从<code>Monster</code>派生出来的类都传入起始血量，重载<code>getAttack()</code>返回那个品种的攻击字符串。 所有事情都一如所料地运行，不久以后，我们的英雄就可以跑来跑去杀死各种野兽了。 我们继续编程，在意识到之前，我们就有了从酸泥怪到僵尸羊的众多怪物子类。</p><p>然后，很奇怪，事情陷入了困境。 设计者最终想要几百个品种，但是我们发现所有的时间都花费在写这些只有七行长的子类和重新编译上。 这会继续变糟——设计者想要协调已经编码的品种。我们之前富有产出的工作日退化成了：</p><ol><li>收到设计者将巨魔的血量从48改到52的邮件。</li><li>签出并修改<code>Troll.h</code>。</li><li>重新编译游戏。</li><li>签入修改。</li><li>回复邮件。</li><li>重复。</li></ol><p>我们度过了失意的一天，因为我们变成了填数据的猴子。 设计者也感到挫败，因为修改一个数据就要老久。 我们需要的是一种无需每次重新编译游戏就能修改品种的状态。 如果设计者创建和修改品种时无需<em>任何</em>程序员的介入那就更好了。</p><h5 id="为类型建类"><a href="#为类型建类" class="headerlink" title="为类型建类"></a>为类型建类</h5><p>从较高的层次看来，我们试图解决的问题非常简单。 游戏中有很多不同的怪物，我们想要在它们之间分享属性。 一大群怪物在攻击英雄，我们想要它们中的一些使用相同的攻击文本。 我们声明这些怪物是相同的“品种”，而品种决定了攻击字符串。</p><p>这种情况下我们很容易想到类，那就试试吧。 龙是怪物，每条龙都是龙“类”的实例。 定义每个品种为抽象基类<code>Monster</code> 的子类，让游戏中每个怪物都是子类的实例反映了那点。最终的类层次是这样的：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/type-object-subclasses.png"></p><blockquote><p>这里的<img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/arrow-inherits-20210801094623523.png">意为“从……继承”。</p></blockquote><p>每个怪物的实例属于某个继承怪物类的类型。 我们有的品种越多，类层次越高。 这当然是问题：添加新品种就需要添加新代码，而每个品种都需要被编译为它自己的类型。</p><p>这可行，但不是唯一的选项。 我们也可以重构代码让每个怪物<em>有</em>品种。 不是让每个品种继承<code>Monster</code>，我们现在有单一的<code>Monster</code>类和<code>Breed</code>类。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/type-object-breed.png"></p><blockquote><p>这里<img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/arrow-references.png">意为“被……引用”。</p></blockquote><p>这就成了，就两个类。注意这里完全没有继承。 通过这个系统，游戏中的每个怪物都是<code>Monster</code>的实例。 <code>Breed</code>类包含了在不同品种怪物间分享的信息：开始血量和攻击字符串。</p><p>为了将怪物与品种相关联，我们给了每个<code>Monster</code>实例对包含品种信息的<code>Breed</code>对象的引用。 为了获得攻击字符串，一个怪兽可以调用它品种的方法。 <code>Breed</code>类本质上定义了一个怪物的类型，这就是为啥这个模式叫做类型对象。</p><p>这个模式特别有用的一点是，我们现在可以定义全新的类型而无需搅乱代码库。 我们本质上将部分的类型系统从硬编码的继承结构中拉出，放到可以在运行时定义的数据中去。</p><p>我们可以通过用不同值实例化<code>Monster</code>来创建成百上千的新品种。 如果从配置文件读取不同的数据初始化品种，我们就有能力完全靠数据定义新怪物品种。 这么容易，设计者也可以做到！</p><h5 id="模式-2"><a href="#模式-2" class="headerlink" title="模式"></a>模式</h5><p>定义类型对象类和有类型的对象类。每个类型对象实例代表一种不同的逻辑类型。 每种有类型的对象保存对描述它类型的类型对象的引用。</p><p>实例相关的数据被存储在有类型对象的实例中，被同种类分享的数据或者行为存储在类型对象中。 引用同一类型对象的对象将会像同一类型一样运作。 这让我们在一组相同的对象间分享行为和数据，就像子类让我们做的那样，但没有固定的硬编码子类集合。</p><h4 id="何时使用-2"><a href="#何时使用-2" class="headerlink" title="何时使用"></a>何时使用</h4><p>在任何你需要定义不同“种”事物，但是语言自身的类型系统过于僵硬的时候使用该模式。尤其是下面两者之一成立时：</p><ul><li>你不知道你后面还需要什么类型。（举个例子，如果你的游戏需要支持资料包，而资料包有新的怪物品种呢？）</li><li>想不改变代码或者重新编译就能修改或添加新类型。</li></ul><h4 id="记住-2"><a href="#记住-2" class="headerlink" title="记住"></a>记住</h4><p>这个模型是关于将“类型”的定义从命令式僵硬的语言世界移到灵活但是缺少行为的对象内存世界。 灵活性很好，但是将类型提到数据丧失了一些东西。</p><h5 id="需要手动追踪类型对象"><a href="#需要手动追踪类型对象" class="headerlink" title="需要手动追踪类型对象"></a>需要手动追踪类型对象</h5><p>使用像C++类型系统这种东西的好处之一就是编译器自动记录类的注册。 定义类的数据自动编译到可执行的静态内存段然后就运作起来了。</p><p>使用类型对象模式，我们现在不但要负责管理内存中的怪物，同时要管理它们的类型 ——我们要保证，只要我的怪物需要，所有的品种对象都能实例化并保存在内存中。 无论何时创建新的怪物，由我们来保证能初始化为含有品种的引用。</p><p>我们从编译器的限制中解放了自己，但是代价是需要重新实现一些它以前为我们做的事情。</p><h5 id="更难为每种类型定义行为"><a href="#更难为每种类型定义行为" class="headerlink" title="更难为每种类型定义行为"></a>更难为每种类型定义行为</h5><blockquote><p>C++内部使用了“虚函数表”（“vtable”）实现虚方法。 虚函数表是个简单的<code>struct</code>，包含了一集合函数指针，每个对应一个类中的虚方法。 在内存中每个类有一个虚函数表。每个类的实例有一个指针指向它的类的虚函数表。</p><p>当你调用一个虚函数，代码首先在虚函数表中查找对象，然后调用表中函数指针指向的函数。</p><p>听起来很熟悉？虚函数表就是个品种对象，而指向虚函数表的指针是怪物保留的、指向品种的引用。 C++的类是C中的类型对象，由编译器自动处理。</p></blockquote><p>使用子类派生，你可以重载方法，然后做你想做的事——用程序计算值，调用其他代码，等等。 天高任鸟飞。如果我们想的话，可以定义一个怪物子类，根据月亮的阶段改变它的攻击字符串。（我觉得就像狼人。）</p><p>当我们使用类型对象模式时，我们将重载的方法替换成了成员变量。 不再让怪物的子类重载方法，用不同的代码来计算攻击字符串，而是让我们的品种对象在不同的变量中存储攻击字符串。</p><p>这让使用类型对象定义类型相关的<em>数据</em>变得容易，但是定义类型相关的<em>行为</em>变得困难。 如果，举个例子，不同品种的怪物需要使用不同的AI算法，使用这个模式就面临着挑战。</p><p>有很多方式可以让我们跨越这个限制。 一个简单的方式是使用预先定义的固定行为， 然后类型对象中的数据简单地选择它们中的一个。 举例，假设我们的怪物AI总是处于“站着不动”、“追逐英雄”或者“恐惧地呜咽颤抖”（嘿，他们不可能都是强势的龙）状态。 我们可以定义函数来实现每种行为。 然后，我们在方法中存储合适函数的引用，将AI算法与品种相关联。</p><blockquote><p>听起来很熟悉？这是在我们的类型对象中实现虚函数表。</p></blockquote><p>另一个更加彻底的解决方案是真正地在数据中支持定义行为。 解释器模式和字节码模式让我们定义有行为的对象。 如果我们读取数据文件并用上面两种模式之一构建数据结构，我们就将行为完全从代码中移出，放入了数据之中。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><blockquote><p>时过境迁，游戏越来越多地由数据驱动。 硬件变得更为强大，我们发现比起能榨干多少硬件的性能，瓶颈更多于在能完成多少内容。 使用64K软盘的时代，挑战是将游戏塞入其中。 而在使用双面DVD的时代，挑战是用游戏填满它。</p><p>脚本语言和其他定义游戏行为的高层方式能给我们提供必要的生产力，同时只消耗可预期的运行时性能。 由于硬件越来越好，而大脑并非如此，这种交换越来越有意义。</p></blockquote><p>在第一遍实现中，让我们从简单的开始，只构建动机那节提到的基础系统。 我们从<code>Breed</code>类开始：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Breed</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Breed</span>(<span class="type">int</span> health, <span class="type">const</span> <span class="type">char</span>* attack)</span><br><span class="line">  : <span class="built_in">health_</span>(health),</span><br><span class="line">    <span class="built_in">attack_</span>(attack)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getHealth</span><span class="params">()</span> </span>{ <span class="keyword">return</span> health_; }</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getAttack</span><span class="params">()</span> </span>{ <span class="keyword">return</span> attack_; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> health_; <span class="comment">// 初始血值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* attack_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>很简单。它基本上只是两个数据字段的容器：起始血量和攻击字符串。 让我们看看怪物怎么使用它：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Monster</span>(Breed&amp; breed)</span><br><span class="line">  : <span class="built_in">health_</span>(breed.<span class="built_in">getHealth</span>()),</span><br><span class="line">    <span class="built_in">breed_</span>(breed)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">return</span> breed_.<span class="built_in">getAttack</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>    health_; <span class="comment">// 当前血值</span></span><br><span class="line">  Breed&amp; breed_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>当我们建构怪物时，我们给它一个品种对象的引用。 它定义了怪物的品种，取代了之前的子类。 在构造函数中，<code>Monster</code>使用的品种决定了起始血量。 为了获得攻击字符串，怪物简单地将调用转发给它的品种。</p><p>这段非常简单的代码是这章的核心思路。剩下的任何东西都是红利。</p><h5 id="让类型对象更像类型：构造器"><a href="#让类型对象更像类型：构造器" class="headerlink" title="让类型对象更像类型：构造器"></a>让类型对象更像类型：构造器</h5><p>现在，我们可以直接构造怪物并负责传入它的品种。 和常用的OOP语言实现的对象相比这有些退步——我们通常不会分配一块空白内存，然后<em>赋予</em>它类型。 相反，我们根据类调用构造器，它负责创建一个新实例。</p><p>我们可以在类型对象上应用同样的模式。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Breed</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Monster* <span class="title">newMonster</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Monster</span>(*<span class="keyword">this</span>); }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous Breed code...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>“模式”一词用在这里正合适。我们讨论的是设计模式中经典的模式：工厂方法。</p><p>在一些语言中，这个模式被用来构造<em>所有</em>的对象。 在Ruby，Smalltalk，Objective-C以及其他类是对象的语言中，你通过在类对象本身上调用方法来构建实例。</p><p>以及那个使用它们的类：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Breed</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getAttack</span><span class="params">()</span> </span>{ <span class="keyword">return</span> breed_.<span class="built_in">getAttack</span>(); }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Monster</span>(Breed&amp; breed)</span><br><span class="line">  : <span class="built_in">health_</span>(breed.<span class="built_in">getHealth</span>()),</span><br><span class="line">    <span class="built_in">breed_</span>(breed)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> health_; <span class="comment">// 当前血值</span></span><br><span class="line">  Breed&amp; breed_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>不同的关键点在于<code>Breed</code>中的<code>newMonster()</code>。 这是我们的“构造器”工厂方法。使用我们原先的实现，就像这样创建怪物：</p><p>这里还有一个小小的不同。 因为样例代码由C++写就，我们可以使用一个小小的特性：友类。</p><p>我们让<code>Monster</code>的构造器成为私有，防止了任何人直接调用它。 友类放松了这个限制，<code>Breed</code>仍可接触它。 这意味着构造怪物的<em>唯一</em>方法是通过<code>newMonster()</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Monster* monster = <span class="keyword">new</span> <span class="built_in">Monster</span>(someBreed);</span><br></pre></td></tr></tbody></table></figure><p>在我们改动后，它看上去是这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Monster* monster = someBreed.<span class="built_in">newMonster</span>();</span><br></pre></td></tr></tbody></table></figure><p>所以，为什么这么做？创建一个对象分为两步：内存分配和初始化。 <code>Monster</code>的构造器让我们做完了所有需要的初始化。 在例子中，那只存储了类型；但是在完整的游戏中，那需要加载图形，初始化怪物AI以及做其他的设置工作。</p><p>但是，那都发生在内存分配之后。 在构造器调用前，我们已经找到了内存放置怪物。 在游戏中，我们通常也想控制对象创造这一环节： 我们通常使用自定义的分配器或者对象池模式来控制对象最终在内存中的位置。</p><p>在<code>Breed</code>中定义“构造器”函数给了我们地方实现这些逻辑。 不是简单地调用<code>new</code>,<code>newMonster()</code>函数可以在将控制权传递给<code>Monster</code>初始化之前，从池中或堆中获取内存。 通过在唯一有能力创建怪物的<code>Breed</code>函数中放置这些逻辑， 我们保证了所有怪物变量遵守了内存管理规范。</p><h5 id="通过继承分享数据"><a href="#通过继承分享数据" class="headerlink" title="通过继承分享数据"></a>通过继承分享数据</h5><p>我们现在已经实现了能完美服务的类型对象系统，但是它非常基础。 我们的游戏最终有<em>上百</em>种不同品种，每种都有成打的特性。 如果设计者想要协调30种不同的巨魔，让它们变得强壮一点，他会得处理很多数据。</p><p>能帮上忙的是在不同品种间分享属性的能力，一如品种在不同的怪物间分享属性的能力。 就像我们在之前OOP方案中做的那样，我们可以使用派生完成这点。 只是，这次，不使用语言的继承机制，我们用类型对象实现它。</p><p>简单起见，我们只支持单继承。 就像类可以有一个父类，我们允许品种有一个父品种：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Breed</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Breed</span>(Breed* parent, <span class="type">int</span> health, <span class="type">const</span> <span class="type">char</span>* attack)</span><br><span class="line">  : <span class="built_in">parent_</span>(parent),</span><br><span class="line">    <span class="built_in">health_</span>(health),</span><br><span class="line">    <span class="built_in">attack_</span>(attack)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>         <span class="title">getHealth</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getAttack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Breed*      parent_;</span><br><span class="line">  <span class="type">int</span>         health_; <span class="comment">// 初始血值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* attack_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>当我们构建一个品种，我们先传入它继承的父品种。 我们可以为基础品种传入<code>NULL</code>表明它没有祖先。</p><p>为了让这有用，子品种需要控制它从父品种继承了哪些属性，以及哪些属性需要重载并由自己指定。 在我们的示例系统中，我们可以说品种用非零值重载了怪物的健康，用非空字符串重载了攻击字符串。 否则，这些属性要从它的父品种里继承。</p><p>实现方式有两种。 一种是每次属性被请求时动态处理委托，就像这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Breed::getHealth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 重载</span></span><br><span class="line">  <span class="keyword">if</span> (health_ != <span class="number">0</span> || parent_ == <span class="literal">NULL</span>) <span class="keyword">return</span> health_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继承</span></span><br><span class="line">  <span class="keyword">return</span> parent_-&gt;<span class="built_in">getHealth</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Breed::getAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 重载</span></span><br><span class="line">  <span class="keyword">if</span> (attack_ != <span class="literal">NULL</span> || parent_ == <span class="literal">NULL</span>) <span class="keyword">return</span> attack_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继承</span></span><br><span class="line">  <span class="keyword">return</span> parent_-&gt;<span class="built_in">getAttack</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果品种在运行时修改种类，不再重载，或者不再继承某些属性时，这能保证做正确的事。 另一方面，这要更多的内存（它需要保存指向它的父品种的指针）而且更慢。 每次你查找属性都需要回溯继承链。</p><p>如果我们可以保证品种的属性不变，一个更快的解决方案是在构造时使用继承。 这被称为“复制”委托，因为在创建对象时，我们复制继承的属性到推导的类型。它看上去是这样的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Breed</span>(Breed* parent, <span class="type">int</span> health, <span class="type">const</span> <span class="type">char</span>* attack)</span><br><span class="line">: <span class="built_in">health_</span>(health),</span><br><span class="line">  <span class="built_in">attack_</span>(attack)</span><br><span class="line">{</span><br><span class="line">  <span class="comment">// 继承没有重载的属性</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">NULL</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span> (health == <span class="number">0</span>) health_ = parent-&gt;<span class="built_in">getHealth</span>();</span><br><span class="line">    <span class="keyword">if</span> (attack == <span class="literal">NULL</span>) attack_ = parent-&gt;<span class="built_in">getAttack</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意现在我们不再需要给父品种的字段了。 一旦构造器完成，我们可以忘了父品种，因为我们已经拷贝了它的所有属性。 为了获得品种的属性，我们现在直接返回字段：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>         <span class="title">getHealth</span><span class="params">()</span> </span>{ <span class="keyword">return</span> health_; }</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getAttack</span><span class="params">()</span> </span>{ <span class="keyword">return</span> attack_; }</span><br></pre></td></tr></tbody></table></figure><p>又好又快！</p><p>假设游戏引擎从品种的JSON文件加载设置然后创建类型。它看上去是这样的：</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"Troll"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"health"</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"attack"</span><span class="punctuation">:</span> <span class="string">"The troll hits you!"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"Troll Archer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"parent"</span><span class="punctuation">:</span> <span class="string">"Troll"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"health"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"attack"</span><span class="punctuation">:</span> <span class="string">"The troll archer fires an arrow!"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"Troll Wizard"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"parent"</span><span class="punctuation">:</span> <span class="string">"Troll"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"health"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"attack"</span><span class="punctuation">:</span> <span class="string">"The troll wizard casts a spell on you!"</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">:</span><span class="punctuation">:</span><span class="punctuation">:</span>json</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"Troll"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"health"</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"attack"</span><span class="punctuation">:</span> <span class="string">"The troll hits you!"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"Troll Archer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"parent"</span><span class="punctuation">:</span> <span class="string">"Troll"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"health"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"attack"</span><span class="punctuation">:</span> <span class="string">"The troll archer fires an arrow!"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"Troll Wizard"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"parent"</span><span class="punctuation">:</span> <span class="string">"Troll"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"health"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"attack"</span><span class="punctuation">:</span> <span class="string">"The troll wizard casts a spell on you!"</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>我们有一段代码读取每个品种，用新数据实例化品种实例。 就像你从<code>"parent": "Troll"</code>字段看到的， <code>Troll Archer</code>和<code>Troll Wizard</code>品种都由基础<code>Troll</code>品种继承而来。</p><p>由于派生类的初始血量都是0，所以该值从基础<code>Troll</code>品种继承。 这意味着无论怎么调整<code>Troll</code>的血量，三个品种的血量都会被更新。 随着品种的数量和属性的数量增加，这节约了很多时间。 现在，通过一小块代码，系统给了设计者控制权，让他们能好好利用时间。 与此同时，我们可以回去编码其他特性了。</p><h4 id="设计决策-1"><a href="#设计决策-1" class="headerlink" title="设计决策"></a>设计决策</h4><p>类型对象模式让我们建立类型系统，就好像在设计自己的编程语言。 设计空间是开放的，我们可以做很多有趣的事情。</p><p>在实践中，有些东西打破了我们的幻想。 时间和可维护性阻止我们创建特别复杂的东西。 更重要的是，无论如何设计类型系统，用户（通常不是程序员）要能轻松地理解它。 我们将其做得越简单，它就越有用。 所以我们在这里谈到的是已经反复探索的领域，开辟新路就留给学者和探索者吧。</p><h5 id="类型对象是封装的还是暴露的？"><a href="#类型对象是封装的还是暴露的？" class="headerlink" title="类型对象是封装的还是暴露的？"></a>类型对象是封装的还是暴露的？</h5><p>在我们的简单实现中，<code>Monster</code>有一个对品种的引用，但是它没有显式暴露这个引用。 外部代码不能直接获取怪物的品种。 从代码库的角度看来，怪物事实上是没有类型的，事实上它们拥有品种只是个实现细节。</p><p>我们可以很容易地改变这点，让<code>Monster</code>返回它的<code>Breed</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Breed&amp; <span class="title">getBreed</span><span class="params">()</span> </span>{ <span class="keyword">return</span> breed_; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前的代码……</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在本书的另一个例子中，我们遵守了惯例，返回对象的引用而不是对象的指针，保证了永远不会返回<code>NULL</code>。</p></blockquote><p>这样做改变了<code>Monster</code>的设计。 事实是所有怪物都拥有品种是API的可见部分了，下面是这两者各自的好处：</p><ul><li><p><strong>如果类型对象是封装的：</strong></p><ul><li><p><strong>类型对象模式的复杂性对代码库的其他部分是隐藏的。</strong> 它成为了只有有类型的对象才需要考虑的实现细节。</p></li><li><p><strong>有类型的对象可以选择性地修改类型对象的重载行为。</strong> 假设我们想要怪物在它接近死亡时改变它的攻击字符串。 由于攻击字符串总是通过<code>Monster</code>获取的，我们有一个方便的地方放置代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Monster::getAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span> (health_ &lt; LOW_HEALTH)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"The monster flails weakly."</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> breed_.<span class="built_in">getAttack</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果外部代码直接调用品种的<code>getAttack()</code>，我们就没有机会能插入逻辑。</p></li><li><p><strong>我们得为每个类型对象暴露的方法写转发。</strong> 这是这个设计的冗长之处。如果类型对象有很多方法，对象类也得为每一个方法建立属于自己的公共可见方法。</p></li></ul></li><li><p><strong>如果类型对象是暴露的：</strong></p><ul><li><strong>外部代码可以与类型对象直接交互，无需拥有类型对象的实例。</strong> 如果类型对象是封装的，那么没有一个拥有它的对象就没法使用它。 这阻止我们使用构造器模式这样的方法，在品种上调用方法来创建新怪物。 如果用户不能直接获得品种，他们就没办法调用它。</li><li><strong>类型对象现在是对象公共API的一部分了。</strong> 大体上，窄接口比宽接口更容易掌控——你暴露给代码库其他部分的越少，你需要处理的复杂度和维护工作就越少。 通过暴露类型对象，我们扩宽了对象的API，包含了所有类型对象提供的东西。</li></ul></li></ul><h5 id="有类型的对象是如何创建的？"><a href="#有类型的对象是如何创建的？" class="headerlink" title="有类型的对象是如何创建的？"></a>有类型的对象是如何创建的？</h5><p>使用这个模式，每个“对象”现在都是一对对象：主对象和它的类型对象。 所以我们怎样创建并绑定两者呢？</p><ul><li><strong>构造对象然后传入类型对象：</strong><ul><li><strong>外部代码可以控制分配。</strong> 由于调用代码也是构建对象的代码，它可以控制其内存位置。 如果我们想要UI在多种内存场景中使用（不同的分配器，在栈中，等等），这给了完成它的灵活性。</li></ul></li><li><strong>在类型对象上调用“构造器”函数：</strong><ul><li><strong>类型对象控制了内存分配。</strong> 这是硬币的另一面。如果我们不想让用户选择在内存中何处创建对象， 在类型对象上调用工厂方法可以达到这一点。 如果我们想保证所有的对象都来自具体的对象池或者其他的内存分配器时也有用。</li></ul></li></ul><h5 id="能改变类型吗？"><a href="#能改变类型吗？" class="headerlink" title="能改变类型吗？"></a>能改变类型吗？</h5><p>到目前为止，我们假设一旦对象创建并绑定到类型对象上，这永远不会改变。 对象创建时的类型就是它销毁时的类型。这其实没有必要。 我们可以允许对象随着时间改变它的类型。</p><p>让我们回想下我们的例子。 当怪物死去时，设计者告诉我们，有时它的尸体会复活成僵尸。 我们可以通过在怪物死亡时产生僵尸类型的新怪兽，但另一个选项是拿到现有的怪物，然后将它的品种改为僵尸。</p><ul><li><p><strong>如果类型不改变：</strong></p><ul><li><strong>编码和理解都更容易。</strong> 在概念上，大多数人不期望“类型”会改变。这符合大多数人的理解。</li><li><strong>更容易查找漏洞。</strong> 如果我们试图追踪怪物进入奇怪状态时的漏洞，现在看到的品种就是怪物始终保持的品种可以大大简化工作。</li></ul></li><li><p><strong>如果类型可以改变：</strong></p><ul><li><p><strong>需要创建的对象更少。</strong> 在我们的例子中，如果类型不能改变，我们需要消耗CPU循环创建新的僵尸怪物对象， 把原先对象中需要保留的属性都拷贝过来，然后删除它。 如果我们可以改变类型，所有的工作都被一个简单的声明取代。</p></li><li><p><strong>我们需要小心地做约束。</strong> 在对象和它的类型间有强耦合是很自然的事情。 举个例子，一个品种也许假设怪物当前的血量永远高于品种中的初始血量。</p><p>如果我们允许品种改变，我们需要确保已存对象满足新品种的需求。 当我们改变类型时，我们也许需要执行一些验证代码保证对象现在的状态对新类型是有意义的。</p></li></ul></li></ul><h5 id="它支持何种继承？"><a href="#它支持何种继承？" class="headerlink" title="它支持何种继承？"></a>它支持何种继承？</h5><ul><li><p><strong>没有继承：</strong></p><ul><li><strong>简单。</strong> 最简单的通常是最好的。如果你在类型对象间没有大量数据共享，为什么要为难自己呢？</li><li><strong>这会带来重复的工作。</strong> 我从未见过哪个编码系统中设计者不想要继承的。 当你有十五种不同的精灵时，协调血量就要修改十五处同样的数字真是糟透了。</li></ul></li><li><p><strong>单继承：</strong></p><ul><li><em>还是相对简单。</em> 它易于实现，但是，更重要的是，也易于理解。如果非技术用户正在使用这个系统，要操作的部分越少越好。 这就是很多编程语言只支持单继承的原因。这看起来是能力和简洁之间的平衡点。</li><li><em>查询属性更慢。</em> 为了在类型对象中获取一块数据，我们也许需要回溯继承链寻找是哪一个类型最终决定了值。 在性能攸关的代码上，我们也许不想花时间在这上面。</li></ul></li><li><p><strong>多重继承：</strong></p><ul><li><p><strong>可以避免绝大多数代码重复。</strong> 使用优良的多继承系统，用户可以为类型对象建立几乎没有冗余的层次。 改变数值时，我们可以避免很多复制和粘贴。</p></li><li><p><strong>复杂。</strong> 不幸的是，它的好处更多地是理论上的而非实际上的。多重继承很难理解。</p><p>如果僵尸龙继承僵尸和龙，哪些属性来自僵尸，哪些来自于龙？ 为了使用系统，用户需要理解如何遍历继承图，还需要有设计优秀层次的远见。</p><p>我看到的大多数C++编码标准趋向于禁止多重继承，Java和C#完全移除了它。 这承认了一个悲伤的事实：它太难掌握了，最好根本不要用。 尽管值得考虑，但你很少想要在类型对象上实现多重继承。就像往常一样，简单的总是最好的。</p></li></ul></li></ul><h4 id="参见-2"><a href="#参见-2" class="headerlink" title="参见"></a>参见</h4><ul><li><p>这个模式处理的高层问题是在多个对象间分享数据和行为。 另一个用另一种方式解决了相同问题的模式是原型模式。</p></li><li><p>类型对象是享元模式的近亲。 两者都让你在实例间分享代码。使用享元，意图是节约内存，而分享的数据也许不代表任何概念上对象的“类型”。 使用类型对象模式，焦点在组织性和灵活性。</p></li><li><p>这个模式和状态模式有很多相似之处。 两者都委托对象的部分定义给另外一个对象。 通过类型对象，我们通常委托了对象是什么：不变的数据概括描述对象。 通过状态，我们委托了对象现在是什么：暂时描述对象当前状态的数据。</p><p>当我们讨论对象改变它的类型时，你可以认为类型对象起到了和状态相似的职责。</p></li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/archives/341aeb83.html" rel="prev" title="序列模式"><i class="fa fa-chevron-left"></i> 序列模式</a></div><div class="post-nav-item"><a href="/archives/6ec960b4.html" rel="next" title="Two Pointers">Two Pointers <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%8F%E5%9B%BE"><span class="nav-number">2.1.</span> <span class="nav-text">意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%9C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">动机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%95%E6%9C%AF%E6%88%98%E6%96%97%EF%BC%81"><span class="nav-number">2.2.1.</span> <span class="nav-text">法术战斗！</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE-gt-%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.2.</span> <span class="nav-text">数据 &gt; 代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.3.</span> <span class="nav-text">解释器模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="nav-number">2.2.4.</span> <span class="nav-text">虚拟的机器码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8"><span class="nav-number">2.4.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E4%BD%8F"><span class="nav-number">2.5.</span> <span class="nav-text">记住</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%A0%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF"><span class="nav-number">2.5.1.</span> <span class="nav-text">你需要一个前端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%A0%E4%BC%9A%E6%83%B3%E5%BF%B5%E8%B0%83%E8%AF%95%E5%99%A8"><span class="nav-number">2.5.2.</span> <span class="nav-text">你会想念调试器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">2.6.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%95%E6%9C%AF%E7%9A%84API"><span class="nav-number">2.6.1.</span> <span class="nav-text">法术的API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%95%E6%9C%AF%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">2.6.2.</span> <span class="nav-text">法术指令集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%BC%8F%E6%9C%BA%E5%99%A8"><span class="nav-number">2.6.3.</span> <span class="nav-text">栈式机器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA-x3D-%E7%BB%84%E5%90%88"><span class="nav-number">2.6.4.</span> <span class="nav-text">行为 = 组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">2.6.5.</span> <span class="nav-text">一台虚拟机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7"><span class="nav-number">2.6.6.</span> <span class="nav-text">语法转换工具</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96"><span class="nav-number">2.7.</span> <span class="nav-text">设计决策</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%A0%86%E6%A0%88%EF%BC%9F"><span class="nav-number">2.7.1.</span> <span class="nav-text">指令如何访问堆栈？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="nav-number">2.7.2.</span> <span class="nav-text">你有什么指令？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E6%98%AF%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E7%9A%84%EF%BC%9F"><span class="nav-number">2.7.3.</span> <span class="nav-text">数值是如何表示的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F"><span class="nav-number">2.7.4.</span> <span class="nav-text">如何生成字节码？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%A7%81"><span class="nav-number">2.8.</span> <span class="nav-text">参见</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E6%B2%99%E7%9B%92"><span class="nav-number">3.</span> <span class="nav-text">子类沙盒</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%8F%E5%9B%BE-1"><span class="nav-number">3.1.</span> <span class="nav-text">意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%9C%BA-1"><span class="nav-number">3.2.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">3.3.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-1"><span class="nav-number">3.4.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E4%BD%8F-1"><span class="nav-number">3.5.</span> <span class="nav-text">记住</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">3.6.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B3%E7%AD%96%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.7.</span> <span class="nav-text">决策设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BE%9B%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">3.7.1.</span> <span class="nav-text">应该提供什么操作？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BA%94%E8%AF%A5%E7%9B%B4%E6%8E%A5%E6%8F%90%E4%BE%9B%EF%BC%8C%E8%BF%98%E6%98%AF%E5%8C%85%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%8F%90%E4%BE%9B%EF%BC%9F"><span class="nav-number">3.7.2.</span> <span class="nav-text">方法应该直接提供，还是包在对象中提供？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E5%AE%83%E9%9C%80%E8%A6%81%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">3.7.3.</span> <span class="nav-text">基类如何获得它需要的状态？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%A7%81-1"><span class="nav-number">3.8.</span> <span class="nav-text">参见</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">类型对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%8F%E5%9B%BE-2"><span class="nav-number">4.1.</span> <span class="nav-text">意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%9C%BA-2"><span class="nav-number">4.2.</span> <span class="nav-text">动机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%A1%88"><span class="nav-number">4.2.1.</span> <span class="nav-text">传统的面向对象方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%BB%BA%E7%B1%BB"><span class="nav-number">4.2.2.</span> <span class="nav-text">为类型建类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F-2"><span class="nav-number">4.2.3.</span> <span class="nav-text">模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-2"><span class="nav-number">4.3.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E4%BD%8F-2"><span class="nav-number">4.4.</span> <span class="nav-text">记住</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E8%BF%BD%E8%B8%AA%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.4.1.</span> <span class="nav-text">需要手动追踪类型对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E9%9A%BE%E4%B8%BA%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"><span class="nav-number">4.4.2.</span> <span class="nav-text">更难为每种类型定义行为</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">4.5.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A9%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%9B%B4%E5%83%8F%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">4.5.1.</span> <span class="nav-text">让类型对象更像类型：构造器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%88%86%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">4.5.2.</span> <span class="nav-text">通过继承分享数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96-1"><span class="nav-number">4.6.</span> <span class="nav-text">设计决策</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%98%E6%98%AF%E6%9A%B4%E9%9C%B2%E7%9A%84%EF%BC%9F"><span class="nav-number">4.6.1.</span> <span class="nav-text">类型对象是封装的还是暴露的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F"><span class="nav-number">4.6.2.</span> <span class="nav-text">有类型的对象是如何创建的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%83%BD%E6%94%B9%E5%8F%98%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="nav-number">4.6.3.</span> <span class="nav-text">能改变类型吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%83%E6%94%AF%E6%8C%81%E4%BD%95%E7%A7%8D%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="nav-number">4.6.4.</span> <span class="nav-text">它支持何种继承？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%A7%81-2"><span class="nav-number">4.7.</span> <span class="nav-text">参见</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">310</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">77</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/399504060" title="Bilibili → https://space.bilibili.com/399504060" rel="noopener" target="_blank"><i class="fa fa-th-large fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.6m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
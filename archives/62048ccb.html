<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言本节我们将添加单反弹漫反射全局间接照明。"><meta property="og:type" content="article"><meta property="og:title" content="A Gentle Introduction to DirectX Raytracing 12"><meta property="og:url" content="https://yousazoe.top/archives/62048ccb.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言本节我们将添加单反弹漫反射全局间接照明。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor12-Output.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor12-Output-20220129153109822.png"><meta property="article:published_time" content="2022-01-29T07:25:55.000Z"><meta property="article:modified_time" content="2022-06-07T15:26:55.993Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor12-Output.png"><link rel="canonical" href="https://yousazoe.top/archives/62048ccb.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>A Gentle Introduction to DirectX Raytracing 12 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/62048ccb.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">A Gentle Introduction to DirectX Raytracing 12</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-01-29 15:25:55" itemprop="dateCreated datePublished" datetime="2022-01-29T15:25:55+08:00">2022-01-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">光线追踪 (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>8.1k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>15 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor12-Output.png"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本节我们将添加单反弹漫反射全局间接照明。</p><span id="more"></span><blockquote><p>In <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor11/tutorial11.md.html">Tutorial 11</a>, we changed our Lambertian shading pass to stochastically shoot exactly one shadow ray per pixel, rather than shooting one ray per scene light. This demonstrates a very simplistic <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monte_Carlo_integration">Monte Carlo integration</a> process, which we will extend in this tutorial to compute one-bounce <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Diffuse_reflection">diffuse</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Global_illumination">global illumination</a>.</p></blockquote><p>在<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor11/tutorial11.md.html">教程 11</a>中，我们更改了 Lambertian 着色通道，以随机方式为每个像素精确地拍摄一条阴影光线，而不是为每个场景光拍摄一条光线。这演示了一个非常简单的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monte_Carlo_integration">Monte Carlo 积分</a>过程，我们将在本教程中对其进行扩展，以计算单次反射<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Diffuse_reflection">漫反射</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Global_illumination">全局照明</a>。</p><h3 id="Changes-to-our-C-Render-Pass"><a href="#Changes-to-our-C-Render-Pass" class="headerlink" title="Changes to our C++ Render Pass"></a>Changes to our C++ Render Pass</h3><blockquote><p>As in most of the later tutorials, differences in the C++ <code>RenderPass</code> are fairly minor. In our new <code>SimpleDiffuseGIPass.h</code>, we now add the following methods and variables:</p></blockquote><p>与后面的大多数教程一样，C++<code>RenderPass</code>中的差异非常小。在我们的 new <code>SimpleDiffuseGIPass.h</code> 中，我们现在添加以下方法和变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// So we can use an environment map to illuminate the scene</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">usesEnvironmentMap</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> <span class="literal">true</span>; }</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some user controls allowing the UI to switch on/off certain rays</span></span><br><span class="line"><span class="type">bool</span> mDoIndirectGI = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> mDoDirectShadows = <span class="literal">true</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The major change in <code>SimpleDiffuseGIPass::initialize()</code> occurs because we now plan to shoot <strong>two</strong> types of rays: <strong>shadow rays</strong> and <strong>indirect bounce rays</strong>. This means, we need to define both types when we initialize our <em><code>RayLaunce</code></em> wrapper class:</p></blockquote><p>主要变化 <code>SimpleDiffuseGIPass::initialize()</code> 是因为我们现在计划发射<strong>两种</strong>类型的光线： <strong>阴影光线</strong>和<strong>间接反弹光线</strong>。这意味着，我们需要在初始化 <code>RayLaunce</code> 包装类时定义这两种类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create our ray tracing wrapper and define the ray generation shader</span></span><br><span class="line">std::string shaderFile = <span class="string">"simpleDiffuseGI.rt.hlsl"</span>;</span><br><span class="line">mpRays = RayLaunch::<span class="built_in">create</span>(shaderFile, <span class="string">"DiffuseRayGen"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define our miss shaders</span></span><br><span class="line">mpRays-&gt;<span class="built_in">addMissShader</span>(shaderFile, <span class="string">"ShadowMiss"</span>);   <span class="comment">// Miss shader #0</span></span><br><span class="line">mpRays-&gt;<span class="built_in">addMissShader</span>(shaderFile, <span class="string">"IndirectMiss"</span>); <span class="comment">// Miss shader #1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define our hit groups (first is #0, second is #1)</span></span><br><span class="line">mpRays-&gt;<span class="built_in">addHitShader</span>(shaderFile, <span class="string">"ShadowClosest"</span>, <span class="string">"ShadowAny"</span>);  </span><br><span class="line">mpRays-&gt;<span class="built_in">addHitShader</span>(shaderFile, <span class="string">"IndirectClosest"</span>, <span class="string">"IndirectAny"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Finalize pass; compile and attach our scene</span></span><br><span class="line">mpRays-&gt;<span class="built_in">compileRayProgram</span>();</span><br><span class="line"><span class="keyword">if</span> (mpScene) mpRays-&gt;<span class="built_in">setScene</span>(mpScene);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The only other changes our C++ code includes sending additional variables down to our DirectX shaders, see <code>SimpleDiffuseGIPass::execute()</code>:</p></blockquote><p>我们的 C++ 代码的唯一其他更改包括将额外的变量发送到我们的 DirectX 着色器，请参阅 <code>SimpleDiffuseGIPass::execute()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Send down our optional UI parameters</span></span><br><span class="line"><span class="keyword">auto</span> rayGenVars = mpRays-&gt;<span class="built_in">getRayGenVars</span>();</span><br><span class="line">rayGenVars[<span class="string">"RayGenCB"</span>][<span class="string">"gDoIndirectGI"</span>] = mDoIndirectGI;</span><br><span class="line">rayGenVars[<span class="string">"RayGenCB"</span>][<span class="string">"gDirectShadow"</span>] = mDoDirectShadows;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set an environment map for indirect rays that miss geometry</span></span><br><span class="line"><span class="keyword">auto</span> missVars = mpRays-&gt;<span class="built_in">getMissVars</span>(<span class="number">1</span>);   <span class="comment">// Indirect rays use miss shader #1</span></span><br><span class="line">missVars[<span class="string">"gEnvMap"</span>] = mpResManager-&gt;<span class="built_in">getTexture</span>(ResourceManager::kEnvironmentMap);</span><br></pre></td></tr></tbody></table></figure><h3 id="HLSL-Changes-for-Diffuse-Global-Illumination"><a href="#HLSL-Changes-for-Diffuse-Global-Illumination" class="headerlink" title="HLSL Changes for Diffuse Global Illumination"></a>HLSL Changes for Diffuse Global Illumination</h3><blockquote><p>Open up <code>simpleDiffuseGI.rt.hlsl</code>. Our first change is we define a new set of shaders for our indirect ray. The miss shader is essentially copied from our environment map lookup in <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor10/tutorial10.md.html">Tutorial 10</a> and the any-hit shader is our standard any-hit shader that performs <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing#Alpha_testing">alpha testing</a>:</p></blockquote><p>打开 <code>simpleDiffuseGI.rt.hlsl</code>。我们的第一个变化是我们为间接光线定义了一组新的着色器。未命中着色器本质上是从<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor10/tutorial10.md.html">教程 10</a>中的环境贴图查找中复制而来的，而任意命中着色器是我们执行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing#Alpha_testing">alpha 测试</a>的标准任意命中着色器：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Identical to our environment map code in Tutoral 10</span></span><br><span class="line">[<span class="built_in">shader</span>(<span class="string">"miss"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndirectMiss</span><span class="params">(inout IndirectPayload rayData)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	float2 dims;</span><br><span class="line">	gEnvMap.<span class="built_in">GetDimensions</span>(dims.x, dims.y);</span><br><span class="line">	float2 uv = <span class="built_in">wsVectorToLatLong</span>(<span class="built_in">WorldRayDirection</span>());</span><br><span class="line">	rayData.color = gEnvMap[<span class="built_in">uint2</span>(uv * dims)].rgb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identical to any hit shaders for most other rays we've defined</span></span><br><span class="line">[<span class="built_in">shader</span>(<span class="string">"anyhit"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndirectAny</span><span class="params">(inout IndirectPayload rayData, </span></span></span><br><span class="line"><span class="params"><span class="function">                 BuiltinIntersectionAttribs attribs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">alphaTestFails</span>(attribs)) <span class="built_in">IgnoreHit</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Our new indirect ray’s closest hit shader is somewhat more complex, but essentially reproduces the direct illumination code from <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor11/tutorial11.md.html">Tutorial 11</a>. Basically: when we our bounce rays hit another surface, we do simple Lambertian shading at the hit points, using the same math we previously defined for primary hits. To save cost, we only shoot one shadow ray from each hit (rather than looping through all scene lights):</p></blockquote><p>我们新的间接光线的最近命中着色器稍微复杂一些，但基本上再现了<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor11/tutorial11.md.html">教程 11</a>中的直接照明代码。基本上：当我们的反弹光线照射到另一个表面时，我们会在命中点处进行简单的 Lambertian 着色，使用我们之前为主要命中定义的相同数学。为了节省成本，我们每次命中只拍摄一条阴影光线（而不是循环通过所有场景灯光）：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="built_in">shader</span>(<span class="string">"closesthit"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndirectClosest</span><span class="params">(inout IndirectPayload rayData, </span></span></span><br><span class="line"><span class="params"><span class="function">                     BuiltinIntersectionAttribs attribs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Extract data from our scene description to allow shading this point</span></span><br><span class="line">	ShadingData shadeData = <span class="built_in">getHitShadingData</span>( attribs );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pick a random light from our scene to shoot a shadow ray towards</span></span><br><span class="line">	<span class="type">int</span> lightToSample = <span class="built_in">min</span>( <span class="built_in">int</span>(gLightsCount * <span class="built_in">nextRand</span>(rayData.rndSeed)), </span><br><span class="line">                             gLightsCount - <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query our scene to get this info about the current light</span></span><br><span class="line">     <span class="type">float</span>  distToLight;   <span class="comment">// How far away is it?</span></span><br><span class="line">     float3 lightColor;    <span class="comment">// What color is it?</span></span><br><span class="line">     float3 toLight;       <span class="comment">// What direction is it from our current hitpoint?</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// A helper to query the Falcor scene to get light data</span></span><br><span class="line">     <span class="built_in">getLightData</span>(lightIdx, shadeData.posW, toLight, lightColor, distToLight);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Compute our Lambertion term (NL dot L)</span></span><br><span class="line">     <span class="type">float</span> NdotL = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(shadeData.N, toLight));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Shoot our ray.  Return 1.0 for lit, 0.0 for shadowed</span></span><br><span class="line">     <span class="type">float</span> vis   = <span class="built_in">shootShadowRay</span>(shadeData.posW, toLight, </span><br><span class="line">                                  <span class="built_in">RayTMin</span>(), distToLight);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Return the shaded Lambertian shading at this indirect hit point</span></span><br><span class="line">     rayData.color = vis * NdotL * lightColor * shadeData.diffuse / M_PI;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We also add a utility function, similar to <code>shootShadowRay</code> that encapsulates the process of shooting an indirect ray and returning the incident color in the selected direction:</p></blockquote><p>我们还添加了一个实用函数，类似于 <code>shootShadowRay</code> 封装了拍摄间接光线并返回所选方向的入射颜色的过程：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndirectPayload</span></span><br><span class="line">{</span><br><span class="line">	float3 color;    <span class="comment">// The color in the ray's direction</span></span><br><span class="line">	uint   rndSeed;  <span class="comment">// Our current random seed</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">shootIndirectRay</span><span class="params">(float3 orig, float3 dir, <span class="type">float</span> minT, uint seed)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Setup shadow ray and the default ray payload</span></span><br><span class="line">	RayDesc         rayColor = { orig, minT, dir, <span class="number">1.0e+38</span>f };</span><br><span class="line">	IndirectPayload payload  = { <span class="built_in">float3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), seed };</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trace our indirect ray.  Use hit group #1 and miss shader #1 (of 2)</span></span><br><span class="line">	<span class="built_in">TraceRay</span>(gRtScene, <span class="number">0</span>, <span class="number">0xFF</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, rayColor, payload);</span><br><span class="line">	<span class="keyword">return</span> payload.color;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Changes-to-our-Ray-Generation-Shader-to-Add-Indirect-Lighting"><a href="#Changes-to-our-Ray-Generation-Shader-to-Add-Indirect-Lighting" class="headerlink" title="Changes to our Ray Generation Shader to Add Indirect Lighting"></a>Changes to our Ray Generation Shader to Add Indirect Lighting</h4><blockquote><p>In our ray generation shader from <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor11/tutorial11.md.html">Tutorial 11</a>, we essentially have the following code:</p></blockquote><p>在<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor11/tutorial11.md.html">教程 11</a>中的光线生成着色器中，我们基本上有以下代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="built_in">shader</span>(<span class="string">"raygeneration"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SimpleDiffuseGIRayGen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// Shoot a shadow ray for our direct lighting</span></span><br><span class="line">     <span class="type">float</span> vis = <span class="built_in">shootShadowRay</span>(worldPos.xyz, toLight, gMinT, distToLight);</span><br><span class="line">     shadeColor += vis * NdotL * lightColor * difMatlColor.rgb / M_PI;</span><br><span class="line">     ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>After adding our color for <strong>direct illumination</strong> we need to add our color computations for <code>indirect illumination</code>:</p></blockquote><p>添加我们的<strong>直接照明</strong>颜色后，我们需要添加我们的颜色计算 <code>indirect illumination</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Pick a random direction for our indirect ray (in a cosine distribution)</span></span><br><span class="line">float3 bounceDir = <span class="built_in">getCosHemisphereSample</span>(randSeed, worldNorm.xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get NdotL for our selected ray direction</span></span><br><span class="line"><span class="type">float</span> NdotL = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(worldNorm.xyz, bounceDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shoot our indirect global illumination ray</span></span><br><span class="line">float3 bounceColor = <span class="built_in">shootIndirectRay</span>(worldPos.xyz, bounceDir, </span><br><span class="line">                                      gMinT, randSeed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Probability of sampling a cosine lobe</span></span><br><span class="line"><span class="type">float</span> sampleProb = NdotL / M_PI;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do Monte Carlo integration of indirect light (i.e., rendering equation)</span></span><br><span class="line"><span class="comment">//    -&gt; This is:  (NdotL * incoming light * BRDF) / probability-of-sample</span></span><br><span class="line">shadeColor += (NdotL * bounceColor * difMatlColor.rgb / M_PI) / sampleProb;</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This is doing <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monte_Carlo_integration">Monte Carlo integration</a> of the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rendering_equation">rendering equation</a> for just the indirect component of the lighting. In this tutorial, I explicitly define the sampling probability for our random ray.</p></blockquote><p>这是对光照的间接分量进行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rendering_equation">渲染方程</a> 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monte_Carlo_integration">蒙特卡罗积分</a>。在本教程中，我明确定义了随机射线的采样概率。</p><blockquote><p>In more efficient code, you would obviously cancel the duplicate terms. But for novices (and even experts), cancelling terms is an easy way to forget the underlying math. Once you forget the math, you might decide to select your ray differently and forget to update the accumulation term with a new sampling probability. Almost every rendering researcher and engineer has stories of “magic coefficients” used to get a good results in some code base—forgetting the underlying mathematics is usually the cause of these spurious magic numbers.</p></blockquote><p>在更高效的代码中，您显然会取消重复的术语。但是对于新手（甚至专家）来说，取消术语是一种忘记基础数学的简单方法。一旦你忘记了数学，你可能会决定以不同的方式选择你的射线，并忘记用新的采样概率更新累积项。几乎每个渲染研究人员和工程师都有关于在某些代码库中获得良好结果的“魔法系数”的故事——忘记基础数学通常是这些虚假魔法数字的原因。</p><h3 id="What-Does-it-Look-Like"><a href="#What-Does-it-Look-Like" class="headerlink" title="What Does it Look Like?"></a>What Does it Look Like?</h3><blockquote><p>That covers the important points of this tutorial. When running, you get the following result:</p></blockquote><p>这涵盖了本教程的重点。运行时，您会得到以下结果：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor12-Output-20220129153109822.png"></p><blockquote><p>With this tutorial, you now have one-bounce diffuse global illumination (and the UI allows you to turn on and off direct and indirect light for comparison). We’re getting close to an interesting renderer. However, before continuing on to add more complex materials and multi-bounce global illumination, <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor13/tutorial13.md.html">Tutorial 13</a> adds a detour to handle <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/High-dynamic-range_imaging">high dynamic range</a> outputs.</p></blockquote><p>通过本教程，您现在拥有单反射漫反射全局照明（并且 UI 允许您打开和关闭直接和间接光以进行比较）。我们正在接近一个有趣的渲染器。但是，在继续添加更复杂的材质和多反射全局照明之前， <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor13/tutorial13.md.html">教程 13</a>增加了处理<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/High-dynamic-range_imaging">高动态范围</a> 输出的弯路。</p><blockquote><p>When rendering simple materials and lighting, displaying colors in a monitor’s arbitrary [0…1] range is typically sufficient. However, adding multiple bounces and HDR environment maps starts giving output colors that no longer fit in that range. This can give very dark or blown out images. In order to address this, <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor13/tutorial13.md.html">Tutorial 13</a> allows you to turn on <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tone_mapping">tone mapping</a> to map a wider range of colors onto your monitor.</p></blockquote><p>在渲染简单的材质和光照时，在监视器的任意 [0…1] 范围内显示颜色通常就足够了。但是，添加多个反弹和 HDR 环境贴图会开始提供不再适合该范围的输出颜色。这会产生非常暗或过曝的图像。为了解决这个问题，<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor13/tutorial13.md.html">教程 13</a> 允许您打开<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tone_mapping">色调映射</a>以将更广泛的颜色映射到显示器上。</p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/1503bc5d.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 13</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/fb0ddd71.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 11</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/cacca1cf.html" rel="prev" title="Our First Triangle"><i class="fa fa-chevron-left"></i> Our First Triangle</a></div><div class="post-nav-item"><a href="/archives/1503bc5d.html" rel="next" title="A Gentle Introduction to DirectX Raytracing 13">A Gentle Introduction to DirectX Raytracing 13 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Changes-to-our-C-Render-Pass"><span class="nav-number">2.</span> <span class="nav-text">Changes to our C++ Render Pass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HLSL-Changes-for-Diffuse-Global-Illumination"><span class="nav-number">3.</span> <span class="nav-text">HLSL Changes for Diffuse Global Illumination</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Changes-to-our-Ray-Generation-Shader-to-Add-Indirect-Lighting"><span class="nav-number">3.1.</span> <span class="nav-text">Changes to our Ray Generation Shader to Add Indirect Lighting</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-Does-it-Look-Like"><span class="nav-number">4.</span> <span class="nav-text">What Does it Look Like?</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">271</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4m</span></div><div class="powered-by">今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//fastly.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//fastly.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//fastly.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script async="" src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script>!function(t,h,e,j){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:2272201,hjsv:6},e=h.getElementsByTagName("head")[0],(j=h.createElement("script")).async=1,j.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,e.appendChild(j)}(window,document)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
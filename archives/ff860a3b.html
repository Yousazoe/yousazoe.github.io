<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Vintage 80s office by        Mohamed Chahin             引言Acquire fundamental elements of algorithms and data structures."><meta property="og:type" content="article"><meta property="og:title" content="Algorithms and Data Structures I"><meta property="og:url" content="https://yousazoe.top/archives/ff860a3b.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Vintage 80s office by        Mohamed Chahin             引言Acquire fundamental elements of algorithms and data structures."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/2c6a8066350161.5b14609dc369c.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/insertionSort.gif"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210825112019357.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210825102505186.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210825103458574.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bubbleSort.gif"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210825223208799.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210826101114504.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210826101723045.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210826104017337.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830164811717.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830165140835.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830171638314.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830172108945.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830173659086.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210901104603378.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830224047245.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830224731815.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830225431016.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210901105114406.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210831110013313.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210831110648538.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210831111931081.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210901115117624.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/IMAGE2_ALDS1_3_D.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210831225645641.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210901144841510.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210902142228460.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913211856149.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913212426873.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210914084025098.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/IMAGE2_ALDS1_5_A.png"><meta property="article:published_time" content="2021-03-01T01:06:36.000Z"><meta property="article:modified_time" content="2022-06-11T15:53:11.708Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Online Judge"><meta property="article:tag" content="AOJ"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/2c6a8066350161.5b14609dc369c.png"><link rel="canonical" href="https://yousazoe.top/archives/ff860a3b.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Algorithms and Data Structures I | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/ff860a3b.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Algorithms and Data Structures I</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-03-01 09:06:36" itemprop="dateCreated datePublished" datetime="2021-03-01T09:06:36+08:00">2021-03-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E4%BC%9A%E6%B4%A5%E5%A4%A7%E5%AD%A6%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%84-Aizu-Online-Judge/" itemprop="url" rel="index"><span itemprop="name">会津大学在线测评 (Aizu Online Judge)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>41k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>1:14</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/2c6a8066350161.5b14609dc369c.png"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://www.behance.net/gallery/66350161/Vintage-80s-office">Vintage 80s office</a> by <a target="_blank" rel="noopener" href="https://www.behance.net/MChahin">Mohamed Chahin</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Acquire fundamental elements of algorithms and data structures.</p><span id="more"></span><h3 id="Topic-1-Getting-Started"><a href="#Topic-1-Getting-Started" class="headerlink" title="Topic #1 Getting Started"></a>Topic #1 Getting Started</h3><h4 id="ALDS1-1-A-Insertion-Sort"><a href="#ALDS1-1-A-Insertion-Sort" class="headerlink" title="ALDS1_1_A Insertion Sort"></a>ALDS1_1_A Insertion Sort</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Write a program of the Insertion Sort algorithm which sorts a sequence A in ascending order. The algorithm should be based on the following pseudocode:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to A.length<span class="number">-1</span></span><br><span class="line">    key = A[i]</span><br><span class="line">    <span class="comment">/* insert A[i] into the sorted sequence A[0,...,j-1] */</span></span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; key</span><br><span class="line">        A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">        j--</span><br><span class="line">    A[j+<span class="number">1</span>] = key</span><br></pre></td></tr></tbody></table></figure><p>Note that, indices for array elements are based on 0-origin.</p><p>To illustrate the algorithms, your program should trace intermediate result for each step.</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>The first line of the input includes an integer N, the number of elements in the sequence.</p><p>In the second line, <em>N</em> elements of the sequence are given separated by a single space.</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>The output consists of <em>N</em> lines. Please output the intermediate sequence in a line for each step. Elements of the sequence should be separated by single space.</p><h5 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h5><p>1 ≤ <em>N</em> ≤ 100</p><h5 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 2 4 6 1 3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5 2 4 6 1 3</span><br><span class="line">2 5 4 6 1 3</span><br><span class="line">2 4 5 6 1 3</span><br><span class="line">2 4 5 6 1 3</span><br><span class="line">1 2 4 5 6 3</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く"><a href="#問題を解く" class="headerlink" title="問題を解く"></a>問題を解く</h5><h6 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h6><p>本题要求我们实现插入排序算法并输出升序排列过程。在插入排序的过程中，会将整体数组分成“已排序部分”和“未排序部分”，题目中已经给出了插入排序的伪代码，我们可以先翻译一下整个排序过程：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">将开头元素视为已排序</span><br><span class="line">执行下述处理，直至未排序部分消失：</span><br><span class="line">	1. 取出未排序部分的开头元素赋给变量v</span><br><span class="line">	2. 在已排序的部分，将所有比v大的元素向后移一个单位</span><br><span class="line">	3. 将已取出的元素v插入空格</span><br></pre></td></tr></tbody></table></figure><p>如果这段话不是很好理解，我们可以用下图来阐释排序的整个过程：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/insertionSort.gif"></p><p>再举个例子，我们对数组<code>A={8,3,1,5,2,1}</code>进行插入排序时，整体流程如下：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210825112019357.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0: 8 3 1 5 2 1</span><br><span class="line">1: 3 8 1 5 2 1</span><br><span class="line">2: 1 3 8 5 2 1</span><br><span class="line">3: 1 3 5 8 2 1</span><br><span class="line">4: 1 2 3 5 8 1</span><br><span class="line">5: 1 1 2 3 5 8</span><br></pre></td></tr></tbody></table></figure><p>在步骤1中，将开头元素<code>A[0]</code>（=8）视为已排序，所以我们去除<code>A[1]</code>的3，将其插入已排序部分的恰当位置。首先把原先位于<code>A[0]</code>的8移动至<code>A[1]</code>，再把3插入<code>A[0]</code>。这样一来，开头2个元素就完成了排序。</p><p>在步骤2中，我们要把<code>A[2]</code>的1插入恰当位置。这里首先将比1大的<code>A[1]</code>（=8）和<code>A[0]</code>（=3）顺次向后移一个位置，然后把1插入<code>A[0]</code>。</p><p>在步骤3中，我们要把<code>A[3]</code>的5插入恰当位置。这次将比5大的<code>A[2]</code>（=8）向后移一个位置，然后把5插入<code>A[2]</code>。</p><p>之后同理，将已排序部分的其中一段向后移动，再把未排序部分的开头元素插入已排序部分的恰当位置。插入排序的特点在于，只要0到第i号元素全部排入已排序部分，那么无论后面如何插入，这个0到第i号的元素将永远保持排序完毕的状态。</p><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><p>回到代码实现，首先我们先将主函数的输入部分和单独的输出部分<code>trace()</code>函数写出来：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">" "</span> &lt;&lt; arr[i];</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>准备工作完成后开始写<code>insertionSort()</code>插入排序的函数：</p><ul><li><code>i</code>：循环变量，表示未排序部分的开头元素</li><li><code>key</code>：临时保存<code>arr[i]</code>值的变量</li><li><code>j</code>：循环变量，用于在已排序部分寻找<code>key</code>的插入位置</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="type">int</span> j,key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        key = arr[i];</span><br><span class="line"></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key){</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">        <span class="built_in">trace</span>(arr,n);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>外层循环的<code>i</code>自增。在每次循环开始时，将<code>arr[i]</code>的值临时保存在变量<code>key</code>中。</p><p>接下来是内部循环。我们要从已排序的部分找出比<code>key</code>大的元素并让它们顺次后移一个位置。这里我们让<code>j</code>从<code>i-1</code>开始向前自减，同时将比<code>key</code>大的元素从<code>arr[j]</code>移动到<code>arr[j+1]</code>。一旦<code>j</code>等于-1或当前<code>arr[j]</code>小于等于<code>key</code>则结束循环，并将<code>key</code>插入当前<code>j+1</code>的位置。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">" "</span> &lt;&lt; arr[i];</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="type">int</span> j,key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        key = arr[i];</span><br><span class="line"></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key){</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">        <span class="built_in">trace</span>(arr,n);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insertionSort</span>(arr,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><ul><li>数组长度是否足够长</li><li>是否搞错了0起点和1起点的数组下标</li><li>是否误用了循环变量（比如<code>i</code>、<code>j</code>）</li><li>是否输出了多余的空格或换行</li></ul><h6 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h6><p>在插入排序中，我们只将比<code>key</code>（取出的值）大的元素向后平移，不相邻的元素不会直接交换位置，因此整个排序算法十分稳定。</p><p>然后我们考虑一下插入排序算法的复杂度。这里需要估算每个<code>i</code>循环中<code>arr[j]</code>元素向后移动的次数。最坏情况下，每个<code>i</code>循环都需要执行<code>i</code>次移动，总共需要$1+2+…+N-1=(N^2-N)/2$次移动，即算法复杂度为$O(N^2)$。</p><p>插入排序是一种很有趣的算法，输入数据的顺序能大幅影响它的复杂度。我们前面说它的复杂度为$O(N^2)$，也仅是指输入数据为降序排列的情况。如果输入数据为升序排列，那么<code>arr[j]</code>从头到尾都不需要移动，程序仅需要经历<code>N</code>次比较便可执行完毕。可见，插入排序法的优势在于能快速处理相对有序的数据。</p><h4 id="ALDS1-1-B-Common-Divisor-Greatest"><a href="#ALDS1-1-B-Common-Divisor-Greatest" class="headerlink" title="ALDS1_1_B Common Divisor Greatest"></a>ALDS1_1_B Common Divisor Greatest</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Write a program which finds the greatest common divisor of two natural numbers <em>a</em> and <em>b</em></p><h5 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h5><p><em>a</em> and <em>b</em> are given in a line sparated by a single space.</p><h5 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h5><p>Output the greatest common divisor of <em>a</em> and <em>b</em>.</p><h5 id="Constrants"><a href="#Constrants" class="headerlink" title="Constrants"></a>Constrants</h5><p>1 ≤ <em>a</em>, <em>b</em> ≤ 109</p><h5 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h5><p>You can use the following observation:</p><p>For integers <em>x</em> and <em>y</em>, if <em>x</em> ≥ <em>y</em>, then gcd(<em>x</em>, <em>y</em>) = gcd(<em>y</em>, <em>x</em>%<em>y</em>)</p><h5 id="Sample-Input-1-1"><a href="#Sample-Input-1-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">54 20</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-1"><a href="#Sample-Output-1-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-1"><a href="#Sample-Input-2-1" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">147 105</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-1"><a href="#Sample-Output-2-1" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-1"><a href="#問題を解く-1" class="headerlink" title="問題を解く"></a>問題を解く</h5><p><strong>最大公因数</strong><br>最大公因数，也称最大公约数，指两个或多个整数共有约数中最大的一个。a，b的最大公约数记为（a，b）。求最大公约数有多种方法，常见的有质因数分解法、辗转相除法等等。</p><p><strong>欧几里得算法</strong><br>欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。欧几里得算法在RSA加密算法中有运用。</p><p><strong>算法分析</strong><br>算法通过连续计算余数，知道余数是0为止，最后所得的非0余数就是最大公因数。例如 M=1989 ，N=1590，则余数序列为399，393，6，3，0。因而，Gcd(1989,1590)=3，从余数的序列可知，这是一个快速收敛的算法。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">        r = m % n;</span><br><span class="line">        m = n;</span><br><span class="line">        n = r;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">gcd</span>(m, n) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ALDS1-1-C-Prime-Numbers"><a href="#ALDS1-1-C-Prime-Numbers" class="headerlink" title="ALDS1_1_C Prime Numbers"></a>ALDS1_1_C Prime Numbers</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.</p><p>Write a program which reads a list of <em>N</em> integers and prints the number of prime numbers in the list.</p><h5 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h5><p>The first line contains an integer <em>N</em>, the number of elements in the list.</p><p><em>N</em> numbers are given in the following lines.</p><h5 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h5><p>Print the number of prime numbers in the given list.</p><h5 id="Constraints-1"><a href="#Constraints-1" class="headerlink" title="Constraints"></a>Constraints</h5><p>1 ≤ <em>N</em> ≤ 10000</p><p>2 ≤ <em>an element of the list</em> ≤ 108</p><h5 id="Sample-Input-1-2"><a href="#Sample-Input-1-2" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-2"><a href="#Sample-Output-1-2" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-2"><a href="#Sample-Input-2-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">11</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-2"><a href="#Sample-Output-2-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-2"><a href="#問題を解く-2" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数，这样的数称为质数。</p><p>判断一个数 n 是否为质数，n 是否能被 [2,sqrt(n)] 间的整数整除：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">2</span> || num == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(num); ++i) {</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N, num, count = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(num))</span><br><span class="line">            count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ALDS1-1-D-Maximum-Profit"><a href="#ALDS1-1-D-Maximum-Profit" class="headerlink" title="ALDS1_1_D Maximum Profit"></a>ALDS1_1_D Maximum Profit</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>You can obtain profits from foreign exchange margin transactions. For example, if you buy 1000 dollar at a rate of 100 yen per dollar, and sell them at a rate of 108 yen per dollar, you can obtain (108 - 100) × 1000 = 8000 yen.</p><p>Write a program which reads values of a currency $R_t$ at a certain time $t$ ($t=0,1,2,…n−1$), and reports the maximum value of $R_j−R_i$ where $j&gt;i$ .</p><h5 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h5><p>The first line contains an integer nn. In the following nn lines, $R_t$ ($t=0,1,2,…n−1$) are given in order.</p><h5 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h5><p>Print the maximum value in a line.</p><h5 id="Constraints-2"><a href="#Constraints-2" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>2≤n≤200,000</li><li>1≤$R_t$≤$10^9$</li></ul><h5 id="Sample-Input-1-3"><a href="#Sample-Input-1-3" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-3"><a href="#Sample-Output-1-3" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></tbody></table></figure><p>价格为 1 时买入、为 4 时卖出可获得 4 - 1 = 3 的最大利益。虽然取最开始的 5 有 5 - 1 = 4 &gt; 3，但 5 的时间在 1 之前，不符合实际情况。</p><h5 id="Sample-Input-2-3"><a href="#Sample-Input-2-3" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-3"><a href="#Sample-Output-2-3" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></tbody></table></figure><p>由于我们的问题要求程序在 j &gt; i 的条件下完成 1 次买卖操作，因此得出最大利益为 -1。</p><h5 id="問題を解く-3"><a href="#問題を解く-3" class="headerlink" title="問題を解く"></a>問題を解く</h5><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210825102505186.png"></p><p>首先我们可以使用暴力算法遍历所有可能组合的情况：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j from <span class="number">1</span> to n<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> i from <span class="number">0</span> to j<span class="number">-1</span></span><br><span class="line">		maxv = <span class="built_in">max</span>(maxv, R[j] - R[i]);</span><br></pre></td></tr></tbody></table></figure><p>这个算法虽然可以获取正确的输出，但其复杂度高达 $O(n^2)$，考虑到输入上限会发现当输入较大时该程序无法在限制时间内完成处理，因此我们需要更高效的算法。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210825103458574.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">minv = R[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> j from <span class="number">1</span> to n<span class="number">-1</span></span><br><span class="line">	maxv = <span class="built_in">max</span>(maxv, R[j] - minv);</span><br><span class="line">	minv = <span class="built_in">min</span>(minv, R[j]);</span><br></pre></td></tr></tbody></table></figure><p>原先的简单算法时关于 n 的二重循环，复杂度为 $O(n^2)$。经我们改良之后，算法中仅包含一个循环，复杂度降低至 $O(n)$。另外改良后的算法不需要将输入数据保存在数组之内，因此同时也改善了内存的使用量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n, input;</span><br><span class="line">    <span class="type">int</span> minv, maxv = <span class="number">-1000000000</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cin &gt;&gt; input;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">            minv = input;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, input - minv);</span><br><span class="line">        minv = <span class="built_in">min</span>(minv, input);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; maxv &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Topic-2-Sort-I"><a href="#Topic-2-Sort-I" class="headerlink" title="Topic # 2 Sort I"></a>Topic # 2 Sort I</h3><h4 id="ALDS1-2-A-Bubble-Sort"><a href="#ALDS1-2-A-Bubble-Sort" class="headerlink" title="ALDS1_2_A Bubble Sort"></a>ALDS1_2_A Bubble Sort</h4><p>Write a program of the Bubble Sort algorithm which sorts a sequence <em>A</em> in ascending order. The algorithm should be based on the following pseudocode:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">BubbleSort</span>(A)</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span> to A.length<span class="number">-1</span></span><br><span class="line">     <span class="keyword">for</span> j = A.length<span class="number">-1</span> downto i+<span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> A[j] &lt; A[j<span class="number">-1</span>]</span><br><span class="line">             swap A[j] <span class="keyword">and</span> A[j<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure><p>Note that, indices for array elements are based on 0-origin.</p><p>Your program should also print the number of swap operations defined in line 4 of the pseudocode.</p><h5 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h5><p>The first line of the input includes an integer <em>N</em>, the number of elements in the sequence.</p><p>In the second line, <em>N</em> elements of the sequence are given separated by spaces characters.</p><h5 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h5><p>The output consists of 2 lines.</p><p>In the first line, please print the sorted sequence. Two contiguous elements of the sequence should be separated by a space character.</p><p>In the second line, please print the number of swap operations.</p><h5 id="Constraints-3"><a href="#Constraints-3" class="headerlink" title="Constraints"></a>Constraints</h5><p>1 ≤ <em>N</em> ≤ 100</p><h5 id="Sample-Input-1-4"><a href="#Sample-Input-1-4" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5 3 2 4 1</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-4"><a href="#Sample-Output-1-4" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">8</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-4"><a href="#Sample-Input-2-4" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 2 4 6 1 3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-4"><a href="#Sample-Output-2-4" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br><span class="line">9</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-4"><a href="#問題を解く-4" class="headerlink" title="問題を解く"></a>問題を解く</h5><h6 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h6><p>本题要求我们实现冒泡排序算法并输出升序排列过程。与插入排序一样，冒泡排序的各个计算步骤中，数组也分成“已排序部分”和“未排序部分”。题目中已经给出了插入排序的伪代码，我们可以先翻译一下整个排序过程：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">重复执行下述处理，直到数组中不包含顺序相反的相邻元素：</span><br><span class="line">	从数组末尾开始依次比较相邻两个元素，如果大小关系相反则交换位置</span><br></pre></td></tr></tbody></table></figure><p>如果这段话不是很好理解，我们可以用下图来阐释排序的整个过程：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/bubbleSort.gif"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210825223208799.png"></p><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> N)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; A[i];</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> N)</span> </span>{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = N - <span class="number">1</span>; j &gt;= i; --j) {</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[j - <span class="number">1</span>]) {</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j - <span class="number">1</span>]);</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">trace</span>(A, N);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> A[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bubbleSort</span>(A, N) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h6><p>冒泡排序仅对数组中的相邻元素进行比较和交换，因此键相同的元素不会改变顺序。所以冒泡排序也属于一种稳定排序的算法。但要注意的是，一旦将比较运算<code>arr[j] &lt; arr[j - 1]</code>改为<code>arr[j] &lt;= arr[j - 1]</code>，算法就会失去稳定性。</p><p>然后我们来考虑一下冒泡排序的复杂度。假设数据总量为<code>N</code>，冒泡排序需对未排序部分的相邻元素进行$(N-1)+(N-2)+…+1=(N^2-N)/2$次比较。也就是说，冒泡排序在最坏的情况下需要进行$(N^2-N)/2$次比较运算，算法复杂度数量级为$O(N^2)$。</p><p>顺便一提，冒泡排序中的交换次数又称为反序数或逆序数，可用于体现数列的错乱程度。</p><h4 id="ALDS1-2-B-Selection-Sort"><a href="#ALDS1-2-B-Selection-Sort" class="headerlink" title="ALDS1_2_B Selection Sort"></a>ALDS1_2_B Selection Sort</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Write a program of the Selection Sort algorithm which sorts a sequence A in ascending order. The algorithm should be based on the following pseudocode:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">SelectionSort</span>(A)</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span> to A.length<span class="number">-1</span></span><br><span class="line">      mini = i</span><br><span class="line">      <span class="keyword">for</span> j = i to A.length<span class="number">-1</span></span><br><span class="line">          <span class="keyword">if</span> A[j] &lt; A[mini]</span><br><span class="line">              mini = j</span><br><span class="line">      swap A[i] <span class="keyword">and</span> A[mini]</span><br></pre></td></tr></tbody></table></figure><p>Note that, indices for array elements are based on 0-origin.</p><p>Your program should also print the number of swap operations defined in line 6 of the pseudocode in the case where i ≠ mini.</p><h5 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h5><p>The first line of the input includes an integer <em>N</em>, the number of elements in the sequence.</p><p>In the second line, <em>N</em> elements of the sequence are given separated by space characters.</p><h5 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h5><p>The output consists of 2 lines.</p><p>In the first line, please print the sorted sequence. Two contiguous elements of the sequence should be separated by a space character.</p><p>In the second line, please print the number of swap operations.</p><h5 id="Constraints-4"><a href="#Constraints-4" class="headerlink" title="Constraints"></a>Constraints</h5><p>1 ≤ <em>N</em> ≤ 100</p><h5 id="Sample-Input-1-5"><a href="#Sample-Input-1-5" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 6 4 2 1 3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-5"><a href="#Sample-Output-1-5" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-5"><a href="#Sample-Input-2-5" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 2 4 6 1 3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-5"><a href="#Sample-Output-2-5" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-5"><a href="#問題を解く-5" class="headerlink" title="問題を解く"></a>問題を解く</h5><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210826101114504.png"></p><p>步骤 0 为初始状态，此时所有元素均属于未排序部分。</p><p>在步骤 1 中，我 们找出未排序部分最小值的位置（ minj = 6 )，然后将该位置的元素 A[6]( =1 ) 与未排序部分的起始元素 A[0]( = 5)进行交换。这样一来，已排序部分就增加了一个元素。</p><p>在步骤 2 中，找出未排序部分最小值的位置（ minj = 5 )，然后将该位置的元素 A[5]( = 3) 与未排序部分的起始元素 A[l]( = 4) 进行交换。后面的步骤同理，从数组开头按由小到大的顺 序逐个确定每个位置的值。 实现选择排序法时需要的主要变量如图 3.7 所示</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210826101723045.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210826104017337.png" alt="image-20210826104017337"></p><p>现在，让我们回过头来看看这三种排序算法（冒泡、选择、插入），比较一下它们的特征。</p><p>冒泡排序法与选择排序法相比，一个从局部入手减少逆序元素，一个放眼大局逐个选择最小值， 二者思路大不相同。但是，它们又都有着 “通过 i 次外层循环，从数据中顺次求岀 i 个最小值” 的相同特征。相对地，插入排序法是通过 i 次外层循环，直接将原数组的 i 个元素重新排序。另外，不含 flag 的简单冒泡排序法和选择排序法不依赖数据，即比较运算的次数（ 算法复杂度 ）不受输入数据影响，而插入算法在执行时却依赖数据，处理某些数据时具有很高的效率。</p><h4 id="ALDS1-2-C-Stable-Sort"><a href="#ALDS1-2-C-Stable-Sort" class="headerlink" title="ALDS1_2_C Stable Sort"></a>ALDS1_2_C Stable Sort</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Let’s arrange a deck of cards. There are totally 36 cards of 4 suits(S, H, C, D) and 9 values (1, 2, … 9). For example, ‘eight of heart’ is represented by H8 and ‘one of diamonds’ is represented by D1.</p><p>Your task is to write a program which sorts a given set of cards in ascending order by their values using the Bubble Sort algorithms and the Selection Sort algorithm respectively. These algorithms should be based on the following pseudocode:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">BubbleSort</span>(C)</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span> to C.length<span class="number">-1</span></span><br><span class="line">      <span class="keyword">for</span> j = C.length<span class="number">-1</span> downto i+<span class="number">1</span></span><br><span class="line">          <span class="keyword">if</span> C[j].value &lt; C[j<span class="number">-1</span>].value</span><br><span class="line">              swap C[j] <span class="keyword">and</span> C[j<span class="number">-1</span>]</span><br><span class="line"><span class="built_in">SelectionSort</span>(C)</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span> to C.length<span class="number">-1</span></span><br><span class="line">      mini = i</span><br><span class="line">      <span class="keyword">for</span> j = i to C.length<span class="number">-1</span></span><br><span class="line">          <span class="keyword">if</span> C[j].value &lt; C[mini].value</span><br><span class="line">              mini = j</span><br><span class="line">      swap C[i] <span class="keyword">and</span> C[mini]</span><br></pre></td></tr></tbody></table></figure><p>Note that, indices for array elements are based on 0-origin.</p><p>For each algorithm, report the stability of the output for the given input (instance). Here, ‘stability of the output’ means that: cards with the same value appear in the output in the same order as they do in the input (instance).</p><h5 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h5><p>The first line contains an integer <em>N</em>, the number of cards.</p><p><em>N</em> cards are given in the following line. Each card is represented by two characters. Two consecutive cards are separated by a space character.</p><h5 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h5><p>In the first line, print the arranged cards provided by the Bubble Sort algorithm. Two consecutive cards should be separated by a space character.</p><p>In the second line, print the stability (“Stable” or “Not stable”) of this output.</p><p>In the third line, print the arranged cards provided by the Selection Sort algorithm. Two consecutive cards should be separated by a space character.</p><p>In the fourth line, print the stability (“Stable” or “Not stable”) of this output.</p><h5 id="Constraints-5"><a href="#Constraints-5" class="headerlink" title="Constraints"></a>Constraints</h5><p>1 ≤ <em>N</em> ≤ 36</p><h5 id="Sample-Input-1-6"><a href="#Sample-Input-1-6" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">H4 C9 S4 D2 C3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-6"><a href="#Sample-Output-1-6" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">D2 C3 H4 S4 C9</span><br><span class="line">Stable</span><br><span class="line">D2 C3 S4 H4 C9</span><br><span class="line">Not stable</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-6"><a href="#Sample-Input-2-6" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">S1 H1</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-6"><a href="#Sample-Output-2-6" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">S1 H1</span><br><span class="line">Stable</span><br><span class="line">S1 H1</span><br><span class="line">Stable</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-6"><a href="#問題を解く-6" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>由于本题中的 N 值较小，因此我们在检查排序结果是否稳定时，可以用 Program 3.2 中的 这种比较笨的 $o(N^4)$ 算法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">isStable</span>(in, out)</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to N - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> j = i + <span class="number">1</span> to N - <span class="number">1</span></span><br><span class="line">			<span class="keyword">for</span> a = <span class="number">0</span> to N - <span class="number">1</span></span><br><span class="line">				<span class="keyword">for</span> b = a + <span class="number">1</span> to N - <span class="number">1</span></span><br><span class="line">					<span class="keyword">if</span> in[i].num == in[j].num</span><br><span class="line">                    	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>               	</span><br></pre></td></tr></tbody></table></figure><p>本题中使用 $O(N^4)$ 的算法足以满足要求，但在处理 N 更大的问题时，就需要多花些心思 了。冒泡排序法属于稳定排序算法，因此输出永远都是“Stable”。然而，选择排序法是一种不稳定的排序算法，因此必须检查输出结果。其实，我们可以将选择排序的结果与冒泡排序的结果相比较，如此一 来只用 $O(N)$ 便能解决问题。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Card</span> {</span><br><span class="line">    <span class="type">char</span> suit;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (Card c1, Card c2) {</span><br><span class="line">    <span class="keyword">return</span> c1.value &lt; c2.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace</span><span class="params">(Card A[], <span class="type">int</span> N)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        cout &lt;&lt; A[i].suit &lt;&lt; A[i].value;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(Card A[], <span class="type">int</span> N)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = N - <span class="number">1</span>; j &gt;= i + <span class="number">1</span>; --j) {</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[j - <span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(Card A[], <span class="type">int</span> N)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        <span class="type">int</span> minj = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; N; ++j) {</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[minj])</span><br><span class="line">                minj = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[minj]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isStable</span><span class="params">(Card C1[], Card C2[], <span class="type">int</span> N)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (C1[i].suit != C2[i].suit)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    Card C1[<span class="number">50</span>], C2[<span class="number">50</span>];</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        cin &gt;&gt; C1[i].suit &gt;&gt; C1[i].value;</span><br><span class="line">        C2[i] = C1[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort</span>(C1, N);</span><br><span class="line">    <span class="built_in">insertionSort</span>(C2, N);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">trace</span>(C1, N);</span><br><span class="line">    cout &lt;&lt; <span class="string">"Stable"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">trace</span>(C2, N);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStable</span>(C1, C2, N))</span><br><span class="line">        cout &lt;&lt; <span class="string">"Stable"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"Not stable"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ALDS1-2-D-Shell-Sort"><a href="#ALDS1-2-D-Shell-Sort" class="headerlink" title="ALDS1_2_D Shell Sort"></a>ALDS1_2_D Shell Sort</h4><blockquote><p>Time Limit : 6 sec , Memory Limit : 131072 KB</p></blockquote><p>Shell Sort is a generalization of <a target="_blank" rel="noopener" href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_1_A">Insertion Sort</a> to arrange a list of nn elements AA.</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">insertionSort</span>(A, n, g)</span><br><span class="line">    <span class="keyword">for</span> i = g to n<span class="number">-1</span></span><br><span class="line">        v = A[i]</span><br><span class="line">        j = i - g</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; v</span><br><span class="line">            A[j+g] = A[j]</span><br><span class="line">            j = j - g</span><br><span class="line">            cnt++</span><br><span class="line">        A[j+g] = v</span><br><span class="line"></span><br><span class="line"><span class="built_in">shellSort</span>(A, n)</span><br><span class="line">   cnt = <span class="number">0</span></span><br><span class="line">   m = ?</span><br><span class="line">   G[] = {?, ?,..., ?}</span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span> to m<span class="number">-1</span></span><br><span class="line">       <span class="built_in">insertionSort</span>(A, n, G[i])</span><br></pre></td></tr></tbody></table></figure><p>A function shellSort(A, n) performs a function insertionSort(A, n, g), which considers every <em>g</em>-th elements. Beginning with large values of gg, it repeats the insertion sort with smaller <em>g</em>.</p><p>Your task is to complete the above program by filling ?. Write a program which reads an integer <strong>n</strong> and a sequence <strong>A</strong>, and prints <strong>m</strong>, $G_i(i=0,1,…,m−1)$ in the pseudo code and the sequence <strong>A</strong> in ascending order. The output of your program must meet the following requirements:</p><ul><li>1 ≤ m ≤ 100</li><li>0 ≤ $G_i$ ≤ n</li><li>cnt does not exceed ⌈$n^{1.5}$⌉</li></ul><h5 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h5><p>In the first line, an integer nn is given. In the following nn lines, $A_i(i=0,1,…,n−1)$ are given for each line.</p><h5 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h5><p>In the first line, print an integer mm. In the second line, print <strong>m</strong> integers $G_i(i=0,1,…,m−1)$ separated by single space character in a line.<br>In the third line, print cnt in a line. In the following nn lines, print $A_i(i=0,1,…,n−1)$$ respectively.</p><p>This problem has multiple solutions and the judge will be performed by a special validator.</p><h5 id="Constraints-6"><a href="#Constraints-6" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>1 ≤ n ≤ 1,000,000</li><li>0 ≤ $A_i$ ≤ $10^9$</li></ul><h5 id="Sample-Input-1-7"><a href="#Sample-Input-1-7" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-7"><a href="#Sample-Output-1-7" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-7"><a href="#Sample-Input-2-7" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-7"><a href="#Sample-Output-2-7" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-7"><a href="#問題を解く-7" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>我们之前提到过，插入排序法可以高速处理顺序较整齐的数据，而希尔排序法就是充分发挥插人排序法这一特长的高速算法。希尔排序法中，程序会重复进行以间隔为 $g$ 的元素为对象的插入排序。举个例子，设 $g$ 的集合为 $G$，对 $A = {4,8,9,1,10,6,2,5,3, 7}$ 进行 $G ={4,3,1}$ 的希尔排序，其整体过程如图 3.9 所示。</p><p>图 3.9 中，我们按照处理顺序自上而下地列出了数组元素的变化:， 每一步计算中，程序都将 $A[i]$ ( 最后一个深灰色元素 ）插入前方间隔为 $g$ 的元素列（ 此时已经排序完毕 ）的恰当位置。图右侧的补充说明，是为了标出各组间隔为 $g$ 的插入排序。这里请注意，程序的处理顺序与组的顺序无关。</p><p>要想完成数据排序必须在最后执行 $g = 1$，即普通的插入排序法。不过，此时对象数据的 顺序应该已经很整齐了。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830164811717.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830165140835.png"></p><p>$g = G_i$ 的选择方法数不胜数，至今为止人们已对其进行了许多研究，不过其相关解析超出 r本书的范围，所以这里仅给各位举个例子：当 $g= 1,4,13,40,121…$，即 $g_{n + 1} = 3g_n + l$ 时，算法的复杂度基本维持在 $O(N^{1.25})$。除上述数列外，只要使用最终值为 1 的递减数列，基本都能高效地完成数据排序。不过，如果遇到 2 的幂指数（$ 2^n = 1,2,4,8…$ ）等 1 之前几乎不需要排序的数列，希尔排序法的效率会大打折扣。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> g)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = g; i &lt; n; ++i) {</span><br><span class="line">        <span class="type">int</span> v = A[i];</span><br><span class="line">        <span class="type">int</span> j = i - g;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; v) {</span><br><span class="line">            A[j + g] = A[j];</span><br><span class="line">            j -= g;</span><br><span class="line">            cnt++;</span><br><span class="line">        }</span><br><span class="line">        A[j + g] = v;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">1</span>; ; ) {</span><br><span class="line">        <span class="keyword">if</span> (h &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        G.<span class="built_in">push_back</span>(h);</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = G.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">        <span class="built_in">insertSort</span>(A, n, G[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    }</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shellSort</span>(A, n);</span><br><span class="line">    cout &lt;&lt; G.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = G.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">        cout &lt;&lt; G[i];</span><br><span class="line">        <span class="keyword">if</span> (i) cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cout &lt;&lt; A[i] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Topic-3-Elementary-data-structures"><a href="#Topic-3-Elementary-data-structures" class="headerlink" title="Topic # 3 Elementary data structures"></a>Topic # 3 Elementary data structures</h3><p>要想实现高效的算法，离不开高效管理数据的 “数据结构”。长期以来，人们针对各种问题开发了种类繁多的数据结构。</p><p>本章就将带领各位求解一些与初等数据结构有关的问题。</p><h4 id="ALDS1-3-A-Stack"><a href="#ALDS1-3-A-Stack" class="headerlink" title="ALDS1_3_A Stack"></a>ALDS1_3_A Stack</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Reverse Polish notation is a notation where every operator follows all of its operands. For example, an expression (1+2)*(5+4) in the conventional Polish notation can be represented as 1 2 + 5 4 + * in the Reverse Polish notation. One of advantages of the Reverse Polish notation is that it is parenthesis-free.</p><p>Write a program which reads an expression in the Reverse Polish notation and prints the computational result.</p><p>An expression in the Reverse Polish notation is calculated using a stack. To evaluate the expression, the program should read symbols in order. If the symbol is an operand, the corresponding value should be pushed into the stack. On the other hand, if the symbols is an operator, the program should pop two elements from the stack, perform the corresponding operations, then push the result in to the stack. The program should repeat this operations.</p><h5 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h5><p>An expression is given in a line. Two consequtive symbols (operand or operator) are separated by a space character.</p><p>You can assume that +, - and * are given as the operator and an operand is a positive integer less than 106</p><h5 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h5><p>Print the computational result in a line.</p><h5 id="Constraints-7"><a href="#Constraints-7" class="headerlink" title="Constraints"></a>Constraints</h5><p>2 ≤ the number of operands in the expression ≤ 100<br>1 ≤ the number of operators in the expression ≤ 99<br>-1 × $10^9$ ≤ values in the stack ≤ $10^9$</p><h5 id="Sample-Input-1-8"><a href="#Sample-Input-1-8" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 +</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-8"><a href="#Sample-Output-1-8" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-8"><a href="#Sample-Input-2-8" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 + 3 4 - *</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-8"><a href="#Sample-Output-2-8" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-3</span><br></pre></td></tr></tbody></table></figure><h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><p><a target="_blank" rel="noopener" href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/3/template/ALDS1_3_A_template.c">Template in C</a></p><h5 id="問題を解く-8"><a href="#問題を解く-8" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>逆波兰表示法是一种将运算符写在操作数后面的描述程序（算式）的方法。举个例子，我们平常用中缀表示法描述的算式（ 1 + 2 ) * ( 5 + 4 )，改为逆波兰表示法之后则是 1 2 + 54 + *。相较于中缀表示法，逆波兰表示法的优势在于不需要括号。</p><p>用逆波兰表示法描述的算式可以借助栈进行运算。如图 4.2 所示，程序在计算时从算式开 头逐一读取字符串，如果字符串是操作数（ 数值 ）则压入栈，如果是运算符（ + 、 - 、* ) 则从栈中取出两个数值算出结果再压入栈，如此循环。最终栈中剩下的数值便是答案。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830171638314.png"></p><p>栈等数据结构可以通过多种方法来实现，比如使用数组或表（指针）。本书重点带领各位理解数据结构的操作和限制，因此这里用数组来实现存储整型数据的栈。 用数组实现栈主要需要以下变量及函数：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830172108945.png"></p><ul><li><p>用来存储数据的一维整型数组：<code>S</code></p><p><code>push</code> 来的数据存储在数组 <code>S</code> 的各元素之中。需要根据问题内容保证充足的内存空间。另外，这里介绍的实现方法中 S[0] —直为空，图 4.3 所示的情况代表容量为 5 的栈中已压入了 3 个元素</p></li><li><p>用作栈顶指针的整型变量：<code>top</code></p><p>指明了栈顶部（栈顶）元素（最后被添加的元素）的整型变量。<code>top</code> 表示最后一个被添加的元素存储在什么位置。这个变量称为栈顶指针。另外，<code>top</code> 的值与栈中元素的数量相等</p></li><li><p>向栈中添加元素 <code>x</code> 的函数：<code>push(x)</code></p><p><code>top</code> 增加 1，<code>x</code> 代入 <code>S[top]</code></p></li><li><p>从栈顶取出元素的函数：<code>pop()</code></p><p>返回 <code>S[top]</code> 的值，<code>top</code> 减少 1</p></li></ul><p>下面我们来看看实际操作栈时的样子。图 4.4 所示的是一个由数组构成的栈，我们随意选了 一些值来演示栈的压入和取出。数据结构的操作是一个动态过程，因此栈的元素也是时常变化的：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830173659086.png"></p><h6 id="原生栈"><a href="#原生栈" class="headerlink" title="原生栈"></a>原生栈</h6><p><code>push(x)</code> 送来的元素在 <code>top</code> 加 1 之后插入 <code>S[top]</code>。相对地，<code>pop()</code> 返回 <code>top</code> 所指的元素，然后让 <code>top</code> 减一。</p><p>由数组构成的栈可以通过下述伪代码实现。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">initialize</span>()</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line"><span class="built_in">isEmpty</span>()</span><br><span class="line">	<span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line"><span class="built_in">isFull</span>()</span><br><span class="line">    <span class="keyword">return</span> top &gt;= MAX - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>(x)</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">isFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="title">error</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	top++</span>;</span><br><span class="line">	s[top] = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pop</span>()</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="title">error</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    top--</span>;</span><br><span class="line">	<span class="keyword">return</span> S[top + <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li><code>initialize</code> 函数将 <code>top</code> 置 0, 清空栈。此时数组（内存）中的元素虽然还在，但会被之后的 <code>push</code> 操作覆盖。<code>isEmpty</code> 函数通过检查 <code>top</code> 是否为 0 来判断栈中有无元素</li><li><code>isFull</code> 函数用于判断栈是否已满。比方说，我们用作栈的 0 起点数组的容量为 <code>MAX</code>， 那么 <code>top</code> 大于或等于 <code>MAX - 1</code> 时栈就是满的</li><li><code>push</code> 函数会将 <code>top</code> 加 1，然后在 <code>top</code> 所指的位置添加元素 <code>x</code>。另外，在栈已满的状态下进行报错处理</li><li><code>pop</code> 函数返冋 <code>top</code> 所指的元素，即位于栈顶的元素，同时将 <code>top</code> 减一，将栈顶元素删除。另外，在栈为空的状态下进行报错处理</li></ul><p>设计、实现数据结构时，我们要估算对其执行各种操作时的复杂度。本题介绍了以数组为基础的栈操作，考虑到对栈顶指针的加、 减以及数组的代入运算，<code>pop</code> 与 <code>push</code> 的复杂度都为 $O(1)$。</p><blockquote><p>一般情况下，数据结构多以结构体或类的形式实现。以类的形式可以同时管理多种数据结构，方便程序调用数据。</p></blockquote><h6 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h6><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210901104603378.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[<span class="number">0</span>])){</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>()));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> b = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">"+"</span>) st.<span class="built_in">push</span>(b + a);</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">"-"</span>) st.<span class="built_in">push</span>(b - a);</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">"*"</span>) st.<span class="built_in">push</span>(b * a);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的 <code>atoi()</code> 是 C 语言标准库中的函数，用于将自负串形式的数字转换为整型数值。</p><h4 id="ALDS1-3-B-Queue"><a href="#ALDS1-3-B-Queue" class="headerlink" title="ALDS1_3_B Queue"></a>ALDS1_3_B Queue</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>There are <em>n</em> processes in a queue. Each process has name<em>i</em> and time<em>i</em>. The round-robin scheduling handles the processes in order. A round-robin scheduler gives each process a <em>quantum</em> (a time slot) and interrupts the process if it is not completed by then. The process is resumed and moved to the end of the queue, then the scheduler handles the next process in the queue.</p><p>For example, we have the following queue with the quantum of 100ms.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A(150) - B(80) - C(200) - D(200)</span><br></pre></td></tr></tbody></table></figure><p>First, process A is handled for 100ms, then the process is moved to the end of the queue with the remaining time (50ms).</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">B(80) - C(200) - D(200) - A(50)</span><br></pre></td></tr></tbody></table></figure><p>Next, process B is handled for 80ms. The process is completed with the time stamp of 180ms and removed from the queue.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C(200) - D(200) - A(50)</span><br></pre></td></tr></tbody></table></figure><p>Your task is to write a program which simulates the round-robin scheduling.</p><h5 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h5><p><em>n</em> <em>q</em><br>$name_1$ $time_1$<br>$name_2$ $time_2$<br>…<br>$name_n$ $time_n$</p><p>In the first line the number of processes <em>n</em> and the quantum <em>q</em> are given separated by a single space.</p><p>In the following <em>n</em> lines, names and times for the <em>n</em> processes are given. <em>namei</em> and <em>timei</em> are separated by a single space.</p><h5 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h5><p>For each process, prints its name and the time the process finished in order.</p><h5 id="Constraints-8"><a href="#Constraints-8" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>1 ≤ <em>n</em> ≤ 100000</li><li>1 ≤ <em>q</em> ≤ 1000</li><li>1 ≤ $time_i$ ≤ 50000</li><li>1 ≤ length of $name_i$ ≤ 10</li><li>1 ≤ Sum of $time_i$ ≤ 1000000</li></ul><h5 id="Sample-Input-1-9"><a href="#Sample-Input-1-9" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5 100</span><br><span class="line">p1 150</span><br><span class="line">p2 80</span><br><span class="line">p3 200</span><br><span class="line">p4 350</span><br><span class="line">p5 20</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-9"><a href="#Sample-Output-1-9" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p2 180</span><br><span class="line">p5 400</span><br><span class="line">p1 450</span><br><span class="line">p3 550</span><br><span class="line">p4 800</span><br></pre></td></tr></tbody></table></figure><h5 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes"></a>Notes</h5><p><a target="_blank" rel="noopener" href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/3/template/ALDS1_3_B_template.c">Template in C</a></p><h5 id="問題を解く-9"><a href="#問題を解く-9" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>现有名称为 $name_i$ 且处理时间为的 $time_i$ 个任务按顺序排成一列，CPU 通过循环调度法逐一处理这些任务，每个任务最多处理 q ms （这个时间称为时间片）。如果 q ms 之后任务尚未处理完毕，那么该任务将被移动至队伍最末尾，CPU 随即开始处理下一 个任务。</p><p>举个例子，假设 q 是 100, 然后有如下任务队列。</p><p>A ( 150 ) - B ( 80 ) - C ( 200 ) - D ( 200 )</p><p>首先 A 被处理 100 ms，然后带着剩余的 50 ms 移动至队尾。</p><p>B ( 80 ) - C ( 200 ) - D ( 200 ) - A ( 50 )</p><p>随后 B 被处理 80 ms，在总计第 180 ms 时完成处理，从队列中消失。</p><p>C ( 200 ) - D ( 200 ) - A ( 50 )</p><p>接下来 C 被处理 100 ms, 然后带着剩余的 100 ms 移动至队尾。</p><p>D ( 200 ) - A ( 50 ) - C ( 100 )</p><p>之后同理，一直循环到处理完所有任务。 请编写一个程序，模拟循环调度法。</p><h6 id="原生队列"><a href="#原生队列" class="headerlink" title="原生队列"></a>原生队列</h6><p>我们可以用存放（ 管理 ）任务的队列来模拟循环调度法。首先，将初始状态的任务按顺序存入队列，然后从队头取任务 ，最多进行一个时间片的处理，再将仍需更多处理（ 时间 ）的任 务重新添加至队列，如此循环直至队列为空。</p><p>这里要向各位介绍一下如何用数组实现一个存放整型数据的队列。用数组实现队列主要需要以下变量和函数（ 图 4.5 )。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830224047245.png"></p><ul><li><p>用来存放数据的一维整型数组：<code>Q</code></p><p><code>enqueue</code> 来的数据存放在数组 <code>Q</code> 的各元素中。需要根据问题内容保证足够的内存空间。 图 4.5 是已存入数个元素的情况</p></li><li><p>用作队头指针的整型变量：<code>head</code></p><p>指示队列开头位置的变量。<code>dequeue</code> 会取出所指的元素。请注意，队头元素的下标不总是 0</p></li><li><p>用作队尾指针的整型变量：<code>tail</code></p><p>指示队列末尾 + 1 是哪个位置（ 最后一个元素的后一个位置 ）的变量。<code>tail</code> 所指的位置就是要添加新元素的位置。<code>head</code> 与 <code>tail</code> 夹着的部分（ 不包含 <code>tail</code> 所指的元素 ）是队列的内容</p></li><li><p>向队列添加新元素 <code>x</code> 的函数：<code>enqueue(x)</code></p><p>将 <code>x</code> 代入，然后 <code>tail</code> 加 1</p></li><li><p>从队列开头取出元素的函数：<code>dequeue()</code></p><p>返问 <code>Q[head]</code> 的值，然后 <code>head</code> 加 1</p></li></ul><p>下面我们来看看实际操作队列时的样子。图 4.6 演示了队列中值的添加和取出：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830224731815.png"></p><p>当 <code>head</code> 和 <code>tail</code> —致时队列为空，但此时这两个变量不一定为 0。每执行一次 <code>enqueue(x)</code>，新元素就会加人到 <code>tail</code> 的位置，然后 <code>tail</code> 增加 1。执行 <code>dequeue()</code> 则会返回 <code>head</code> 所指的元素，然后 <code>head</code> 加 1。</p><p>用数组实现队列会出现图 4.6 所示的情况，随着数据不断进出，<code>head</code> 与 <code>tail</code> 之间的队列主体部分会逐渐向数组末尾（ 图的右侧 ） 移动。这样一来，<code>tail</code> 和 <code>head</code> 很快会超出数组的容量上限。如果 <code>tail</code> 超出数组下标上限即判定为向上溢出，那么整个数组中会有相当大的一部分空间被白白浪费掉。然而，若想防止这一情况需要让 <code>head</code> 时常保持在 0, 即每次执行完 <code>dequeued()</code> 之后让数据整体向数组开头（ 左侧 ）移动，但每次移动都会增加 $O(n)$ 的复杂度。</p><p>为应对这个问题，我们可以把构成队列的数组视为环形缓冲区来管理数据。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210830225431016.png"></p><p>环形缓冲区由一维数组构成，指示队列范围的 <code>head</code> 和 <code>tail</code> 指针在超出数组范围时重新从数组开头开始循环。也就是说，如果指针加 1 之后超出了数组范围，就重新置为 0。</p><p>图 4.7 模拟了在一个已存有若干数据的队列中存取数据时的情况。执行 <code>enqueue(1)</code> 向队列中添加 1 时，<code>tail</code> 的值 7 + 1 = 8 超出了数组范围，因此将 <code>tail</code> 重置为 0。如果按照顺时针方向观察环形缓冲区，那么队列中的现存数据按照的顺序排列。另 外，为区分队列的空与满，我们规定 <code>tail</code>—&gt; <code>head</code> 之间至少要有一个空位。</p><p>由数组构成的队列可通过以下方法实现。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">initialize</span>()</span><br><span class="line">    head = tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isEmpty</span>()</span><br><span class="line">    <span class="keyword">return</span> head == tail</span><br><span class="line">    </span><br><span class="line"><span class="built_in">isFull</span>()</span><br><span class="line">    <span class="keyword">return</span> head == (tail + <span class="number">1</span>) % MAX</span><br><span class="line">    </span><br><span class="line"><span class="built_in">enqueue</span>(x)    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isFull</span>()</span><br><span class="line">        <span class="built_in">error</span>(上溢)</span><br><span class="line">    Q[tail] = x</span><br><span class="line">    <span class="keyword">if</span> tail + <span class="number">1</span> == MAX</span><br><span class="line">        tail = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tail++</span><br><span class="line">        </span><br><span class="line"><span class="built_in">dequeue</span>()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">isEmpty</span>()</span><br><span class="line">        <span class="built_in">error</span>(下溢)</span><br><span class="line">    x = Q[head]</span><br><span class="line">    <span class="keyword">if</span> head + <span class="number">1</span> == MAX</span><br><span class="line">        head = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        head++</span><br><span class="line">    <span class="keyword">return</span> x    </span><br></pre></td></tr></tbody></table></figure><ul><li><code>initialize</code> 函数用来将 <code>head</code> 和 <code>tail</code> 设为相同值，从而清空队列</li><li><code>isEmpty</code> 函数负责检查 <code>head</code> 和 <code>tail</code> 的值是否相等，以判断队列是否为空</li><li><code>isFull</code> 函数用于检查队列是否已满。举个例子，假设我们使用了长度为 <code>MAX</code> 的 0 起点数组，那么当 <code>head</code> 与（<code>tail</code> + 1) % <code>MAX</code> 相等时，队列就是满的。这里 a%b 代表 a 除以 b 的余数</li><li><code>enqueue</code> 函数用于在 <code>tail</code> 所指的位置添加 <code>x</code>。由于元素数增加了 1，所以 <code>tail</code> 也随之加 1。此时 <code>tail</code> 如果超过了数组容量上限（<code>MAX</code> - 1) 则重置为 0。另外，当队列为满时进行报错处理</li><li><code>dequeue</code> 函数会将 <code>head</code> 所指的队头元素暂时存入变量 <code>x</code>，随后加 1 并返回 <code>x</code> 的值。此时如果超过了数组容量上限（<code>MAX</code> - 1 ) 则重置为 0。另外，当队列为空时进行报错处理。</li></ul><p>用数组实现队列时，关键在于如何有效利用内存，以及如何将 <code>enqueue</code> 和 <code>dequeue</code> 的算法复杂度控制在 $O (1)$。实际上，只要使用环形缓冲区，就可以同时以复杂度 $O(1)$ 实现 <code>enqueue</code> 和 <code>dequeue</code> 的操作。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task</span> {</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head, tail, n, q;</span><br><span class="line">task Q[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(task x)</span> </span>{</span><br><span class="line">    Q[tail] = x;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % MAX;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    task x = Q[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % MAX;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> cost, sum = <span class="number">0</span>;</span><br><span class="line">    task t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cin &gt;&gt; Q[i].name &gt;&gt; Q[i].time;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != tail) {</span><br><span class="line">        t = <span class="built_in">dequeue</span>();</span><br><span class="line">        cost = <span class="built_in">min</span>(q, t.time);</span><br><span class="line">        t.time -= cost;</span><br><span class="line">        sum += cost;</span><br><span class="line">        <span class="keyword">if</span> (t.time &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">enqueue</span>(t);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; t.name &lt;&lt; <span class="string">" "</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="标准库-1"><a href="#标准库-1" class="headerlink" title="标准库"></a>标准库</h6><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210901105114406.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> n, q, key, cost, sum = <span class="number">0</span>;</span><br><span class="line">    string name;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    queue&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; key;</span><br><span class="line">        Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(name, key));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pair&lt;string, <span class="type">int</span>&gt; u;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) {</span><br><span class="line">        u = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        cost = <span class="built_in">min</span>(q, u.second);</span><br><span class="line">        u.second -= cost;</span><br><span class="line">        sum += cost;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (u.second &gt; <span class="number">0</span>) </span><br><span class="line">            Q.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; u.first &lt;&lt; <span class="string">" "</span> &lt;&lt; u.second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>pair</code> 是保存成对数值的结构体模板，声明时需要在 <code>&lt; &gt;</code> 中指令两个数据类型。<code>make_pair</code> 用于生成一对数值，第 1 个元素通过 <code>first</code> 访问，第 2 个元素通过 <code>second</code> 访问。</p><h4 id="ALDS1-3-C-Doubly-Linked-List"><a href="#ALDS1-3-C-Doubly-Linked-List" class="headerlink" title="ALDS1_3_C Doubly Linked List"></a>ALDS1_3_C Doubly Linked List</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Your task is to implement a double linked list.</p><p>Write a program which performs the following operations:</p><ul><li>insert x: insert an element with key x into the front of the list.</li><li>delete x: delete the first element which has the key of x from the list. If there is not such element, you need not do anything.</li><li>deleteFirst: delete the first element from the list.</li><li>deleteLast: delete the last element from the list.</li></ul><h5 id="Input-10"><a href="#Input-10" class="headerlink" title="Input"></a>Input</h5><p>The input is given in the following format:</p><p><em>n</em><br><em>command</em>1<br><em>command</em>2<br>…<br><em>commandn</em></p><p>In the first line, the number of operations <em>n</em> is given. In the following <em>n</em> lines, the above mentioned operations are given in the following format:</p><ul><li>insert x</li><li>delete x</li><li>deleteFirst</li><li>deleteLast</li></ul><h5 id="Output-10"><a href="#Output-10" class="headerlink" title="Output"></a>Output</h5><p>Print all the element (key) in the list after the given operations. Two consequtive keys should be separated by a single space.</p><h5 id="Constraints-9"><a href="#Constraints-9" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>The number of operations ≤ 2,000,000</li><li>The number of delete operations ≤ 20</li><li>0 ≤ value of a key ≤ $10^9$</li><li>The number of elements in the list does not exceed $10^6$</li><li>For a delete, deleteFirst or deleteLast operation, there is at least one element in the list.</li></ul><h5 id="Sample-Input-1-10"><a href="#Sample-Input-1-10" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">7</span><br><span class="line">insert 5</span><br><span class="line">insert 2</span><br><span class="line">insert 3</span><br><span class="line">insert 1</span><br><span class="line">delete 3</span><br><span class="line">insert 6</span><br><span class="line">delete 5</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-10"><a href="#Sample-Output-1-10" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">6 1 2</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-9"><a href="#Sample-Input-2-9" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">9</span><br><span class="line">insert 5</span><br><span class="line">insert 2</span><br><span class="line">insert 3</span><br><span class="line">insert 1</span><br><span class="line">delete 3</span><br><span class="line">insert 6</span><br><span class="line">delete 5</span><br><span class="line">deleteFirst</span><br><span class="line">deleteLast</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-9"><a href="#Sample-Output-2-9" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-10"><a href="#問題を解く-10" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>某些数据结构需要满足数据的动态变化。在实现它们的时候，编程者需要具备适时申请或释放内存的技巧。</p><p>这里， 本书特地使用 C++ 程序实现双向链表的操作，通过对其代码的讲解， 向各位具体说明内存申请和链表更改的相关知识。</p><h6 id="原生链表"><a href="#原生链表" class="headerlink" title="原生链表"></a>原生链表</h6><p>如图 4.8 所示， 表中的各元素称作 “结点”。双向链表的结点是结构体，由数据本体（ 这里是整数 key ), 指向前一元素的指针 prev 以及指向后一元素的指针 next 组成，这些结构体通过指针连接成一个链，就形成了双向链表。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210831110013313.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	Node *prev, *next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外，在表头设置一个特殊结点可以简化链表的实现。我们将这个结点称为 “头结点”。 头结点中虽然不包含实际数据，但它可以让我们更轻松地对链表做更改。比如， 加入头结点之后，我们将更容易实现删除元素的操作。</p><p><code>init</code> 函数用于初始化链表，如图 4.9 所示，它会生成一个 NIL 结点（编程语言中，NIL 和 NULL 这两个值表示 “空”，虽然在不同语言中其内容有所差异，但本书中的 NIL 意义为 “空”，同时还作为保存 “不存在的编号” 等数据的变量来使用）作为链表的尖结点, 然后让 prev 和 next 都指向这个头结点，从而创建一个空表。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210831110648538.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">    Node *x = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    x-&gt;key = key;</span><br><span class="line">    </span><br><span class="line">    x-&gt;next = nil-&gt;next;</span><br><span class="line">    nil-&gt;next-&gt;prev = x;</span><br><span class="line">    nil-&gt;next = x;</span><br><span class="line">    x-&gt;prev = nil;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>listSearch</code> 函数用于搜索元素，它可以在链表中寻找包含指定键值的结点，并返回其指针。假设 cur 为指向当前位置结点的指针，那么只要从头结点的 next 所指的结点，即链表开头的元素汗始逐个执行 cur = cur -&gt; next，即可逐一访问每个结点。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">listSearch</span><span class="params">()</span> </span>{</span><br><span class="line">	Node *cur = nil-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur != nil &amp;&amp; cur-&gt;key != key) {</span><br><span class="line">        cur = cur -&gt; next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在访问过程中发现 key 或者指针回到头结点 NIL 时结朿搜索，并返回此时 cur 的值。</p><p><code>deleteNode</code> 函数会通过如图 4.11 所示的步骤改变指针所指的位置，从而删除指定结点 <em>t</em>。在 C++ 中，我们必须手动释放已删除结点的内存。这里的 <code>free</code> 是 C 语言标准库中的函数， 用于释放已不需要的内存空间。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210831111931081.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(Node *t)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (t == nil) <span class="keyword">return</span>;</span><br><span class="line">    t-&gt;prev-&gt;next = t-&gt;next;</span><br><span class="line">    t-&gt;next-&gt;prev = t-&gt;prev;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">deleteNode</span>(nil-&gt;next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">deleteNode</span>(nil-&gt;prev);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteKey</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">    <span class="built_in">deleteNode</span>(<span class="built_in">listSearch</span>(key));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>deleteFirst</code> 函数 、<code>deleteLast</code> 函数分别用于删除头结点 next 、prev 所指向的结点。</p><p><code>deleteKey</code> 函数可以删除包含指定 key 的结点，它会先通过 <code>listSearch</code> 函数搜索出 key —致的结点 <em>t</em>，然后再使用 <code>deleteNote(t)</code> 删除该结点。</p><p>往双向链表中添加元素时，只需要更改几个指针的指向，因此算法复杂度为 $O(1)$。</p><p>数组访问 <em>A[i]</em> 所消耗的时间固定，但表需要通过指针一步步寻找元素。因此当表中含有 <em>N</em> 个元素时，搜索算法的复杂度为 $O(N)$。</p><p>删除双向链表开头或末尾的元素仅需 $O(1)$ 的复杂度，但删除包含特定 key 的元素时需要按顺序遍历链表，所以算法复杂度为 $O(N)$。</p><p>这里介绍的链表的实现方法中，由于搜索和删除的算法复杂度都高达 $O(N)$ , 因此对单个链表来说实用价值不大。但是，它们在之后的章节中将作为其他数据结构的零部件（ 或者实现 其他数据结构所需的知识）出现并发挥作用。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Node *prev, *next;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Node* nil;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">    nil = <span class="keyword">new</span> Node;</span><br><span class="line">    nil-&gt;prev = nil;</span><br><span class="line">    nil-&gt;next = nil;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">    Node* x = <span class="keyword">new</span> Node;</span><br><span class="line">    x-&gt;key = key;</span><br><span class="line">    x-&gt;next = nil-&gt;next;</span><br><span class="line">    nil-&gt;next-&gt;prev = x;</span><br><span class="line">    nil-&gt;next = x;</span><br><span class="line">    x-&gt;prev = nil;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">listSearch</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">    Node* cur = nil-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur != nil &amp;&amp; cur-&gt;key != key) {</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(Node* t)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (t == nil) <span class="keyword">return</span>;</span><br><span class="line">    t-&gt;prev-&gt;next = t-&gt;next;</span><br><span class="line">    t-&gt;next-&gt;prev = t-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">deleteNode</span>(nil-&gt;next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">deleteNode</span>(nil-&gt;prev);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteKey</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">    <span class="built_in">deleteNode</span>(<span class="built_in">listSearch</span>(key));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span> </span>{</span><br><span class="line">    Node* cur = nil-&gt;next;</span><br><span class="line">    <span class="type">int</span> isFirst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (cur == nil) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (isFirst++ &gt; <span class="number">0</span>) std::cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        std::cout &lt;&lt; cur-&gt;key;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> n, key;</span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">6</span>] == <span class="string">'F'</span>)</span><br><span class="line">            <span class="built_in">deleteFirst</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">6</span>] == <span class="string">'L'</span>)</span><br><span class="line">            <span class="built_in">deleteLast</span>();</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line">            <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'i'</span>)</span><br><span class="line">                <span class="built_in">insert</span>(key);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'d'</span>)</span><br><span class="line">                <span class="built_in">deleteKey</span>(key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printList</span>();</span><br><span class="line">    <span class="keyword">delete</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的输入出现了一点小小的问题，原书是这样写的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, cmd, &amp;key);</span><br><span class="line">    <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'i'</span>)</span><br><span class="line">        <span class="built_in">insert</span>(key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'d'</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(cmd) &gt; <span class="number">6</span>) {</span><br><span class="line">            <span class="keyword">if</span> (cmd[<span class="number">6</span>] == <span class="string">'F'</span>)</span><br><span class="line">                <span class="built_in">deleteFirst</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">6</span>] == <span class="string">'L'</span>)</span><br><span class="line">                <span class="built_in">deleteLast</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">deleteKey</span>(key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>后面不知道哪里出了问题，改了一下输入的逻辑就ok了：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">	<span class="keyword">if</span> (cmd[<span class="number">6</span>] == <span class="string">'F'</span>)</span><br><span class="line">		<span class="built_in">deleteFirst</span>();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">6</span>] == <span class="string">'L'</span>)</span><br><span class="line">		<span class="built_in">deleteLast</span>();</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line">		<span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'i'</span>)</span><br><span class="line">			<span class="built_in">insert</span>(key);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'d'</span>)</span><br><span class="line">			<span class="built_in">deleteKey</span>(key);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="标准库-2"><a href="#标准库-2" class="headerlink" title="标准库"></a>标准库</h6><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210901115117624.png"></p><p>list 既可以像 vector —样通过“[ ]”运算符直接访问特定元素，也可以用迭代器逐个进行访问另外，list 还具备一项 vector 所不具备的特长，那就是元素的插入与删除操作只需 $O(1)$ 即可完成，效率极高。 现在我们用 STL 的 list 来解之前的例题3 ALDS1 _3_C: Doubly Linked List 可以通过下述方法实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> n, key;</span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">20</span>];</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'i'</span>) {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line">            v.<span class="built_in">push_front</span>(key);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">6</span>] == <span class="string">'F'</span>) {</span><br><span class="line">            v.<span class="built_in">pop_front</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">6</span>] == <span class="string">'L'</span>) {</span><br><span class="line">            v.<span class="built_in">pop_back</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'d'</span>) {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line">            <span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">                <span class="keyword">if</span> (*it == key) {</span><br><span class="line">                    v.<span class="built_in">erase</span>(it);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> isFirst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (isFirst++) cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        cout &lt;&lt; *it;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ALDS1-3-D-Areas-on-the-Cross-Section-Diagram"><a href="#ALDS1-3-D-Areas-on-the-Cross-Section-Diagram" class="headerlink" title="ALDS1_3_D Areas on the Cross-Section Diagram"></a>ALDS1_3_D Areas on the Cross-Section Diagram</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Your task is to simulate a flood damage.</p><p>For a given cross-section diagram, reports areas of flooded sections.</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/IMAGE2_ALDS1_3_D.png"></p><p>Assume that rain is falling endlessly in the region and the water overflowing from the region is falling in the sea at the both sides. For example, for the above cross-section diagram, the rain will create floods which have areas of 4, 2, 1, 19 and 9 respectively.</p><h5 id="Input-11"><a href="#Input-11" class="headerlink" title="Input"></a>Input</h5><p>A string, which represents slopes and flatlands by ‘/‘, ‘\‘ and ‘_‘ respectively, is given in a line. For example, the region of the above example is given by a string:</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210831225645641.png"></p><h5 id="Output-11"><a href="#Output-11" class="headerlink" title="Output"></a>Output</h5><p>Report the areas of floods in the following format:</p><p>$A$<br>$k L_1 L_2 … L_k$</p><p>In the first line, print the total area $A$ of created floods.</p><p>In the second line, print the number of floods $k$ and areas $L_i(i=1,2,…,k)$ for each flood from the left side of the cross-section diagram. Print a space character before $L_i$.</p><h5 id="Constraints-10"><a href="#Constraints-10" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>1≤ length of the string ≤20,000</li></ul><h5 id="Sample-Input-1-11"><a href="#Sample-Input-1-11" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">\\//</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-11"><a href="#Sample-Output-1-11" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 4</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-10"><a href="#Sample-Input-2-10" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">\\///\_/\/\\\\/_/\\///__\\\_\\/_\/_/\</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-10"><a href="#Sample-Output-2-10" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">35</span><br><span class="line">5 4 2 1 19 9</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-11"><a href="#問題を解く-11" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>为给某地区制订防洪策略，我们要模拟洪水时的受灾状况。如上图所示，现已在 1 X 1( $m^2$ ) 的网格纸上画出了该地区的地形断面图，请报告该地区各积水处的横截面积。</p><p>假设给定地区持续降雨，从该地区溢出的多余雨水将流人左右的海中。以上图中的断面图为例，积水处的横截面积从左至右分别为 4、2、1、19。</p><p>本题的解法有很多，比如运用排序算法。不过在这里，我们要考虑如何用栈实现题目需求。</p><p>首先，我们通过下述算法求总面积（第 1 个输出数据 ）。</p><p>对输入的字符 $s_i$ 进行逐个检查：</p><ul><li>如果是 “\”， 则将表示该字符位置（ 从开头数第几个字符 ）的整数 $i$ 压人栈S1</li><li>如果是 “/”，则从栈 S1 顶部取出与之对应的 “\”的位置 $i_p$, 算出二者的距离 $i-i_p$ 并累加到总面积里</li></ul><p>字符 “_” 的作用只是将一对 “\” 与 “/” 的距离加 1 ，因此我们从栈中取出 “\” 时可以直接与对应的 “/”计算距离，不必考虑 “_”。</p><p>接下来是求各积水处面积的算法。</p><p>我们另建一个栈 S2 来保存各积水处的面积。栈 S2 中的每个元素包含一对数据，分別是 “该积水处最左侧 “\” 的位置” 和 “该积水处当前的面积”。例如图 4.12 中，i 表示当前 “/” 表示当前 “/” 的位置， 表示与之相对应的 “\” 的位置，S2 中存放着（ j +1，5 ) 和 ( k, 4 ) 两个积水处的面积。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210901144841510.png"></p><p>接下来，新形成的面积 = 当前 S2 中的两个面积之和 + 新形成的 i - j 部分的面积。这里我们要从 S2 中取出被引用的（多个）面积，再将新算出的面积压入 S2。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; s2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; cin &gt;&gt; ch; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'\\'</span>) {</span><br><span class="line">            s1.<span class="built_in">push</span>(i);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'/'</span> &amp;&amp; s1.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> j = s1.<span class="built_in">top</span>();</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">            sum += i - j;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> area = i - j;</span><br><span class="line">            <span class="keyword">while</span> (s2.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; s2.<span class="built_in">top</span>().first &gt; j) {</span><br><span class="line">                area += s2.<span class="built_in">top</span>().second;</span><br><span class="line">                s2.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            s2.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(j, area));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (s2.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">        ans.<span class="built_in">push_back</span>(s2.<span class="built_in">top</span>().second);</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">        cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Topic-4-Search"><a href="#Topic-4-Search" class="headerlink" title="Topic # 4 Search"></a>Topic # 4 Search</h3><p>搜索（ 或检索 ）是指从数据集合中找岀目标元素的处理。与排序相同，搜索的各元素通常也由多个项目组成。不过，本章例题中使用的数据相对简单，多以值作为关键字。</p><p>所谓搜索，就是在数据集合中寻找给定关键字的位置或判断其有无，比如 “数列 {8,13,5, 7,21,1} 中 7 位于第几位?” 等。基本的搜索算法有如下二种， 分别为线性搜索、 二分搜索、 散列法。</p><p><strong>线性搜索</strong></p><p>线性搜索就是从数组开头顺次访问各元素，检查该元素是否与目标值相等。一旦相等则返回该元素的位置并结束搜索。如果检查到数组末尾仍未发现目标值， 则返回一个特殊值来说明该情况。线性搜索的算法效率很低，但适用于任何形式的数据。</p><p><strong>二分搜索</strong></p><p>二分搜索（二分查找）算法可以利用数据的大小进行高速搜索。很多时候，计算机管理数据时会根据特定项目对其进行排序， 这就让二分搜索算法有了用武之地。</p><p>假设数组中存放的数据已按关键字升序排列，那么对其使用二分搜索算法时思路如下</p><ol><li>将整个数组作为搜索范围</li><li>检查位于搜索范围正中央的元素</li><li>如果中央元素的关键字与目标关键字一致则结束搜索</li><li>如果中央元素的关键字小于目标关键字，则以前半部分为搜索范围重新执行 2; 如果大于目标关键字，则以后半部分为搜索范围重新执行 2。</li></ol><p>二分搜索每执行完一步搜索范围都会减半，因此可以在极短时间内完成搜索。</p><p><strong>散列法</strong></p><p>在散列法中，各元素的存储位置由散列函数决定。散列既是一种数据结构，同时也是一种使用散列表的算法。这种算法只需将元素的关键字（ 值 ）代入特定函数便可找岀其对应位置， 对某些种类的数据有着极高的搜索效率。</p><h4 id="ALDS1-4-A-Search-I"><a href="#ALDS1-4-A-Search-I" class="headerlink" title="ALDS1_4_A Search I"></a>ALDS1_4_A Search I</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>You are given a sequence of <em>n</em> integers S and a sequence of different <em>q</em> integers T. Write a program which outputs C, the number of integers in T which are also in the set S.</p><h5 id="Input-12"><a href="#Input-12" class="headerlink" title="Input"></a>Input</h5><p>In the first line <em>n</em> is given. In the second line, <em>n</em> integers are given. In the third line <em>q</em> is given. Then, in the fourth line, <em>q</em> integers are given.</p><h5 id="Output-12"><a href="#Output-12" class="headerlink" title="Output"></a>Output</h5><p>Print C in a line.</p><h5 id="Constraints-11"><a href="#Constraints-11" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>n ≤ 10000</li><li>q ≤ 500</li><li>0 ≤ an element in S ≤ $10^9$</li><li>0 ≤ an element in T ≤ $10^9$</li></ul><h5 id="Sample-Input-1-12"><a href="#Sample-Input-1-12" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">3</span><br><span class="line">3 4 1</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-12"><a href="#Sample-Output-1-12" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-11"><a href="#Sample-Input-2-11" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 1 2</span><br><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-11"><a href="#Sample-Output-2-11" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 1 2 2 3</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-12"><a href="#問題を解く-12" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>请编写一个程序，输入包含 $n$ 个整数的数列 S 以及包含 q 个不重复整数的数列 T， 输出既包含于 T 也包含于 S 的整数的个数 C。</p><p>我们通过线性搜索来检查数列 S 中是否包含 T 的各元素。线性搜索可以用 for 循环来实现，具体过程如下。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">linearSearch</span>()</span><br><span class="line">	<span class="keyword">for</span> i from <span class="number">0</span> to n - <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> A[i] == key</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> NOT_FOUND</span><br></pre></td></tr></tbody></table></figure><p>向线性搜索中引入“标记”可以将算法效率提高常数倍。所谓标记，就是我们在数组等数 据结构中设置的一个拥有特殊值的元素。借助这项编程技巧，我们能达到简化循环控制等诸多目的。在线性搜索中，我们可以把含有目标关键字的数据放在数组末尾，用作标标记。具体操作如图 5.1 所示。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210902142228460.png"></p><p>含有标记的线性搜索可以用如下方法实现。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">linearSearch</span>()</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">    A[n] = key</span><br><span class="line">    <span class="keyword">while</span> A[i] 与 key 不同</span><br><span class="line">        i++</span><br><span class="line">    <span class="keyword">if</span> i 到达了 n</span><br><span class="line">        <span class="keyword">return</span> NOT_FOUND</span><br><span class="line">	<span class="keyword">return</span> i</span><br></pre></td></tr></tbody></table></figure><p>Program 5.1 与 Program 5.2 的区别在于主循环中比较运算的次数。Program 5.1 需要两个比较运算，一个是 for 循环的结束条件（比如C语言中 <code>for (i = 0;i &lt; n;i++)</code> ），另一个是关键字之间的比较。相对地，Program 5.2 只需要一个不等价运算即可。由于标记能确保 while 不成为死循环，因此可以省去循环结束条件。</p><p>线性搜索的算法复杂度为 $O(n)$，但在引入标记之后效率能提升常数倍，处理大规模数据时会有比较明显的效果。</p><p>解本题 (ALDS1_4 A: Linear Search ) 时，总共要对具有 $n$ 个元素的数组进行 $q$ 次线性搜索，算法复杂度为 $O(qn)$。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">linearSearch</span><span class="params">(vector&lt;<span class="type">long</span>&gt; s, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    s[s.<span class="built_in">size</span>()] = key;</span><br><span class="line">    <span class="keyword">while</span> (s[i] != key) i++;</span><br><span class="line">    <span class="keyword">return</span> i != s.<span class="built_in">size</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">long</span> input;</span><br><span class="line">    <span class="type">int</span> n, q, count = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">long</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cin &gt;&gt; input;</span><br><span class="line">        s.<span class="built_in">push_back</span>(input);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; q; ++j) {</span><br><span class="line">        cin &gt;&gt; input;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">linearSearch</span>(s, input)) count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ALDS1-4-B-Search-II"><a href="#ALDS1-4-B-Search-II" class="headerlink" title="ALDS1_4_B Search II"></a>ALDS1_4_B Search II</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>You are given a sequence of <em>n</em> integers S and a sequence of different <em>q</em> integers T. Write a program which outputs C, the number of integers in T which are also in the set S.</p><h5 id="Input-13"><a href="#Input-13" class="headerlink" title="Input"></a>Input</h5><p>In the first line <em>n</em> is given. In the second line, <em>n</em> integers are given. In the third line <em>q</em> is given. Then, in the fourth line, <em>q</em> integers are given.</p><h5 id="Output-13"><a href="#Output-13" class="headerlink" title="Output"></a>Output</h5><p>Print C in a line.</p><h5 id="Constraints-12"><a href="#Constraints-12" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>Elements in S is sorted in ascending order</li><li>n ≤ 100000</li><li>q ≤ 50000</li><li>0 ≤ an element in S ≤ 109</li><li>0 ≤ an element in T ≤ 109</li></ul><h5 id="Sample-Input-1-13"><a href="#Sample-Input-1-13" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">3</span><br><span class="line">3 4 1</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-13"><a href="#Sample-Output-1-13" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-12"><a href="#Sample-Input-2-12" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-12"><a href="#Sample-Output-2-12" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-3-1"><a href="#Sample-Input-3-1" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 1 2 2 3</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-3-1"><a href="#Sample-Output-3-1" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h5 id="問題を解く-13"><a href="#問題を解く-13" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>本题的思路与上一题基本相同， 都是通过搜索检查数列 S 中是否包含 T 的各个元素。但是，$O(n)$ 的线性搜索无法在限制时间之内完成处理。本题我们要有效利用 “S 的元素按升序排列” 这一限制条件，采用二分搜索解题。</p><p>假设有一个包含 $n$ 个元素的数组 $A$，我们要用二分搜索在其中寻找 <code>key</code>，其算法伪代码如下。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">binarySearch</span>(A, key)</span><br><span class="line">	left = <span class="number">0</span></span><br><span class="line">    right = n</span><br><span class="line">    <span class="keyword">while</span> left &lt; right</span><br><span class="line">        mid = (left + right)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] == key</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> A[mid] &gt; key</span><br><span class="line">            right = mid</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> NOT_FOUND</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913211856149.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913212426873.png"></p><p>在 while 循环中，先通过 <code>( left +right ) /2</code> 求出当前搜索范围的中间位置 <code>mid</code>，再将 <code>mid</code> 所指的元素 <code>A[mid]</code> 与 <code>key</code> 进行比较，如果一致则返回 <code>mid</code>。当 <code>key</code> 小于 <code>A[mid]</code> 时，证明目标值位于 <code>mid</code> 前方，所以把 <code>mid</code> 赋给 <code>right</code>，将搜索范围收缩至前半部分。反之则把 <code>mid+1</code> 赋给 <code>left</code>，将搜索范围收缩至后半部分。上面例子的第一步中，<code>key</code> ( = 36) 比中间值 <code>A[mid]</code> 更大，所以将 <code>left</code> 设置为8 (搜索 8 之前的元素没有意义)。</p><p>while 的循环条件 <code>left &lt; right</code> 表示搜索范围仍不为空。如果搜索范围为空， 就代表数组中没有找到 <code>key</code>，返回 <code>NOT_FOUND</code>。</p><p>对含有 $n$ 个元素的数组执行线性搜索以及二分搜索时，最坏的情况下的比较运算的次数分别如下表所示。</p><table><thead><tr><th>元素数</th><th>线性搜索</th><th>二分搜索</th></tr></thead><tbody><tr><td>100</td><td>100</td><td>7</td></tr><tr><td>10000</td><td>10000</td><td>14</td></tr><tr><td>1000000</td><td>1000000</td><td>20</td></tr></tbody></table><p>线性搜索在最坏情况下要比较 $n$ 次，二分搜索大概需要 $\log_2{n}$ 次。由于二分搜索每进行一 次比较搜索范围就会减半， 因此很容易推导出其计算效率为 $O(\log{n})$。</p><p>本题 ( ALDS1_4_C: Binary Search ) 需要以 $T$ 的各元素为 <code>key</code> 进行二分搜索，即解题算法复杂度为 $O(q\log{n})$。</p><p>本题的输入数据已经完成了排序，今后当我们遇到无序的数据时，只要预先进行一次排序，就可以套用二分搜索了。总而言之，“排序之后即可使用二分搜索”的思路可以应用到诸多问题之中。不过，考虑到数据的体积，绝大多数情况下都需要用到高等排序算法（我们将在 第 7 章详细学习）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binarySearch</span><span class="params">(<span class="type">long</span> A[], <span class="type">int</span> n, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt; key)</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">long</span> input;</span><br><span class="line">    <span class="type">int</span> n, q, count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> A[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; q; ++j) {</span><br><span class="line">        cin &gt;&gt; input;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">binarySearch</span>(A, n, input)) count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ALDS1-4-C-Search-III"><a href="#ALDS1-4-C-Search-III" class="headerlink" title="ALDS1_4_C Search III"></a>ALDS1_4_C Search III</h4><blockquote><p>Time Limit : <code>2 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Your task is to write a program of a simple <em>dictionary</em> which implements the following instructions:</p><ul><li>insert <em>str</em>: insert a string str in to the dictionary</li><li>find <em>str</em>: if the distionary contains str, then print ‘yes’, otherwise print ‘no’</li></ul><h5 id="Input-14"><a href="#Input-14" class="headerlink" title="Input"></a>Input</h5><p>In the first line <em>n</em>, the number of instructions is given. In the following <em>n</em> lines, <em>n</em> instructions are given in the above mentioned format.</p><h5 id="Output-14"><a href="#Output-14" class="headerlink" title="Output"></a>Output</h5><p>Print yes or no for each find instruction in a line.</p><h5 id="Constraints-13"><a href="#Constraints-13" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>A string consists of ‘A’, ‘C’, ‘G’, or ‘T’</li><li>1 ≤ length of a string ≤ 12</li><li><em>n</em> ≤ 1000000</li></ul><h5 id="Sample-Input-1-14"><a href="#Sample-Input-1-14" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">insert A</span><br><span class="line">insert T</span><br><span class="line">insert C</span><br><span class="line">find G</span><br><span class="line">find A</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-14"><a href="#Sample-Output-1-14" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">no</span><br><span class="line">yes</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Input-2-13"><a href="#Sample-Input-2-13" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">13</span><br><span class="line">insert AAA</span><br><span class="line">insert AAC</span><br><span class="line">insert AGA</span><br><span class="line">insert AGG</span><br><span class="line">insert TTT</span><br><span class="line">find AAA</span><br><span class="line">find CCC</span><br><span class="line">find CCC</span><br><span class="line">insert CCC</span><br><span class="line">find CCC</span><br><span class="line">insert T</span><br><span class="line">find TTT</span><br><span class="line">find T</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-13"><a href="#Sample-Output-2-13" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yes</span><br><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">yes</span><br></pre></td></tr></tbody></table></figure><h5 id="Notes-2"><a href="#Notes-2" class="headerlink" title="Notes"></a>Notes</h5><p><a target="_blank" rel="noopener" href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/4/template/ALDS1_4_C_template.c">Template in C</a></p><h5 id="問題を解く-14"><a href="#問題を解く-14" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>散列法是一种搜索算法，它可以根据各元素的值来确定存储位置，然后将位置保管在散列表中， 从而实现数据的高速搜索。其中散列表是一种数据结构，能对包含关键字的数据集合高效地执行动态插入、搜索、删除操作。虽然链表也能完成同样操作，但搜索和删除的复杂度都高达 $O(n)$。</p><p>散列表由容纳 m 个元素的数组 T 以及根据数据关键字决定数组下标的函数共同组成。也就是说，我们要将数据的关键字输入该函数，由该函数决定数据在数组中的位置，散列表大致可通过以下方法实现。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(data)</span><br><span class="line">	T[<span class="built_in">h</span>(data.key)] = data</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(data)</span><br><span class="line">    <span class="keyword">return</span> T[<span class="built_in">h</span>(data.key)]</span><br></pre></td></tr></tbody></table></figure><p>这里我们假设散列函数的输人值 <code>data.key</code> 为整数。请注意，当关键字为字符串等其他类型时，需要借助某些手法将其转换为相应的整数。</p><p>这里的 $h(k)$ 是根据 $k$ 值求数组 $T$ 下标的函数，称为散列函数。另外，该函数的返回值称为散列值。散列函数求出的散列值范围在 0 到 m - 1 之间（m 为数组 T 的长度）。为满足这一 条件，函数内需要使用取余运算，保证输出值为 0 到 m - 1 之间的整数，比如<br>$$<br>h(k) = k \space mod \space m<br>$$<br>就是一种散列函数（这里 a mod b 是指 a 除以 b 所得的余数）。不过，如果单有这一个运算，会发生不同 <code>key</code> 对应同一散列值的情况，即出现“冲突”。</p><p>开放地址法是解决这类冲突的常用手段之一。这里向各位介绍的是双散列结构中使用的开放地址法。如下所示，在双散列结构中一旦出现冲突，程序会调用第二个散列函数来求散列值。<br>$$<br>H(k) = h(k, i)=(h_1(k) + i \times h_2(k)) \space mod \space m<br>$$<br>散列函数 $h(k,i)$ 拥有关键字 $k$ 和整数 $i$ 两个参数，这里的 $i$ 是发生冲突后计算下一个散列值的次数。也就是说，只要散列函数 $H(k)$ 起了冲突，就会依次调用 $h(k,0)$、$h(k,1)$、$h(k,2)$…， 直到不发生冲突为止，然后返回这个 $h(k,i)$ 的值作为散列值。如图5.4所示，该算法先通过 $h_1(k)$ 求出第一个下标，然后在发生冲突时将下标移动 $h_2(k)$ 个位置，从而寻找仍然空着的位置。</p><p>要注意的是，因为下标每次移动 $h(k)$ 个位置，所以必须保证 $T$ 的长度 $m$ 与 $h_2(k)$ 互质，否则会出现无法生成下标的情况。这种时候，我们可以特意让 $m$ 为质数，然后取一个小于 $m$ 的值作为 $h_2(k)$，从而避免上述情况发生。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210914084025098.png"></p><p>比如，散列法可以通过下述方法实现。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">h1</span>(key)</span><br><span class="line">	<span class="keyword">return</span> key mod</span><br><span class="line"></span><br><span class="line"><span class="built_in">h2</span>(key)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + (key <span class="built_in">mod</span> (m - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">h</span>(key, i)</span><br><span class="line">	<span class="built_in">return</span> (<span class="built_in">h1</span>(key) + i * <span class="built_in">h2</span>(key)) mod m</span><br><span class="line">    </span><br><span class="line"><span class="built_in">insert</span>(T, key)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        j = <span class="built_in">h</span>(key, i)</span><br><span class="line">        <span class="keyword">if</span> T[j] == NIL</span><br><span class="line">            T[j] = key</span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            i++</span><br><span class="line">      </span><br><span class="line"><span class="built_in">search</span>(T, key)</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        j = <span class="built_in">h</span>(key, i)</span><br><span class="line">        <span class="keyword">if</span> T[j] == NIL</span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> T[j] == NIL <span class="keyword">or</span> i &gt;= m</span><br><span class="line">            <span class="keyword">return</span> NIL</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++</span><br></pre></td></tr></tbody></table></figure><p>上述伪代码中，我们用 $T[j]$ 是否为 <code>NIL</code> 来判断当前位置是否为空。</p><p>如果忽略发生冲突的情况，散列法插入和搜索元素的算法复杂度仅为 $O(1)$。散列函数根据其用途不同会用到各种算法（比如加密技术），有时还会用到启发式计算式。本书在编写前已经对基本的散列函数及其机制进行了验证。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1046527</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L 14</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> H[M][L];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getChar</span><span class="params">(<span class="type">char</span> ch)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'T'</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getKey</span><span class="params">(<span class="type">char</span> str[])</span></span>{</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> key = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++){</span><br><span class="line">        key += p*(<span class="built_in">getChar</span>(str[i]));</span><br><span class="line">        p *= <span class="number">5</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h1</span><span class="params">(<span class="type">int</span> key)</span> </span>{ </span><br><span class="line">    <span class="keyword">return</span> key % M; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h2</span><span class="params">(<span class="type">int</span> key)</span> </span>{ </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (key % (M - <span class="number">1</span>)); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> i)</span> </span>{ </span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">h1</span>(key) + i * <span class="built_in">h2</span>(key)) % M;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> str[])</span> </span>{</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> key, h;</span><br><span class="line">    key = <span class="built_in">getKey</span>(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;; i++) {</span><br><span class="line">        h = <span class="built_in">hash</span>(key, i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(H[h],str) == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strlen</span>(H[h]) == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span> </span>{</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> key, h;</span><br><span class="line">    key = <span class="built_in">getKey</span>(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; ; i++) {</span><br><span class="line">        h = <span class="built_in">hash</span>(key, i);</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(H[h],str) == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strlen</span>(H[h]) == <span class="number">0</span> ) {</span><br><span class="line">            <span class="built_in">strcpy</span>(H[h], str);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> i, n, h;</span><br><span class="line">    <span class="type">char</span> str[L], cmd[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; M; i++ ) H[i][<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++ ) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, cmd, str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'i'</span>)</span><br><span class="line">            <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">find</span>(str))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ALDS1-4-D-Allocation"><a href="#ALDS1-4-D-Allocation" class="headerlink" title="ALDS1_4_D Allocation"></a>ALDS1_4_D Allocation</h4><blockquote><p>Time Limit : <code>1 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>You are given $n$ packages of $w_i$ kg from a belt conveyor in order ($i=0,1,…n−1$). You should load all packages onto $k$ trucks which have the common maximum load $P$. Each truck can load consecutive packages (more than or equals to zero) from the belt conveyor unless the total weights of the packages in the sequence does not exceed the maximum load PP.</p><p>Write a program which reads $n$, $k$ and $w_i$, and reports the minimum value of the maximum load $P$ to load all packages from the belt conveyor.</p><h5 id="Input-15"><a href="#Input-15" class="headerlink" title="Input"></a>Input</h5><p>In the first line, two integers $n$ and $k$ are given separated by a space character. In the following nn lines, $w_i$ are given respectively.</p><h5 id="Output-15"><a href="#Output-15" class="headerlink" title="Output"></a>Output</h5><p>Print the minimum value of $P$ in a line.</p><h5 id="Constraints-14"><a href="#Constraints-14" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>1 ≤ $n$ ≤ 100,000</li><li>1 ≤ $k$ ≤ 100,000</li><li>1 ≤ $w_i$ ≤ 10,000</li></ul><h5 id="Sample-Input-1-15"><a href="#Sample-Input-1-15" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">8</span><br><span class="line">1</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">9</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-15"><a href="#Sample-Output-1-15" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></tbody></table></figure><p>If the first truck loads two packages of {8,1}, the second truck loads two packages of {7,3} and the third truck loads a package of {9}, then the minimum value of the maximum load $P$ shall be 10.</p><h5 id="Sample-Input-2-14"><a href="#Sample-Input-2-14" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-2-14"><a href="#Sample-Output-2-14" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></tbody></table></figure><p>If the first truck loads three packages of {1,2,2} and the second truck loads a package of {6}, then the minimum value of the maximum load $P$ shall be 6.</p><h5 id="問題を解く-15"><a href="#問題を解く-15" class="headerlink" title="問題を解く"></a>問題を解く</h5><p>传送带依次送来了重量分别为 $w_i$($i=0,1,⋯，N -1$) 的 $n$ 个货物。现在要将这些货物装到 $k$ 辆卡车上。每辆卡车可装载的货物数大于等于0, 但货物重量总和不得超过卡车的最大运载量 $P$。所有卡车的最大运载量 $P$ —致。</p><p>请编写一个程序，输入 $n$、$k$、$w_i$，求出装载全部货物所需的最大运载量 $P$ 的最小值。</p><p>确定最大运载量 $P$ 时，首先要编写一个算法来计算 $k$ 辆以内的卡车总共能装多少货物。思路很简单，只要卡车的运载量没达到 $P$，我们就让其继续按顺序装货物，最后再计算所有卡车运载量的总和即可。这里我们以 $P$ 为实参，编写一个返回可装载货物数 $v$ 的函数 $v = f(P)$。这个函数的算法复杂度为 $O(n)$。</p><p>现在我们只需要调用这个函数，让 $P$ 从 0 开始逐渐自增，第一个让 $v$ 大于等于 $n$ 的 $P$ 就是答案。但是，逐个检查 $P$ 会使算法复杂度达到 $O(Pn)$，结合问题的限制条件来看，程序不可能在限制时间内完成处理。</p><p>这里我们利用 “$P$ 增加则 $v$ 也增加” （严格来说是 $P$ 增加时会减少）的性质，用二分搜索来求 $P$。二分搜索可以将算法复杂度降低至 $( n\log P)$。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> w[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> p)</span> </span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++j) {</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s + w[i] &lt;= p) {</span><br><span class="line">            s += w[i];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == n) <span class="keyword">return</span> n;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> right = <span class="number">100000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) {</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">check</span>(mid);</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= n) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="built_in">solve</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Topic-5-Recursion-x2F-Divide-and-Conquer"><a href="#Topic-5-Recursion-x2F-Divide-and-Conquer" class="headerlink" title="Topic # 5 Recursion / Divide and Conquer"></a>Topic # 5 Recursion / Divide and Conquer</h3><p>将问题分解，通过求解局部性的小问题来解开原本的问题这种技巧称为分治法，我们在很多算法中都能看到。实现分治法需要用到递归。本章就将带领各位求解分治法以及递归的相关问题</p><p>使用递归的技巧，可以将一个问题拆分成两个或更多较小的局部问题，利用递归函数求出每个局部问题的解，然后再将结果整合，最终解决原问题。这种编程手法称为分治法( Divide and Conquer ), 其算法实现的步骤如下。</p><ol><li>将问题“分割”成局部问题（Divide）</li><li>递归地求解局部问题（Solve）</li><li>将局部问题的解“整合”，解决原问题</li></ol><p>举个例子，数组 <em>A</em> 中最大的元素既可以用线性搜索来查找，也可以如 Program 6.2 所示用分治法来查找。这里的函数 <code>findMaximum(A, 1, r)</code> 表示在数组 <em>A</em> 的 <em>l</em> 到 <em>r</em> （不包含 <em>r</em>）的范围内查找最大元素。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">findMaximum</span>(A, l, r)</span><br><span class="line">	m = (l + r)/<span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> l == r - <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> A[l]</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    	u = <span class="built_in">findMaximum</span>(A, l, m)</span><br><span class="line">    	v = <span class="built_in">findMaximum</span>(A, m, r)</span><br><span class="line">    	x = <span class="built_in">max</span>(u, v)</span><br><span class="line">    <span class="keyword">return</span> x	</span><br></pre></td></tr></tbody></table></figure><h4 id="ALDS1-5-A-Exhaustive-Search"><a href="#ALDS1-5-A-Exhaustive-Search" class="headerlink" title="ALDS1_5_A Exhaustive Search"></a>ALDS1_5_A Exhaustive Search</h4><blockquote><p>Time Limit : <code>5 sec</code> , Memory Limit : <code>131072 KB</code></p></blockquote><p>Write a program which reads a sequence <em>A</em> of <em>n</em> elements and an integer <em>M</em>, and outputs “yes” if you can make <em>M</em> by adding elements in <em>A</em>, otherwise “no”. You can use an element only once.</p><p>You are given the sequence <em>A</em> and <em>q</em> questions where each question contains $M_i$.</p><h5 id="Input-16"><a href="#Input-16" class="headerlink" title="Input"></a>Input</h5><p>In the first line <em>n</em> is given. In the second line, <em>n</em> integers are given. In the third line <em>q</em> is given. Then, in the fourth line, <em>q</em> integers ($M_i$) are given.</p><h5 id="Output-16"><a href="#Output-16" class="headerlink" title="Output"></a>Output</h5><p>For each question $M_i$, print yes or no.</p><h5 id="Constraints-15"><a href="#Constraints-15" class="headerlink" title="Constraints"></a>Constraints</h5><ul><li>n ≤ 20</li><li>q ≤ 200</li><li>1 ≤ elements in A ≤ 2000</li><li>1 ≤ $M_i$ ≤ 2000</li></ul><h5 id="Sample-Input-1-16"><a href="#Sample-Input-1-16" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 7 10 21</span><br><span class="line">8</span><br><span class="line">2 4 17 8 22 21 100 35</span><br></pre></td></tr></tbody></table></figure><h5 id="Sample-Output-1-16"><a href="#Sample-Output-1-16" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">no</span><br><span class="line">no</span><br></pre></td></tr></tbody></table></figure><h5 id="Notes-3"><a href="#Notes-3" class="headerlink" title="Notes"></a>Notes</h5><p>You can solve this problem by a Burte Force approach. Suppose solve(p, t) is a function which checkes whether you can make t by selecting elements after p-th element (inclusive). Then you can recursively call the following functions:</p><p>solve(0, M)<br>solve(1, M-{sum created from elements before 1st element})<br>solve(2, M-{sum created from elements before 2nd element})<br>…</p><p>The recursive function has two choices: you selected p-th element and not. So, you can check solve(p+1, t-A[p]) and solve(p+1, t) in solve(p, t) to check the all combinations.</p><p>For example, the following figure shows that 8 can be made by A[0] + A[2].</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/IMAGE2_ALDS1_5_A.png"></p><h5 id="問題を解く-16"><a href="#問題を解く-16" class="headerlink" title="問題を解く"></a>問題を解く</h5></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/c735be6b.html" rel="bookmark">Introduction to Programming I</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8add02f4.html" rel="bookmark">剑指Offer(专项突破版)</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/dd921d98.html" rel="bookmark">剑指Offer</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Cpp/" rel="tag"># Cpp</a> <a href="/tags/Algorithm/" rel="tag"># Algorithm</a> <a href="/tags/Online-Judge/" rel="tag"># Online Judge</a> <a href="/tags/AOJ/" rel="tag"># AOJ</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/d10a3b2.html" rel="prev" title="游戏开发导论"><i class="fa fa-chevron-left"></i> 游戏开发导论</a></div><div class="post-nav-item"><a href="/archives/55180fbf.html" rel="next" title="词法分析">词法分析 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Topic-1-Getting-Started"><span class="nav-number">2.</span> <span class="nav-text">Topic #1 Getting Started</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-1-A-Insertion-Sort"><span class="nav-number">2.1.</span> <span class="nav-text">ALDS1_1_A Insertion Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input"><span class="nav-number">2.1.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output"><span class="nav-number">2.1.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints"><span class="nav-number">2.1.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1"><span class="nav-number">2.1.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1"><span class="nav-number">2.1.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2"><span class="nav-number">2.1.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2"><span class="nav-number">2.1.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F"><span class="nav-number">2.1.8.</span> <span class="nav-text">問題を解く</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.8.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.8.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">2.1.8.3.</span> <span class="nav-text">注意点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%9D%E8%80%83"><span class="nav-number">2.1.8.4.</span> <span class="nav-text">思考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-1-B-Common-Divisor-Greatest"><span class="nav-number">2.2.</span> <span class="nav-text">ALDS1_1_B Common Divisor Greatest</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constrants"><span class="nav-number">2.2.3.</span> <span class="nav-text">Constrants</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hint"><span class="nav-number">2.2.4.</span> <span class="nav-text">Hint</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-1"><span class="nav-number">2.2.5.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-1"><span class="nav-number">2.2.6.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-1"><span class="nav-number">2.2.7.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-1"><span class="nav-number">2.2.8.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-1"><span class="nav-number">2.2.9.</span> <span class="nav-text">問題を解く</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-1-C-Prime-Numbers"><span class="nav-number">2.3.</span> <span class="nav-text">ALDS1_1_C Prime Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-2"><span class="nav-number">2.3.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-2"><span class="nav-number">2.3.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-2"><span class="nav-number">2.3.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-2"><span class="nav-number">2.3.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-2"><span class="nav-number">2.3.8.</span> <span class="nav-text">問題を解く</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-1-D-Maximum-Profit"><span class="nav-number">2.4.</span> <span class="nav-text">ALDS1_1_D Maximum Profit</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-2"><span class="nav-number">2.4.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-3"><span class="nav-number">2.4.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-3"><span class="nav-number">2.4.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-3"><span class="nav-number">2.4.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-3"><span class="nav-number">2.4.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-3"><span class="nav-number">2.4.8.</span> <span class="nav-text">問題を解く</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Topic-2-Sort-I"><span class="nav-number">3.</span> <span class="nav-text">Topic # 2 Sort I</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-2-A-Bubble-Sort"><span class="nav-number">3.1.</span> <span class="nav-text">ALDS1_2_A Bubble Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-4"><span class="nav-number">3.1.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-4"><span class="nav-number">3.1.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-3"><span class="nav-number">3.1.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-4"><span class="nav-number">3.1.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-4"><span class="nav-number">3.1.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-4"><span class="nav-number">3.1.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-4"><span class="nav-number">3.1.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-4"><span class="nav-number">3.1.8.</span> <span class="nav-text">問題を解く</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-1"><span class="nav-number">3.1.8.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">3.1.8.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%9D%E8%80%83-1"><span class="nav-number">3.1.8.3.</span> <span class="nav-text">思考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-2-B-Selection-Sort"><span class="nav-number">3.2.</span> <span class="nav-text">ALDS1_2_B Selection Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-5"><span class="nav-number">3.2.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-5"><span class="nav-number">3.2.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-4"><span class="nav-number">3.2.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-5"><span class="nav-number">3.2.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-5"><span class="nav-number">3.2.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-5"><span class="nav-number">3.2.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-5"><span class="nav-number">3.2.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-5"><span class="nav-number">3.2.8.</span> <span class="nav-text">問題を解く</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-2-C-Stable-Sort"><span class="nav-number">3.3.</span> <span class="nav-text">ALDS1_2_C Stable Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-6"><span class="nav-number">3.3.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-6"><span class="nav-number">3.3.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-5"><span class="nav-number">3.3.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-6"><span class="nav-number">3.3.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-6"><span class="nav-number">3.3.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-6"><span class="nav-number">3.3.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-6"><span class="nav-number">3.3.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-6"><span class="nav-number">3.3.8.</span> <span class="nav-text">問題を解く</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-2-D-Shell-Sort"><span class="nav-number">3.4.</span> <span class="nav-text">ALDS1_2_D Shell Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-7"><span class="nav-number">3.4.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-7"><span class="nav-number">3.4.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-6"><span class="nav-number">3.4.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-7"><span class="nav-number">3.4.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-7"><span class="nav-number">3.4.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-7"><span class="nav-number">3.4.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-7"><span class="nav-number">3.4.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-7"><span class="nav-number">3.4.8.</span> <span class="nav-text">問題を解く</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Topic-3-Elementary-data-structures"><span class="nav-number">4.</span> <span class="nav-text">Topic # 3 Elementary data structures</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-3-A-Stack"><span class="nav-number">4.1.</span> <span class="nav-text">ALDS1_3_A Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-8"><span class="nav-number">4.1.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-8"><span class="nav-number">4.1.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-7"><span class="nav-number">4.1.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-8"><span class="nav-number">4.1.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-8"><span class="nav-number">4.1.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-8"><span class="nav-number">4.1.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-8"><span class="nav-number">4.1.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Notes"><span class="nav-number">4.1.8.</span> <span class="nav-text">Notes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-8"><span class="nav-number">4.1.9.</span> <span class="nav-text">問題を解く</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E6%A0%88"><span class="nav-number">4.1.9.1.</span> <span class="nav-text">原生栈</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">4.1.9.2.</span> <span class="nav-text">标准库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-3-B-Queue"><span class="nav-number">4.2.</span> <span class="nav-text">ALDS1_3_B Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-9"><span class="nav-number">4.2.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-9"><span class="nav-number">4.2.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-8"><span class="nav-number">4.2.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-9"><span class="nav-number">4.2.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-9"><span class="nav-number">4.2.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Notes-1"><span class="nav-number">4.2.6.</span> <span class="nav-text">Notes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-9"><span class="nav-number">4.2.7.</span> <span class="nav-text">問題を解く</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E9%98%9F%E5%88%97"><span class="nav-number">4.2.7.1.</span> <span class="nav-text">原生队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93-1"><span class="nav-number">4.2.7.2.</span> <span class="nav-text">标准库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-3-C-Doubly-Linked-List"><span class="nav-number">4.3.</span> <span class="nav-text">ALDS1_3_C Doubly Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-10"><span class="nav-number">4.3.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-10"><span class="nav-number">4.3.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-9"><span class="nav-number">4.3.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-10"><span class="nav-number">4.3.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-10"><span class="nav-number">4.3.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-9"><span class="nav-number">4.3.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-9"><span class="nav-number">4.3.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-10"><span class="nav-number">4.3.8.</span> <span class="nav-text">問題を解く</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E9%93%BE%E8%A1%A8"><span class="nav-number">4.3.8.1.</span> <span class="nav-text">原生链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93-2"><span class="nav-number">4.3.8.2.</span> <span class="nav-text">标准库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-3-D-Areas-on-the-Cross-Section-Diagram"><span class="nav-number">4.4.</span> <span class="nav-text">ALDS1_3_D Areas on the Cross-Section Diagram</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-11"><span class="nav-number">4.4.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-11"><span class="nav-number">4.4.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-10"><span class="nav-number">4.4.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-11"><span class="nav-number">4.4.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-11"><span class="nav-number">4.4.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-10"><span class="nav-number">4.4.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-10"><span class="nav-number">4.4.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-11"><span class="nav-number">4.4.8.</span> <span class="nav-text">問題を解く</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Topic-4-Search"><span class="nav-number">5.</span> <span class="nav-text">Topic # 4 Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-4-A-Search-I"><span class="nav-number">5.1.</span> <span class="nav-text">ALDS1_4_A Search I</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-12"><span class="nav-number">5.1.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-12"><span class="nav-number">5.1.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-11"><span class="nav-number">5.1.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-12"><span class="nav-number">5.1.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-12"><span class="nav-number">5.1.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-11"><span class="nav-number">5.1.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-11"><span class="nav-number">5.1.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-3"><span class="nav-number">5.1.8.</span> <span class="nav-text">Sample Input 3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-3"><span class="nav-number">5.1.9.</span> <span class="nav-text">Sample Output 3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-12"><span class="nav-number">5.1.10.</span> <span class="nav-text">問題を解く</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-4-B-Search-II"><span class="nav-number">5.2.</span> <span class="nav-text">ALDS1_4_B Search II</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-13"><span class="nav-number">5.2.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-13"><span class="nav-number">5.2.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-12"><span class="nav-number">5.2.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-13"><span class="nav-number">5.2.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-13"><span class="nav-number">5.2.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-12"><span class="nav-number">5.2.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-12"><span class="nav-number">5.2.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-3-1"><span class="nav-number">5.2.8.</span> <span class="nav-text">Sample Input 3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-3-1"><span class="nav-number">5.2.9.</span> <span class="nav-text">Sample Output 3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-13"><span class="nav-number">5.2.10.</span> <span class="nav-text">問題を解く</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-4-C-Search-III"><span class="nav-number">5.3.</span> <span class="nav-text">ALDS1_4_C Search III</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-14"><span class="nav-number">5.3.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-14"><span class="nav-number">5.3.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-13"><span class="nav-number">5.3.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-14"><span class="nav-number">5.3.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-14"><span class="nav-number">5.3.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-13"><span class="nav-number">5.3.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-13"><span class="nav-number">5.3.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Notes-2"><span class="nav-number">5.3.8.</span> <span class="nav-text">Notes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-14"><span class="nav-number">5.3.9.</span> <span class="nav-text">問題を解く</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-4-D-Allocation"><span class="nav-number">5.4.</span> <span class="nav-text">ALDS1_4_D Allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-15"><span class="nav-number">5.4.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-15"><span class="nav-number">5.4.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-14"><span class="nav-number">5.4.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-15"><span class="nav-number">5.4.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-15"><span class="nav-number">5.4.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-2-14"><span class="nav-number">5.4.6.</span> <span class="nav-text">Sample Input 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-2-14"><span class="nav-number">5.4.7.</span> <span class="nav-text">Sample Output 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-15"><span class="nav-number">5.4.8.</span> <span class="nav-text">問題を解く</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Topic-5-Recursion-x2F-Divide-and-Conquer"><span class="nav-number">6.</span> <span class="nav-text">Topic # 5 Recursion / Divide and Conquer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ALDS1-5-A-Exhaustive-Search"><span class="nav-number">6.1.</span> <span class="nav-text">ALDS1_5_A Exhaustive Search</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Input-16"><span class="nav-number">6.1.1.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Output-16"><span class="nav-number">6.1.2.</span> <span class="nav-text">Output</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraints-15"><span class="nav-number">6.1.3.</span> <span class="nav-text">Constraints</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Input-1-16"><span class="nav-number">6.1.4.</span> <span class="nav-text">Sample Input 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Output-1-16"><span class="nav-number">6.1.5.</span> <span class="nav-text">Sample Output 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Notes-3"><span class="nav-number">6.1.6.</span> <span class="nav-text">Notes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F-16"><span class="nav-number">6.1.7.</span> <span class="nav-text">問題を解く</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">271</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4m</span></div><div class="powered-by">今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//fastly.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//fastly.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//fastly.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script async="" src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script>!function(t,h,e,j){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:2272201,hjsv:6},e=h.getElementsByTagName("head")[0],(j=h.createElement("script")).async=1,j.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,e.appendChild(j)}(window,document)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
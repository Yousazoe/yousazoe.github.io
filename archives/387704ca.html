<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言开始使用 DXR。创建相同的 G 缓冲区，这次使用 DirectX 光线追踪。"><meta property="og:type" content="article"><meta property="og:title" content="A Gentle Introduction to DirectX Raytracing 4"><meta property="og:url" content="https://yousazoe.top/archives/387704ca.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言开始使用 DXR。创建相同的 G 缓冲区，这次使用 DirectX 光线追踪。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_Menu.PNG"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_Menu.PNG"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_WorldNorml.PNG"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_WorldPosition.PNG"><meta property="article:published_time" content="2021-12-14T12:48:06.000Z"><meta property="article:modified_time" content="2022-09-08T13:25:48.700Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_Menu.PNG"><link rel="canonical" href="https://yousazoe.top/archives/387704ca.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>A Gentle Introduction to DirectX Raytracing 4 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/387704ca.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">A Gentle Introduction to DirectX Raytracing 4</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-12-14 20:48:06" itemprop="dateCreated datePublished" datetime="2021-12-14T20:48:06+08:00">2021-12-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">光线追踪 (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>20k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>37 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_Menu.PNG"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>开始使用 DXR。创建相同的 G 缓冲区，这次使用 DirectX 光线追踪。</p><span id="more"></span><blockquote><p>Our first three <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/dxr_tutors.md.html">tutorials</a> focused on getting up to speed with our simple tutorial infrastructure and making simple DirectX rasterization calls (to create a basic <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deferred_shading">G-Buffer</a>). This tutorial finally moves on to actually spawning some ray tracing with DirectX. To focus on how ray tracing and rasterization are different, this tutorial builds a G-Buffer identical to the one created in <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">Tutorial 3</a>.</p></blockquote><p>我们的前三个<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/dxr_tutors.md.html">教程</a>侧重于快速了解我们的简单教程基础结构并进行简单的 DirectX 栅格化调用（以创建基本的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deferred_shading">G-Buffer</a>）。本教程最后将转到使用 DirectX 实际生成一些光线追踪。为了重点介绍光线追踪和光栅化的不同之处，本教程构建了一个与<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">教程 3</a>中创建的G缓冲区相同的G缓冲区.</p><h3 id="Our-Basic-Ray-Tracing-Render-Pipeline"><a href="#Our-Basic-Ray-Tracing-Render-Pipeline" class="headerlink" title="Our Basic Ray Tracing Render Pipeline"></a>Our Basic Ray Tracing Render Pipeline</h3><blockquote><p>If you open up <code>Tutor04-RayTracedGBuffer.cpp</code>, you will find the only change is we swaped out <code>SimpleGBufferPass</code> for the new <code>RayTracedGBufferPass</code> we’ll build below. We reuse the same <code>CopyToOutputPass</code> we created in <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">Tutorial 3</a>.</p></blockquote><p>如果您打开 <code>Tutor04-RayTracedGBuffer.cpp</code>，您会发现唯一的变化是我们将在下面构建的新<code>RayTracedGBufferPass</code> <code>SimpleGBufferPass</code> 。我们重用我们在<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">教程 3</a>中创建的相同<code>CopyToOutputPass</code> 。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create our rendering pipeline</span></span><br><span class="line">RenderingPipeline *pipeline = <span class="keyword">new</span> <span class="built_in">RenderingPipeline</span>();</span><br><span class="line">pipeline-&gt;<span class="built_in">setPass</span>(<span class="number">0</span>, RayTracedGBufferPass::<span class="built_in">create</span>());   </span><br><span class="line">pipeline-&gt;<span class="built_in">setPass</span>(<span class="number">1</span>, CopyToOutputPass::<span class="built_in">create</span>());   </span><br></pre></td></tr></tbody></table></figure><blockquote><p>For those who skipped the first three tutorials, this code can be read as “create a rendering pipeline with two components: a pass that generates a ray-traced G-buffer followed by a pass that copies a selectable buffer onscreen.”</p></blockquote><p>对于那些跳过前三个教程的人来说，这段代码可以读作“创建一个包含两个组件的渲染管线：一个生成光线追踪G缓冲区的管道，另一个在屏幕上复制可选缓冲区的管道。”</p><h3 id="Creating-and-Launching-DirectX-Raytracing-Work"><a href="#Creating-and-Launching-DirectX-Raytracing-Work" class="headerlink" title="Creating and Launching DirectX Raytracing Work"></a>Creating and Launching DirectX Raytracing Work</h3><blockquote><p>Start by looking in <code>RayTracedGBufferPass.h</code>. This should look familiar, as the boilerplate is nearly identical to that from the <code>RenderPasses</code> from prior tutorials. The major difference is in our pass’ member variables:</p></blockquote><p>首先查看 <code>RayTracedGBufferPass.h</code>。这应该看起来很熟悉，因为模板几乎与之前教程中的 <code>RenderPasses</code> 样板相同。主要区别在于我们的 pass 的成员变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">RtScene::SharedPtr      mpScene;     <span class="comment">// Falcor scene abstraction </span></span><br><span class="line">RayLaunch::SharedPtr    mpRays;      <span class="comment">// Encapsulates DirectX Raytracing pass</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>The <code>RtScene</code> class encapsultes Falcor’s scene representation, with additions for ray tracing. In the rest of our tutorials, we will use the <code>RtScene</code> class (which derives from the <code>Scene</code> class from <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">Tutorial 3</a> but adds functionality required for ray tracing).</p></blockquote><p><code>RtScene</code> 类封装了 Falcor 的场景表示并添加了用于光线追踪的功能。在其余教程中，我们将使用 <code>RtScene</code> 类（该类派生自<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">教程 3</a> <code>Scene</code>类，但添加了光线追踪所需的功能）。</p><blockquote><p>The <code>RayLaunch</code> is similar to the <code>RasterLaunch</code> class from <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">Tutorial 3</a>, except it exposes methods for setting up all the new HLSL ray tracing shader types and setting their variables.</p></blockquote><p><code>RayLaunch</code> 类似于<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">教程 3</a>中的 <code>RasterLaunch</code> 类，只不过它公开了用于设置所有新的 HLSL 光线追踪着色器类型和设置其变量的方法。</p><h4 id="Initializing-our-Ray-Traced-G-Buffer-Pass"><a href="#Initializing-our-Ray-Traced-G-Buffer-Pass" class="headerlink" title="Initializing our Ray Traced G-Buffer Pass"></a>Initializing our Ray Traced G-Buffer Pass</h4><blockquote><p>Our <code>RayTracedGBufferPass::initialize()</code> looks quite similar to the one for <code>SimpleGBufferPass</code>:</p></blockquote><p>我们的 <code>RayTracedGBufferPass::initialize()</code> 看起来与 <code>SimpleGBufferPass</code> 非常相似:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RayTracedGBufferPass::initialize</span><span class="params">(RenderContext::SharedPtr pRenderContext, </span></span></span><br><span class="line"><span class="params"><span class="function">                                   ResourceManager::SharedPtr pResManager)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// Stash a copy of our resource manager; tell it what shared texture</span></span><br><span class="line">  <span class="comment">//     resources we need for this pass.</span></span><br><span class="line">  mpResManager = pResManager;</span><br><span class="line">  mpResManager-&gt;<span class="built_in">requestTextureResources</span>({<span class="string">"WorldPosition"</span>, <span class="string">"WorldNormal"</span>,</span><br><span class="line">                                        <span class="string">"MaterialDiffuse"</span>, <span class="string">"MaterialSpecRough"</span>, </span><br><span class="line">                                        <span class="string">"MaterialExtraParams"</span>});</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create our wrapper for our DirectX Raytracing launch.</span></span><br><span class="line">  mpRays = RayLaunch::<span class="built_in">create</span>(<span class="string">"rtGBuffer.hlsl"</span>, <span class="string">"GBufferRayGen"</span>);</span><br><span class="line">  mpRays-&gt;<span class="built_in">addMissShader</span>(<span class="string">"rtGBuffer.hlsl"</span>, <span class="string">"PrimaryMiss"</span>);</span><br><span class="line">  mpRays-&gt;<span class="built_in">addHitShader</span>(<span class="string">"rtGBuffer.hlsl"</span>, <span class="string">"PrimaryClosestHit"</span>, <span class="string">"PrimaryAnyHit"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compile our shaders and pass in our scene</span></span><br><span class="line">  mpRays-&gt;<span class="built_in">compileRayProgram</span>();</span><br><span class="line">  mpRays-&gt;<span class="built_in">setScene</span>(mpScene);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>A couple important notes:</p><ul><li>The method <code>requestTextureResources</code> is identical to calling <code>requiresTextureResource</code> multiple times, with each of the specified names, simplifying the code somewhat.</li><li>We don’t request a Z-buffer, because ray tracing does not generate one by default. (Of course, if desired you can output a Z-buffer manually.)</li></ul></blockquote><p>一些重要的注意事项：</p><ul><li>方法 <code>requestTextureResources</code> 与多次调用 <code>requiresTextureResource</code> 相同，每个名称都指定，在一定程度上简化了代码。</li><li>我们不请求 Z 缓冲区，因为默认情况下光线追踪不会生成 Z 缓冲区。（当然，如果需要，您可以手动输出 Z 缓冲区。</li></ul><blockquote><p>We then create our ray tracing wrapper <code>mpRays</code> by pointing it to our shader file <code>rtGBuffer.hlsl</code> and specifying the function where our <em>ray generation shader</em> starts, in this case the function <code>GBufferRayGen()</code> in our HLSL file. Because we plan to launch rays from this shader, we also have to specify the <em>miss shader</em> to use, named <code>PrimaryMiss()</code>, and our <em>closest-hit</em> and <em>any hit shaders</em>, named <code>PrimaryClosestHit()</code> and <code>PrimaryAnyHit()</code>.</p></blockquote><p>然后，我们创建光线追踪包装器 <code>mpRays</code> 方法是将其指向我们的着色器文件 <code>rtGBuffer.hlsl</code> 并指定光线生成着色器开始的函数。在本例中为 HLSL 文件中的函数 <code>GBufferRayGen()</code> 由于我们计划从此着色器启动光线，因此我们还必须指定要使用的 miss 着色器，命名为 <code>PrimaryMiss()</code>，以及我们最接近的着色器和任何命中着色器，命名为<code>PrimaryClosestHit()</code>*和 <code>PrimaryAnyHit()</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create our wrapper for our DirectX Raytracing launch.</span></span><br><span class="line">mpRays = RayLaunch::<span class="built_in">create</span>(<span class="string">"rtGBuffer.hlsl"</span>, <span class="string">"GBufferRayGen"</span>);</span><br><span class="line">mpRays-&gt;<span class="built_in">addMissShader</span>(<span class="string">"rtGBuffer.hlsl"</span>, <span class="string">"PrimaryMiss"</span>);</span><br><span class="line">mpRays-&gt;<span class="built_in">addHitShader</span>(<span class="string">"rtGBuffer.hlsl"</span>, <span class="string">"PrimaryClosestHit"</span>, <span class="string">"PrimaryAnyHit"</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>When ray tracing, we can have multiple ray types. This means we can call <code>addMissShader</code> multiple times. The first time it is called, we specify miss shader #0. The second time, we specify miss shader #1. The next, miss shader #2. Et cetera. Similarly, when called multiple times, <code>addHitShader</code> specifies hit group #0, 1, 2, etc. This integer identifier is important, as calling <code>TraceRay()</code> in HLSL requires you specify the correct IDs.</p></blockquote><p>在光线追踪时，我们可以有多种光线类型。这意味着我们可以多次调用 <code>addMissShader</code>。第一次调用它时，我们指定 miss shader #0。第二次，我们指定 miss 着色器 #1。接下来，miss 着色器#2 等等……同样，当多次调用时 <code>addHitShader</code> 会指定命中组 #0、1、2 等。此整数标识符很重要，因为在 HLSL 中调用 <code>TraceRay()</code> 需要指定正确的 ID。</p><h4 id="Launching-Ray-Tracing-and-Sending-Data-to-HLSL"><a href="#Launching-Ray-Tracing-and-Sending-Data-to-HLSL" class="headerlink" title="Launching Ray Tracing and Sending Data to HLSL"></a>Launching Ray Tracing and Sending Data to HLSL</h4><blockquote><p>Now that we initialized our rendering resources, we can create our ray traced G-buffer. The <code>RayTracedGBufferPass::execute</code> pass is somewhat complex, so let’s split it into multiple pieces:</p></blockquote><p>现在，我们初始化了渲染资源，可以创建光线追踪的 G 缓冲区了。<code>RayTracedGBufferPass::execute</code> 管线有点复杂，所以让我们把它分成多个部分：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RayTracedGBufferPass::execute</span><span class="params">(RenderContext::SharedPtr pRenderContext)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// Color used to clear our G-buffer </span></span><br><span class="line">  vec4 black    = <span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load our textures; ask the resource manager to clear them first</span></span><br><span class="line">  <span class="comment">//    Note:  'auto' type used for brevity; actually Texture::SharedPtr</span></span><br><span class="line">  <span class="keyword">auto</span> wsPos    = mpResManager-&gt;<span class="built_in">getClearedTexture</span>(<span class="string">"WorldPosition"</span>,       black);</span><br><span class="line">  <span class="keyword">auto</span> wsNorm   = mpResManager-&gt;<span class="built_in">getClearedTexture</span>(<span class="string">"WorldNormal"</span>,         black);</span><br><span class="line">  <span class="keyword">auto</span> matDif   = mpResManager-&gt;<span class="built_in">getClearedTexture</span>(<span class="string">"MaterialDiffuse"</span>,     black);</span><br><span class="line">  <span class="keyword">auto</span> matSpec  = mpResManager-&gt;<span class="built_in">getClearedTexture</span>(<span class="string">"MaterialSpecRough"</span>,   black);</span><br><span class="line">  <span class="keyword">auto</span> matExtra = mpResManager-&gt;<span class="built_in">getClearedTexture</span>(<span class="string">"MaterialExtraParams"</span>, black);</span><br><span class="line">  <span class="keyword">auto</span> matEmit  = mpResManager-&gt;<span class="built_in">getClearedTexture</span>(<span class="string">"Emissive"</span>,            black);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>First, we need access the textures we’ll use to write out our G-buffer. Unlike in <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor2/tutorial02.md.html">Tutorials 2</a> <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">and 3</a>, we do not need to create a framebuffer object. Instead for ray tracing, we’ll write directly into them (<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sm5-object-rwtexture2d">using UAVs</a>). We also ask our resource manager to clear them to black prior to returning the textures.</p></blockquote><p>首先，我们需要访问将用于写出 G 缓冲区的纹理。与<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor2/tutorial02.md.html">教程 2</a> <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">和教程 3</a>不同，我们不需要创建帧缓冲器对象。相反，对于光线追踪，我们将直接写入它们（<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sm5-object-rwtexture2d">使用 UAVs</a>）。我们还要求资源管理器在返回纹理之前将它们清除为黑色。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Pass our background color down to miss shader #0</span></span><br><span class="line">  <span class="keyword">auto</span> missVars = mpRays-&gt;<span class="built_in">getMissVars</span>(<span class="number">0</span>);</span><br><span class="line">  missVars[<span class="string">"MissShaderCB"</span>][<span class="string">"gBgColor"</span>] = mBgColor;  <span class="comment">// Color for background</span></span><br><span class="line">  missVars[<span class="string">"gMatDif"</span>] = matDif;                     <span class="comment">// Where to store bg color</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Next, we set the HLSL variables for our <em>miss shader #0</em>. These variables are scoped so they are <em>only</em> usable while executing this specific miss shader. This uses the same syntax we used for raster shaders, except we need to specifically ask (<code>getMissVars(0)</code>) for variables for miss shader #0. In this case, if our rays miss we’ll store the specified background color in the <code>"MaterialDiffuse"</code> texture.</p></blockquote><p>接下来，我们为 <em>miss 着色器 #0</em> 设置 HLSL 变量。这些变量的作用域仅在执行此特定未命中着色器时可用。它使用与光栅化着色器相同的语法，只是我们需要专门询问 （<code>getMissVars(0)</code>) 对于 miss 着色器 #0 的变量。在这种情况下，如果我们的光线丢失，我们将以 <code>"MaterialDiffuse"</code> 纹理存储指定的背景色。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Pass down variables for our hit group #0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pVars : mpRays-&gt;<span class="built_in">getHitVars</span>(<span class="number">0</span>))   </span><br><span class="line">{</span><br><span class="line">  pVars[<span class="string">"gWsPos"</span>] = wsPos;</span><br><span class="line">  pVars[<span class="string">"gWsNorm"</span>] = wsNorm;</span><br><span class="line">  pVars[<span class="string">"gMatDif"</span>] = matDif;</span><br><span class="line">  pVars[<span class="string">"gMatSpec"</span>] = matSpec;</span><br><span class="line">  pVars[<span class="string">"gMatExtra"</span>] = matExtra;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>In this snippet, we are setting the HLSL variables for hit group #0 (i.e, the <em>closest-hit</em> and <em>any-hit</em> shaders). This code is more complex than for miss shaders, since your variables may change for each geometry instance in your scene. This is the cause of the <em><code>for</code></em> loop, as we loop over all the instances. In this case, the variables specifed are scoped so they are only visibile by the closest-hit and any-hit shaders executed while intersecting the specified geometry instance.</p></blockquote><p>在此代码段中，我们将为命中组 #0（即最接近命中和任意命中着色器）设置 HLSL 变量。此代码比未命中着色器的代码更复杂，因为场景中的每个几何实例的变量可能会发生变化。这是for循环的原因，因为我们遍历了所有实例。在这种情况下，指定的变量的作用域为，因此它们只能通过与指定几何实例相交时执行的最接近和任意命中着色器可见。</p><blockquote><p>Above, we are specifying the output textures <code>gWsPos</code>, <code>gWsNorm</code>, <code>gMatDif</code>, <code>gMatSpec</code>, and <code>gMatExtra</code>. We will store our G=Buffer output in our <em>closest-hit</em> shader, which can thought of as similar to a pixel shader.</p></blockquote><p>上面，我们指定了输出纹理 <code>gWsPos</code>、 <code>gWsNorm</code>、 <code>gMatDif</code>、 <code>gMatSpec</code> 和 <code>gMatExtra</code>。我们将 G=Buffer 输出存储在最接近的着色器中，这可以被视为类似于像素着色器。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">// Launch our ray tracing</span></span><br><span class="line">  mpRays-&gt;<span class="built_in">execute</span>( pRenderContext, mpResManager-&gt;<span class="built_in">getScreenSize</span>() );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Finally, we launch our ray tracing pass. <code>execute()</code> requres the DirectX context and the number of rays to launch (often dependant on screen resolution).</p></blockquote><p>最后，我们启动光线追踪管线。<code>execute()</code> 的参数包含 DirectX context 和要启动的光线数（通常取决于屏幕分辨率）。</p><h3 id="The-DirectX-Raytracing-HLSL-for-Our-G-Buffer"><a href="#The-DirectX-Raytracing-HLSL-for-Our-G-Buffer" class="headerlink" title="The DirectX Raytracing HLSL for Our G-Buffer"></a>The DirectX Raytracing HLSL for Our G-Buffer</h3><blockquote><p>Just like when starting to read a C++ program it often makes sense to start reading at <code>main()</code>, you should probably start reading HLSL ray tracing code at the ray generation shader. As specified above during our pass initialization, our shader’s ray generation shader is named <code>GBufferRayGen()</code>:</p></blockquote><p>就像开始读取C++程序一样，从 <code>main()</code> 开始读取通常是有意义的，您可能应该在光线生成着色器处开始读取 HLSL 光线追踪代码。如上所述，在管线初始化期间，着色器的光线生成着色器被命名为 <code>GBufferRayGen()</code> :</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="built_in">shader</span>(<span class="string">"raygeneration"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GBufferRayGen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Convert our ray index into a ray direction in world space. </span></span><br><span class="line">    float2 currenPixelLocation = <span class="built_in">DispatchRaysIndex</span>() + <span class="built_in">float2</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">	float2 pixelCenter = currenPixelLocation / <span class="built_in">DispatchRaysDimensions</span>();</span><br><span class="line">	float2 ndc = <span class="built_in">float2</span>(<span class="number">2</span>, <span class="number">-2</span>) * pixelCenter + <span class="built_in">float2</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">	float3 rayDir = <span class="built_in">normalize</span>( ndc.x * gCamera.cameraU + </span><br><span class="line">                               ndc.y * gCamera.cameraV + </span><br><span class="line">                                       gCamera.cameraW );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize a ray structure for our ray tracer</span></span><br><span class="line">	RayDesc ray = { gCamera.posW, <span class="number">0.0f</span>, rayDir, <span class="number">1e+38</span>f };</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize our ray payload (a per-ray, user-definable structure).</span></span><br><span class="line">	SimplePayload payload = { <span class="literal">false</span> };</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trace our ray</span></span><br><span class="line">	<span class="built_in">TraceRay</span>(gRtScene, RAY_FLAG_NONE, <span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, ray, payload );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The first few lines lookup the current pixel location. The number of rays launched (i.e., the parmaeter passed to <code>mpRays-&gt;execute</code>) is accessible via HLSL’s <code>DispatchRayDimensions()</code> intrinsic, and the current pixel being processed is given by <code>DispatchRaysIndex()</code>. After converting the pixel location into a value in [−1…1], we use the current camera parameters to generate a world-space vector that describes the ray from the camera through this pixel. The camera variable <code>gCamera</code> is automatically passed down by our framework.</p></blockquote><p>前几行查找当前像素位置。发射的光线数量（即传递给 <code>mpRays-&gt;execute</code>）可以通过 HLSL 的<code>DispatchRayDimensions()</code> 来访问，并且当前正在处理的像素由 <code>DispatchRaysIndex()</code> 给出。将像素位置转换为 [−1…1]，我们使用当前的相机参数来生成一个世界空间矢量，该矢量描述了来自相机的光线通过此像素。相机变量 <code>gCamera</code> 由我们的框架自动传递。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Convert our ray index into a ray direction in world space. </span></span><br><span class="line">float2 currenPixelLocation = <span class="built_in">DispatchRaysIndex</span>() + <span class="built_in">float2</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">float2 pixelCenter = currenPixelLocation / <span class="built_in">DispatchRaysDimensions</span>();</span><br><span class="line">float2 ndc = <span class="built_in">float2</span>(<span class="number">2</span>, <span class="number">-2</span>) * pixelCenter + <span class="built_in">float2</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">float3 rayDir = <span class="built_in">normalize</span>( ndc.x * gCamera.cameraU + </span><br><span class="line">                          ndc.y * gCamera.cameraV + </span><br><span class="line">                          gCamera.cameraW );</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We then create a ray using the DirectX data type <code>RayDesc</code>. The first entry in the structure (named <code>Origin</code>) specifies where the ray starts. The second entry (named <code>TMin</code>) specifies the minimum distance we need to travel along our ray before reporting a valid hit. The third entry (named <code>Direction</code>) specifies the ray directions. The fourth entry (named <code>TMax</code>) specifies the maximum distance along our ray to return a valid hit.</p></blockquote><p>然后，我们使用 DirectX 数据类型 <code>RayDesc</code> 创建一个射线。参数中的第一个参数（名为 <code>Origin</code>）指定光线的起始位置。第二个参数（名为 <code>TMin</code> 指定了在报告有效命中之前，我们需要沿着光线行进的最小距离。第三个参数（名为 <code>Direction</code>“）指定光线方向。第四个参数（名为 <code>TMax</code> 指定了返回有效命中时沿光线的最大距离。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize a ray structure for our ray tracer</span></span><br><span class="line">RayDesc ray = { gCamera.posW, <span class="number">0.0f</span>, rayDir, <span class="number">1e+38</span>f };</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize a ray structure for our ray tracer</span></span><br><span class="line"><span class="comment">// RayDesc ray;</span></span><br><span class="line"><span class="comment">// ray.Origin    = gCamera.posW;      // Start our ray at the world-space camera position</span></span><br><span class="line"><span class="comment">// ray.Direction = normalize(rayDir); // Our ray direction; normalizing this is often wise</span></span><br><span class="line"><span class="comment">// ray.TMin      = 0.0f;              // Start at 0.0; for camera, no danger of self-intersection</span></span><br><span class="line"><span class="comment">// ray.TMax      = 1e+38f;            // Maximum distance to look for a ray hit</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>When tracing rays in DirectX, there is a user-definable <em>payload</em> structure that accompanies each ray and allows you to stash temporary data during ray tracing. In this example shader this payload is unused, so is not particularly important.</p></blockquote><p>在使用 DirectX 进行跟踪光线时，每条光线都附带一个用户可定义的<em>有效负载</em>结构，并允许您在光线追踪期间存储临时数据。在此示例着色器中此有效负载未使用，因此不是特别重要。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize our ray payload (a per-ray, user-definable structure).</span></span><br><span class="line">SimplePayload payload = { <span class="literal">false</span> };</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Finally, we call <code>TraceRay()</code> to launch our ray with the following parameters:</p><ul><li>The first parameter, <code>gRtScene</code>, is the ray acceleration structure. Our framework populates this HLSL variable for you automatically.</li><li>Second, we specify flags to control ray behavior. Here, we use no special flags.</li><li>Third, we specify an instance mask. This allows you to skip some instances during traversal. A value <code>0xFF</code> tests all geometry in the scene (skipping none).</li><li>Fourth, we specify which hit group to use. In the DXR spec, this is a somewhat complex computation. For most simple usage, this corresponds directly to the ID of your hit group, as determined in <code>RayTracedGBufferPass::initialize</code>. (In our case, there is only one hit group so this takes a value of 0).</li><li>Fifth, we specify how many hit groups there are. In our case this is 1. (Our framework computes this and stores it in the varaible <code>hitProgramCount</code>, if you wish to avoid hard coding this value.)</li><li>Sixth, we specify which miss shader to use. This directly corresponds to the miss shader ID determined in <code>RayTracedGBufferPass::initialize</code>.</li><li>Seventh, we specify the ray to trace.</li><li>Finally, we specify the payload data structure to use while tracing this ray.</li></ul></blockquote><p>最后，我们调用<code>TraceRay()</code>来启动具有以下参数的射线：</p><ul><li>第一个参数 <code>gRtScene</code> 是射线加速度结构。我们的框架会自动为您填充此 HLSL 变量</li><li>第二个参数，我们指定标志来控制光线行为。在这里我们没有使用特殊标志</li><li>第三个参数，我们指定一个实例掩码。这允许您在遍历期间跳过某些实例。值 <code>0xFF</code> 表示测试场景中的所有几何图形（不跳过任何几何图形）</li><li>第四个参数，我们指定要使用的命中组。在 DXR 规范中，这是一个有点复杂的计算。对于大多数简单的用法，这直接对应于命中组的 ID，如 <code>RayTracedGBufferPass::initialize</code> 中所确定的那样（在我们的例子中，只有一个命中组，所以这需要一个值为 0）</li><li>第五个参数，我们指定有多少个命中组。在我们的例子中是1（我们的框架会计算这一点，如果你想避免硬编码这个值会将其存储在可修改的 <code>hitProgramCount</code> 中）</li><li>第六个参数，我们指定要使用的未命中着色器。这直接对应于在 <code>RayTracedGBufferPass::initialize</code> 中确定的 miss 着色器 ID</li><li>第七个参数，我们指定要追踪的光线</li><li>最后，我们指定在追踪此光线时要使用的有效负载数据结构</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Trace our ray</span></span><br><span class="line"><span class="built_in">TraceRay</span>(gRtScene, RAY_FLAG_NONE, <span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, ray, payload );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trace our ray</span></span><br><span class="line"><span class="built_in">TraceRay</span>(gRtScene,                        <span class="comment">// A Falcor built-in containing the raytracing acceleration structure</span></span><br><span class="line">         RAY_FLAG_CULL_BACK_FACING_TRIANGLES,  <span class="comment">// Ray flags.  (Here, we will skip hits with back-facing triangles)</span></span><br><span class="line">         <span class="number">0xFF</span>,                                 <span class="comment">// Instance inclusion mask.  0xFF =&gt; no instances discarded from this mask</span></span><br><span class="line">         <span class="number">0</span>,                                    <span class="comment">// Hit group to index (i.e., when intersecting, call hit shader #0)</span></span><br><span class="line">         hitProgramCount,                      <span class="comment">// Number of hit groups ('hitProgramCount' is built-in from Falcor with the right number)</span></span><br><span class="line">         <span class="number">0</span>,                                    <span class="comment">// Miss program index (i.e., when missing, call miss shader #0)</span></span><br><span class="line">         ray,                                  <span class="comment">// Data structure describing the ray to trace</span></span><br><span class="line">         rayData);                             <span class="comment">// Our user-defined ray payload structure to store intermediate results</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>After calling <code>TraceRay()</code>, some processing happens internally. The next shader executed depends on the geometry, ray direction, and internal data structures. <em>Any-hit shaders</em> get launched for some potential hits, <em>closest-hit shaders</em> get launched when you have identified the single closest hit along the ray, and <em>miss shaders</em> get launched if no valid hit occurs.</p></blockquote><p>调用<code>TraceRay()</code>后，一些处理在内部进行。执行的下一个着色器取决于几何体、光线方向和内部数据结构。<em>对于任何命中着色器</em>，都会针对某些潜在的命中启动，当您确定光线沿线的单个最接近<em>的</em>命中时，将启动最接近命中的着色器，如果没有发生有效的命中，<em>则会启动未命中着色器</em>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// A dummy payload for this simple ray; never used</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimplePayload</span> {</span><br><span class="line">	<span class="type">bool</span> dummyValue;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our miss shader's variables</span></span><br><span class="line">cbuffer MissShaderCB {</span><br><span class="line">	float3  gBgColor;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// The output textures.  See bindings in C++ code.</span></span><br><span class="line"><span class="comment">//     -&gt; gMatDif is visible in the miss shader</span></span><br><span class="line"><span class="comment">//     -&gt; All textures are visible in the hit shaders</span></span><br><span class="line">RWTexture2D&lt;float4&gt; gWsPos, gWsNorm, gMatDif, gMatSpec, gMatExtra;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">shader</span>(<span class="string">"miss"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimaryMiss</span><span class="params">(inout SimplePayload)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gMatDif[<span class="built_in">DispatchRaysIndex</span>()] = <span class="built_in">float4</span>( gBgColor, <span class="number">1.0f</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This miss shader is fairly straightforward. When a ray misses all geometry, write out the background color into the specified texture. Where in the texture do we write? That depends on the current pixel location we are working on (using the same <code>DispatchRaysIndex()</code> intrinsic we used in our ray generation shader).</p></blockquote><p>这个未命中着色器相当简单。当光线错过所有几何图形时，将背景色写出到指定的纹理中。我们在纹理的哪个位置写？这取决于我们正在处理的当前像素位置（使用我们在光线生成着色器中使用的相同 <code>DispatchRaysIndex()</code> 固有功能）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// What code is executed when our ray hits a potentially transparent surface?</span></span><br><span class="line">[<span class="built_in">shader</span>(<span class="string">"anyhit"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimaryAnyHit</span><span class="params">(inout SimpleRayPayload, BuiltInTriangleIntersectionAttributes attribs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Is this a transparent part of the surface?  If so, ignore this hit</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">alphaTestFails</span>(attribs))</span><br><span class="line">		<span class="built_in">IgnoreHit</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Our any hit shader is also straightforward. In most cases, when ray traversal detects a hit point, it is a valid intersection. However, if the geometry uses alpha-testing and has a textured alpha mask, we need to query it before confirming the intersection. Here we call a utility function <code>alphaTestFails()</code> (see tutorial code for specifics) that loads the alpha texture from Falcor’s internal scene structure and determines if we hit a transparent texel. If so, this hit is ignored via the <code>IgnoreHit()</code> intrinsic, otherwise the hit is accepted.</p></blockquote><p>我们的任何命中着色器也很简单。在大多数情况下，当光线遍历检测到命中点时，它是一个有效的交集。但是，如果几何体使用 alpha 测试并具有纹理 alpha 蒙版，则需要在确认交集之前对其进行查询。在这里，我们调用一个实用程序函数 <code>alphaTestFails()</code> 有关详细信息，请参阅教程代码），该函数从 Falcor 的内部场景结构加载 alpha 纹理并确定我们是否命中透明纹理。如果是这样，则通过 <code>IgnoreHit()</code> 内部函数忽略此命中，否则将接受此命中。</p><p>（译者注：这里附上该函数的完整定义，位于同一个文件夹下的 <code>alphaTest.hlsli</code>。）</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************************************************************</span></span><br><span class="line"><span class="comment"># Copyright (c) 2018, NVIDIA CORPORATION. All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redistribution and use in source and binary forms, with or without modification, are permitted provided that the</span></span><br><span class="line"><span class="comment"># following conditions are met:</span></span><br><span class="line"><span class="comment">#  * Redistributions of code must retain the copyright notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment">#  * Neither the name of NVIDIA CORPORATION nor the names of its contributors may be used to endorse or promote products</span></span><br><span class="line"><span class="comment">#    derived from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></span><br><span class="line"><span class="comment"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT</span></span><br><span class="line"><span class="comment"># SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span></span><br><span class="line"><span class="comment"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,</span></span><br><span class="line"><span class="comment"># OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span></span><br><span class="line"><span class="comment"># LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF</span></span><br><span class="line"><span class="comment"># ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment">**********************************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This function tests if the alpha test fails, given the attributes of the current hit. </span></span><br><span class="line"><span class="comment">//   -&gt; Can legally be called in a DXR any-hit shader or a DXR closest-hit shader, and </span></span><br><span class="line"><span class="comment">//      accesses Falcor helpers and data structures to extract and perform the alpha test.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">alphaTestFails</span><span class="params">(BuiltInTriangleIntersectionAttributes attribs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Run a Falcor helper to extract the current hit point's geometric data</span></span><br><span class="line">	VertexOut  vsOut = <span class="built_in">getVertexAttributes</span>(<span class="built_in">PrimitiveIndex</span>(), attribs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extracts the diffuse color from the material (the alpha component is opacity)</span></span><br><span class="line">    ExplicitLodTextureSampler lodSampler = { <span class="number">0</span> };  <span class="comment">// Specify the tex lod/mip to use here</span></span><br><span class="line">	float4 baseColor = <span class="built_in">sampleTexture</span>(gMaterial.resources.baseColor, gMaterial.resources.samplerState,</span><br><span class="line">		vsOut.texC, gMaterial.baseColor, <span class="built_in">EXTRACT_DIFFUSE_TYPE</span>(gMaterial.flags), lodSampler);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Test if this hit point fails a standard alpha test.  </span></span><br><span class="line">	<span class="keyword">return</span> (baseColor.a &lt; gMaterial.alphaThreshold);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function combines two Falcor-defined utility routines into one.  (That does not</span></span><br><span class="line"><span class="comment">//       require the user to define an additional opaque data type 'VertexOut', which </span></span><br><span class="line"><span class="comment">//       is largely irrelevant since ShadingData contains all the important data from</span></span><br><span class="line"><span class="comment">//       VertexOut)</span></span><br><span class="line"><span class="function">ShadingData <span class="title">getShadingData</span><span class="params">(uint primId, BuiltInTriangleIntersectionAttributes barys)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	VertexOut  vsOut = <span class="built_in">getVertexAttributes</span>(primId, barys);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">prepareShadingData</span>(vsOut, gMaterial, gCamera.posW, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="built_in">shader</span>(<span class="string">"closesthit"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimaryClosestHit</span><span class="params">(inout SimpleRayPayload, BuiltinIntersectionAttribs attribs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Which pixel spawned our ray?</span></span><br><span class="line">	uint2 idx = <span class="built_in">DispatchRaysIndex</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run helper function to compute important data at the current hit point</span></span><br><span class="line">	ShadingData shadeData = <span class="built_in">getShadingData</span>( <span class="built_in">PrimitiveIndex</span>(), attribs );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save out our G-buffer values to the specified output textures</span></span><br><span class="line">	gWsPos[idx] = <span class="built_in">float4</span>(shadeData.posW, <span class="number">1.f</span>);</span><br><span class="line">	gWsNorm[idx] = <span class="built_in">float4</span>(shadeData.N, <span class="built_in">length</span>(shadeData.posW - gCamera.posW));</span><br><span class="line">	gMatDif[idx] = <span class="built_in">float4</span>(shadeData.diffuse, shadeData.opacity);</span><br><span class="line">	gMatSpec[idx] = <span class="built_in">float4</span>(shadeData.specular, shadeData.linearRoughness);</span><br><span class="line">	gMatExtra[idx] = <span class="built_in">float4</span>(shadeData.IoR, </span><br><span class="line">                            shadeData.doubleSidedMaterial ? <span class="number">1.f</span> : <span class="number">0.f</span>, </span><br><span class="line">                            <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Our closest hit shader looks remarkably like ou pixel shader in <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">Tutorial 3</a>. We first find which pixel onscreen this ray belongs to (using the <code>DispatchRaysIndex()</code> intrinsic), then we get our <code>ShadingData</code> using Falcor utility functions, finally we output our G-buffer data to the corresponding output buffers.</p></blockquote><p>我们最接近的着色器看起来非常像<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">教程3</a>中的ou像素着色器。我们首先找到此光线在屏幕上属于哪个像素（使用 <code>DispatchRaysIndex()</code> 内部函数），然后使用 Falcor 实用程序函数获取<code>ShadingData</code>，最后将 G 缓冲区数据输出到相应的输出缓冲区。</p><blockquote><p>As in <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">Tutorial 3</a>, this G-buffer is extremely verbose, and you could likely compress the same data into many fewer bits. This format is used for clarity.</p></blockquote><p>和 <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">教程3</a> 一样，这个G缓冲区非常冗长，您可能会将相同的数据压缩更少。为清楚起见，我们还是采用此格式。</p><h3 id="What-Does-it-Look-Like"><a href="#What-Does-it-Look-Like" class="headerlink" title="What Does it Look Like?"></a>What Does it Look Like?</h3><blockquote><p>That covers the important points of this tutorial. When running, you get basically the same result as in Tutorial 3:</p></blockquote><p>这涵盖了本教程的要点。运行时，您将获得与教程 3 中基本相同的结果：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_Menu.PNG"></p><blockquote><p>Hopefully, this tutorial demonstrated:</p><ul><li>How to launch DirectX Raytracing work.</li><li>Write basic ray tracing HLSL shaders.</li><li>Use intrinsic structures and functions like <code>RayDesc</code>, <code>DispatchRaysIndex</code> and <code>TraceRay</code>.</li></ul></blockquote><p>希望本教程能够演示：</p><ul><li>如何启动 DirectX 光线追踪工作</li><li>编写基本的光线追踪 HLSL 着色器</li><li>使用内部结构和函数，如 <code>RayDesc</code>、<code>TraceRay</code> 和 <code>DispatchRaysIndex</code></li></ul><blockquote><p>When you are ready, continue on to <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor5/tutorial05.md.html">Tutorial 5</a>, where we build on our existing G-buffers to render ray traced ambient occlusion.</p></blockquote><p>准备就绪后，请继续学习 <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor5/tutorial05.md.html">教程 5</a>，我们在现有 G 缓冲区的基础上进行构建，以渲染光线追踪环境光遮蔽。</p><p>（译注：下面是一些补充展示：）</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_WorldNorml.PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tour4_WorldPosition.PNG"></p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/7dbe30e4.html" rel="bookmark">Blockwise Multi-Order Feature Regression for Real-Time Path Tracing Reconstruction</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/971404c0.html" rel="bookmark">Rendering Course by Wangningbei</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/5e049055.html" rel="prev" title="双城需要海克斯，而不是马克思"><i class="fa fa-chevron-left"></i> 双城需要海克斯，而不是马克思</a></div><div class="post-nav-item"><a href="/archives/4f70345c.html" rel="next" title="A Gentle Introduction to DirectX Raytracing 5">A Gentle Introduction to DirectX Raytracing 5 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Our-Basic-Ray-Tracing-Render-Pipeline"><span class="nav-number">2.</span> <span class="nav-text">Our Basic Ray Tracing Render Pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Creating-and-Launching-DirectX-Raytracing-Work"><span class="nav-number">3.</span> <span class="nav-text">Creating and Launching DirectX Raytracing Work</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Initializing-our-Ray-Traced-G-Buffer-Pass"><span class="nav-number">3.1.</span> <span class="nav-text">Initializing our Ray Traced G-Buffer Pass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Launching-Ray-Tracing-and-Sending-Data-to-HLSL"><span class="nav-number">3.2.</span> <span class="nav-text">Launching Ray Tracing and Sending Data to HLSL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-DirectX-Raytracing-HLSL-for-Our-G-Buffer"><span class="nav-number">4.</span> <span class="nav-text">The DirectX Raytracing HLSL for Our G-Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-Does-it-Look-Like"><span class="nav-number">5.</span> <span class="nav-text">What Does it Look Like?</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">289</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.5m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
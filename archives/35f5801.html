<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Tiny Rooms by        Mohamed Chahin            引言本文涵盖C++对象模型、关键机制、优良编程风格、内存管理，让读者从一无所知到具备大家风范，让读者对于C++有更深入的理解和体会，彻底掌握C++的面向对象与底层运作。"><meta property="og:type" content="article"><meta property="og:title" content="C++ Object Oriented Programming 1"><meta property="og:url" content="https://yousazoe.top/archives/35f5801.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Tiny Rooms by        Mohamed Chahin            引言本文涵盖C++对象模型、关键机制、优良编程风格、内存管理，让读者从一无所知到具备大家风范，让读者对于C++有更深入的理解和体会，彻底掌握C++的面向对象与底层运作。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/ca5130102453055.604679a91b53f.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818213320391.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818213458398.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818213821799.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818214402289.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818214714415.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818215553502.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818215839268.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818220815786.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818221239636.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818225043475.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818230323854.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819104812676.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819105356869.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819110311648.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819112635184.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819223501742.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820112641161.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820114127242.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820115448472.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820120656441.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820121445528.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820122153036.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820150325664.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820151406068.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820180144352.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823154606993.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823155709624.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823155945055.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823160324361.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823161157389.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823161904498.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823162315933.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823171952112.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823174517442.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823202715075.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823202315551.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823204405058.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823205054777.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823211315457.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823211332142.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823211354565.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823211438698.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823221339604.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823222655279.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223009420.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223122806.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223233857.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223344333.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223613722.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223638973.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823224806821.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823231045236.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823231109371.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824102505111.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824104900700.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824105322050.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824105344896.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824110132744.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824110722224.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824110745888.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824110813283.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824112649826.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824112813409.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824152028873.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824152927693.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824192045392.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824203840574.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210127597.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210150671.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210509039.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210537933.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210606058.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824214428079.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824215945677.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210826203102362.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906082747835.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906090711456.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906101042855.png"><meta property="article:published_time" content="2021-08-18T12:31:49.000Z"><meta property="article:modified_time" content="2022-08-07T08:03:35.959Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Cpp"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/ca5130102453055.604679a91b53f.png"><link rel="canonical" href="https://yousazoe.top/archives/35f5801.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>C++ Object Oriented Programming 1 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/35f5801.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++ Object Oriented Programming 1</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-08-18 20:31:49" itemprop="dateCreated datePublished" datetime="2021-08-18T20:31:49+08:00">2021-08-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E4%BE%AF%E6%8D%B7C-%E7%B3%BB%E5%88%97-HouJie-C-Series/" itemprop="url" rel="index"><span itemprop="name">侯捷C++系列 (HouJie C++ Series)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>22k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>41 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/ca5130102453055.604679a91b53f.png"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://www.behance.net/gallery/102453055/Tiny-Rooms">Tiny Rooms</a> by <a target="_blank" rel="noopener" href="https://www.behance.net/MChahin">Mohamed Chahin</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文涵盖C++对象模型、关键机制、优良编程风格、内存管理，让读者从一无所知到具备大家风范，让读者对于C++有更深入的理解和体会，彻底掌握C++的面向对象与底层运作。</p><span id="more"></span><h3 id="C-编程简介"><a href="#C-编程简介" class="headerlink" title="C++ 编程简介"></a>C++ 编程简介</h3><h4 id="你應具備的基礎"><a href="#你應具備的基礎" class="headerlink" title="你應具備的基礎"></a>你應具備的基礎</h4><ul><li><p>曾經學過某種 <strong>procedural language (C 語言最佳)</strong></p><ul><li>變量 <strong>(variables)</strong></li><li>類型 <strong>(types) :</strong> <strong>int, float, char, struct</strong> <strong>…</strong></li><li>作用域 <strong>(scope)</strong></li><li>循環 <strong>(loops) :</strong> <strong>while, for</strong>,</li><li>流程控制 : <strong>if-else, switch-case</strong></li></ul></li><li><p>知道一個程序需要編譯、連結才能被執行</p></li><li><p>知道如何編譯和連結(如何建立一個可運行程序)</p></li></ul><h4 id="我們的目標"><a href="#我們的目標" class="headerlink" title="我們的目標"></a>我們的目標</h4><ul><li><p>培養正規的、大氣的編程習慣</p></li><li><p><strong>Object Based (基於對象)</strong></p><p>以良好的方式編寫 <strong>C++ class</strong></p><ul><li><strong>class without pointer members</strong> <strong>— Complex</strong></li><li><strong>class with pointer members</strong> <strong>— String</strong></li></ul></li><li><p><strong>Object Oriented (面向對象)</strong></p><p>學習 <strong>Classes</strong> 之間的關係</p><ul><li>繼承 <strong>(inheritance)</strong></li><li>複合 <strong>(composition)</strong></li><li>委託 <strong>(delegation)</strong></li></ul></li></ul><h4 id="你將獲得的代碼"><a href="#你將獲得的代碼" class="headerlink" title="你將獲得的代碼"></a>你將獲得的代碼</h4><ul><li><p><strong>complex.h</strong></p></li><li><p><strong>complex-test.cpp</strong></p></li><li><p><strong>string.h</strong></p></li><li><p><strong>string-test.cpp</strong></p></li></ul><p>我们将实现复数和字符串的例子。</p><h4 id="C-的歷史"><a href="#C-的歷史" class="headerlink" title="C++ 的歷史"></a>C++ 的歷史</h4><ul><li>B 語言 (1969)</li><li>C 語言 (1972)</li><li>C++ 語言 (1983)<br>(new C -&gt; C with Class -&gt; C++)</li><li>Java 語言</li><li>C# 語言</li></ul><p>可以看到 C++ 是以 C 语言为基础的面向对象语言，是第一个被全世界广泛接受的语言。</p><h4 id="C-演化"><a href="#C-演化" class="headerlink" title="C++ 演化"></a>C++ 演化</h4><ul><li><strong>C++ 98 (1.0)</strong></li><li>C++ 03 (TR1, Technical Report 1)</li><li><strong>C++ 11 (2.0)</strong></li><li>C++ 14</li></ul><p>C++ 1983 年就有了，但正规化在 1998 年。上面加粗部分是大版本更新正规化，目前业界大部分程序员是 C++ 11/14（录课时是 2015 年，比较流行的是 C++ 98/11），出现了许多新的工具和特性。</p><p>我们学习 C++ 可以分为语言部分和标准库部分，基本所有的编程语言都是这样把这两个分开，使用标准库也是非常重要的事情，本文主要讨论语言部分。</p><h4 id="書目誌"><a href="#書目誌" class="headerlink" title="書目誌"></a>書目誌</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818213320391.png"></p><p>在语言部分这两本书可能是全世界卖得最好读者最多的 C++ 百科等级的书籍。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818213458398.png"></p><p>我们学了语言之后很希望得到专家的建议，这本书以调侃的方式告诉你什么该做，什么不该做，做什么样的动作会影响什么样的效率，这是专家给我们的意见。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818213821799.png"></p><p>刚才提到语言，C++ 除了语法本身另外还有标准库。标准库很庞大，我们需要好的书籍帮助学习，上面两本书可以帮助你。</p><h3 id="头文件与类的声明"><a href="#头文件与类的声明" class="headerlink" title="头文件与类的声明"></a>头文件与类的声明</h3><h4 id="C-vs-C-關於數據和函數"><a href="#C-vs-C-關於數據和函數" class="headerlink" title="C vs. C++, 關於數據和函數"></a>C vs. C++, 關於數據和函數</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818214402289.png"></p><p>在 C 语言设计程序的时候，我们会准备一些数据和函数（用于处理数据）。由于语言没有提供足够的关键字，这些数据一定是全局的，对后面有很大影响的。</p><p>面向对象语言如 C++ 的想法是把数据和处理数据的函数包在一起，通过创建对象来使用，不会混杂在一起。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818214714415.png"></p><p>对于 Class 分类可以区分为是否带指针，这会影响后面的写法，最有代表性的就是复数和字符串。</p><h4 id="Object-Based-基於對象-vs-Object-Oriented-面向對象"><a href="#Object-Based-基於對象-vs-Object-Oriented-面向對象" class="headerlink" title="Object Based (基於對象) vs. Object Oriented (面向對象)"></a>Object Based (基於對象) vs. Object Oriented (面向對象)</h4><p><strong>Object Based:</strong> 面對的是單一 <strong>class</strong> 的設計</p><p><strong>Object Oriented :</strong> 面對的是多重 <strong>classes</strong> 的設計， <strong>classes</strong> 和 <strong>classes</strong> 之間的關係</p><p>再次提醒，当一个类里包含指针时需要非常小心。</p><h4 id="C-programs-代碼基本形式"><a href="#C-programs-代碼基本形式" class="headerlink" title="C++ programs 代碼基本形式"></a>C++ programs 代碼基本形式</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818215553502.png"></p><p>在我们正式写程序之前来谈谈 C++ 代码基本形式，一般而言会包含头文件、主程序。</p><h4 id="Output-C-vs-C"><a href="#Output-C-vs-C" class="headerlink" title="Output, C++ vs. C"></a>Output, C++ vs. C</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818215839268.png"></p><p>关于 C 与 C++ 的输出方式。</p><h4 id="Header-頭文件-中的防衛式聲明"><a href="#Header-頭文件-中的防衛式聲明" class="headerlink" title="Header (頭文件) 中的防衛式聲明"></a>Header (頭文件) 中的防衛式聲明</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818220815786.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMPLEX_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMPLEX_</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>上面的防卫式声明告诉编译器一进来如果不曾经定义过 <code>_COMPLEX_</code>，那么就把它定义出来。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"complex.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    complex c2;</span><br><span class="line">    cout &lt;&lt; c1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c2 = c1 + <span class="number">5</span>;</span><br><span class="line">    c2 = <span class="number">7</span> + c1;</span><br><span class="line">    c2 = c1 + c2;</span><br><span class="line">    c2 += c1;</span><br><span class="line">    c2 += <span class="number">3</span>;</span><br><span class="line">    c2 = -c1;</span><br><span class="line">    cout &lt;&lt; (c1 == c2) &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; (c1 != c2) &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">conj</span>(c1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Header-頭文件-的佈局"><a href="#Header-頭文件-的佈局" class="headerlink" title="Header (頭文件) 的佈局"></a>Header (頭文件) 的佈局</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818221239636.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMPLEX_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMPLEX_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>;</span><br><span class="line"></span><br><span class="line">complex&amp; _doap1(complex* ths, <span class="type">const</span> complex&amp; r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span> {</span><br><span class="line">    </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="class-的聲明-declaration"><a href="#class-的聲明-declaration" class="headerlink" title="class 的聲明 (declaration)"></a>class 的聲明 (declaration)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818225043475.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span> {</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i  = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i) {}</span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> re; }</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> im; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> re, im;</span><br><span class="line">    <span class="keyword">friend</span> complex&amp; _doap1(complex* ths, <span class="type">const</span> complex&amp; r);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>函数可以在类中或者类外定义。</p><h4 id="class-template-模板-簡介"><a href="#class-template-模板-簡介" class="headerlink" title="class template (模板) 簡介"></a>class template (模板) 簡介</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818230323854.png"></p><p>前面的 <code>re</code>、<code>im</code> 都是 <code>double</code> 类型的，那么 <code>int</code>、<code>float</code> 类型呢？如果我们只修改这个地方却要创建三个类岂不是非常不方便？这就是模板发挥的时候。</p><p>我现在的需求是把实部虚部的类型不要写死成 <code>double</code>，将来用的时候再去定义：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+template&lt;typename T&gt;</span></span><br><span class="line">class complex {</span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   complex(T r = 0, T i  = 0)</span></span><br><span class="line">        : re(r), im(i) {}</span><br><span class="line">    complex&amp; operator += (const complex&amp;);</span><br><span class="line"><span class="addition">+   T real() const { return re; }</span></span><br><span class="line"><span class="addition">+   T imag() const { return im; }</span></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"><span class="addition">+   T re, im;</span></span><br><span class="line">    friend complex&amp; _doap1(complex* ths, const complex&amp; r);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c2;</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="inline-內聯-函數"><a href="#inline-內聯-函數" class="headerlink" title="inline (內聯)函數"></a>inline (內聯)函數</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819104812676.png"></p><p>如果你的函数属于 <code>inline</code> 会比较快，而 <code>inline</code> 只是给编译器的建议而已，是不是真正的 <code>inline</code> 还是由编译器决定。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span></span></span><br><span class="line"><span class="function"><span class="title">imag</span><span class="params">(<span class="type">const</span> complex&amp; x)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>补充：内联函数在编译时会把函数的代码副本放置在每个调用该函数的地方，因此对内联函数进行任何修改都需要重新修改，否则将会继续使用旧的函数。</p><h4 id="access-level-訪問級別"><a href="#access-level-訪問級別" class="headerlink" title="access level (訪問級別)"></a>access level (訪問級別)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819105356869.png"></p><p>数据需要封装起来，函数部分则区分为处理内部事务和提供给外部调用两种情况。</p><p>下面代码是创建对象，需要调用构造函数。我都想打印它的实部和虚部出来：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">complex c1(2, 1);</span><br><span class="line"><span class="deletion">-cout &lt;&lt; c1.re;</span></span><br><span class="line"><span class="deletion">-cout &lt;&lt; c1.im;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+cout &lt;&lt; c1.real();</span></span><br><span class="line"><span class="addition">+cout &lt;&lt; c1.imag();</span></span><br></pre></td></tr></tbody></table></figure><h4 id="constructor-ctor-構造函數"><a href="#constructor-ctor-構造函數" class="headerlink" title="constructor (ctor, 構造函數)"></a>constructor (ctor, 構造函數)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819110311648.png"></p><p>你想要创建一个对象构造函数会自动被调用，默认参数、初始化列表都是老生常谈的事情。</p><h4 id="ctor-構造函數-可以有很多個-–-overloading-重載"><a href="#ctor-構造函數-可以有很多個-–-overloading-重載" class="headerlink" title="ctor (構造函數) 可以有很多個 – overloading (重載)"></a>ctor (構造函數) 可以有很多個 – overloading (重載)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819112635184.png"></p><p>创建对象你可以有很多想法，所以构造函数可以有很多个，又被称为重载。在大部分例子中都可能看到一个以上的构造函数。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class complex {</span><br><span class="line">public:</span><br><span class="line"><span class="deletion">-   complex() : re(0), im(0) {}</span></span><br><span class="line">    complex(T r = 0, T i  = 0)</span><br><span class="line">            : re(r), im(i) {}</span><br><span class="line">    complex&amp; operator += (const complex&amp;);</span><br><span class="line">    T real() const { return re; }</span><br><span class="line">    T imag() const { return im; }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    T re, im;</span><br><span class="line">    friend complex&amp; _doap1(complex* ths, const complex&amp; r);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>同名函数可以有一个以上，既然同样名称那么将来调用的时候调用哪一个呢？其实函数实际名称编译器还是会区分开，编码为一个奇怪的东西，取决于编译器。</p><h3 id="参数传递与返回值"><a href="#参数传递与返回值" class="headerlink" title="参数传递与返回值"></a>参数传递与返回值</h3><h4 id="constructor-ctor-構造函數-被放在-private-區"><a href="#constructor-ctor-構造函數-被放在-private-區" class="headerlink" title="constructor (ctor, 構造函數) 被放在 private 區"></a>constructor (ctor, 構造函數) 被放在 private 區</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210819223501742.png"></p><p>如果构造函数放在私有区域，那么外界将无法调用构造函数，这个动作是不合理的。</p><h4 id="ctors-放在-private-區"><a href="#ctors-放在-private-區" class="headerlink" title="ctors 放在 private 區"></a>ctors 放在 private 區</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820112641161.png"></p><p>最简单的设计模式就是单例模式，它的写法就是刚刚我们说的把构造函数放在 <code>private</code> 里。 <code>static</code> 保证了这里的单一性，外界要这个类需通过 <code>getInstance()</code> 函数取得。</p><h4 id="const-member-functions-常量成員函數"><a href="#const-member-functions-常量成員函數" class="headerlink" title="const member functions (常量成員函數)"></a>const member functions (常量成員函數)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820114127242.png"></p><p>函数部分的 <code>const</code> 意味着不会改变数据内容，当你在想它的逻辑意义的时候就已经知道要不要加 <code>const</code>。</p><h4 id="參數傳遞-pass-by-value-vs-pass-by-reference-to-const"><a href="#參數傳遞-pass-by-value-vs-pass-by-reference-to-const" class="headerlink" title="參數傳遞:pass by value vs. pass by reference (to const)"></a>參數傳遞:pass by value vs. pass by reference (to const)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820115448472.png"></p><p>参数传递中值传递是整包传过来，如果这个参数很大在 C 语言中可以使用指针，这里的传引用就相当于传指针，但形式上更为优美（其实是语法糖），建议最好所有的参数传递使用引用。</p><h4 id="返回值傳遞-return-by-value-vs-return-by-reference-to-const"><a href="#返回值傳遞-return-by-value-vs-return-by-reference-to-const" class="headerlink" title="返回值傳遞:return by value vs. return by reference (to const)"></a>返回值傳遞:return by value vs. return by reference (to const)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820120656441.png"></p><p>引用主要就是用来做参数传递和返回值，选择 C++ 主要就是为了效率，结论是返回值也尽量使用引用。</p><h4 id="friend-友元"><a href="#friend-友元" class="headerlink" title="friend (友元)"></a>friend (友元)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820121445528.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; _doapl(complex* ths, <span class="type">const</span> complex&amp; r) {</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>友元就相当于现实生活中的朋友，可以来拿类里封装的数据。虽然我把实部虚部放在 <code>private</code> 就是不想让别人随意拿取，但对于一些函数它是我的朋友，我可以网开一面。</p><p>需要注意的是 C++ 强调封装性，而友元无疑是打破这种特性，需要谨慎使用。</p><h4 id="相同-class-的各個-objects-互為-friends-友元"><a href="#相同-class-的各個-objects-互為-friends-友元" class="headerlink" title="相同 class 的各個 objects 互為 friends (友元)"></a>相同 class 的各個 objects 互為 friends (友元)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820122153036.png"></p><p>该 <code>func()</code> 接收另一个复数，它直接取得了传进来复数的实部和虚部。相同 class 的各個 objects 互為 friends (友元)。</p><h4 id="class-body-外的各種定義-definitions"><a href="#class-body-外的各種定義-definitions" class="headerlink" title="class body 外的各種定義 (definitions)"></a>class body 外的各種定義 (definitions)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820150325664.png"></p><ul><li>什麼情況下可以 <strong>pass by reference</strong></li><li>什麼情況下可以 <strong>return by reference</strong></li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; _doapl(complex* ths, <span class="type">const</span> complex&amp; r) {</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp; complex::<span class="keyword">operator</span>+=(<span class="type">const</span> complex&amp; r) {</span><br><span class="line">    <span class="keyword">return</span> _doapl(<span class="keyword">this</span>, r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="操作符重载与临时对象"><a href="#操作符重载与临时对象" class="headerlink" title="操作符重载与临时对象"></a>操作符重载与临时对象</h3><h4 id="operator-overloading-操作符重載-1-成員函數-this"><a href="#operator-overloading-操作符重載-1-成員函數-this" class="headerlink" title="operator overloading (操作符重載-1, 成員函數) this"></a>operator overloading (操作符重載-1, 成員函數) this</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820151406068.png"></p><p>操作符重载是 C++ 很重要的特性。在其他语言里你要对一个东西做操作一般会涉及函数，事实上在 C++ 里面操作符就是一种函数，并且可以自己定义。</p><h4 id="return-by-reference-語法分析"><a href="#return-by-reference-語法分析" class="headerlink" title="return by reference 語法分析"></a>return by reference 語法分析</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210820180144352.png"></p><p>傳遞者無需知道接收者是以 reference 形式接收。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; _doapl(complex* ths, <span class="type">const</span> complex&amp; r) {</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里函数头是引用 <code>complex&amp;</code>，返回的是指针内容 <code>*ths</code>。这种写法是正确的，虽然你返回的是内容，但接收端如何接收你不必在意，这也是引用的优点。</p><h4 id="class-body-之外的各種定義-definitions"><a href="#class-body-之外的各種定義-definitions" class="headerlink" title="class body 之外的各種定義 (definitions)"></a>class body 之外的各種定義 (definitions)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823154606993.png"></p><p>这两个函数没有带命名空间，所以是全局函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">imag</span><span class="params">(<span class="type">const</span> complex&amp; x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">real</span><span class="params">(<span class="type">const</span> complex&amp; x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">real</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="operator-overloading-操作符重載-2-非成員函數-無-this"><a href="#operator-overloading-操作符重載-2-非成員函數-無-this" class="headerlink" title="operator overloading (操作符重載-2, 非成員函數) (無 this)"></a>operator overloading (操作符重載-2, 非成員函數) (無 this)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823155709624.png"></p><p>為了對付 <strong>client</strong> 的三種可能用法，這兒對應開發三個函數：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x) + <span class="built_in">real</span>(y),</span><br><span class="line">                   <span class="built_in">imag</span>(x) + <span class="built_in">imag</span>(y));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x) + y, <span class="built_in">imag</span>(x));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">double</span> x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(x + <span class="built_in">real</span>(y), <span class="built_in">imag</span>(y));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="temp-object（临时对象）typename"><a href="#temp-object（临时对象）typename" class="headerlink" title="temp object（临时对象）typename();"></a>temp object（临时对象）typename();</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823155945055.png"></p><p>为什么这些函数不返回引用呢？因為，它們返回的必定是個 local object.</p><h4 id="class-body-之外的各種定義-definitions-1"><a href="#class-body-之外的各種定義-definitions-1" class="headerlink" title="class body 之外的各種定義 (definitions)"></a>class body 之外的各種定義 (definitions)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823160324361.png"></p><p>這個函數絕不可 <strong>return by reference</strong>， 因為其返回的必定是個 <strong>local object</strong>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">const</span> complex&amp; x) {</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>- (<span class="type">const</span> complex&amp; x) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(-<span class="built_in">real</span>(x), -<span class="built_in">imag</span>(x));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="operator-overloading-操作符重載-非成員函數"><a href="#operator-overloading-操作符重載-非成員函數" class="headerlink" title="operator overloading (操作符重載), 非成員函數"></a>operator overloading (操作符重載), 非成員函數</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823161157389.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real</span>(x) == <span class="built_in">real</span>(y)</span><br><span class="line">        &amp;&amp; <span class="built_in">imag</span>(x) == <span class="built_in">imag</span>(y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real</span>(x) == y &amp;&amp; <span class="built_in">imag</span>(x) == <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">double</span> x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> x == <span class="built_in">real</span>(y) &amp;&amp; <span class="built_in">imag</span>(y) == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823161904498.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real</span>(x) != <span class="built_in">real</span>(y)</span><br><span class="line">        || <span class="built_in">imag</span>(x) != <span class="built_in">imag</span>(y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real</span>(x) != y || <span class="built_in">imag</span>(x) != <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">double</span> x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> x != <span class="built_in">real</span>(y) || <span class="built_in">imag</span>(y) != <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823162315933.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> complex <span class="title">conj</span><span class="params">(<span class="type">const</span> complex&amp; x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x), -<span class="built_in">imag</span>(x));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; os, <span class="type">const</span> complex&amp; x) {</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">'('</span> &lt;&lt; <span class="built_in">real</span>(x) &lt;&lt; <span class="string">','</span></span><br><span class="line">              &lt;&lt; <span class="built_in">imag</span>(x) &lt;&lt; <span class="string">')'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于 <code>&lt;&lt;</code> 操作符你只能选择全局的写法。</p><p>这里需要声明 <code>std::</code> 以区别之前的 <code>ostream</code>，如果按照之前的写法会出错：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#ifndef _COMPLEX_</span><br><span class="line">#define _COMPLEX_</span><br><span class="line"></span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">class complex;</span><br><span class="line"><span class="deletion">-class ostream;</span></span><br><span class="line"></span><br><span class="line">complex&amp; _doapl(complex* ths, const complex&amp; r);</span><br><span class="line"></span><br><span class="line">class complex {</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"><span class="addition">+std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const complex&amp; x) {</span></span><br><span class="line">    return os &lt;&lt; '(' &lt;&lt; real(x) &lt;&lt; ','</span><br><span class="line">              &lt;&lt; imag(x) &lt;&lt; 'i' &lt;&lt; ')';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#endif //_COMPLEX_</span><br></pre></td></tr></tbody></table></figure><h3 id="Complex-类实现过程"><a href="#Complex-类实现过程" class="headerlink" title="Complex 类实现过程"></a>Complex 类实现过程</h3><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"complex.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    complex c2;</span><br><span class="line">    cout &lt;&lt; c1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c2 = c1 + <span class="number">5</span>;</span><br><span class="line">    c2 = <span class="number">7</span> + c1;</span><br><span class="line">    c2 = c1 + c2;</span><br><span class="line">    c2 += c1;</span><br><span class="line">    c2 += <span class="number">3</span>;</span><br><span class="line">    c2 = -c1;</span><br><span class="line">    cout &lt;&lt; (c1 == c2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (c1 != c2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">conj</span>(c1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMPLEX_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMPLEX_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>;</span><br><span class="line"></span><br><span class="line">complex&amp; _doapl(complex* ths, <span class="type">const</span> complex&amp; r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i  = <span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i) {}</span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> re; }</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> im; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> re, im;</span><br><span class="line">    <span class="keyword">friend</span> complex&amp; _doapl(complex* ths, <span class="type">const</span> complex&amp; r);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp; complex::<span class="keyword">operator</span>+=(<span class="type">const</span> complex&amp; r) {</span><br><span class="line">    <span class="keyword">return</span> _doapl(<span class="keyword">this</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">imag</span><span class="params">(<span class="type">const</span> complex&amp; x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">real</span><span class="params">(<span class="type">const</span> complex&amp; x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">real</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp; _doapl(complex* ths, <span class="type">const</span> complex&amp; r) {</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x) + <span class="built_in">real</span>(y),</span><br><span class="line">                   <span class="built_in">imag</span>(x) + <span class="built_in">imag</span>(y));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x) + y, <span class="built_in">imag</span>(x));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">double</span> x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(x + <span class="built_in">real</span>(y), <span class="built_in">imag</span>(y));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">const</span> complex&amp; x) {</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>- (<span class="type">const</span> complex&amp; x) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(-<span class="built_in">real</span>(x), -<span class="built_in">imag</span>(x));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real</span>(x) == <span class="built_in">real</span>(y)</span><br><span class="line">        &amp;&amp; <span class="built_in">imag</span>(x) == <span class="built_in">imag</span>(y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real</span>(x) == y &amp;&amp; <span class="built_in">imag</span>(x) == <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">double</span> x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> x == <span class="built_in">real</span>(y) &amp;&amp; <span class="built_in">imag</span>(y) == <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real</span>(x) != <span class="built_in">real</span>(y)</span><br><span class="line">        || <span class="built_in">imag</span>(x) != <span class="built_in">imag</span>(y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> complex&amp; x, <span class="type">double</span> y) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real</span>(x) != y || <span class="built_in">imag</span>(x) != <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">double</span> x, <span class="type">const</span> complex&amp; y) {</span><br><span class="line">    <span class="keyword">return</span> x != <span class="built_in">real</span>(y) || <span class="built_in">imag</span>(y) != <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> complex <span class="title">conj</span><span class="params">(<span class="type">const</span> complex&amp; x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x), -<span class="built_in">imag</span>(x));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os, <span class="type">const</span> complex&amp; x) {</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">'('</span> &lt;&lt; <span class="built_in">real</span>(x) &lt;&lt; <span class="string">','</span></span><br><span class="line">              &lt;&lt; <span class="built_in">imag</span>(x) &lt;&lt; <span class="string">'i'</span> &lt;&lt; <span class="string">')'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//_COMPLEX_</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="拷贝构造，拷贝赋值与析构函数"><a href="#拷贝构造，拷贝赋值与析构函数" class="headerlink" title="拷贝构造，拷贝赋值与析构函数"></a>拷贝构造，拷贝赋值与析构函数</h3><h4 id="String-class"><a href="#String-class" class="headerlink" title="String class"></a>String class</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823171952112.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">s2</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;</span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是这里有两个拷贝动作：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;</span><br><span class="line">s3 = s2;</span><br></pre></td></tr></tbody></table></figure><p>分别是拷贝构造和拷贝赋值。</p><h4 id="Big-Three-三個特殊函數"><a href="#Big-Three-三個特殊函數" class="headerlink" title="Big Three, 三個特殊函數"></a>Big Three, 三個特殊函數</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823174517442.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str);</span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_data; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>一般而言字符串都会这样设计，让字符串里有一个指针 <code>m_data</code>，在需要内存的时候才去创建另外一个空间创建字符。这是因为字符串的东西有大有小，有时候是空字符串，所以这样的动态设计比较好，而不要在字符串里面放一个数组。</p><h4 id="ctor-和-dtor-構造函數-和-析構函數"><a href="#ctor-和-dtor-構造函數-和-析構函數" class="headerlink" title="ctor 和 dtor (構造函數 和 析構函數)"></a>ctor 和 dtor (構造函數 和 析構函數)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823202715075.png"></p><p>字符串长度有两种设计思路，一种是不知道多长，但最后面有一个标识符 <code>\0</code>；另外一种是后面没有标识符，但前面多一个长度的整数。如果你的对象带有指针，那么大概率需要这样动态分配，那么在析构函数需要将你动态分配的内存释放掉。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cstr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cstr) {</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> String::~<span class="built_in">String</span>() {</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="class-with-pointer-members-必須有-copy-ctor-和-copy-op-x3D"><a href="#class-with-pointer-members-必須有-copy-ctor-和-copy-op-x3D" class="headerlink" title="class with pointer members 必須有 copy ctor 和 copy op="></a>class with pointer members 必須有 copy ctor 和 copy op=</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823202315551.png"></p><p>如果成员变量有指针，那么必须包含拷贝构造和拷贝赋值。如果没有自己写，编译器默认做法会造成内存泄漏，上图所示虽然 <code>b</code> 和 <code>a</code> 的内容相同，但原有的 <code>World\0</code> 找不到变成孤儿了，并且两个指针指向同一个区域这个操作本身同样非常危险。</p><h4 id="copy-ctor-拷貝構造函數"><a href="#copy-ctor-拷貝構造函數" class="headerlink" title="copy ctor (拷貝構造函數)"></a>copy ctor (拷貝構造函數)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823204405058.png"></p><p>我们来看看什么叫深拷贝。上面是一个构造函数，拷贝则是因为参数是它本身，好比石头拷贝给石头，人拷贝给人，猪拷贝给猪，所以这个叫拷贝构造函数。拷贝构造应该创造出足够的空间来放置数据。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="type">const</span> String &amp;str)</span> </span>{</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果没有写这个函数，编译器给的默认版本只会拷贝指针，也称之为浅拷贝，这是我们要避免的。</p><h4 id="copy-assignment-operator-拷貝賦值函數"><a href="#copy-assignment-operator-拷貝賦值函數" class="headerlink" title="copy assignment operator (拷貝賦值函數)"></a>copy assignment operator (拷貝賦值函數)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823205054777.png"></p><p>拷贝赋值这个概念要把右手的东西赋值或拷贝给左手，假设左右本来都有东西：</p><ol><li>先把左边清空</li><li>创建出跟右边一样大的空间</li><li>再把右边赋值到左边</li></ol><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823211315457.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823211332142.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823211354565.png"></p><h4 id="一定要在-operator-x3D-中檢查是否-self-assignment"><a href="#一定要在-operator-x3D-中檢查是否-self-assignment" class="headerlink" title="一定要在 operator= 中檢查是否 self assignment"></a>一定要在 operator= 中檢查是否 self assignment</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823211438698.png"></p><p>注意自己赋值给自己的情况，檢測自我賦值 (self assignment)。</p><h3 id="堆栈与内存管理"><a href="#堆栈与内存管理" class="headerlink" title="堆栈与内存管理"></a>堆栈与内存管理</h3><h4 id="output-函數"><a href="#output-函數" class="headerlink" title="output 函數"></a>output 函數</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823221339604.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os, <span class="type">const</span> String&amp; str) {</span><br><span class="line">    os &lt;&lt; str.<span class="built_in">get_c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="所謂-stack-棧-所謂-heap-堆"><a href="#所謂-stack-棧-所謂-heap-堆" class="headerlink" title="所謂 stack (棧), 所謂 heap (堆)"></a>所謂 stack (棧), 所謂 heap (堆)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823222655279.png"></p><p><strong>Stack</strong>，是存在於某作用域 <strong>(scope)</strong> 的一塊內存空間 **(memory space)**。例如當你調用函數，函數本身即會形成一個 <strong>stack</strong> 用來放置它所接收的參數，以及返回地址。</p><p>在函數本體 <strong>(function body)</strong> 內聲明的任何變量， 其所使用的內存塊都取自上述 <strong>stack</strong>。</p><p><strong>Heap</strong>，或謂 <strong>system heap</strong>，是指由操作系統提供的 一塊 <strong>global</strong> 內存空間，程序可動態分配 <strong>(dynamic allocated)</strong> 從某中獲得若干區塊 **(blocks)**。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {...};</span><br><span class="line">...</span><br><span class="line">{</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    Complex* p = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">3</span>);</span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><h4 id="stack-objects-的生命期"><a href="#stack-objects-的生命期" class="headerlink" title="stack objects 的生命期"></a>stack objects 的生命期</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223009420.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> { ... };</span><br><span class="line">...</span><br><span class="line">{</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>c1</strong> 便是所謂 stack object，其生命在作用域 (scope) 結束之際結束。 這種作用域內的 object，又稱為 auto object，因為它會被「自動」清理。</p><h4 id="static-local-objects-的生命期"><a href="#static-local-objects-的生命期" class="headerlink" title="static local objects 的生命期"></a>static local objects 的生命期</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223122806.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {...};</span><br><span class="line">...</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">static</span> Complex <span class="title">c2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure><p><strong>c2</strong> 便是所謂 static object，其生命在作用域 (scope) 結束之後仍然存在，直到整個程序結束。</p><h4 id="global-objects-的生命期"><a href="#global-objects-的生命期" class="headerlink" title="global objects 的生命期"></a>global objects 的生命期</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223233857.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {...};</span><br><span class="line">...</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>c3</strong> 便是所謂 global object，其生命在整個程序結束之後才結束。你也可以把它視為一種 static object，其作用域 是「整個程序」。</p><h4 id="heap-objects-的生命期"><a href="#heap-objects-的生命期" class="headerlink" title="heap objects 的生命期"></a>heap objects 的生命期</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223344333.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {...};</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">{</span><br><span class="line">    Complex* p = <span class="keyword">new</span> Complex;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><p><strong>P</strong> 所指的便是 heap object，其生命 在它被 <strong>deleted</strong> 之際結束。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {...};</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">	Complex* p = <span class="keyword">new</span> Complex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上出現內存洩漏 (memory leak)， 因為當作用域結束，<strong>p</strong> 所指的 heap object 仍然存在，但指針 <strong>p</strong> 的生命卻結束了，作用域之外再也看不到 <strong>p</strong> (也就沒機會 <strong>delete p</strong>)</p><h4 id="new-先分配-memory-再調用-ctor"><a href="#new-先分配-memory-再調用-ctor" class="headerlink" title="new:先分配 memory, 再調用 ctor"></a>new:先分配 memory, 再調用 ctor</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223613722.png"></p><p>你的 C++ 语法书籍会查到 <code>new</code> 任何一个东西先得到一片空间，然后调用构造函数。我们把这样的事情结合起来，<code>new</code> 被分解为三个动作：</p><ol><li><code>operator new()</code> 函数调用 <code>malloc()</code> 分配内存</li><li><code>static_cast&lt;&gt;</code> 把第一步得到的指针进行类型转换</li><li>通过这个指针调用构造函数 <code>Complex()</code></li></ol><h4 id="delete-先調用-dtor-再釋放-memory"><a href="#delete-先調用-dtor-再釋放-memory" class="headerlink" title="delete:先調用 dtor, 再釋放 memory"></a>delete:先調用 dtor, 再釋放 memory</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823223638973.png"></p><p>你的语法书还会告诉你，<code>delete</code> 先调用析构函数再释放内存。这个次序跟之前的 <code>new</code> 刚刚相反，这里 <code>delete</code> 被转化为两个动作：</p><ol><li>首先调用析构函数 <code>~Complex()</code></li><li><code>operator delete()</code> 函数调用 <code>free()</code> 释放内存</li></ol><h4 id="動態分配所得的內存塊-memory-block-in-VC"><a href="#動態分配所得的內存塊-memory-block-in-VC" class="headerlink" title="動態分配所得的內存塊 (memory block), in VC"></a>動態分配所得的內存塊 (memory block), in VC</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823224806821.png"></p><p>如果你分配一个复数，刚刚算过是 8 个字节（2 个 <code>double</code>），体现在图上就是最左边的亮绿色区块。那么你只得到 8 个字节码？在调试模式下，你会得到上面 4 * 8 = 32 个字节，下面还会多得到一个 4 字节，体现在图上就是最左边的灰色区块。除此之外，你还会得到上下两块红色区块 Cookie 4 * 2 = 8 个字节。由于是在 VC 环境下区块分配必须为 16 的倍数，而 52 不是，所以还要填补青绿色区域 pad 4 * 3 = 12：<br>$$<br>Compelex(4 \times 2) + Debug(4 \times 8 + 4) + Cookie(4 \times 2) + Pad(4 \times 3) = 64<br>$$<br>对于初学者一般使用 Release 模式，保留 <code>Complex</code> 和 Cookie 再次计算会得到 4 * 2 + 4 * 2 = 16，刚好满足 16 的倍数不需要添加 pad。</p><p>上下 Cookie 的作用在于帮助系统回收内存，如果你只给一个指针系统怎么知道该回收多少呢？所以必须记录这个长度。观察 Cookie 的 00000041，4 为 64/16 的倍数，而 1 则代表这块内存已经被分配出去，相当于一个标识符。</p><p>对于字符串只内含一个指针，指针大小为 4 字节，在调试模式下加上灰色区块 4 * 8 + 4 = 36 字节，上下 Cookie 为 4 * 2 = 8 个字节。最后得到 48 字节正好是 16 的倍数，所以不需要填补 pad 区域。同理在 Release 模式下 12 不满足 16 的倍数，所以需要填补 4 字节到达 16 进位。</p><p>当然你不知道这些事情不会对你的编程有立即的影响，但是知道它我们更能够彻底掌握。</p><h4 id="動態分配所得的-array"><a href="#動態分配所得的-array" class="headerlink" title="動態分配所得的 array"></a>動態分配所得的 array</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823231045236.png"></p><p>如果我们分配的是数组呢？假设我要分配三个复数，那么就是 6 个 <code>double</code> 4 * 6 = 24 字节，调试模式下增加上下 4 * 8 + 4 字节，加上上下 Cookie 4 * 2 = 8，最后 VC 的做法会分配一块空间记录数组的大小为 3。</p><p>同理可以推导字符串的内存分配。</p><h4 id="array-new-一定要搭配-array-delete"><a href="#array-new-一定要搭配-array-delete" class="headerlink" title="array new 一定要搭配 array delete"></a>array new 一定要搭配 array delete</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210823231109371.png"></p><p>经过刚才的内存分配，我们可以看到 <code>delete[]</code> 的重要性，只有把 <code>[]</code> 写出来编译器才知道下面还有数组，而析构函数调用次数的差别会造成内存泄漏。</p><h3 id="String-类实现过程"><a href="#String-类实现过程" class="headerlink" title="String 类实现过程"></a>String 类实现过程</h3><h4 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    String s1;</span><br><span class="line">    <span class="function">String <span class="title">s2</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;</span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYSTRING_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MYSTRING_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str);</span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_data; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cstr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cstr) {</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> String::~<span class="built_in">String</span>() {</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="type">const</span> String&amp; str)</span> </span>{</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os, <span class="type">const</span> String&amp; str) {</span><br><span class="line">    os &lt;&lt; str.<span class="built_in">get_c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//_MYSTRING_</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="类模板与函数模板"><a href="#类模板与函数模板" class="headerlink" title="类模板与函数模板"></a>类模板与函数模板</h3><h4 id="進一步補充-static"><a href="#進一步補充-static" class="headerlink" title="進一步補充:static"></a>進一步補充:static</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824102505111.png"></p><p>对于非静态成员函数，面对不同的参数值 <code>c1</code>、<code>c2</code> 和 <code>c3</code> 需要使用 <code>this pointer</code>。而对于静态的数据永远只有一份，比如设计一个银行账户类，有 100 个人来开户，所以你需要创建 100 个户头出来：<code>c1</code>、<code>c2</code>……<code>c100</code>，但有一样东西不应该和账户绑定，就是利率，100 个人用的都是同一份利率，这种情况下就不应该把利率设计为普通的成员数据，而应该设计为只有一份的静态数据。</p><p>那什么时候使用静态函数呢？静态函数跟一般成员函数的区别在于静态函数没有 <code>this pointer</code>，可见它不能像一般成员函数一样去访问、存储和处理对象里的东西，显然只能处理静态数据。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824104900700.png"></p><p>調用 static 函數的方式有二:</p><ol><li>通過 object 調用</li><li>通過 class name 調用</li></ol><h4 id="進一步補充-把-ctors-放在-private-區"><a href="#進一步補充-把-ctors-放在-private-區" class="headerlink" title="進一步補充: 把 ctors 放在 private 區"></a>進一步補充: 把 ctors 放在 private 區</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824105322050.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">setup</span>() {...}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先前提过我们写一个类只希望产生一个对象，这里静态就发挥出作用。上面的代码可以看到 <code>a</code> 是唯一的，而只有通过调用静态函数 <code>getInstance()</code> 才能获取 <code>a</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824105344896.png"></p><p>这是设计模式中的单例模式，很容易通过静态实现出来。</p><h4 id="進一步補充-cout"><a href="#進一步補充-cout" class="headerlink" title="進一步補充:cout"></a>進一步補充:cout</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824110132744.png"></p><p>在前面为了验证我们会用 <code>cout</code> 把东西打印出来，也许你会疑惑为什么 <code>cout</code> 可以接收各式各样的数据，你可以把整数、浮点数、字符串都给它打印出来。</p><p>如我们所想，它做了很多操作符重载，所以才能接收如此之多的数据。</p><h4 id="進一步補充-class-template-類模板"><a href="#進一步補充-class-template-類模板" class="headerlink" title="進一步補充:class template, 類模板"></a>進一步補充:class template, 類模板</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824110722224.png"></p><h4 id="進一步補充-function-template-函數模板"><a href="#進一步補充-function-template-函數模板" class="headerlink" title="進一步補充:function template, 函數模板"></a>進一步補充:function template, 函數模板</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824110745888.png"></p><p>函数模板不必指出使用类型，编译器会做实参推导得到一个函数版本，引數推導的結果，<code>T</code> 為 <code>stone</code>，於是調用 <code>stone::operator&lt;</code>。</p><h4 id="進一步補充-namespace"><a href="#進一步補充-namespace" class="headerlink" title="進一步補充:namespace"></a>進一步補充:namespace</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824110813283.png"></p><h3 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h3><h4 id="Object-Oriented-Programming-Object-Oriented-Design-OOP-OOD"><a href="#Object-Oriented-Programming-Object-Oriented-Design-OOP-OOD" class="headerlink" title="Object Oriented Programming, Object Oriented Design OOP, OOD"></a>Object Oriented Programming, Object Oriented Design OOP, OOD</h4><ul><li><strong>Inheritance</strong> (繼承)</li><li><strong>Composition</strong> (複合)</li><li><strong>Delegation</strong> (委託)</li></ul><p>对于复数或字符串一般不会和其他类发生关系，但一些比较复杂的情况你就需要让类和类之间产生关系，这就叫面向对象编程思想。</p><h4 id="Composition-複合-表示-has-a"><a href="#Composition-複合-表示-has-a" class="headerlink" title="Composition (複合), 表示 has-a"></a>Composition (複合), 表示 has-a</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824112649826.png"></p><p>上面是标准库的队列实现，默认 <code>Sequence</code> 为 <code>deque&lt;T&gt;</code> 类型。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824112813409.png"></p><p>我里面有另外一种东西，称之为复合，表示的是“has a”的关系。很显然这里的 <code>deque</code> 功能非常强大，<code>queue</code> 在其基础上调用操作函数即可。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824152028873.png"></p><p>现在我们从内存的角度来看一看。<code>Itr</code> 有 4 个指针 4 * 4 = 16 个字节，而 <code>deque</code> 则有 2 个 <code>Itr</code> 16 * 2 = 32 字节，加上多的 1 个指针 1 个非负整型 4 + 4 = 8，最后得到 40 字节，而 <code>queue</code> 本身只有一个 <code>deque</code>，所以大小也是 40。</p><h4 id="Composition-複合-關係下的構造和析構"><a href="#Composition-複合-關係下的構造和析構" class="headerlink" title="Composition (複合) 關係下的構造和析構"></a>Composition (複合) 關係下的構造和析構</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824152927693.png"></p><p><strong>構造由內而外</strong></p><p><strong>Container</strong> 的構造函數首先調用 <strong>Component</strong> 的 <strong>default</strong> 構造函數，然後才執行自己。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>(...): <span class="built_in">Component</span>() {...};</span><br></pre></td></tr></tbody></table></figure><p><strong>析構由外而內</strong></p><p><strong>Container</strong> 的析構函數首先執行自己，然後才調用 <strong>Component</strong> 的析構函數。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Container::~<span class="built_in">Container</span>(...){ ~<span class="built_in">Component</span>() };</span><br></pre></td></tr></tbody></table></figure><h4 id="Delegation-委託-Composition-by-reference"><a href="#Delegation-委託-Composition-by-reference" class="headerlink" title="Delegation (委託). Composition by reference."></a>Delegation (委託). Composition by reference.</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824192045392.png"></p><p>可以看到 <code>String</code> 拥有一个 <code>StringRep</code> 的指针，我们称之为 Delegation (委託)。这一种 pimpl 写法非常有名，字符串的设计不在左边写出来，左边只是对外的接口，设计的实现都在右边写出来，当左边需要动作的时候都调用右边的类的函数来服务。可以看到 Pimpl 拥有如下优点：</p><ul><li><strong>减少依赖项</strong>（降低耦合性）：其一减少原类不必要的头文件的依赖，加速编译；其二对Impl类进行修改，无需重新编译原类</li><li><strong>接口和实现的分离</strong>（隐藏了类的实现）：私有成员完全可以隐藏在共有接口之外，给用户一个间接明了的使用接口，尤其适合闭源API设计</li><li><strong>可使用惰性分配技术</strong>：类的某部分实现可以写成按需分配或者实际使用时再分配，从而节省资源</li></ul><p>Pimpl也拥有一些缺点：</p><ul><li>每个类需要占用小小额外的指针内存</li><li>每个类每次访问具体实现时都要多一个间接指针操作的开销，并且再使用、阅读和调试上都可能有所不便。</li></ul><p>可以说，在性能/内存要求不敏感（非极端底层）的领域，Pimpl 技术可以有相当不错的发挥和作用。</p><h4 id="Inheritance-繼承-表示-is-a"><a href="#Inheritance-繼承-表示-is-a" class="headerlink" title="Inheritance (繼承), 表示 is-a"></a>Inheritance (繼承), 表示 is-a</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824203840574.png"></p><p>使用 <code>public</code> Inheritance (繼承) 代表“is a”的关系。</p><h4 id="Inheritance-繼承-關係下的構造和析構"><a href="#Inheritance-繼承-關係下的構造和析構" class="headerlink" title="Inheritance (繼承) 關係下的構造和析構"></a>Inheritance (繼承) 關係下的構造和析構</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210127597.png"></p><p><strong>構造由內而外</strong></p><p><strong>Derived</strong> 的構造函數首先調用 <strong>Base</strong> 的 <strong>default</strong> 構造函數， 然後才執行自己。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>(...): <span class="built_in">Base</span>() {...};</span><br></pre></td></tr></tbody></table></figure><p><strong>析構由外而內</strong></p><p><strong>Derived</strong> 的析構函數首先執行自己，然後才調用 <strong>Base</strong> 的析構函數。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Derived::~<span class="built_in">Derived</span>(...){ ... ~<span class="built_in">Base</span>() };</span><br></pre></td></tr></tbody></table></figure><h3 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h3><h4 id="Inheritance-繼承-with-virtual-functions-虛函數"><a href="#Inheritance-繼承-with-virtual-functions-虛函數" class="headerlink" title="Inheritance (繼承) with virtual functions (虛函數)"></a>Inheritance (繼承) with virtual functions (虛函數)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210150671.png"></p><p><strong>non-virtual</strong> 函數:你不希望 <strong>derived class</strong> 重新定義 <strong>(override,</strong> 覆寫**)** 它。</p><p><strong>virtual</strong> 函數:你希望 <strong>derived class</strong> 重新定義 <strong>(override,</strong> 覆寫**)** 它，且你對它已有默認定義。</p><p><strong>pure virtual</strong> 函數:你希望 <strong>derived class</strong> 一定要重新定義 <strong>(override</strong> 覆寫**)** 它，你對它沒有默認定義。</p><h4 id="Inheritance-繼承-with-virtual"><a href="#Inheritance-繼承-with-virtual" class="headerlink" title="Inheritance (繼承) with virtual"></a>Inheritance (繼承) with virtual</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210509039.png"></p><p>这里我使用 PPT 在菜单栏选择打开文件，弹出的窗口有文件名搜索栏。如果我输入一个文件名，它应该检查文件名是否正确，然后到硬盘里找这个文件在不在，最后把这个文件打开。</p><p>在这个流程中除了最后打开文件由于格式不同可能读取存在问题，其他步骤都可以提前写好。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210537933.png"></p><p>在这个例子中读取文件 <code>Serialize()</code> 是没办法提前写好的，所以我们需要将其设置为纯虚函数或者包含定义的虚函数。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824210606058.png"></p><h4 id="Inheritance-Composition-關係下的構造和析構"><a href="#Inheritance-Composition-關係下的構造和析構" class="headerlink" title="Inheritance+Composition 關係下的構造和析構"></a>Inheritance+Composition 關係下的構造和析構</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824214428079.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210824215945677.png"></p><p><strong>構造由內而外</strong></p><p><strong>Derived</strong> 的構造函數首先調用 <strong>Base</strong> 的 <strong>default</strong> 構造函數， 然後調用 <strong>Component</strong> 的 <strong>default</strong> 構造函數， 然後才執行自己。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>(...): <span class="built_in">Base</span>(),<span class="built_in">Component</span>() { ... };</span><br></pre></td></tr></tbody></table></figure><p><strong>析構由外而內</strong></p><p><strong>Derived</strong> 的析構函數首先執行自己， 然後調用 <strong>Component</strong> 的 析構函數，然後調用 <strong>Base</strong> 的析構函數。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Derived::~<span class="built_in">Derived</span>(...){ ... ~<span class="built_in">Component</span>(), ~<span class="built_in">Base</span>() };</span><br></pre></td></tr></tbody></table></figure><h3 id="委托相关设计"><a href="#委托相关设计" class="headerlink" title="委托相关设计"></a>委托相关设计</h3><h4 id="Delegation-委託-Inheritance-繼承"><a href="#Delegation-委託-Inheritance-繼承" class="headerlink" title="Delegation (委託) + Inheritance (繼承)"></a>Delegation (委託) + Inheritance (繼承)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210826203102362.png"></p><p>现在我们有了复合、继承和委托三板斧，如果我的任务是做一个文件系统，我们该如何设计呢？现在打开 Windows 窗口系统，都是大窗口里有小窗口，而文件目录可以放文件，还可以与其他目录结合在一起再放到另外一个目录里，现在我们面对的就是这样一种奇特的情况。</p><p>首先我们应该有一个代表文件的类 <code>Primitive</code>，另外我也需要准备一个 <code>Composite</code> 组合类。作为 <code>Compostie</code> 应该是一个容器，可以容纳很多个 <code>Primitive</code>，但刚刚我们分析过它也应该能够容纳 <code>Composite</code> 本身，那该如何是好呢？</p><p>我们的策略是为左边和右边写一个父类：</p><ul><li><code>Primitive</code> is a <code>Component</code></li><li><code>Composite</code> is a <code>Component</code></li></ul><p>这样右边的容器不必写死为 <code>Primitive</code> 或 <code>Composite</code>，放入父类指针 <code>Component*</code>。同样，添加功能也需要添加两个类别，所以也放入父类指针 <code>Component*</code>。在设计模式中这种设计方法称为组合模式。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906082747835.png"></p><p>假如我需要一个树状继承体系，创建未来才需要的子类该怎么办？在图中可以看到 <code>Image</code> 是抽象层之上的，下面的 <code>LandImage</code> 和 <code>SpotImage</code> 都是派生下来的子类，这时名称才可能出现，而 <code>Image</code> 可能是我三年前写的。现在的问题是我不知道未来的类有什么，我如何创建它呢？</p><p>有些聪明的人想出一个办法，有没有办法让下面派生的子类都创建一个自己作为原型传给父类。只要派生子类创建出来的东西能够被父类看到，就可以当作蓝本不断拷贝。以 <code>LandSatImage</code> 为例，私有的构造函数会调用 <code>Image</code> 父类 <code>addPrototype(this)</code> 使其感知，<code>Image</code> 得到的指针再放到自己的容器数组 <code>prototypes</code>，依此类推。而父类就可以通过之前传递的原型调用子类的 <code>clone()</code> 函数。</p><p>有人会说把 <code>clone()</code> 函数设为静态，不需要对象就能够调用它。静态函数的调用一定需要类名称，而未来的类名我们并不知道，所以我们必须舍弃这个想法。这个解法十分精巧，让人拍案叫绝，由《Design Patterns Explained Simply》的作者提出的。</p><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906090711456.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">imageType</span> {</span><br><span class="line">    LAST, SPOT</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Image* <span class="title">findAndClone</span><span class="params">(imageType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> imageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Image* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// As each subclass of Image is declared, it registers its prototype</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addPrototype</span><span class="params">(Image* image)</span> </span>{</span><br><span class="line">        _prototypes[_nextSlot++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// addPrototype() saves each registered prototype here</span></span><br><span class="line">    <span class="type">static</span> Image* _prototypes[<span class="number">10</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _nextSlot;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Image* Image::_prototypes[];</span><br><span class="line"><span class="type">int</span> Image::_nextSlot;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client calls this public static member function when it needs an instance</span></span><br><span class="line"><span class="comment">// of an Image subclass</span></span><br><span class="line"><span class="function">Image *<span class="title">Image::findAndClone</span><span class="params">(imageType type)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (_prototypes[i]-&gt;<span class="built_in">returnType</span>() == type)</span><br><span class="line">            <span class="keyword">return</span> _prototypes[i]-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>父类的 <code>clone()</code> 为纯虚函数，它不知道怎么克隆，但它要求子类一定要写出来。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LandSatImage</span> : <span class="keyword">public</span> Image {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">imageType <span class="title">returnType</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> LAST;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"LandSatImage::draw "</span> &lt;&lt; _id &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When clone() is called, call the one-argument ctor with a dummy arg</span></span><br><span class="line">    <span class="function">Image* <span class="title">clone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LandSatImage</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// This is only called from clone()</span></span><br><span class="line">    <span class="built_in">LandSatImage</span>(<span class="type">int</span> dummy) {</span><br><span class="line">        _id = _count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Mechanism for initializing an Image subclass - this causes the</span></span><br><span class="line">    <span class="comment">// default ctor to be called, which registers the subclass's prototype</span></span><br><span class="line">    <span class="type">static</span> LandSatImage _landSatImage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is only called when the private static data member is inited</span></span><br><span class="line">    <span class="built_in">LandSatImage</span>() {</span><br><span class="line">        <span class="built_in">addPrototype</span>(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Nominal "state" per instance mechanism</span></span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the subclass's prototype</span></span><br><span class="line">LandSatImage LandSatImage::_landSatImage;</span><br><span class="line"><span class="comment">// Initialize the "state" per instance mechanism</span></span><br><span class="line"><span class="type">int</span> LandSatImage::_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotImage</span> : <span class="keyword">public</span> Image {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">imageType <span class="title">returnType</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> SPOT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"SpotImage::draw "</span> &lt;&lt; _id &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Image* <span class="title">clone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SpotImage</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SpotImage</span>(<span class="type">int</span> dummy) {</span><br><span class="line">        _id = _count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SpotImage</span>() {</span><br><span class="line">        <span class="built_in">addPrototype</span>(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> SpotImage _spotImage;</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line">};</span><br><span class="line">SpotImage SpotImage::_spotImage;</span><br><span class="line"><span class="type">int</span> SpotImage::_count = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906101042855.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Simulated stream of creation requests</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_IMAGES = <span class="number">8</span>;</span><br><span class="line">imageType input[NUM_IMAGES] = {</span><br><span class="line">        LAST, LAST, LAST, SPOT, LAST, SPOT, SPOT, LAST</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Image* images[NUM_IMAGES];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Given an image type, find the right prototype, and return a clone</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; ++i) {</span><br><span class="line">        images[i] = Image::<span class="built_in">findAndClone</span>(input[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstrate that correct image objects have been cloned</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; ++i) {</span><br><span class="line">        images[i]-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the dynamic memory</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; ++i) {</span><br><span class="line">        <span class="keyword">delete</span> images[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整的源码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">imageType</span> {</span><br><span class="line">    LAST, SPOT</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Image* <span class="title">findAndClone</span><span class="params">(imageType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> imageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Image* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// As each subclass of Image is declared, it registers its prototype</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addPrototype</span><span class="params">(Image* image)</span> </span>{</span><br><span class="line">        _prototypes[_nextSlot++] = image;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// addPrototype() saves each registered prototype here</span></span><br><span class="line">    <span class="type">static</span> Image* _prototypes[<span class="number">10</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _nextSlot;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Image* Image::_prototypes[];</span><br><span class="line"><span class="type">int</span> Image::_nextSlot;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client calls this public static member function when it needs an instance</span></span><br><span class="line"><span class="comment">// of an Image subclass</span></span><br><span class="line"><span class="function">Image* <span class="title">Image::findAndClone</span><span class="params">(imageType type)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (_prototypes[i]-&gt;<span class="built_in">returnType</span>() == type)</span><br><span class="line">            <span class="keyword">return</span> _prototypes[i]-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">"Wrong Image Type\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LandSatImage</span> : <span class="keyword">public</span> Image {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">imageType <span class="title">returnType</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> LAST;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"LandSatImage::draw "</span> &lt;&lt; _id &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When clone() is called, call the one-argument ctor with a dummy arg</span></span><br><span class="line">    <span class="function">Image* <span class="title">clone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LandSatImage</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// This is only called from clone()</span></span><br><span class="line">    <span class="built_in">LandSatImage</span>(<span class="type">int</span> dummy) {</span><br><span class="line">        _id = _count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Mechanism for initializing an Image subclass - this causes the</span></span><br><span class="line">    <span class="comment">// default ctor to be called, which registers the subclass's prototype</span></span><br><span class="line">    <span class="type">static</span> LandSatImage _landSatImage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is only called when the private static data member is inited</span></span><br><span class="line">    <span class="built_in">LandSatImage</span>() {</span><br><span class="line">        <span class="built_in">addPrototype</span>(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Nominal "state" per instance mechanism</span></span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the subclass's prototype</span></span><br><span class="line">LandSatImage LandSatImage::_landSatImage;</span><br><span class="line"><span class="comment">// Initialize the "state" per instance mechanism</span></span><br><span class="line"><span class="type">int</span> LandSatImage::_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotImage</span> : <span class="keyword">public</span> Image {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">imageType <span class="title">returnType</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> SPOT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"SpotImage::draw "</span> &lt;&lt; _id &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Image* <span class="title">clone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SpotImage</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SpotImage</span>(<span class="type">int</span> dummy) {</span><br><span class="line">        _id = _count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SpotImage</span>() {</span><br><span class="line">        <span class="built_in">addPrototype</span>(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> SpotImage _spotImage;</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line">};</span><br><span class="line">SpotImage SpotImage::_spotImage;</span><br><span class="line"><span class="type">int</span> SpotImage::_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simulated stream of creation requests</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_IMAGES = <span class="number">8</span>;</span><br><span class="line">imageType input[NUM_IMAGES] = {</span><br><span class="line">        LAST, LAST, LAST, SPOT, LAST, SPOT, SPOT, LAST</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Image* images[NUM_IMAGES];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Given an image type, find the right prototype, and return a clone</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; ++i) {</span><br><span class="line">        images[i] = Image::<span class="built_in">findAndClone</span>(input[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstrate that correct image objects have been cloned</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; ++i) {</span><br><span class="line">        images[i]-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the dynamic memory</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; ++i) {</span><br><span class="line">        <span class="keyword">delete</span> images[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/c1beecdf.html" rel="bookmark">Infinite Dev Log</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/63b4255a.html" rel="bookmark">TEXTURES</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/a8dbb28c.html" rel="bookmark">Shader Abstraction and Uniforms</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Cpp/" rel="tag"># Cpp</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/8069546e.html" rel="prev" title="Stack"><i class="fa fa-chevron-left"></i> Stack</a></div><div class="post-nav-item"><a href="/archives/dd921d98.html" rel="next" title="剑指Offer">剑指Offer <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">C++ 编程简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E6%87%89%E5%85%B7%E5%82%99%E7%9A%84%E5%9F%BA%E7%A4%8E"><span class="nav-number">2.1.</span> <span class="nav-text">你應具備的基礎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E5%80%91%E7%9A%84%E7%9B%AE%E6%A8%99"><span class="nav-number">2.2.</span> <span class="nav-text">我們的目標</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E5%B0%87%E7%8D%B2%E5%BE%97%E7%9A%84%E4%BB%A3%E7%A2%BC"><span class="nav-number">2.3.</span> <span class="nav-text">你將獲得的代碼</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E7%9A%84%E6%AD%B7%E5%8F%B2"><span class="nav-number">2.4.</span> <span class="nav-text">C++ 的歷史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%BC%94%E5%8C%96"><span class="nav-number">2.5.</span> <span class="nav-text">C++ 演化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B8%E7%9B%AE%E8%AA%8C"><span class="nav-number">2.6.</span> <span class="nav-text">書目誌</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">3.</span> <span class="nav-text">头文件与类的声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-vs-C-%E9%97%9C%E6%96%BC%E6%95%B8%E6%93%9A%E5%92%8C%E5%87%BD%E6%95%B8"><span class="nav-number">3.1.</span> <span class="nav-text">C vs. C++, 關於數據和函數</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-Based-%E5%9F%BA%E6%96%BC%E5%B0%8D%E8%B1%A1-vs-Object-Oriented-%E9%9D%A2%E5%90%91%E5%B0%8D%E8%B1%A1"><span class="nav-number">3.2.</span> <span class="nav-text">Object Based (基於對象) vs. Object Oriented (面向對象)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-programs-%E4%BB%A3%E7%A2%BC%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">C++ programs 代碼基本形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Output-C-vs-C"><span class="nav-number">3.4.</span> <span class="nav-text">Output, C++ vs. C</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Header-%E9%A0%AD%E6%96%87%E4%BB%B6-%E4%B8%AD%E7%9A%84%E9%98%B2%E8%A1%9B%E5%BC%8F%E8%81%B2%E6%98%8E"><span class="nav-number">3.5.</span> <span class="nav-text">Header (頭文件) 中的防衛式聲明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Header-%E9%A0%AD%E6%96%87%E4%BB%B6-%E7%9A%84%E4%BD%88%E5%B1%80"><span class="nav-number">3.6.</span> <span class="nav-text">Header (頭文件) 的佈局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-%E7%9A%84%E8%81%B2%E6%98%8E-declaration"><span class="nav-number">3.7.</span> <span class="nav-text">class 的聲明 (declaration)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-template-%E6%A8%A1%E6%9D%BF-%E7%B0%A1%E4%BB%8B"><span class="nav-number">3.8.</span> <span class="nav-text">class template (模板) 簡介</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#inline-%E5%85%A7%E8%81%AF-%E5%87%BD%E6%95%B8"><span class="nav-number">4.1.</span> <span class="nav-text">inline (內聯)函數</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#access-level-%E8%A8%AA%E5%95%8F%E7%B4%9A%E5%88%A5"><span class="nav-number">4.2.</span> <span class="nav-text">access level (訪問級別)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constructor-ctor-%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8"><span class="nav-number">4.3.</span> <span class="nav-text">constructor (ctor, 構造函數)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ctor-%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8-%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%BE%88%E5%A4%9A%E5%80%8B-%E2%80%93-overloading-%E9%87%8D%E8%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">ctor (構造函數) 可以有很多個 – overloading (重載)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">5.</span> <span class="nav-text">参数传递与返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constructor-ctor-%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8-%E8%A2%AB%E6%94%BE%E5%9C%A8-private-%E5%8D%80"><span class="nav-number">5.1.</span> <span class="nav-text">constructor (ctor, 構造函數) 被放在 private 區</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ctors-%E6%94%BE%E5%9C%A8-private-%E5%8D%80"><span class="nav-number">5.2.</span> <span class="nav-text">ctors 放在 private 區</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-member-functions-%E5%B8%B8%E9%87%8F%E6%88%90%E5%93%A1%E5%87%BD%E6%95%B8"><span class="nav-number">5.3.</span> <span class="nav-text">const member functions (常量成員函數)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%83%E6%95%B8%E5%82%B3%E9%81%9E-pass-by-value-vs-pass-by-reference-to-const"><span class="nav-number">5.4.</span> <span class="nav-text">參數傳遞:pass by value vs. pass by reference (to const)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%82%B3%E9%81%9E-return-by-value-vs-return-by-reference-to-const"><span class="nav-number">5.5.</span> <span class="nav-text">返回值傳遞:return by value vs. return by reference (to const)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#friend-%E5%8F%8B%E5%85%83"><span class="nav-number">5.6.</span> <span class="nav-text">friend (友元)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C-class-%E7%9A%84%E5%90%84%E5%80%8B-objects-%E4%BA%92%E7%82%BA-friends-%E5%8F%8B%E5%85%83"><span class="nav-number">5.7.</span> <span class="nav-text">相同 class 的各個 objects 互為 friends (友元)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-body-%E5%A4%96%E7%9A%84%E5%90%84%E7%A8%AE%E5%AE%9A%E7%BE%A9-definitions"><span class="nav-number">5.8.</span> <span class="nav-text">class body 外的各種定義 (definitions)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.</span> <span class="nav-text">操作符重载与临时对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#operator-overloading-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BC%89-1-%E6%88%90%E5%93%A1%E5%87%BD%E6%95%B8-this"><span class="nav-number">6.1.</span> <span class="nav-text">operator overloading (操作符重載-1, 成員函數) this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#return-by-reference-%E8%AA%9E%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">6.2.</span> <span class="nav-text">return by reference 語法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-body-%E4%B9%8B%E5%A4%96%E7%9A%84%E5%90%84%E7%A8%AE%E5%AE%9A%E7%BE%A9-definitions"><span class="nav-number">6.3.</span> <span class="nav-text">class body 之外的各種定義 (definitions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#operator-overloading-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BC%89-2-%E9%9D%9E%E6%88%90%E5%93%A1%E5%87%BD%E6%95%B8-%E7%84%A1-this"><span class="nav-number">6.4.</span> <span class="nav-text">operator overloading (操作符重載-2, 非成員函數) (無 this)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#temp-object%EF%BC%88%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%EF%BC%89typename"><span class="nav-number">6.5.</span> <span class="nav-text">temp object（临时对象）typename();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-body-%E4%B9%8B%E5%A4%96%E7%9A%84%E5%90%84%E7%A8%AE%E5%AE%9A%E7%BE%A9-definitions-1"><span class="nav-number">6.6.</span> <span class="nav-text">class body 之外的各種定義 (definitions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#operator-overloading-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BC%89-%E9%9D%9E%E6%88%90%E5%93%A1%E5%87%BD%E6%95%B8"><span class="nav-number">6.7.</span> <span class="nav-text">operator overloading (操作符重載), 非成員函數</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Complex-%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">Complex 类实现过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-number">7.1.</span> <span class="nav-text">测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">拷贝构造，拷贝赋值与析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String-class"><span class="nav-number">8.1.</span> <span class="nav-text">String class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Big-Three-%E4%B8%89%E5%80%8B%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B8"><span class="nav-number">8.2.</span> <span class="nav-text">Big Three, 三個特殊函數</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ctor-%E5%92%8C-dtor-%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8-%E5%92%8C-%E6%9E%90%E6%A7%8B%E5%87%BD%E6%95%B8"><span class="nav-number">8.3.</span> <span class="nav-text">ctor 和 dtor (構造函數 和 析構函數)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-with-pointer-members-%E5%BF%85%E9%A0%88%E6%9C%89-copy-ctor-%E5%92%8C-copy-op-x3D"><span class="nav-number">8.4.</span> <span class="nav-text">class with pointer members 必須有 copy ctor 和 copy op=</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-ctor-%E6%8B%B7%E8%B2%9D%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8"><span class="nav-number">8.5.</span> <span class="nav-text">copy ctor (拷貝構造函數)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-assignment-operator-%E6%8B%B7%E8%B2%9D%E8%B3%A6%E5%80%BC%E5%87%BD%E6%95%B8"><span class="nav-number">8.6.</span> <span class="nav-text">copy assignment operator (拷貝賦值函數)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8-operator-x3D-%E4%B8%AD%E6%AA%A2%E6%9F%A5%E6%98%AF%E5%90%A6-self-assignment"><span class="nav-number">8.7.</span> <span class="nav-text">一定要在 operator= 中檢查是否 self assignment</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">堆栈与内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#output-%E5%87%BD%E6%95%B8"><span class="nav-number">9.1.</span> <span class="nav-text">output 函數</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E8%AC%82-stack-%E6%A3%A7-%E6%89%80%E8%AC%82-heap-%E5%A0%86"><span class="nav-number">9.2.</span> <span class="nav-text">所謂 stack (棧), 所謂 heap (堆)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stack-objects-%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="nav-number">9.3.</span> <span class="nav-text">stack objects 的生命期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-local-objects-%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="nav-number">9.4.</span> <span class="nav-text">static local objects 的生命期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#global-objects-%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="nav-number">9.5.</span> <span class="nav-text">global objects 的生命期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#heap-objects-%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="nav-number">9.6.</span> <span class="nav-text">heap objects 的生命期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E5%85%88%E5%88%86%E9%85%8D-memory-%E5%86%8D%E8%AA%BF%E7%94%A8-ctor"><span class="nav-number">9.7.</span> <span class="nav-text">new:先分配 memory, 再調用 ctor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete-%E5%85%88%E8%AA%BF%E7%94%A8-dtor-%E5%86%8D%E9%87%8B%E6%94%BE-memory"><span class="nav-number">9.8.</span> <span class="nav-text">delete:先調用 dtor, 再釋放 memory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8B%95%E6%85%8B%E5%88%86%E9%85%8D%E6%89%80%E5%BE%97%E7%9A%84%E5%85%A7%E5%AD%98%E5%A1%8A-memory-block-in-VC"><span class="nav-number">9.9.</span> <span class="nav-text">動態分配所得的內存塊 (memory block), in VC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8B%95%E6%85%8B%E5%88%86%E9%85%8D%E6%89%80%E5%BE%97%E7%9A%84-array"><span class="nav-number">9.10.</span> <span class="nav-text">動態分配所得的 array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#array-new-%E4%B8%80%E5%AE%9A%E8%A6%81%E6%90%AD%E9%85%8D-array-delete"><span class="nav-number">9.11.</span> <span class="nav-text">array new 一定要搭配 array delete</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text">String 类实现过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-1"><span class="nav-number">10.1.</span> <span class="nav-text">测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">10.2.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">11.</span> <span class="nav-text">类模板与函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%B2%E4%B8%80%E6%AD%A5%E8%A3%9C%E5%85%85-static"><span class="nav-number">11.1.</span> <span class="nav-text">進一步補充:static</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%B2%E4%B8%80%E6%AD%A5%E8%A3%9C%E5%85%85-%E6%8A%8A-ctors-%E6%94%BE%E5%9C%A8-private-%E5%8D%80"><span class="nav-number">11.2.</span> <span class="nav-text">進一步補充: 把 ctors 放在 private 區</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%B2%E4%B8%80%E6%AD%A5%E8%A3%9C%E5%85%85-cout"><span class="nav-number">11.3.</span> <span class="nav-text">進一步補充:cout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%B2%E4%B8%80%E6%AD%A5%E8%A3%9C%E5%85%85-class-template-%E9%A1%9E%E6%A8%A1%E6%9D%BF"><span class="nav-number">11.4.</span> <span class="nav-text">進一步補充:class template, 類模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%B2%E4%B8%80%E6%AD%A5%E8%A3%9C%E5%85%85-function-template-%E5%87%BD%E6%95%B8%E6%A8%A1%E6%9D%BF"><span class="nav-number">11.5.</span> <span class="nav-text">進一步補充:function template, 函數模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%B2%E4%B8%80%E6%AD%A5%E8%A3%9C%E5%85%85-namespace"><span class="nav-number">11.6.</span> <span class="nav-text">進一步補充:namespace</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">12.</span> <span class="nav-text">组合与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-Oriented-Programming-Object-Oriented-Design-OOP-OOD"><span class="nav-number">12.1.</span> <span class="nav-text">Object Oriented Programming, Object Oriented Design OOP, OOD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Composition-%E8%A4%87%E5%90%88-%E8%A1%A8%E7%A4%BA-has-a"><span class="nav-number">12.2.</span> <span class="nav-text">Composition (複合), 表示 has-a</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Composition-%E8%A4%87%E5%90%88-%E9%97%9C%E4%BF%82%E4%B8%8B%E7%9A%84%E6%A7%8B%E9%80%A0%E5%92%8C%E6%9E%90%E6%A7%8B"><span class="nav-number">12.3.</span> <span class="nav-text">Composition (複合) 關係下的構造和析構</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Delegation-%E5%A7%94%E8%A8%97-Composition-by-reference"><span class="nav-number">12.4.</span> <span class="nav-text">Delegation (委託). Composition by reference.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inheritance-%E7%B9%BC%E6%89%BF-%E8%A1%A8%E7%A4%BA-is-a"><span class="nav-number">12.5.</span> <span class="nav-text">Inheritance (繼承), 表示 is-a</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inheritance-%E7%B9%BC%E6%89%BF-%E9%97%9C%E4%BF%82%E4%B8%8B%E7%9A%84%E6%A7%8B%E9%80%A0%E5%92%8C%E6%9E%90%E6%A7%8B"><span class="nav-number">12.6.</span> <span class="nav-text">Inheritance (繼承) 關係下的構造和析構</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-number">13.</span> <span class="nav-text">虚函数与多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Inheritance-%E7%B9%BC%E6%89%BF-with-virtual-functions-%E8%99%9B%E5%87%BD%E6%95%B8"><span class="nav-number">13.1.</span> <span class="nav-text">Inheritance (繼承) with virtual functions (虛函數)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inheritance-%E7%B9%BC%E6%89%BF-with-virtual"><span class="nav-number">13.2.</span> <span class="nav-text">Inheritance (繼承) with virtual</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inheritance-Composition-%E9%97%9C%E4%BF%82%E4%B8%8B%E7%9A%84%E6%A7%8B%E9%80%A0%E5%92%8C%E6%9E%90%E6%A7%8B"><span class="nav-number">13.3.</span> <span class="nav-text">Inheritance+Composition 關係下的構造和析構</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1"><span class="nav-number">14.</span> <span class="nav-text">委托相关设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Delegation-%E5%A7%94%E8%A8%97-Inheritance-%E7%B9%BC%E6%89%BF"><span class="nav-number">14.1.</span> <span class="nav-text">Delegation (委託) + Inheritance (繼承)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Prototype"><span class="nav-number">14.2.</span> <span class="nav-text">Prototype</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">282</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.4m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Tiny Rooms by        Mohamed Chahin           引言这个系列将讲解C++需知道的一切内容，涵盖这门语言的基础知识。本节将开始讲解C++的面向对象特性。"><meta property="og:type" content="article"><meta property="og:title" content="C++面向对象设计基础"><meta property="og:url" content="https://yousazoe.top/archives/f28a8c2c.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Tiny Rooms by        Mohamed Chahin           引言这个系列将讲解C++需知道的一切内容，涵盖这门语言的基础知识。本节将开始讲解C++的面向对象特性。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/cf34c4102453055.5f467520af6a5.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210609093343389.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210610103012424.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210610212904211.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210614025735750.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618083556637.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618083754174.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618084357358.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618085312201.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618090417145.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619082513364.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619083147989.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619083611316.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619093455626.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619100918732.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619102541655.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210626131612993.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210627232258711.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629083055729.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629084412052.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629085153097.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629085538328.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210709121151471.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210709145146053.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210709145852556.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210714165907398.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210714170141707.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210714172447949.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210714173036506.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210715212054849.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629093357666.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629093612094.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629093758366.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629095135161.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629095841847.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629111020683.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704152839890.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704155920565.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704160429996.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704161449301.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704162639642.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705160236508.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705163801189.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705212818328.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705225327136.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705225650753.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705230250552.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210706143544608.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210716232530922.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210719113605774.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210719114229142.png"><meta property="article:published_time" content="2021-06-09T00:57:47.000Z"><meta property="article:modified_time" content="2024-09-24T16:58:45.597Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Cpp"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/cf34c4102453055.5f467520af6a5.png"><link rel="canonical" href="https://yousazoe.top/archives/f28a8c2c.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>C++面向对象设计基础 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/f28a8c2c.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++面向对象设计基础</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-06-09 08:57:47" itemprop="dateCreated datePublished" datetime="2021-06-09T08:57:47+08:00">2021-06-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Cherno%E7%9A%84C-%E7%AC%94%E8%AE%B0-Cherno-C/" itemprop="url" rel="index"><span itemprop="name">Cherno的C++笔记 (Cherno C++)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>50k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>1:30</span></span></div></header><div class="post-body" itemprop="articleBody"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/cf34c4102453055.5f467520af6a5.png"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://www.behance.net/gallery/102453055/Tiny-Rooms">Tiny Rooms</a> by <a target="_blank" rel="noopener" href="https://www.behance.net/MChahin">Mohamed Chahin</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这个系列将讲解C++需知道的一切内容，涵盖这门语言的基础知识。本节将开始讲解C++的面向对象特性。</p><span id="more"></span><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>我们终于讲到了面向对象编程，这是一种非常流行的编程方式，但实际上只是一种你编写代码的一种方式，其他语言诸如C#、Java主要是面向对象的语言。事实上，用这些语言你不能写任何其他类型的代码，虽然你也可以尝试，最终这些语言都是面向对象的语言。</p><p>然而C++有点不同，因为它并没有给你强加一种特定风格。例如用C语言不支持面向对象编程，因为为了面向对象编程你需要有一些概念比如类和对象，这些东西C语言没有，而C++会添加所有这些功能，在某种程度上，使用面向对象总是一个好主意。</p><p>简单的说，类只是数据和功能组合在一起的一种方法。例如在游戏中我们可能想要一些代表角色的东西，那么我们需要什么样的东西来代表一个角色呢？我们当然需要一些数据，例如角色在游戏中的位置、角色可能拥有的某些属性比如角色移动的速度，我们还可能需要一些3D模型代表角色的屏幕形象，所有这些数据都需要存储在某个地方。</p><p>我们可以为所有这些创建变量，假设我们想要创建一个角色比如位置、速度：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> spped = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在你可能发现这有点乱了，事实上这些名字太普通了，当我们游戏有两个角色时不得不复制然后改成<code>playerX0</code>、<code>playerX1</code>等：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> playerX0,playerY0;</span><br><span class="line">    <span class="type">int</span> playerSpped0 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> playerX1,playerY1;</span><br><span class="line">    <span class="type">int</span> playerSpped1 = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你当然可以使用数组，但重点还是一样的：它们只是一堆没有组合在一起的变量，它们是无组织的放在我们的代码中，这不是一个好主意。另一个很好的例子可以说明为什么这很烦人，如果我想写一个函数来移动角色，我需要把这三个参数都指定为整数参数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> spped)</span></span>{</span><br><span class="line">	......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所有这一切变成了如此多的代码，难以维护且非常混乱。所以我们要做的是通过使用类简化它，我们可以创建一个叫做<code>Player</code>类，它包含了所有我们想要的数据变成一种类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>{</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们通过使用<code>class</code>然后给它一个名字来实现，这个名字必须是唯一的，因为<code>class</code>是类型，这里是创建一个新的变量类型。</p><p>现在我们又了一个全新的类<code>Player</code>，本质上它是一种类型，如果我们开始使用<code>Player</code>类可以把它当作其他变量来创建：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">		Player player;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由类类型构成的变量称为对象，新的对象变量称为实例，在这里我们实例化了一个<code>Player</code>对象，如果我想设置这些变量可以简单写为<code>player.+x</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">player.x = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><p>但这里会提示出错，原因是<code>Player</code>中这些成员变量都是私有的：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210609093343389.png"></p><p>这是可见性的原因，当你创建一个新类时你可以选择制定类中的内容的可见性。默认情况下，一个类中所有东西都是私有的，这意味着只有类中的函数才能访问这些变量，然而我们希望能够从<code>main</code>函数中访问这些变量，所以在这里把它设为<code>public</code>：意味着我们可以在类之外的任何地方访问这些变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>{</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译成功，现在我们实现了第一个目标：把所有的变量都放在了一个地方，这些变量集合可以代表一个<code>player</code>，所以我们把它很好的分组了。</p><p>现在我们有了这些数据，假设我们想让<code>player</code>做一些事情例如移动，需要写一个函数来改变<code>x</code>和<code>y</code>变量值，我们该怎么做呢？</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(Player&amp; player,<span class="type">int</span> xa,<span class="type">int</span> ya)</span></span>{</span><br><span class="line">    player.x += player.speed * xa;</span><br><span class="line">    player.y += player.speed * ya;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">Move</span>(player,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们已经写了一个可以移动<code>player</code>的函数，然而我们可以做的更好一点。类实际上可以包含函数，这意味着我们可以将<code>move</code>函数移动到类中，类中的函数被称为方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa,<span class="type">int</span> ya)</span></span>{</span><br><span class="line">      x += speed * xa;</span><br><span class="line">      y += speed * ya;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">5</span>;</span><br><span class="line">    player.<span class="built_in">Move</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在函数在类里面了，我们可以直接得到这些变量而不需要传入<code>player</code>对象，所有的<code>x</code>、<code>y</code>和<code>speed</code>指的就是当前对象的变量。</p><p>我们已经简化了我们的代码，每个<code>Player</code>对象都有自己的<code>move</code>函数，当我们为指定的<code>Player</code>对象调用<code>move</code>时这个对象将会移动。这与<code>Player</code>类之外的<code>move</code>函数没有什么不同，它所做的就是让我们的代码更干净，这样看起来更好看，而当你处理很多代码时，这是一个巨大的优势。</p><p>这就是类的基本概念，允许我们将变量分组到一个类型中并为这些变量添加功能。如果你再看一下代码，我们真正做的是我们在一个类类型中定义了三个变量以及一个处理这些变量的函数，这就是我们所做的。类本质上只是语法糖，我们可以使用它来组织我们的代码，使它更容易维护。</p><h4 id="类与结构体对比"><a href="#类与结构体对比" class="headerlink" title="类与结构体对比"></a>类与结构体对比</h4><p>类和结构体有什么区别呢？上次我们讲到类的时候我们对类有了一些基本的介绍，结构体<code>struct</code>（structure的缩写）以及类<code>class</code>看起来有点相似，很多人有点困惑到底区别是什么。</p><p>事实是基本没有什么区别，只有一个关于可见度的小区别。一个类的成员默认为<code>private</code>，这意味着如果我没有加<code>public</code>之前的代码会报错，告诉我们<code>Player</code>类的<code>move</code>方法是不可访问的，因为它被标记为默认的<code>private</code>只有在类里面的方法才可以访问<code>move</code>方法。</p><p>这就是区别的本质所在，默认情况下类是私有的，所以如果你不指定修改任何可见性，那默认值就是私有的<code>private</code>。然而在结构体中，默认值却是<code>public</code>的。技术上讲，这是类与结构体的唯一区别，在代码中体现在把<code>class</code>换为<code>struct</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span>{</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa,<span class="type">int</span> ya)</span></span>{</span><br><span class="line">        x += speed * xa;</span><br><span class="line">        y += speed * ya;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">5</span>;</span><br><span class="line">    player.<span class="built_in">Move</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从技术上讲，它们可能没有太大的区别，然而实际发生的使用情况会有所不同。<code>struct</code>结构体在C++中继续存在的唯一原因是因为它希望与C保持向后兼容性，因为C代码没有类但有结构体，如果我们突然去掉整个结构体关键字会失去兼容性，C++编译器不知道什么是<code>struct</code>。</p><p>当然，你可以很容易解决这个问题，只需要用<code>#define</code>来查找，我们可以写一些类似<code>#define</code>的东西：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> struct class</span></span><br></pre></td></tr></tbody></table></figure><p>它要做的就是用<code>class</code>替换所有的<code>struct</code>，在这种情况下尽管这段代码看起来很简单，但如果我们编译它你会发现同样的编译错误，说<code>move</code>在类中，不能在外部访问它：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210610103012424.png"></p><p>这样做也许我们能得到C与C++的某种兼容性，因为理想情况下你应该能将C语言中的<code>struct</code>替换成<code>class</code>，然后将其变成<code>public</code>。所以语义上的不同以及人们如何看待它，或多或少取决于用法，如果没有区别，那什么时候使用<code>struct</code>或者类，如果我想要的所有的成员都是公共的，而又不想写<code>public</code>这个字，我应该使用结构体吗？</p><p>是的，它就是那么微不足道，人们都有自己对这两者的理解和定义，没有什么正确或错误的答案，这取决于你的编程风格。让我们谈谈我的编程风格，以及我可能在哪里使用什么类型。</p><p>当我讨论Plain old data（POD）时，我喜欢尽可能地使用<code>struct</code>，只表示变量的结构。这方面的一个很好的例子可能是数学上的向量类：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span> {</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>不管是<code>class</code>还是<code>struct</code>，都是代表这两个浮点数的一种结构，它不应该像之前的<code>Player</code>类一样包含大量的功能，<code>Player</code>类可能有一个3D模型，它可能会为这个3D模型处理渲染代码、如何在地图上移动并接受键盘输入……这里有很多功能，而我们的向量只是两个变量，我们把它分组只是为了让我们的代码更容易使用。</p><p>当然这不是说我不会在这里添加方法，其实完全可以。我可以添加一个名为<code>add</code>的方法，它取另一个<code>Vec2</code>作为参数，然后把它和当前向量相加：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span> {</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(Vec2&amp; other)</span> </span>{</span><br><span class="line">        x += other.x;</span><br><span class="line">        y += other.y;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>再次强调，我只是在处理这些变量。也许你会较真的说<code>Player</code>类不是也只是操纵这些变量吗？其实在设计上还是有一点不同的，因为我们讨论的东西要复杂的多。</p><p>另外的场景是继承，我不会在<code>struct</code>中使用继承。如果我要有一个完整的类层次结构或者某种继承层次结构，我将使用类，因为继承是一种增加另一层次复杂性的东西，我只希望我的结构体是数据的结构，仅此而已。除此之外如果你尝试混合使用这些类型，例如你有一个类<code>a</code>和一个结构体<code>b</code>，这个<code>b</code>继承自<code>a</code>，某些编译器会报错。</p><p>在这里我使用结构体而不是类的原因是如果我只是想用结构体表示一些数据，我将使用一个结构体；但如果我想要一个大量功能的整个类比如一个游戏世界或者一个Player亦或是其他可能需要继承的东西，我将使用一个类，这也是我个人区分这两种类型的方法。</p><h4 id="如何写一个C-的类"><a href="#如何写一个C-的类" class="headerlink" title="如何写一个C++的类"></a>如何写一个C++的类</h4><p>到目前为止我们学了类，并尝试着从头开始写一个类。今天我们会写一个基本的<code>log</code>类演示我们已经学过的东西。</p><p>让我们来讨论一下我们要写的这个<code>log</code>类，这个<code>log</code>类到底是什么？它是我们管理日志信息的一种方式，换句话说我们想要我们的程序打印消息或信息到控制台，这通常用于调试，非常有帮助。在游戏或应用中，如果你想知道发生了什么，你只需要将事物的状态打印到控制台，因为应用程序中的控制台就像一个放信息的地方，我们可以用它来打印出发生了什么，保证代码在正确的工作。</p><p>如果我们的游戏中有一个图形要显示在控制台或是一些不同的东西，它可能不会一直起作用，如果我们的图形渲染系统出现了问题我们可能得不到那些信息。然而控制台是操作系统内置的最基本的东西，所以我们可以保证它总是有效的。有些复杂的日志系统有几千行代码，只是为了把东西打印到控制台，但它对调试和开发非常重要，所以花时间在上面是绝对值得的。</p><p><code>log</code>日志系统不仅可以打印到控制台，也可以用不同的颜色打印，或是通过网络输出日志消息到一个文件，你可以做很多事情。但<code>log</code>类开始的时候非常简单，它提供向控制台写入文本的能力、保持我们真正想要发送给控制台的日志信息的级别，开始我们有三个级别：</p><ul><li>错误</li><li>警告</li><li>信息</li></ul><p>我们能做的是把日志系统级别设置为“警告”，这意味着只会打印警告和错误，而不会打印信息。这很有用，如果你不想看到一堆信息，你只是想知道哪里出了问题或警告是什么。同样通过过滤实际发送和打印的内容，控制台也会很清爽，让我们来看看它会是什么样子：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> {</span><br><span class="line">    </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在让我们思考一下<code>log</code>类是如何工作的。创建一个类或设计API时，一个很好的方法是通过研究它的使用情况：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> {</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">SetLevel</span>(LogLevelWarning);</span><br><span class="line">    log.<span class="built_in">Warn</span>(<span class="string">"Hello!"</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先我要实例化它，然后肯定会有一个设置<code>log</code>级别的<code>SetLevel</code>方法，意味着只有警告或更重要的信息比如警告或错误才会被打印出来。然后我可能想要打印一个警告符号，里面填点”Hello”这样的。</p><p>现在我知道了我的<code>log</code>类看起来像什么了，我可以直接回去开始填空：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_LogLevel;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>{</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">SetLevel</span>(<span class="number">1</span>);</span><br><span class="line">    log.<span class="built_in">Warn</span>(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中设置日志级别这里的1很难让人理解，1是什么？因此我们需要创建一个变量，它的值是1，来表示我们想要表示的东西。我们给它起名为<code>LogLevelWarning</code>，完善三种类型的日志消息常数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Log {</span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   const int LogLevelError = 0;</span></span><br><span class="line"><span class="addition">+   const int LogLevelWarning = 1;</span></span><br><span class="line"><span class="addition">+   const int LogLevelInfo = 2;</span></span><br><span class="line">private:</span><br><span class="line">    int m_LogLevel = LogLevelInfo;</span><br><span class="line">public:</span><br><span class="line">    void SetLevel(int level){</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Warn(const char* message){</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们有错误<code>Error</code>，警告<code>Warning</code>还有信息<code>Information</code>。默认情况下，我把我的日志级别设置为<code>LogLevelInfo</code>，意味着所有的东西都应该打印出来。最后我们补充<code>Warn</code>函数，把东西打印到控制台上，以此类推补充其余两种函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>{</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[ERROR]: "</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[WARNING]: "</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[INFO]: "</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这样我们就有了设置日志级别的方法，但目前我们还不能做到如果日志级别设置为<code>warning</code>就不打印所有的<code>info</code>信息，我们可以用条件语句来搞定：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Log {</span><br><span class="line">public:</span><br><span class="line">    const int LogLevelError = 0;</span><br><span class="line">    const int LogLevelWarning = 1;</span><br><span class="line">    const int LogLevelInfo = 2;</span><br><span class="line">private:</span><br><span class="line">    int m_LogLevel = LogLevelInfo;</span><br><span class="line">public:</span><br><span class="line">    void SetLevel(int level){</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Error(const char* message){</span><br><span class="line"><span class="addition">+       if (m_LogLevel &gt;= LogLevelError)</span></span><br><span class="line">            std::cout &lt;&lt; "[ERROR]: " &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Warn(const char* message){</span><br><span class="line"><span class="addition">+       if (m_LogLevel &gt;= LogLevelWarning)</span></span><br><span class="line">            std::cout &lt;&lt; "[WARNING]: " &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Info(const char* message){</span><br><span class="line"><span class="addition">+       if (m_LogLevel &gt;= LogLevelInfo)</span></span><br><span class="line">            std::cout &lt;&lt; "[INFO]: " &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Log log;</span><br><span class="line"><span class="addition">+   log.SetLevel(log.LogLevelWarning);</span></span><br><span class="line">    log.Warn("Hello");</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210610212904211.png"></p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Log log;</span><br><span class="line">    log.SetLevel(log.LogLevelWarning);</span><br><span class="line">    log.Warn("Hello");</span><br><span class="line"><span class="addition">+   log.Error("Hello");</span></span><br><span class="line"><span class="addition">+   log.Info("Hello");</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我们打印三条不同的日志信息，但只有<code>warning</code>和<code>error</code>被打印出来，<code>info</code>没有：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210614025735750.png"></p><p>因为我们设定的级别为<code>warning</code>，去掉就会打印三个信息。这个类有很多问题，但它是简单的，而且很有逻辑。当一个人考虑如何编写这个类时，一个经验丰富的程序员是不会这样写的，它给了我一个很好的机会向你们展示如何使用一些不同的概念来改进这个类。</p><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><h4 id="类-x2F-结构体外的静态"><a href="#类-x2F-结构体外的静态" class="headerlink" title="类/结构体外的静态"></a>类/结构体外的静态</h4><p>今天我们将讨论C++中的静态<code>static</code>。<code>static</code>关键字在C++中有两个意思，这取决于上下文，其中之一是在类或结构体外部使用<code>static</code>关键字；另一种是在类或结构体内部使用<code>static</code>。直白的说，类外面的<code>static</code>意味着链接将只是在内部，它只能对你定义的翻译单元可见。</p><p>然而类或结构体内部的静态变量意味着该变量实际上将与类的所有实例共享内存，在你在类中创建的所有实例中静态变量只有一个实例。类似的事情也适用于类中的静态方法，在类中，没有实例会传递给该方法，在这里我们不深入讨论静态<code>static</code>在类或结构体范围内的实际含义，今天我们关注在类和结构体外部的静态。</p><p>回到代码，在一个新建的<code>static.cpp</code>，我要做的就是定义一个静态变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> s_variable = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><p>它和其他变量一样，但在前面是<code>static</code>关键字。它的意思是这个变量只会在这个翻译单元内部链接，静态变量或函数意味着，当需要将这些函数或变量与实际定义的符号链接时链接器不会在这个翻译单元的作用域之外，寻找那个符号的定义。</p><p>最好还是看例子，这里我们创建了一个静态变量<code>s_variable</code>并将它设为5，然后在另一个C++文件（也就是另一个翻译单元）声明同名的变量，编译不会有任何问题：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s_variable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s_variable &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618083556637.png"></p><p>假如我回到<code>static.cpp</code>文件删除<code>static</code>关键字，再次编译运行会得到一个链接错误：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s_variable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s_variable &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618083754174.png"></p><p>这是因为这个<code>s_variable</code>已经在另一个翻译单元中定义了，所以我们不能有两个同名的全局变量。</p><p>一种修改方法是修改这个变量的实际指向，标识这个变量为<code>extern</code>，这意味着它会在外部翻译单元中寻找<code>s_variable</code>变量，这被称为<code>external linking</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> s_variable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s_variable &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我现在运行代码打印出来的是5，因为它引用了<code>static.cpp</code>中的<code>s_variable</code>变量：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618084357358.png"></p><p>然而如果我在<code>static.cpp</code>标记为静态变量，这有点像在类中声明一个私有变量，其他所有的翻译单元都不能看到这个<code>s_variable</code>变量。链接器在全局作用域下，将不会看到这个变量，也就是说此时我们尝试编译代码，我们得到一个未解析的外部符号错误，它在任何地方都找不到名称为<code>s_variable</code>的整型变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> s_variable = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618085312201.png"></p><p>这是因为我们已经有效地标记了这个变量是私有的。回到<code>static.cpp</code>，和之前一样声明一个函数<code>Function</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">static int s_variable = 5;</span><br><span class="line"></span><br><span class="line"><span class="addition">+void Function() {</span></span><br><span class="line"><span class="addition">+    </span></span><br><span class="line"><span class="addition">+};</span></span><br></pre></td></tr></tbody></table></figure><p>在<code>main.cpp</code>我们声明一个同样签名的函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-extern int s_variable;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+void Function() {</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line"><span class="deletion">-   std::cout &lt;&lt; s_variable &lt;&lt; std::endl;</span></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时我们尝试编译，会在链接阶段得到一个重复符号的错误，因为有两个<code>Function</code>函数：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210618090417145.png"></p><p>如果我把<code>static.cpp</code>标记为静态，当链接器开始链接时它根本不会看到这个静态函数，所以我不会得到任何错误：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">static int s_variable = 5;</span><br><span class="line"></span><br><span class="line"><span class="addition">+static void Function() {</span></span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这就是C++中静态的全部含义，当你在类和结构体之外使用静态时，它意味着当你声明静态函数或静态变量时它只会在被它声明的C++文件中被“看到”。</p><p>如果你想在头文件中声明一个静态变量并将该头文件包含在两个不同的C++文件中，你所做的就是和之前我所做的一样：在两个翻译单元中都声明了相同的<code>s_variable</code>变量为静态变量，因为当你包含那个头文件时它会复制所有内容并将其粘贴到C++文件中，你所做的是将一个静态变量放到两个不同的翻译单元中。</p><p>至于你为什么要用<code>static</code>，考虑一下为什么要在类中使用<code>private</code>？如果你不需要变量是全局变量，你就需要尽可能多地使用静态变量，因为一旦你在全局作用域下声明东西的时候，如果没有设定为<code>static</code>，那么链接器会跨编译单元进行链接，这意味着你已经创建了一个全局的变量，这可能会导致一些非常糟糕的bug。</p><p>归根到底，全局变量是不好的，但重点是要让函数和变量标记为静态的，除非你真的需要它们跨翻译单元链接。</p><h4 id="类-x2F-结构体中的静态"><a href="#类-x2F-结构体中的静态" class="headerlink" title="类/结构体中的静态"></a>类/结构体中的静态</h4><p>上次我们讨论了C++中的<code>static</code>关键字以及它在类或结构体之外的意义，今天我们讨论类或结构体中的静态。</p><p>如果它在一个类或一个结构体中，<code>static</code>到底是什么？在几乎所有面向对象的语言中静态在一个类中意味着特殊的东西，如果你把它和变量一起使用，意味着在类的所有实例中，这个变量只有一个实例。如果我创建一个名为<code>Entity</code>的类，不断创建<code>Entity</code>实例，我仍然只会得到那个变量的一个版本：意思是如果某个实例改变了这个静态变量，它会在所有实例中反映这个变化，这是因为尽管我已经创建了一大堆类的实例，只有一个变量。</p><p>正因如此，通过类实例来引用静态变量是没有意义的，因为这就像类的全局实例。静态方法也是一样，不需要通过类的实例就可以被调用，而在静态方法的内部你不能写引用到类实例的代码，因为你不能引用到类的实例。让我们来看些例子：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Entity e1 {<span class="number">5</span>,<span class="number">8</span>};</span><br><span class="line">    </span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e1.<span class="built_in">Print</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这里我写了一个<code>Entity</code>的结构体，包含两个整数<code>x</code>、<code>y</code>（这里我使用结构体，你也可以使用类。这里我选择结构体的原因是希望变量是<code>public</code>）。然后我们给<code>Entity</code>结构体一个函数<code>print</code>打印。</p><p>打印<code>e</code>和<code>e1</code>，我们应该得到2，3和5，8:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619082513364.png"></p><p>如果我让变量是静态的，事情就会改变。如果我来到这里把<code>x</code>和<code>y</code>变成静态的，这里的初始化就会失败，因为<code>x</code>和<code>y</code>不再是类成员：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Entity {</span><br><span class="line"><span class="addition">+   static int x;</span></span><br><span class="line"><span class="addition">+   static int y;</span></span><br><span class="line"></span><br><span class="line">    void Print() {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = 2;</span><br><span class="line">    e.y = 3;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   Entity e1 {5,8};</span></span><br><span class="line"><span class="addition">+   Entity e1;</span></span><br><span class="line"><span class="addition">+   e1.x = 5;</span></span><br><span class="line"><span class="addition">+   e1.y = 8;</span></span><br><span class="line"></span><br><span class="line">    e.Print();</span><br><span class="line">    e1.Print();</span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到我们引用了两个不同的实例，此时编译代码会报错，因为我们实际上需要在某个地方定义那些静态变量：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619083147989.png"></p><p>我们可以这样做，先写作用域<code>Entity</code>，再写变量名<code>x</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Entity {</span><br><span class="line">    static int x;</span><br><span class="line">    static int y;</span><br><span class="line"></span><br><span class="line">    void Print() {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="addition">+int Entity::x;</span></span><br><span class="line"><span class="addition">+int Entity::y;</span></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = 2;</span><br><span class="line">    e.y = 3;</span><br><span class="line"></span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = 5;</span><br><span class="line">    e1.y = 8;</span><br><span class="line"></span><br><span class="line">    e.Print();</span><br><span class="line">    e1.Print();</span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译代码，你会看到我们实际上打印了两次5，8：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619083611316.png"></p><p>这有点奇怪，因为在代码中第一个实例我们设定了2和3，第二个才是5和8。记住当我们让<code>x</code>和<code>y</code>变量为静态时，所有的<code>Entity</code>实例中只有一个这些变量的实例，这意味当我改变第二个<code>Entity</code>实例的<code>x</code>和<code>y</code>时它们实际上和第一个完全一致，它们指向的是相同的内存，两个不同的<code>Entity</code>实例它们的<code>x</code>和<code>y</code>指向同一个地方。</p><p>我们之前这样引用是没啥意义的，可以这样引用它们：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-e1.x = 5;</span></span><br><span class="line"><span class="deletion">-e1.y = 8;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+Entity::x = 5;</span></span><br><span class="line"><span class="addition">+Entity::y = 8;</span></span><br></pre></td></tr></tbody></table></figure><p>这就像我们在名为<code>Entity</code>的命名空间中创建了两个变量，它们实际上并不属于类。从这个意义上说，它们可以是<code>private</code>的，也可以是<code>public</code>的，它们仍然是类的一部分而不是命名空间。但无论出于何种目的，它们其实和在命名空间中一样，当你创建一个新的类的实例或者类似的东西时它们与任何分配无关。</p><p>我们重写一下代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity e;</span><br><span class="line">    Entity::x = <span class="number">2</span>;</span><br><span class="line">    Entity::y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Entity e1;</span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e1.<span class="built_in">Print</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到这些都没啥意义了。这也解释了为什么之前我们得到两个5和8，因为我们实际上在修改相同的变量。</p><p>这当然很有用，在你想要跨类使用变量时可以创建一个全局变量，或者不使用全局变量而是使用一个静态全局变量，它是在内部进行链接的，它不会在你的整个项目中是全局的，这样做会有同样的效果，那你为什么要在类中使用静态呢？</p><p>答案是把它们放在<code>Entity</code>中是有意义的，如果你有东西比如一条信息，你想要在所有的<code>Entity</code>实例之间共享数据或将它实际存储在<code>Entity</code>类中是有意义的，因为它与<code>Entity</code>有关。要组织好代码，你最好在这个类中创建一个静态变量而不是一些静态或全局的东西到处乱放。</p><p>静态方法的工作方式与此类似。如果我让这个<code>Print</code>方法变成静态，它会正常工作，因为你可以看到它指向的<code>x</code>和<code>y</code>它们也是静态变量，所以我们的调用方式也可以换一下：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-e.Print();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+Entity::Print();</span></span><br></pre></td></tr></tbody></table></figure><p>这是正确的调用方式。你也可以注意到，它会打印出相同的东西，因为我们运行了两次相同的方法，在这个例子中我们甚至根本不需要类实例：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity::x = <span class="number">2</span>;</span><br><span class="line">    Entity::y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">Print</span>();</span><br><span class="line">    Entity::<span class="built_in">Print</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们决定让<code>x</code>和<code>y</code>是非静态的，事情就变了。<code>Print</code>方法仍然保持<code>static</code>，但静态方法不能访问非静态变量，就是这样简单的原因。有些人可能会对静态的东西能访问什么非静态的东西感到困惑，它真的一点也不令人困惑。</p><p>返回我们的<code>Entity</code>实例重写代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">5</span>;</span><br><span class="line">    e1.y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">Print</span>();</span><br><span class="line">    Entity::<span class="built_in">Print</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们实际上对于<code>Entity</code>类的每个实例都有一个单独的<code>x</code>和<code>y</code>，但<code>Print</code>方法仍然保持静态。此时编译代码，我们会得到一个错误，可以看到是“非法引用非静态成员”：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619093455626.png"></p><p>因为你不能从静态方法访问它，原因是静态方法没有类实例。本质上，你在类中写的每一个非静态方法总是获得当前类的一个实例作为参数，这是类在幕后的实际工作方式。在类中你看不到这种东西，它们通过隐藏参数发挥作用，静态方法不会得到那个隐藏参数。</p><p>静态方法与在类外部编写方法相同，如果我在外面写一个<code>Print</code>方法，你就知道为什么不能访问<code>x</code>和<code>y</code>了：因为你不知道<code>x</code>、<code>y</code>是啥：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(Entity e)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; e.x &lt;&lt; <span class="string">","</span> &lt;&lt; e.y &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">		......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>想象你有同样的<code>Print</code>方法，但有一个<code>Entity</code>对象作为参数传入。这个方法本质上是非静态类方法在编译时的真实样子，而去掉参数<code>Entity e</code>正是我们将<code>static</code>关键字添加到类方法时所做的，这就是为什么会报错：它不知道你想要访问哪个<code>Entity</code>的<code>x</code>和<code>y</code>，因为你没有给它一个<code>Entity</code>的引用。</p><p><code>static</code>对于那些静态数据非常有用，这些数据不会在类实例之间发生变化，但实际上我们想要在类中使用它们。</p><h4 id="局部静态"><a href="#局部静态" class="headerlink" title="局部静态"></a>局部静态</h4><p>在前面几节我们了解了<code>static</code>关键字在特定上下文中的含义，今天我们看一看局部作用域中的<code>static</code>关键字。你可以在局部作用域中使用<code>static</code>来声明一个变量，这和我们之前看到的两种<code>static</code>有点不同，这次的局部静态（local static）会有更多的含义，声明一个变量需要考虑两种情况：变量的生存期和变量的作用域。</p><p>生存期指的是变量实际存在的时间，换句话说就是在它被删除之前，它会在我们的内存中存在多久。而变量的作用域是指我们可以访问变量的范围，当然，如果在一个函数内部声明一个变量我们不能在其他函数中访问它，因为我们声明的变量对于我们声明的函数是局部的。</p><p>静态局部（local static）变量允许我们声明一个变量，它的生存期基本上相当于整个程序的生存期，然而它的作用域被限制在这个函数内，但它其实和函数没有什么关系，我的意思是你可以在任何作用域中声明这个，刚才只是用函数举个例子，这并不仅仅局限在函数内部，也可以在<code>if</code>语句中，也可以在任何位置。</p><p>这就是为什么函数作用域中的<code>static</code>和类作用域中的<code>static</code>之间没有太大的区别，因为生存期实际上是相同的，唯一的区别是在类作用域中，类的任何东西都可以访问它（这个静态变量）；如果你在函数作用域中声明一个静态变量，那么它将是那个函数的局部变量，对类来说也是局部变量。</p><p>让我们来看一些例子。最简单的例子就是创建一个函数，然后在其中声明一些静态变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这意味着当我第一次调用函数时，这个变量将被初始化为0，然后所有对函数的后续调用实际上不会创建一个全新的变量。</p><p>检验这个最简单的方法是如果我打印<code>i</code>的值，然后每次调用函数时都增加<code>i</code>的值。如果我们暂时把<code>static</code>关键字去掉然后运行程序：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        <span class="built_in">Function</span>();</span><br><span class="line">    }</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619100918732.png"></p><p>运行程序，1被打印了五次。如果我们把<code>static</code>关键字加上，再次运行程序：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">void Function() {</span><br><span class="line"><span class="deletion">-   int i = 0;</span></span><br><span class="line"><span class="addition">+   static int i = 0;</span></span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210619102541655.png"></p><p>这种写法也可以写成下面这样（无论<code>i</code>静态与否），得到的效果是一样的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>{</span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        <span class="built_in">Function</span>();</span><br><span class="line">    }</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但这种方法的问题是我可以在任意地方访问<code>i</code>，这极大的改变了我们程序所做的事情。所以如果你想要做这些，但又不希望每个人都能访问这个变量，你可以在局部作用域下声明成<code>static</code>。</p><p>有些人不赞成使用这种方法，我不完全理解其中的原因，因为我不认为这有什么问题。它确实有它的用处，你可以使用其他方法实现完全相同的行为，比如可以使用类来实现，但你根本不必使用类来编写程序，局部静态确实让编程更轻松。</p><p>另一个例子是如果你有一个单例类（只存在一个实例的类），如果我想创建这个单例类而不使用静态局部作用域，我就需要创建静态的单例实例：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* s_Instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> *s_Instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::s_Instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></tbody></table></figure><p>现在我有了单例类，我可以调用<code>Singleton::Get</code>对它做任何我想做的事情：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* s_Instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> *s_Instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span>{}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::s_Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一切搞定，我们得到了一个可以使用的类实例，你可以用静态方式来使用它，你不一定要这么做。</p><p>另一种方式是使用我们的新知识局部静态local static：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span>{}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们得到了完全相同的行为，运行代码没有问题，你可以看到我们的代码现在干净多了。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>今天我们要讲的是C++的枚举。<code>enum</code>是enumeration的缩写，基本上它就是一个数据集合。如果你想要给枚举一个更实际的定义，他们是给一个值命名的一种方法，所以我们不用一堆叫做<code>a</code>、<code>b</code>、<code>c</code>的整数，我们可以有一个枚举数，它的值是<code>a</code>、<code>b</code>、<code>c</code>与整数对应。</p><p>它能帮助我们将一组数值集合作为类型，而不仅仅是用整型作为类型。当然，你可以给它赋值任何整数或者限制哪些值可以赋值。它只是一种命名值的方法，当你想要使用整数来表示某些状态或者某些数值时，它非常有用。不管怎么说，枚举数其实就是一个整数。</p><p>假设我有三个值想要处理，可能有一些代码来检查当前的<code>value</code>值是什么，然后执行某种操作：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> B = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> C = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> value = B;</span><br><span class="line">    <span class="keyword">if</span> (value == B) {</span><br><span class="line">        <span class="comment">// Do something here</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然而这段代码带来了一些问题。首先这些<code>A</code>、<code>B</code>、<code>C</code>根本没有分组，在代码后面的某个地方你可能会有一个<code>D</code>或者你可能想再次声明<code>A</code>，本质上最大的问题是这些根本没有分组。此外，它们只是整数，这意味着如果<code>int value = 5</code>下面的这些已经没有任何意义了。</p><p>我们希望本质上定义一个类型，只能是这三个数中的一种，而且能够把它们组合起来，这正是我们可以使用枚举的地方：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> {</span><br><span class="line">    A,B,C</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Example value = B;</span><br><span class="line">    <span class="keyword">if</span> (value == B) {</span><br><span class="line">        <span class="comment">// Do something here</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你不按照默认来搞，你也可以指定这些变量的值。默认的第一个是0，然后它一个接一个地递增：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> {</span><br><span class="line">    A = <span class="number">0</span>,</span><br><span class="line">    B = <span class="number">2</span>,</span><br><span class="line">    C = <span class="number">6</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如果你从一个非零的数字开始比如5，并且并没有指定其余的值，它会默认是6和7。我们还可以做的一件事是，指定你想要给枚举赋值的整数类型，你可以写一个冒号后接数据类型，例如<code>unsigned char</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> : <span class="type">unsigned</span> <span class="type">char</span> {</span><br><span class="line">    A = <span class="number">5</span>, B, C</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>枚举默认为32位整型，然而在这个例子中我们没有必要使用32位，我们可以使用8位的整数比如<code>unsigned char</code>减少内存的使用。你不能使用<code>float</code>，因为它不是整数，枚举必须是一个整数比如<code>char</code>。</p><p>这就是枚举的本质，它只是给特定的值命名的一种方式，这样你就不必在各种地方处理各种整数。让我们把枚举用在之前的日志里：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>{</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelError)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"[ERROR]: "</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"[WARNING]: "</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"[INFO]: "</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们在这里使用了三个不同的<code>Log</code>级别，而它们只是整数0、1、2，这是一个非常适合使用枚举的地方，因为我们有三个值，用它们作为整数来表示某个状态。这个例子中日志级别的意思是指会展示哪种级别的日志：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Log {</span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   enum Level{</span></span><br><span class="line"><span class="addition">+       ERROR = 0,</span></span><br><span class="line"><span class="addition">+       WARNING = 1,</span></span><br><span class="line"><span class="addition">+       INFO = 2</span></span><br><span class="line"><span class="addition">+   };</span></span><br><span class="line">    </span><br><span class="line"><span class="deletion">-   const int LogLevelError = 0;</span></span><br><span class="line"><span class="deletion">-   const int LogLevelWarning = 1;</span></span><br><span class="line"><span class="deletion">-   const int LogLevelInfo = 2;</span></span><br><span class="line">private:</span><br><span class="line"><span class="deletion">-   int m_LogLevel = LogLevelInfo;</span></span><br><span class="line"><span class="addition">+   Level m_LogLevel = INFO;</span></span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   void SetLevel(Level level){</span></span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Error(const char* message){</span><br><span class="line"><span class="addition">+       if (m_LogLevel &gt;= ERROR)</span></span><br><span class="line">            std::cout &lt;&lt; "[ERROR]: " &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Warn(const char* message){</span><br><span class="line"><span class="addition">+       if (m_LogLevel &gt;= WARNING)</span></span><br><span class="line">            std::cout &lt;&lt; "[WARNING]: " &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Info(const char* message){</span><br><span class="line"><span class="addition">+       if (m_LogLevel &gt;= INFO)</span></span><br><span class="line">            std::cout &lt;&lt; "[INFO]: " &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Log log;</span><br><span class="line"><span class="addition">+   log.SetLevel(Log::ERROR);</span></span><br><span class="line">    log.Warn("Hello!");</span><br><span class="line">    log.Error("Hello!");</span><br><span class="line">    log.Info("Hello!");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这个枚举<code>Level</code>本身不是一个命名空间，这叫做枚举类。然而对于普通的枚举而言，这个<code>Level</code>并不是真正的命名空间，所以你不能把它当作一个命名空间，这意味着<code>ERROR</code>、<code>WARNING</code>和<code>INFO</code>只存在于这个日志类中。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>今天我们继续学习C++面向对象编程，包括像类、构造函数所有这些东西。那什么是构造函数呢？构造函数基本上是一种特殊类型的方法，它在每次实例化对象时运行，让我们来看个例子。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>假设我们想要创建一个<code>Entity</code>类并在主函数中实例化打印：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210626131612993.png"></p><p>这里得到<code>Entity</code>的位置，看似是随机的值。这是因为我们实例化<code>Entity</code>并为它分配内存时，我们实际上并没有初始化那个内存，这意味着我们得到了那个内存空间里原来的那些东西，我们可能想做的是初始化内存将其设置为0之类的，这样位置就默认为0。</p><p>我们已经知道需要某种初始化，需要一种方法当构造<code>Entity</code>实例时把<code>x</code>和<code>y</code>设为零。我们来创建一个叫<code>Init()</code>的方法，它将设置两者的值：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">public:</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   void Init() {</span></span><br><span class="line"><span class="addition">+       x = 0.0f;</span></span><br><span class="line"><span class="addition">+       y = 0.0f;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">    </span><br><span class="line">    void Print() {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity e;</span><br><span class="line"><span class="addition">+   e.Init();</span></span><br><span class="line">    e.Print();</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210627232258711.png"></p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>我们额外编写了相当多的代码，需要定义<code>Init()</code>方法。每当我们想在代码中创建一个<code>Entity</code>对象（实例）都意味着我们需要实际运行<code>Init()</code>函数，相当多的代码代表着相当地不清爽。</p><p>当我们构造对象时，如果我们有办法直接运行这个初始化代码就好了，于是就有了构造函数。</p><p>构造函数时一种特殊类型的方法，每一次你构造一个对象都会调用这个方法。我们像定义其他方法一样定义它，然而它没有返回类型，并且它的名字必须与类的名称相同：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">public:</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   Entity() {</span></span><br><span class="line"><span class="addition">+       x = 0.0f;</span></span><br><span class="line"><span class="addition">+       y = 0.0f;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   void Init() {</span></span><br><span class="line"><span class="deletion">-       x = 0.0f;</span></span><br><span class="line"><span class="deletion">-       y = 0.0f;</span></span><br><span class="line"><span class="deletion">-   }</span></span><br><span class="line"></span><br><span class="line">    void Print() {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity e;</span><br><span class="line"><span class="deletion">-   e.Init();</span></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; e.x &lt;&lt; "," &lt;&lt; e.y &lt;&lt; std::endl;</span></span><br><span class="line">    e.Print();</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629083055729.png"></p><p>运行代码可以看到我们得到的结果和<code>Init()</code>方法得到的结果是一样的，现在初始化函数可以被构造函数替代了。</p><p>如果不指定构造函数，你仍然有一个构造函数，它是一个叫默认构造函数的东西，默认情况下它已经为你准备好了。然而这个构造函数实际上什么都没做，它基本等于：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Entity</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>像Java等语言中数据基本类型（如<code>int</code>和<code>float</code>）会自动初始化为0，但C++的情况并非如此，你必须手动初始化所有基本类型，否则它们将被设置为留在该内存中的其他值。所以初始化非常重要，一定不要忘记。</p><h4 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h4><p>我们来看一下带参数的构造函数，可以写很多个构造函数，前提是它们有不同的参数。这叫做函数重载，即有相同的函数（方法）名，但是有不同的参数的不同函数版本。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(<span class="type">float</span> x,<span class="type">float</span> y) {</span><br><span class="line">  <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">  <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们把<code>x</code>和<code>y</code>赋值，把参数赋值给了我们的成员变量。现在我可以选择使用参数来构造<code>Entity</code>对象了：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">public:</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    Entity() {</span><br><span class="line">        x = 0.0f;</span><br><span class="line">        y = 0.0f;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   Entity(float x,float y) {</span></span><br><span class="line"><span class="addition">+       this-&gt;x = x;</span></span><br><span class="line"><span class="addition">+       this-&gt;y = y;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line">    void Print() {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line"><span class="addition">+   Entity e(10,5);</span></span><br><span class="line"><span class="deletion">-   std::cout &lt;&lt; e.x &lt;&lt; "," &lt;&lt; e.y &lt;&lt; std::endl;</span></span><br><span class="line">		e.Print();</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629084412052.png"></p><p>如果不实例化对象，构造函数将不会运行，所以如果你只使用一个类的静态方法，它不会运行。当然，当使用<code>new</code>关键字创建一个对象实例时，它也会调用构造函数。</p><p>这里也有一些方法可以删除构造函数，例如你有一个<code>Log</code>类，它只有静态的日志方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">()</span> </span>{</span><br><span class="line">        </span><br><span class="line">    } </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    </span><br><span class="line">    Log::<span class="built_in">write</span>();</span><br><span class="line">    Log l;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我只是想让人们像这样使用我的<code>Log</code>类，不希望人们创建实例。有两种不同的解决方法，我们可以通过设置为<code>private</code>来隐藏构造函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Log {</span><br><span class="line"><span class="addition">+private:</span></span><br><span class="line"><span class="addition">+		Log() {</span></span><br><span class="line"><span class="addition">+		</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line">public:</span><br><span class="line">    static void write() {</span><br><span class="line">        </span><br><span class="line">    } </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    </span><br><span class="line">    Log::write();</span><br><span class="line">    Log l;</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629085153097.png"></p><p>可以看到这里得到一个错误，因为我不能访问构造函数。C++为我们提供了一个默认的构造函数，然而我们可以告诉编译器：“不，我不想要那个默认构造函数”：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Log {</span><br><span class="line"><span class="deletion">-private:</span></span><br><span class="line"><span class="deletion">-		Log() {</span></span><br><span class="line"><span class="deletion">-		</span></span><br><span class="line"><span class="deletion">-		}</span></span><br><span class="line">public:</span><br><span class="line"><span class="addition">+		Log() = delete;</span></span><br><span class="line">		</span><br><span class="line">    static void write() {</span><br><span class="line">        </span><br><span class="line">    } </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    </span><br><span class="line">    Log::write();</span><br><span class="line">    Log l;</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629085538328.png"></p><p>我们同样不能调用<code>Log</code>，因为默认构造函数实际上并不存在，已经被删除掉了。</p><p>还有一些特殊类型的构造函数比如赋值构造函数还有移动构造函数，之后我们会讲。对于基本的使用，这就是构造函数：一个特殊的方法，当你创建类的实例时运行。它的主要用途是初始化该类，当你创建一个新的对象实例时，构造函数确保你初始化了所有的内存，做所有你需要做的设置。</p><h4 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h4><p>今天我要讲的是构造函数初始化列表，这是我们在构造函数中初始化类成员（变量）一种方式。因此当我们编写一个类并向该类添加成员时，通常需要用某种方式对这些成员变量进行初始化。这通常在构造函数中，有两种方法，我们可以在构造函数中初始化一个类成员，让我们来看一看。</p><p>我们有一个 <code>Entity</code> 类，它只有 <code>name</code> 成员变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() {</span><br><span class="line">        name = <span class="string">"UNKOWN"</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这可能是你之前一直在做的方式，但 C++ 中实际上还有另外一种方法：成员初始化列表。与上面设置 <code>name</code> 不同，在构造函数和参数之后我们可以添加一个冒号，然后开始列出你想要初始化的成员：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">private:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   Entity() : name("UNKOWN") {</span></span><br><span class="line"><span class="deletion">-       name = "UNKOWN";</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   Entity(const std::string&amp; name) : name(name) {</span></span><br><span class="line"><span class="deletion">-       this-&gt;name = name;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    const std::string&amp; getName() const {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line"><span class="addition">+   Entity e0;</span></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; e0.getName() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   Entity e1("YOUSAZOE");</span></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; e1.getName() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210709121151471.png"></p><p>这就是成员初始化列表的方式。如果我们有另一个成员比如 <code>score</code>，只需要加一个逗号然后写上这个成员，在这种情况下我把它初始化为0：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">private:</span><br><span class="line"><span class="addition">+   int score;</span></span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   Entity() : name("UNKOWN"), score(0) {</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Entity(const std::string&amp; name) : name(name) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    const std::string&amp; getName() const {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是如果你定义这些变量，那么你在成员初始化列表中要按照顺序写，否则有些编译器会警告你。这很重要，因为不管你怎么写初始化列表，它都会按照定义类成员的顺序进行初始化。</p><p>在这个例子中，首先初始化整数 <code>score</code>，然后初始化字符串 <code>name</code>。即便你在初始化列表的时候，用另一种方式来初始化列表，比如先初始化字符串再初始化整数，会导致各种各样的依赖性问题，所以你要确保你做成员初始化列表时，要与成员变量声明时的顺序一致。</p><p>最大的问题是为什么我们要使用这个成员初始化列表，只是代码风格的问题吗？答案是对，又不对，不对可能更加正确。我喜欢这样写代码，因为如果你有很多成员变量，在函数体内初始化它们会变得非常凌乱，你的构造函数大部分内容都只是在初始化变量，都是些琐碎无聊的事情，可能很难看出构造函数到底在做什么：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">private:</span><br><span class="line">    int score;</span><br><span class="line"><span class="addition">+   int x, y, z;</span></span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Entity() : name("UNKOWN"), score(0) {</span><br><span class="line"><span class="addition">+       x = 0;</span></span><br><span class="line"><span class="addition">+       y = 0;</span></span><br><span class="line"><span class="addition">+       z = 0;</span></span><br><span class="line">        </span><br><span class="line"><span class="addition">+       Init();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Entity(const std::string&amp; name) : name(name) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    const std::string&amp; getName() const {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>你会想隐藏它们，这就是为什么我喜欢把它们放在成员初始化列表中。即使从代码风格的角度来看，我也更喜欢这样，它让我的构造函数非常干净，易于阅读：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">private:</span><br><span class="line">    int score;</span><br><span class="line">    int x, y, z;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   Entity() : score(0), name("UNKOWN"), x(0), y(0), z(0) {</span></span><br><span class="line"><span class="deletion">-       x = 0;</span></span><br><span class="line"><span class="deletion">-       y = 0;</span></span><br><span class="line"><span class="deletion">-       z = 0;</span></span><br><span class="line"></span><br><span class="line">        Init();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Entity(const std::string&amp; name) : name(name) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    const std::string&amp; getName() const {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>但实际上在特定的类的情况下有一个功能上的区别，如果我们稍微修改一下去掉成员初始化列表中的赋值：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">private:</span><br><span class="line">    int score;</span><br><span class="line">    int x, y, z;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   Entity() : x(0), y(0), z(0) {</span></span><br><span class="line"><span class="addition">+       name = "UNKOWN";</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Entity(const std::string&amp; name) : name(name) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    const std::string&amp; getName() const {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>实际上会发生的是这个 <code>name</code> 对象会被构造两次，一次是使用默认构造函数，然后是这个用 <code>UNKOWN</code> 参数初始化，实际上发生的是这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">name = std::<span class="built_in">string</span>(<span class="string">"UNKOWN"</span>);</span><br></pre></td></tr></tbody></table></figure><p>所以你创建了2个字符串，其中一个被直接扔掉了。这是对性能的浪费，让我们演示一下。我要在这里创建一个 <code>Example</code> 类，有两个 <code>public</code> 构造函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+class Example {</span></span><br><span class="line"><span class="addition">+public:</span></span><br><span class="line"><span class="addition">+   Example() {</span></span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; "Created Entity!" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">    </span><br><span class="line"><span class="addition">+   Example(int x) {</span></span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; "Created Entity with " &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"><span class="addition">+};</span></span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">private:</span><br><span class="line"><span class="deletion">-   int score;</span></span><br><span class="line"><span class="deletion">-   int x, y, z;</span></span><br><span class="line">    std::string name;</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   Example example;</span></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Entity() {</span><br><span class="line">        name = "UNKOWN";</span><br><span class="line"><span class="addition">+       example = Example(8);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Entity(const std::string&amp; name) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    const std::string&amp; getName() const {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity e0;</span><br><span class="line"><span class="deletion">-   std::cout &lt;&lt; e0.getName() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   Entity e1("YOUSAZOE");</span></span><br><span class="line"><span class="deletion">-   std::cout &lt;&lt; e1.getName() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我所做的只是创建一个 <code>Entity</code> 对象的实例，使用这个默认构造函数。运行程序：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210709145146053.png"></p><p>我们创建了两个 <code>Entity</code>，一个是无参的，一个是有整型参数的。这两个实际产生的 <code>Entity</code>一个是源自这里：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Example example;</span><br><span class="line">		......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>另一个我们在这里创建了一个新的 <code>Example</code> 实例，然后把它赋值给 <code>example</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line">		......</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() {</span><br><span class="line">        ......</span><br><span class="line">        example = <span class="built_in">Example</span>(<span class="number">8</span>);</span><br><span class="line">    }</span><br><span class="line">		......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>但是我们刚刚创建了一个 <code>Example</code> 类实例，相当于我们又扔掉它，用一个新的对象覆盖它。然而如果我们把它移到初始化列表中：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">private:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    Example example;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   Entity() : example(Example(8)){</span></span><br><span class="line">        name = std::string("UNKOWN");</span><br><span class="line"><span class="deletion">-       example = Example(8);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Entity(const std::string&amp; name) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    const std::string&amp; getName() const {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210709145852556.png"></p><p>我们运行构造函数，只是创建了一个实例。甚至我可以把这个删掉，直接传入参数，你可以看到是完全一样的：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   Entity() : example(8){</span></span><br><span class="line">        name = std::string("UNKOWN");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这就是区别。你应该到处使用成员初始化列表，相反绝对没有理由不使用它们。如果你不喜欢这种代码风格，要习惯它们，因为这不仅仅是风格的问题，实际上有一个功能上的区别，如果不使用它们就会浪费性能。</p><p>当然，并非所有情况都是如此。对于整数这样的基本类型，它不会被初始化，除非你通过赋值来初始化它们，但我不会区分原始类型和类类型，全部使用成员初始化列表。</p><h4 id="创建并初始化对象"><a href="#创建并初始化对象" class="headerlink" title="创建并初始化对象"></a>创建并初始化对象</h4><p>今天讲讨论如何用 C++ 创建对象。C++ 给了我们一些创建对象的方法，当我们写完一个类，就该开始使用我们创建的类了，通常我们需要实例化它，除非它是完全静态的，但我们不讨论这个。</p><p>我们需要实例化一个类，该怎么做呢？我们基本上有两个选择，这两个选择之间的区别是内存是从哪里来的、我们在哪里创建对象。当我们创建一个 C++ 对象时，它需要占用一些内存，即使我们写一个完全为空的类，类中没有成员，什么都没有，它也至少要占用一个字节的内存。</p><p>但同情况并非如此，我们的类中有很多成员，它们需要存储在某地方。当我们决定开始使用这个对象时，我们会创建一堆变量，对象有一堆变量，我们需要在电脑的某个地方分配内存，这样我们就可以记住这些变量设置的值。</p><p>应用程序会将内存主要分为两部分：堆和栈。还有其他部分的内存如源码的区域，这些都是机器代码，它们都很重要，但现在我们就考虑堆和栈。在 C++ 中我们要选择对象要放在哪里，对象是在栈上还是堆上创建，它们有不同的功能差异。比如栈对象有一个自动的生存周期，它们的生存周期实际上是由它声明的地方作用域决定的，只要变量超出作用域，也就是说内存被释放了，因为当作用域结束的时候，栈会弹出作用域里的东西，栈上的任何东西会被释放。</p><p>但堆不同的，堆是个很大的神秘的地方。一旦在堆中分配一个对象，实际上你已经在堆上创建了一个对象，它会一直待在那里直到你做出决定：“我不需要它了，我想释放这个对象”，你想怎么处置那段内存都行。</p><p>让我们看看这两种创建对象的方法的代码是什么样子的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">name</span>(<span class="string">"UNKNOWN"</span>) {}</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name) :<span class="built_in">name</span>(name) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我有一个叫 <code>Entity</code> 的类，有一个成员字符串 <code>name</code>。然后我们有一个构造函数，它不接受任何参数，另一个构造函数它接受一个字符串 <code>name</code> 作为参数。最后我们还有一个简单的 <code>getName()</code> 方法，这就是这个简单类的组成。</p><p>现在让我们在 <code>main</code> 函数中在栈上创建它，键入实例化的类的类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity entity;</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样写实际上调用了默认构造函数。如果你来自 C# 和 Java 语言，这个代码可能看起来有些奇怪，事实上这可能会导致所谓的空指针异常或空引用异常，因为它看起来就像我们根本没有初始化对象，但是实际上我们可以，因为我们有默认构造函数，这代码完全 OK。</p><p>现在我们可以调用 <code>entity.getName()</code> ，这种情况下我们会得到 “UNKNOWN”：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    Entity entity;</span><br><span class="line"><span class="addition">+   entity.getName();</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210714165907398.png"></p><p>如果我们想要指定一个参数，我们只需要给一个参数调用另一个构造函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line"><span class="addition">+   Entity entity = Entity("YOUSAZOE");</span></span><br><span class="line">    std::cout &lt;&lt; entity.getName() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210714170141707.png"></p><p>那么我们什么时候这样创建对象？答案是几乎所有的时候，如果你能像这样创建对象，那就像这样创建对象，这是基本的规则。因为这是 C++ 中最快的方法，也是可以“管控”的方法去初始化对象。</p><p>现在的问题是，某些情况下你不能这么做。其中一个原因是如果你想把它放到这个函数生存期之外比如另一个函数 <code>Function()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>{</span><br><span class="line">    Entity entity = <span class="built_in">Entity</span>(<span class="string">"YOUSAZOE"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一旦我们到达这个花括号，这个 <code>entity</code> 会从内存中被销毁。因为当我们调用 <code>Function()</code> 时就为这个函数创建了一个栈结构，它包含了我们声明的所有局部变量，包括基本类型和我们的类和对象。当这个函数结束时，栈会被销毁，也就是说栈上所有的内存所有创建的变量都消失了，因此我们写一些会失败的代码：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line"><span class="addition">+   Entity* e;{</span></span><br><span class="line">        Entity entity = Entity("YOUSAZOE");</span><br><span class="line"><span class="addition">+       e = &amp;entity;</span></span><br><span class="line">        std::cout &lt;&lt; entity.getName() &lt;&lt; std::endl;</span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210714172447949.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210714173036506.png"></p><p>这个叫 <code>YOUSAZOE</code> 的 <code>entity</code> 已经不存在了，我们到达栈的末端，这就是 <code>YOUSAZOE</code> 的末日。因此，如果我们想让这个 <code>YOUSAZOE</code> 在作用域之外依然存在，就不能分配到栈上，我们讲不得不求助于堆分配。</p><p>另一个我们不想分配到栈的原因是，如果这个 <code>entity</code> 的规模太大，而且我们可能有太多的 <code>entity</code>，我们可能没有足够的空间在栈上分配，因为栈通常非常小，通常1兆或2兆，这取决于你的平台和编译器。但如果你有这么大的类或你想有一千个这样的类（对象），栈上可能没有足够的空间，因此可能必须在堆上进行分配。</p><p>让我们来看看堆分配：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    Entity* e;{</span><br><span class="line"><span class="addition">+       Entity* entity = new Entity("YOUSAZOE");</span></span><br><span class="line"><span class="addition">+       e = entity;</span></span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; entity-&gt;getName() &lt;&lt; std::endl;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line"><span class="addition">+   delete e;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们想把这代码转换成在堆上分配，我们首先要做的是改变类型为 <code>Entity*</code>，然后我们使用 <code>new</code> 关键字。这里最大的区别不是那个类型变成了指针，而是这个 <code>new</code> 关键字。</p><p>当我们调用 <code>new Entity()</code> 时，我们会在堆上分配内存，调用构造函数返回一个 <code>Entity*</code>，而这也是 Java 和 C# 语言的码农做的事情。你不应该到处使用 <code>new</code> 关键字，简单来说就是性能问题，在堆上分配要比栈花费更长的时间，而且在堆上分配的话你必须手动释放被分配的内存。</p><p>这就是我们创造对象的两种方法，如何选择呢？如果对象太大或你要显式地控制对象的生存周期，那么就在堆上创建；否则就在栈上分配吧，栈上创建简单多了，自动化而且更快。</p><h4 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h4><p>这个 <code>new</code> 关键词很有趣，因为它实际上很深奥。这里有很多人他们不会去想这个问题，但还是有很多东西非常重要，需要理解，特别是你用 C++ 来编程。</p><p>事实上你在编写 C++ 程序时，你应该关心内存、性能和优化等问题，因为如果你不关心这些，那你为什么要用 C++ 呢？有很多其他的语言你可以用，尤其是现在2021年，你为什么要写 C++？除非你特别需要性能或者你要掌握一切。</p><p>那你就要知道，<code>new</code> 关键字是非常非常重要的，特别是如果你来自 Java 或 C# 这样的托管语言，内存会自动清理。但在内存方面，你也没那么多控制能力，这可不像是在 C++ 中。所以对于那些懂 Java 或 C# 的人，你总是习惯用 <code>new</code>，那你用 C++ 的时候可能会想：“C++ 也不是最困难的嘛”。</p><p><code>new</code> 的主要目的是在堆上分配内存。你写了 <code>new</code> 然后写上数据类型，根据你所写，不管它是一个类，还是一个基本类型，还是一个数组，它决定了必要的分配大小，以字节为单位，例如通过写一个 <code>new int</code>，它需要4个字节的内存。一旦它有了它要处理的数字，它会询问你的操作系统：“我需要四个字节的内存，请把它给我”。</p><p>这就是乐趣的开始，现在我们需要找到一个包含四个字节内存的连续块，当然四个字节的内存很容易找到，所以分配起来也很快，但它仍然需要在一行内存中找到4个字节的地址空间。一旦这样找到之后，它会返回一个指向这个内存的指针，这样你就可以开始使用你的数据并在那里存储数据，进行读写访问，做所有这些有趣的事情。</p><p>当你调用 <code>new</code> 时，将消耗时间。我说过，我们必须寻找四个字节的连续内存，但这并不是搜索内存就像激光扫过一行那样，而是有一种叫做空闲列表的东西，它会维护那些有空闲字节的地址。这是主要的方法，<code>new</code> 就是找到一个足够大的内存块已满足我们的需求，然后给我们一个指向那块内存的指针。</p><p>让我们看一些代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">name</span>(<span class="string">"UNKNOWN"</span>) {}</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name) :<span class="built_in">name</span>(name) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我有一个非常基本的类，只有一个 <code>name</code> 字符串，之前几次课也用过。</p><p>就像我们平常创建整数那样，我们也可以选择动态分配内存，并通过 <code>new</code> 关键字在堆上创建：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>; </span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一个单一的四字节在堆上分配，这个 <code>b</code> 存储的是它的内存地址。如果我想分配一个数组，那就价格方括号，然后输入我想要多少元素：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>]; </span><br></pre></td></tr></tbody></table></figure><p>这个例子中是50，也就是我们需要200字节内存。如果我们想在堆上分配我们的 <code>Entity</code> 类，可以通过新的关键字 <code>new</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Entity* e0 = <span class="keyword">new</span> Entity;</span><br><span class="line">Entity* e1 = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="string">"YOUSAZOE"</span>);</span><br><span class="line">Entity* e2 = <span class="keyword">new</span> Entity[<span class="number">50</span>];</span><br></pre></td></tr></tbody></table></figure><p><code>new</code> 关键字不仅分配内存，还调用构造函数。查看它的定义就会知道，<code>new</code> 是一个操作符就像加减乘除一样，这意味着你可以重载这个操作符，并改变它的行为，之后我们会讲到操作符重载。</p><p>其次 <code>new</code> 返回的是空指针，它是一个没有类型的指针。指针指示一个内存地址，指针之所以需要类型，是因为你需要类型来操纵它。</p><p>不仅如此，通常调用 <code>new</code> 会调用里面隐藏的 c 函数 <code>malloc()</code>，它代表内存分配以及它实际作用，传入一个 <code>size</code> 也就是我们想要多少字节，然后返回一个 <code>void</code> 指针：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">50</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210715212054849.png"></p><p>这代码实际上相当于我们写了：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Entity* e = <span class="built_in">Entity</span>();</span><br><span class="line">Entity* e0 = (Entity*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Entity));</span><br></pre></td></tr></tbody></table></figure><p>这两行代码之间的仅有区别是前者调用了 <code>Entity</code> 构造函数，而后者做的仅仅是分配内存，然后给我们一个指向那个内存的指针，没有调用构造函数。</p><p>你不应该在 C++ 中这样分配内存，在某些情况下你可能希望这样做，我们以后再谈，但是现在对你来说还是用 <code>new</code> 吧。</p><p>关于 <code>new</code> 最后一点是当你使用 <code>new</code> 关键字时必须要使用 <code>delete</code>。一旦我们分配了所有这些变量比如 <code>b</code> 或 <code>e</code>，我们必须使用 <code>delete</code> 关键字（它也是一个操作符）。它是一个常规函数，它申请调用了 C 语言的 <code>free()</code> 释放 <code>malloc()</code> 申请的内存。</p><p>这一点很重要，因为当我们使用 <code>new</code> 关键字时内存未释放，它不会被放回空闲列表，所以就不能被 <code>new</code> 调用后再分配直到我们调用 <code>delete</code>，我们必须手动操作。当然，很多 C++ 的策略可以让这个过程自动化。有简单的策略，比如基于作用域的指针；也有一些高级策略，比如引用计数。</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>上次我们讨论了构造函数，包括它们是什么以及如何使用它们。今天我们要讨论一下它邪恶的孪生兄弟，析构函数，它们很相似：</p><ul><li>构造函数是你创建一个新的实例对象时运行；而析构函数时在销毁对象时运行，所以任何时候，一个对象要被销毁时将调用析构函数</li><li>构造函数通常是设置变量或者做任何你需要的初始化；同样的，析构函数是你写在变量等东西，并清理你使用过的内存</li><li>析构函数同时适用于栈和堆分配的对象。如果你使用<code>new</code>分配一个对象，当你调用<code>delete</code>时析构函数将会被调用；而如果只是一个栈对象，当作用域结束时栈对象将被删除，这时析构函数也会被调用</li></ul><p>让我们为之前的<code>Entity</code>类添加一个析构函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">~<span class="built_in">Entity</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>构造函数和析构函数在声明与定义时唯一区别，就是放在析构函数前面的波浪号，有了这个符号<code>~</code>，你就知道这是析构了。</p><p>在这个例子中我们只有一个简单的类，有两个成员<code>x</code>和<code>y</code>。当我们为这两个浮点变量申请内存的时候，完全没有考虑之后怎么清除内存，我们会在之后讨论内存分配等复杂问题。</p><p>我们继续添加两条消息，告诉我们对象已经被创建或删除：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">public:</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    Entity() {</span><br><span class="line">        x = 0.0f;</span><br><span class="line">        y = 0.0f;</span><br><span class="line">        </span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; "Created Entity!" &lt;&lt; std::endl;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   Entity(float x,float y) {</span></span><br><span class="line"><span class="deletion">-       this-&gt;x = x;</span></span><br><span class="line"><span class="deletion">-       this-&gt;y = y;</span></span><br><span class="line"><span class="deletion">-   }</span></span><br><span class="line"></span><br><span class="line">    ~Entity() {</span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; "Destroyed Entity!" &lt;&lt; std::endl;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Print() {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity e;</span><br><span class="line">    e.Print();</span><br><span class="line">    </span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为这是栈分配的，只有当主函数退出时析构函数才会被调用，所以我们实际上不会看到，因为我们的程序会在那之后立即结束。所以我要写一个<code>Function()</code>函数，它将执行<code>Entity</code>的相关操作：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+void Function() {</span></span><br><span class="line"><span class="addition">+   Entity e;</span></span><br><span class="line"><span class="addition">+   e.Print();</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line"><span class="deletion">-   Entity e;</span></span><br><span class="line"><span class="deletion">-   e.Print();</span></span><br><span class="line"><span class="addition">+   Function();</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629093357666.png"></p><p>让我们更深入地看看它是如何工作的。我在25行放一个断点开始调试：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629093612094.png"></p><p>可以看到现在控制台啥都没有，继续走下去：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629093758366.png"></p><p>我们看到<code>Entity</code>被创建，构造函数被调用的结果。接着走下去：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629095135161.png"></p><p>这里调用<code>Print()</code>打印两个成员变量数值。再往下走：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629095841847.png" alt="image-20210629095841847"></p><p>最后作用域到此结束，我们要跳回30行：我们函数返回的地方。因为它的对象是在栈上创建的，当超出作用域时它会被自动销毁，也就是对象<code>e</code>，同时析构函数被调用。</p><p>这就是析构函数的本质，它只是一个特殊函数或方法，在对象被销毁时调用。为什么我们要写析构函数呢？因为如果在构造函数中调用了特定的初始化代码，你可能想要在析构函数中卸载或销毁所有这些东西，否则可能会造成内存泄漏。</p><p>这个方面一个很好的例子是在堆上分配的对象，如果你已经在堆上手动分配了任何类型的内存，那么你需要手动清理。如果在<code>Entity</code>类使用中或构造中分配了内存，你可能要在析构函数中删除内存，因为当析构函数调用时那个实例对象消失了。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象编程是一个巨大的编程范式，类之间的继承是它的一个基本方面，它是我们可以实际利用的最强大的特性之一。继承运行我们有一个相互关联的类的层次结构，换句话说它允许我们有一个包含公共功能的基类，然后它允许我们从那个基类中分离出来，从最初的父类中创建子类。</p><p>继承如此有用的主要原因是它可以帮助我们避免代码重复。代码重复是指我们必须多次写完全相同的代码或者只是可能会略有不同，本质是完全一样的东西。我们不需要一遍又一遍地重复自己，我们可以把类之间的所有公共功能放在一个父类中，然后从基类（父类）创建（派生）一些类，稍微改变下功能或者引入全新的功能。继承给我们提供了这样一种方法，将这些公共代码放到基类中，这样我们就不用像写模版那样不断重复了，让我们来看看如何定义它。</p><p>假设我有一个<code>Entity</code>类，它将管理游戏中所有的实体对象。在游戏中我们有很多非常具体的实体，然而在某些方面它们将共享功能。例如每个实体在游戏中都有自己的位置，这可以通过两个<code>float</code>数来表达：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可能想赋予每个实体移动的能力，可通过<code>move()</code>方法，将移动位置作为参数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">float</span> dx,<span class="type">float</span> dy)</span> </span>{</span><br><span class="line">	x += dx;</span><br><span class="line">	y += dy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们有了一个基类<code>Entity</code>，在游戏中创建的每一个实体都将具有这些特征。让我们继续创建一个新类型的实体，例如一个<code>Player</code>类：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">float</span> dx,<span class="type">float</span> dy)</span> </span>{</span><br><span class="line">        x += dx;</span><br><span class="line">        y += dy;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>此时还没有继承。如果我们从零开始，我们希望它也有位置以及移动，和<code>Entity</code>非常相似。也许这个<code>Player</code>类有我们想要额外存储的数据，例如名字<code>name</code>。</p><p>这实际上是不同的类了，然而有相当多的代码只是被复制粘帖。所以我们能做的就是利用继承的力量，扩展这个<code>Entity</code>实体类来创建一个名为<code>Player</code>的新类型，然后让它存储新数据以及提供额外的功能，例如打印名字：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Player {</span><br><span class="line">public:</span><br><span class="line">    const char* name;</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    void move(float dx,float dy) {</span><br><span class="line">        x += dx;</span><br><span class="line">        y += dy;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   void printName() {</span></span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; name &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在让我们把<code>Player</code>变成<code>Entity</code>的子类。我们在类型声明后面写一个冒号<code>:</code>，然后我们写<code>public Entity</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+class Player : public Entity{</span></span><br><span class="line">public:</span><br><span class="line">    const char* name;</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    void move(float dx,float dy) {</span><br><span class="line">        x += dx;</span><br><span class="line">        y += dy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void printName() {</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在我们写的这行代码中发生了一些事情，<code>Player</code>类现在不仅拥有<code>Player</code>类型，而且它也有<code>Entity</code>类型，意思是现在是两种类型了。</p><p>类型在C++中是相当复杂的主题，因为一方面它们实际上并不存在，然而另一方面它们又会搞事，特别是你有特定的运行时标记激活的话，那个时候我们再去深入了解这整个东西时如何工作的。</p><p><code>Player</code>现在拥有<code>Entity</code>拥有的所有东西，所以我们拥有所有的类成员<code>x</code>、<code>y</code>，让我们把重复的代码都去掉：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Player : public Entity{</span><br><span class="line">public:</span><br><span class="line">    const char* name;</span><br><span class="line"><span class="deletion">-   float x;</span></span><br><span class="line"><span class="deletion">-   float y;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   void move(float dx,float dy) {</span></span><br><span class="line"><span class="deletion">-       x += dx;</span></span><br><span class="line"><span class="deletion">-       y += dy;</span></span><br><span class="line"><span class="deletion">-   }</span></span><br><span class="line"></span><br><span class="line">    void printName() {</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这样<code>Player</code>类看起来很干净了，然而它实际上是一个<code>Entity</code>，这意味着仅仅看这个类并不能告诉我们整个故事，我们必须去找<code>Entity</code>看看它有什么。就<code>Player</code>而言任何<code>Entity</code>类中不是私有的东西都可以被访问。</p><p>假设我有一个<code>Player</code>实例<code>player</code>，我不仅可以调用<code>printName()</code>函数，也可以调用<code>move()</code>函数并访问<code>x</code>、<code>y</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    Player player;</span><br><span class="line"><span class="addition">+   player.move(5,5);</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210629111020683.png"></p><p>我可以访问 <code>x</code> 和 <code>y</code> 就像它是一个 <code>Entity</code> 一样，因为它继承了所有的 <code>Entity</code> 的功能。还有一个概念叫做多态，在以后会深入讨论，多态是一个单一类型，但有多个类型的意思。<code>Player</code> 不只是 <code>Player</code> 类型，而且也是一个 <code>Entity</code>，这意味着我们可以在任何我们想要使用 <code>Entity</code> 的地方使用 <code>Player</code>，因为 <code>Player</code> 总会拥有 <code>Entity</code> 所拥有的一切再多加一点点东西。</p><p>如果我想创建一个打印 <code>Entity</code> 对象的独立功能，例如通过访问 <code>x</code> 和 <code>y</code> 变量并将它们打印到控制台上，我可以传入 <code>Player</code> 对象到相同的函数中，即使这个函数是接受 <code>Entity</code>作为参数的。可以这样搞的原因是 <code>Player</code> 保证会有这些 <code>x</code> 和 <code>y</code> 变量，包含所有 <code>Entity</code> 的东西。</p><p>继承是我们一直使用的一种方式，它是一种扩展现有类并为基类提供新功能的方式，这是面向对象编程中最重要的东西之一，当你创建一个子类时，它将包含你的父类所包含的一切。</p><p>另一个证明方法是打印内存的大小：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">public:</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    void move(float dx,float dy) {</span><br><span class="line">        x += dx;</span><br><span class="line">        y += dy;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Player : public Entity{</span><br><span class="line">public:</span><br><span class="line">    const char* name;</span><br><span class="line"></span><br><span class="line">    void printName() const {</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Player player;</span><br><span class="line">    player.move(5,5);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; "sizeof Entity: " &lt;&lt; sizeof(Entity) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; "sizeof Player: " &lt;&lt; sizeof(Player) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704152839890.png"></p><p>这就是继承在C++类中如何工作的要点。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>今天我们来聊聊C++中的虚函数。之前的章节我们一直在讨论类、面向对象编程、继承，所有这些东西包括今天的虚函数，对整个面向对象概念都非常非常重要。</p><p>虚函数允许我们在子类中重写方法，所以假设我们有两个类 <code>A</code> 和 <code>B</code>，<code>B</code> 是 <code>A</code> 派生出来的，也就是 <code>B</code> 是 <code>A</code> 的子类。如果我们在 <code>A</code> 类中创建一个方法，标记为 <code>virtual</code>，我们可以选择在 <code>B</code> 类中重写那个方法，让它做其他事情。</p><h4 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h4><p>像往常一样，通过一个例子可以很好地解释这一点：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Entity"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">name</span>(name) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们创建了两个类，一个是 <code>Entity</code> 是我们的基类，唯一拥有的是一个名为 <code>getName()</code> 的公共方法，它会返回一个字符串 <code>"Entity"</code>；另一个类是 <code>Player</code>，它将是 <code>Entity</code> 类的子类，在这个类里我们存储一个名字字符串 <code>name</code>、提供一个构造函数 <code>Player()</code>，我们给它一个叫 <code>getName()</code> 的方法，返回 <code>name</code>。</p><p>让我们看看如何使用这些设定。假设我们在这里创造了一个 <code>Entity</code>，我要试着打印 <code>getName()</code>，<code>Player</code> 同理：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line"><span class="addition">+   Entity* e = new Entity();</span></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; e-&gt;getName() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   Player* p = new Player("Yousazoe");</span></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; p-&gt;getName() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704155920565.png"></p><p>酷，看起来不错，我们得到了打印结果。然而如果我们使用多态的概念，那么到目前为止我们在这里编写的所有内容都有问题了，如果我们指向一个 <code>Player</code>，就像它是一个 <code>Entity</code> 一样，我们就会遇到问题。</p><p>如果我在这里创建一个名为 <code>entity</code> 的变量，它会被赋值为 <code>p</code> 指向 <code>Player</code> 的指针，此时调用打印函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    Entity* e = new Entity();</span><br><span class="line">    std::cout &lt;&lt; e-&gt;getName() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Player* p = new Player("Yousazoe");</span><br><span class="line">    std::cout &lt;&lt; p-&gt;getName() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   Entity* entity = p;</span></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; entity-&gt;getName() &lt;&lt; std::endl;</span></span><br><span class="line">    </span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704160429996.png"></p><p>运行代码，得到结果为 <code>Entity</code>，然而我们希望是 <code>Player</code>，它是一个 <code>Player</code> 实例。</p><p>一个更好的例子是用一个 <code>printName()</code> 替换：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+void printName(Entity* entity){</span></span><br><span class="line"><span class="addition">+    std::cout &lt;&lt; entity-&gt;getName() &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity* e = new Entity();</span><br><span class="line"><span class="deletion">-   std::cout &lt;&lt; e-&gt;getName() &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+   printName(e);</span></span><br><span class="line"></span><br><span class="line">    Player* p = new Player("Yousazoe");</span><br><span class="line"><span class="deletion">-   std::cout &lt;&lt; p-&gt;getName() &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+   printName(p);</span></span><br><span class="line">    </span><br><span class="line"><span class="deletion">-   Entity* entity = p;</span></span><br><span class="line"><span class="deletion">-   std::cout &lt;&lt; entity-&gt;getName() &lt;&lt; std::endl;</span></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704161449301.png"></p><p>我们期望不同的 <code>getName()</code> 函数作用于不同的类对象。然而如果我们运行代码，<code>Entity</code> 打印了两次，为什么会这样？</p><p>发生这种情况的原因是在我们声明函数时，方法通常在类内部起作用，然后当要调用方法的时候会调用属于该类型的方法，而这里参数为 <code>Entity*</code> 决定了它会从 <code>Entity</code> 类中找到这个 <code>getName()</code> 函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(Entity* entity)</span></span>{</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们希望C++能意识到这一点，这就是虚函数出现的地方。</p><p>虚函数引入了一种叫做动态联编（Dynamic Dispatch）的东西，它通常通过虚函数表来实现编译。虚函数表就是一个表，它包含基类中所有虚函数的映射，这样我们可以在它运行时将它们映射到正确的覆写（override）函数，之后为会做一个关于虚函数表如何运作的深度文章，但为了简单起见，你只需要知道如果想覆写一个函数，必须将基类中的基函数标记为虚函数。</p><p>回到我们的代码，在 <code>Entity</code> 类中 <code>getName()</code> 方法前面加上 <code>virtual</code> 这个词：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">public:</span><br><span class="line"><span class="addition">+   virtual std::string getName(){</span></span><br><span class="line">        return "Entity";</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>尽管没有做很多工作，但这可以告诉编译器：“嘿，生成虚函数表吧！”。运行代码，我们得到了正确的结果：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210704162639642.png"></p><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>在C++11中我们可以做的另一件事情是将覆写函数标记为关键字 <code>override</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Player : public Entity {</span><br><span class="line">private:</span><br><span class="line">    std::string name;</span><br><span class="line">public:</span><br><span class="line">    Player(const std::string&amp; name)</span><br><span class="line">        : name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   std::string getName() override {</span></span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这不是必须的，你可以看到刚刚我们没写那个 <code>override</code>，它也工作得很好。然而你还是应该这样做，因为首先这让它更具可读性，现在我们知道这实际上是一个覆写函数，而且它还可以帮助我们预防 bug 的发生比如拼写错误之类的。</p><p>这就是虚函数的本质，但是很遗憾，虚函数并不是免费（无额外开销）的，有两种与虚函数相关的运行时成本：</p><ul><li>首先我们需要额外的内存来存储虚函数表，这样我们才可以分配到正确的函数，包括基类中要有一个成员指针指向虚函数表</li><li>其次我们调用虚函数时，我们需要遍历这个表来确定映射到哪个函数，这是额外的性能损失</li></ul><p>由于这些成本，有些人根本就不喜欢使用虚函数。老实说，根据我的经验，我没有遇到开销特别大的情况，所以我个人而言经常用，没有任何问题，可能在一些嵌入式平台上 cpu 性能非常差需要注意避免使用虚函数。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>今天我们讲的是一种特殊类型的虚函数：纯虚函数。</p><p>C++纯虚函数本质上与其他语言（如Java或C#）中的抽象方法或接口相同。基本上纯虚函数允许我们在基类中定义一个没有实现的函数，然后强制子类去实现该函数。如果我们看一下之前的例子，可以看到我们在 <code>Entity</code> 类中有一个虚函数 <code>getName()</code>，然后我们在 <code>Player</code> 中重写了那个函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Entity"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">name</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在这个基类中 <code>getName()</code> 有函数体，意味着在某个类中重写它只是一个可选项，即使我们不重写它仍然可以调用 <code>Player.getName()</code> 返回字符串 <code>Entity</code>。然而在某些情况下，提供这种默认实现是没有意义的，实际上我们可能想要强制子类为特定的函数提供自己的定义。</p><p>在面向对象编程中创建一个只由未实现的方法组成，然后强制子类去实现它们非常常见，这通常被称为接口。因此，类中的接口只包含未实现的方法作为模板，由于这个接口类实际上并不包含方法实现，我们实际上不可能实例化那个类。让我们看看这个在 <code>Entity</code> 类中的 <code>getName()</code> 函数能不能搞成纯虚函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们去掉了函数体就写成等于0。注意，这里依然是定义成 <code>virtual</code> 虚函数，但等于0本质上使它成为一个纯虚函数，这意味着如果你想实例化这个子类，它必须在一个子类中实现。</p><p>这样做确实发生了一些变化，在 <code>main()</code> 函数中我们不再具有实例化 <code>Entity</code> 类的实例，我们必须给它一个子类来实现这个函数：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705160236508.png"></p><p>目前 <code>Player</code> 工作正常，因为我们实现了那个 <code>getName()</code> 函数。如果我注销掉这个实现，你可以看到 <code>Player</code> 也不能进行实例化了：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Player : public Entity {</span><br><span class="line">private:</span><br><span class="line">    std::string name;</span><br><span class="line">public:</span><br><span class="line">    Player(const std::string&amp; name)</span><br><span class="line">        : name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   std::string getName() override {</span></span><br><span class="line"><span class="deletion">-       return name;</span></span><br><span class="line"><span class="deletion">-   }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705163801189.png"></p><p>本质上，你只能在实现了所有这些纯虚函数之后，才能够实例化。或者实现在更上层的类也是可以的，比如 <code>Player</code> 类是另一个类（<code>Entity</code> 的子类）的子类，而这个类实现了 <code>getName()</code> 函数。我们的想法是，纯虚函数必须被实现，才能创建这个类的实例。</p><p>好了，让我们看一个更好的例子。先把我们之前的操作撤销，假设我们想要编写一个函数打印这些类的类名，我们需要一个类型可以提供 <code>getClassName()</code> 函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Printable obj)</span></span>{</span><br><span class="line">		std::cout &lt;&lt; obj-&gt;getClassName &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>让我们把这个叫做 <code>Printable</code>，然后设置它。创建一个新类 <code>Printable</code>，它唯一会有的是一个纯虚字符串函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+class Printable {</span></span><br><span class="line"><span class="addition">+public:</span></span><br><span class="line"><span class="addition">+    virtual std::string getClassName() = 0;</span></span><br><span class="line"><span class="addition">+};</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+class Entity : public Printable {</span></span><br><span class="line">public:</span><br><span class="line">    virtual std::string getName(){</span><br><span class="line">        return "Entity";</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Player : public Entity {</span><br><span class="line">private:</span><br><span class="line">    std::string name;</span><br><span class="line">public:</span><br><span class="line">    Player(const std::string&amp; name)</span><br><span class="line">        : name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::string getName() override {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">void printName(Entity* entity){</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;getName() &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="addition">+void Print(Printable obj){</span></span><br><span class="line"><span class="addition">+    std::cout &lt;&lt; obj-&gt;getClassName() &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity* e = new Entity();</span><br><span class="line">    printName(e);</span><br><span class="line"></span><br><span class="line">    Player* p = new Player("Yousazoe");</span><br><span class="line">    printName(p);</span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后我要让 <code>Entity</code> 实现那个接口。注意虽然它叫做接口，但它其实只是一个类，所以还是 <code>class</code> 而不是 <code>interface</code>（其他语言有这个关键字，但C++没有，接口只是C++的类而已）。</p><p>现在所有类都需要实现这个 <code>getClassName()</code> 函数了，否则我们将不能实例化这个类：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Printable {</span><br><span class="line">public:</span><br><span class="line">    virtual std::string getClassName() = 0;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Entity : public Printable {</span><br><span class="line">public:</span><br><span class="line">    virtual std::string getName(){</span><br><span class="line">        return "Entity";</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   std::string getClassName() override {</span></span><br><span class="line"><span class="addition">+       return "Entity";</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Player : public Entity, Printable{</span><br><span class="line">private:</span><br><span class="line">    std::string name;</span><br><span class="line">public:</span><br><span class="line">    Player(const std::string&amp; name)</span><br><span class="line">        : name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::string getName() override {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   std::string getClassName() override {</span></span><br><span class="line"><span class="addition">+       return "Player";</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">void printName(Entity* entity){</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;getName() &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Print(Printable* obj){</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;getClassName() &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity* e = new Entity();</span><br><span class="line"><span class="deletion">-   printName(e);</span></span><br><span class="line"></span><br><span class="line">    Player* p = new Player("Yousazoe");</span><br><span class="line"><span class="deletion">-   printName(p);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   Print(e);</span></span><br><span class="line"><span class="addition">+   Print(p);</span></span><br><span class="line">    </span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705212818328.png"></p><p>现在可以看到，我得到了正确的类名，所有这些都来自于一个 <code>Print()</code> 函数，这个函数接受 <code>Printable</code> 作为参数。如果你不实现这个函数，你就不能实例化这个类。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>今天我们讨论 C++ 中的可见性。</p><p>可见性是一个属于面向对象编程的概念，它指的是类的某些成员或方法实际上有多可见。我说的可见性是指：谁能看到它们、谁能调用它们、谁能使用它们这些东西，所以一开始我要提一下，可见性是对程序实际运行方式完全没有影响的东西，对性能也没有影响，它纯粹是语言中存在的东西，让你能够写出更好的代码或者帮助你组织代码。</p><p>C++ 中有三个基础的可见性修饰符：<code>private</code>、<code>protected</code> 和 <code>public</code>。在其他语言比如 Java 和 C# 有其他关键字，比如 Java 中你可以不使用可见性修饰符，这就是所谓的 <code>default</code> 可见性修饰符；在 C# 中有个可见性修饰符叫做 <code>internal</code>。</p><p>在 C++ 中我们就是三个可见性修饰符：<code>private</code>、<code>protected</code> 和 <code>public</code>。让我们来看看它们在类中是怎么做的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如果我在一个 <code>Entity</code> 中把 <code>x</code> 和 <code>y</code> 定义为两个变量，默认的可见性是私有的，也就是说这段代码和我写 <code>private</code> 完全一样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>但是如果这里不是 <code>class</code> 而是 <code>struct</code>，那么它将默认为公开的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>让我们回到类，把这些设为私有，什么是 <code>private</code>？<code>private</code> 意味着只有（Only*）这个 <code>Entity</code> 类可以访问这些变量，它可以读取和写入它们。这里的 Only* 要给个星号*，因为在 C++ 中有个叫 <code>friend</code> 的东西。它是 C++ 中的关键字，可以让类或者函数成为类 <code>Entity</code> 的朋友（友元），<code>friend</code> 的意思是友元，实际上可以从类中访问私有成员。</p><p>回到代码，如果我此时要在主函数里实例化这个 <code>Entity</code>，在这个类的作用域之外我不能调用 <code>x = 2</code> 或类似的东西，因为它是私有的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() {</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705225327136.png"></p><p>如果有一个 <code>Entity</code> 的子类为 <code>Player</code>，这里依然不能访问 <code>x</code>，只有 <code>Entity</code> 类和它的友元才能访问这些变量：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() {</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>() {</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705225650753.png"></p><p>这同样适用于函数，这里我们新建一个 <code>Print()</code> 函数，可以从 <code>Entity</code> 类中调用函数，这完全没有问题。然而当我试图从子类 <code>Player</code> 或者一个完全不同的地方，实际上我不能调用它，因为是私有的：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">    int x, y;</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   void Print() {}</span></span><br><span class="line">public:</span><br><span class="line">    Entity() {</span><br><span class="line">        x = 0;</span><br><span class="line"><span class="addition">+       Print();</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Player : public Entity {</span><br><span class="line">public:</span><br><span class="line">    Player() {</span><br><span class="line">        x = 2;</span><br><span class="line"><span class="addition">+       Print();</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = 2;</span><br><span class="line"><span class="addition">+   e.Print();</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210705230250552.png"></p><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>我们有个东西叫 <code>protected</code>，它比 <code>private</code> 更可见，但比 <code>public</code> 更不可见。<code>protected</code> 意思是这个 <code>Entity</code> 类和层次结构中的所有子类也可以访问这些符号：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() {</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Print</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>() {</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">Print</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>可以看到现在我完全可以在 <code>Player</code> 类中写 <code>x = 2</code> 和调用 <code>Print()</code>，因为 <code>Player</code> 是 <code>Entity</code> 的子类。然而，我仍然不能在 <code>main()</code> 函数里面这样做，因为它是一个完全不同的函数，且在类外面。</p><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>最后是 <code>public</code>，它意味着所有人都可以访问它：我可以在 <code>Entity</code> 类中访问它、在 <code>Player</code> 类中访问它，也可以在 <code>main()</code> 函数中访问：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() {</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Print</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>() {</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">Print</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210706143544608.png"></p><p>现在我们来谈谈为什么要使用可见性，哪里要用到，为什么不让所有的东西都是 <code>public</code> 呢？</p><p><code>public</code> 公开一切对于开发者而言纯粹是一个糟糕的想法，这是如何写好代码问题。不管是阅读代码还是扩展代码，可见性让代码更加容易维护、容易理解。这与性能无关，也不会产生完全不同的代码，可见性不是 CPU 需要理解的东西，它只是人类为了帮助自己和他人发明的东西。</p><p>所以当我说帮助他人时，我的意思是如果你把某件事标记为 <code>private</code>，这基本上告诉每个人：“嘿，你不应该从其他类或其他代码中访问这个”，你只能在类的内部访问这个。这意味着如果我从来没有使用过一个类，我看它包含了什么，我应该可以这么说：“好吧，我只被允许接触 <code>public</code> 的东西，这就是我使用这个类应该的方式”。</p><p>这是这个类的正确用法，实际上是调用公共函数。如果我使用一个类，看到了一个我想调用的私有函数，我知道我不应该调用私有函数，这个类的作者可能提供了一些其他方法来实现同样的事情，如果我能调用私有函数也许不会给我带来我期待的结果，或者破坏其他东西。</p><p>代码是个错综复杂的东西，通过明确可见性我们可以确保人们不会调用他们不应该调用的代码。一个很好的例子是 UI 界面，如果我想移动按钮的位置，如果我只访问按钮的坐标 <code>x</code> 和 <code>y</code>，然后改变变量，按钮实际上可能不会移动（两者的位置改变方式可能不同），为了让按钮真正移动，我们可能需要刷新显示。</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>今天我们讲 C++ 的隐式构造函数和隐式转换，以及 <code>explicit</code> 关键字是什么意思。</p><h4 id="隐式转换-1"><a href="#隐式转换-1" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>隐式的意思是不会明确地告诉它要做什么，所以有点像自动通过上下文知道意思。C++ 实际上允许编译器对代码执行一次隐式转换，如果我们开始有一个数据类型，然后有了另一个类型，在两者之间 C++ 允许隐式进行转换，而不需要用 <code>cast</code> 做强制转换。</p><p>最好用一个例子来说明，让我们来看看。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(<span class="number">-1</span>) {}</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age) :<span class="built_in">name</span>(<span class="string">"UNKNOWN"</span>), <span class="built_in">age</span>(age) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们有了两个构造函数，非常简单。创建这些对象的常见方法如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">Entity <span class="title">a</span><span class="params">(<span class="string">"YOUSAZOE"</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你也许会毫不犹豫地这样写，因为这实在很简单。也可以加上等号：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity a = <span class="built_in">Entity</span>(<span class="string">"YOUSAZOE"</span>);</span><br><span class="line">    Entity b = <span class="built_in">Entity</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正如大多数人如何使用对象以及如何实例化对象一样。但是，你能做其他人不知道的做法，就是直接将 <code>a</code> 赋值为 <code>YOUSAZOE</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Entity a = <span class="string">"YOUSAZOE"</span>;</span><br><span class="line">    Entity b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这有点奇怪，因为首先你不能用其他语言比如 Java 或 C# 这样搞；其次，<code>Entity b = 20</code> 让 <code>Entity</code> 等于整数？它有一个字符串 <code>name</code>，但我可以把20赋值给这里，到底发生了什么？</p><p>这被称为隐式转换，或叫隐式构造函数。它隐式地将20转换成一个 <code>Entity</code>，构成出一个 <code>Entity</code>，因为有一个 <code>Entity</code> 构造函数接受一个整数参数 <code>name</code>，另一个构造函数接受字符串 <code>name</code> 作为参数。</p><p>另一个例子，有一个 <code>printEntity()</code> 函数，参数是 <code>Entity</code>，用来做打印的：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printEntity</span><span class="params">(<span class="type">const</span> Entity&amp; entity)</span> </span>{</span><br><span class="line">    <span class="comment">// Printing</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">printEntity</span>(<span class="number">20</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>C++ 认为，20可以转换成一个 <code>Entity</code>，因为你可以调用这个构造函数，20是你创建 <code>Entity</code> 的唯一参数。</p><p>现在看看当我尝试通过参数 <code>YOUSAZOE</code> 调用这个 <code>printEntity()</code> 会发生什么？它似乎可以，因为之前的20可以：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">printEntity</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printEntity</span>(<span class="string">"YOUSAZOE"</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果是不，它不工作。它没有成功的原因，是这个 <code>YOUSAZOE</code> 不是 <code>std::string</code>，它是一个 <code>char</code> 数组。</p><p>为了让它起作用，C++ 需要做两次转换，一个从 <code>const char</code> 数组到 <code>string</code>，一个从 <code>string</code> 到 <code>Entity</code>，但它只允许做一次隐式转换。所以为了让它起作用，我们必须把它包装在一个构造函数中，就像这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printEntity</span>(std::<span class="built_in">string</span>(<span class="string">"YOUSAZOE"</span>));</span><br></pre></td></tr></tbody></table></figure><p>或者我们可以包装在一个 <code>Entity</code> 对象中。这也是可行的，因为在本例中它将隐式地将这个字符串转换为 <code>std::string</code> 标准字符串，然后它会被推入 <code>Entity</code> 构造函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printEntity</span>(<span class="built_in">Entity</span>(<span class="string">"YOUSAZOE"</span>));</span><br></pre></td></tr></tbody></table></figure><p>OK，很好，这就是隐式构造函数，非常酷的东西，可以大大简化你的代码。但我尽量避免使用它。</p><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><p>我们来谈谈 <code>explicit</code> 关键字是什么。它与隐式转换这些有关系，因为 <code>explicit</code> 禁用这个隐式 <code>implicit</code> 功能。<code>explicit</code> 关键字放在构造函数前面，如果你有一个 <code>explicit</code> 的构造函数，这意味着没有隐式的转换，如果要使用整数构造这个 <code>Entity</code> 对象，则必须显式调用此构造函数。</p><p>让我们恢复这个隐式转换：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">private:</span><br><span class="line">    int age;</span><br><span class="line">    std::string name;</span><br><span class="line">public:</span><br><span class="line">    Entity(const std::string&amp; name) :name(name), age(-1) {}</span><br><span class="line"><span class="addition">+   explicit Entity(int age) :name("UNKNOWN"), age(age) {}</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">void printEntity(const Entity&amp; entity) {</span><br><span class="line">    // Printing</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    printEntity(20);</span><br><span class="line">    printEntity(Entity("YOUSAZOE"));</span><br><span class="line">    Entity b = 20;</span><br><span class="line">    </span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210716232530922.png"></p><p>如果我们要消除错误，必须显式地将它转换为一个 <code>Entity</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    printEntity(20);</span><br><span class="line">    printEntity(Entity("YOUSAZOE"));</span><br><span class="line"></span><br><span class="line"><span class="addition">+   Entity b = (Entity)20;</span></span><br><span class="line"><span class="addition">+   Entity c = Entity(20);</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这就是 <code>explicit</code> 关键字的唯一作用了，它需要显式地调用构造函数，而不是每次调用构造函数时 C++ 编译器默认地进行隐式转换。</p><p>能用 <code>explicit</code> 的地方比如我有时用于数学库之类的东西，因为我不想总是将数字变成向量，我想确保我的代码尽可能的安全。老实说，我并不经常使用它，当你写低级封装（low level wrapper）或类似的事情时它可以派上用场，它可以防止做意外转换导致的性能问题或 bug。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>今天我要讲的是 C++ 的运算符以及运算符重载。</p><p>首先，运算符是什么？运算符是我们使用的一种符号，通常代替一个函数来执行一些事情。</p><p>我说的不仅仅是数学运算符比如加减乘除这些东西，我们也有其他常用的运算符，实际上我们已经用了很多了，包括逆向引用（derference）运算符、箭头运算符、<code>+=</code> 运算符、还有我们用于内存地址的 <code>&amp;</code> 运算符，也有我们一直在用的左移运算符，也就是两个尖括号把东西打印到 <code>cout</code> 到控制台。</p><p>然后我们还有其他运算符，你们可能根本不把它们当作运算符，比如 <code>new</code> 和 <code>delete</code> 实际也是运算符。我们还有非常奇怪完全不同的运算符，比如逗号运算符，圆括号也可以是运算符。我不会列出所有 C++ 中可用的运算符，可以参考网上完整的运算符列表。</p><p>所以，运算符重载是什么意思？在这个意义上，重载这个术语本质是给运算符重载赋予新的含义，或者添加参数，或者创建允许在程序中定义或更改运算符的行为。这是一个非常有用的特性，但在 Java 等语言中不受支持，它在 C# 等语言中得到部分支持（通常它好的部分是被支持的）。C++ 给了我们完全的控制权。这是件好事，但也可能是一件坏事，这就是 C++，它给了你很大的控制权，但是它会导致很多糟糕的代码，人们痛恨使用这种语言。</p><p>但最终，运算符就是函数，不用给出你的函数名比如 <code>add</code>，你可以把它交给加号 <code>+</code> 这样的运算符。在很多情况下这真的有助于清理你的代码，使其干净整洁，代码会看起来更好，更容易阅读。</p><p>然而，运算符重载的使用应该要非常少，而且只是在完全有意义的情况下。如果人们需要查看运算符的定义，或者类的定义，或者结构的定义，看看运算符到底对它们做了什么，那么你可能会失败。例如，当定义一个 <code>math</code> 类，你需要把两个数学对象加在一起，那么将加法进行重载是很有意义的，因为你可以写代码 <code>a + b</code>，而且可以运行。</p><p>事实上，让我们来看一些例子：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> {</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x,<span class="type">float</span> y)</span><br><span class="line">        :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">Vector2 <span class="title">position</span><span class="params">(<span class="number">4.0f</span>,<span class="number">4.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>,<span class="number">1.5f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我要写一个向量 <code>Vector2</code> 结构体，其中快速定义一个构造函数。在主函数中假设我像存储一个位置以及一个速度。</p><p>好了，我有两个向量，现在我想把它们加在一起并存储结果。我想到了这样一个问题，在没有运算符重载的语言下，我怎样才能写好这个？或者你在 C++ 中但你不想使用运算符重载，你可以构造一个 <code>add()</code> 函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Vector2 {</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    Vector2(float x,float y)</span><br><span class="line">        :x(x), y(y) {}</span><br><span class="line">        </span><br><span class="line"><span class="addition">+   Vector2 add(const Vector2&amp; other) const {</span></span><br><span class="line"><span class="addition">+       return Vector2(x + other.x, y + other.y);</span></span><br><span class="line"><span class="addition">+   }    </span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Vector2 position(4.0f,4.0f);</span><br><span class="line">    Vector2 speed(0.5f,1.5f);</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   Vector2 result = position.add(speed);</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>好吧，听起来很简单，我们已经在主函数派上用场了，看起来还不错。但是如果我们想要通过某种修改来改变 <code>speed</code>，我们可能用 <code>powerup</code> 使速度稍微快一点，想做 <code>speed</code> 乘以 <code>powerup</code> 之类的事情。</p><p>根据这个想法，这意味着我们需要写 <code>speed.mulitply()</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Vector2 {</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    Vector2(float x,float y)</span><br><span class="line">        :x(x), y(y) {}</span><br><span class="line"></span><br><span class="line">    Vector2 add(const Vector2&amp; other) const {</span><br><span class="line">        return Vector2(x + other.x, y + other.y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   Vector2 multiply(const Vector2&amp; other) const {</span></span><br><span class="line"><span class="addition">+       return Vector2(x * other.x, y * other.y);</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Vector2 position(4.0f,4.0f);</span><br><span class="line">    Vector2 speed(0.5f,1.5f);</span><br><span class="line"><span class="addition">+   Vector2 powerup(1.1f,1.1f);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   Vector2 result = position.add(speed.multiply(powerup));</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里开始看起来有点难读，不幸的是在 Java 这样的语言中，这真的是你唯一的选择。但相反，在 C++ 中我们有运算符重载，这意味着我们可以利用这些运算符，并定义我们自己的运算符来处理 <code>Vector2</code> 结构。所以可以不用写成这样，我们可以把它转换成数学运算符：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Vector2 {</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    Vector2(float x,float y)</span><br><span class="line">        :x(x), y(y) {}</span><br><span class="line"></span><br><span class="line">    Vector2 add(const Vector2&amp; other) const {</span><br><span class="line">        return Vector2(x + other.x, y + other.y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   Vector2 operator+(const Vector2&amp; other) const {</span></span><br><span class="line"><span class="addition">+       return add(other);</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line">    Vector2 multiply(const Vector2&amp; other) const {</span><br><span class="line">        return Vector2(x * other.x, y * other.y);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   Vector2 operator*(const Vector2&amp; other) const {</span></span><br><span class="line"><span class="addition">+       return multiply(other);</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    Vector2 position(4.0f,4.0f);</span><br><span class="line">    Vector2 speed(0.5f,1.5f);</span><br><span class="line">    Vector2 powerup(1.1f,1.1f);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   Vector2 result1 = position.add(speed.multiply(powerup));</span></span><br><span class="line"><span class="addition">+   Vector2 result2 = position + speed * powerup;</span></span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为它们和其他函数一样，我也可以反过来做，不是 <code>operator+</code> 调用 <code>add()</code> 函数，而是 <code>add()</code> 函数调用加法运算符。很多人不知道这一点，因为这个语法看起来有点奇怪，你不经常看到。大部分人通常是写代码的方式：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">struct Vector2 {</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line"></span><br><span class="line">    Vector2(float x,float y)</span><br><span class="line">        :x(x), y(y) {}</span><br><span class="line"></span><br><span class="line">    Vector2 add(const Vector2&amp; other) const {</span><br><span class="line"><span class="addition">+       return *this + other;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Vector2 operator+(const Vector2&amp; other) const {</span><br><span class="line"><span class="addition">+       return Vector2(x + other.x, y + other.y);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Vector2 multiply(const Vector2&amp; other) const {</span><br><span class="line"><span class="addition">+       return *this * other;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Vector2 operator*(const Vector2&amp; other) const {</span><br><span class="line"><span class="addition">+       return Vector2(x * other.x, y * other.y);</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>但我们也可以用 <code>operator+</code> 像一个函数一样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Vector2 <span class="title">add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">operator</span>+(other);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它虽然看起来有点奇怪，但是完全可以编译，只是代码风格不同而已。很显然，后者看起来比前者要好太多了：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Vector2 result1 = position.<span class="built_in">add</span>(speed.<span class="built_in">multiply</span>(powerup));</span><br><span class="line">Vector2 result2 = position + speed * powerup;</span><br></pre></td></tr></tbody></table></figure><p>好了，我再给你们看一个 <code>std::cout</code> 时使用的左移运算符。假设现在我们有了这个 <code>Vector2</code>，我们想要把它打印到控制台：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    Vector2 position(4.0f,4.0f);</span><br><span class="line">    Vector2 speed(0.5f,1.5f);</span><br><span class="line">    Vector2 powerup(1.1f,1.1f);</span><br><span class="line"></span><br><span class="line">    Vector2 result1 = position.add(speed.multiply(powerup));</span><br><span class="line">    Vector2 result2 = position + speed * powerup;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   std::cout &lt;&lt; result2 &lt;&lt; std::endl;</span></span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210719113605774.png"></p><p>我们不能这么做，因为这个运算符没有重载。这个运算符接收两个参数，一个是输出流 <code>output stream</code> 也就是 <code>cout</code>，另一个就是 <code>Vector2</code> 了。我们可以将这个运算符重载加进来：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, Vector2&amp; other) {</span><br><span class="line">    stream &lt;&lt; other.x &lt;&lt; <span class="string">","</span> &lt;&lt; other.y;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210719114229142.png"></p><p>我们这个重载的左移运算符有点像 <code>ToString()</code> 函数，在 Java 或 C# 等语言中经常被用来重写，这就是 C++ 的厉害之处了，你可以用运算符代替函数。</p><p>这里简单的介绍了 C++ 的少部分运算符重载以及通常的工作方式。记住，它们只是函数。当然，如果你愿意，重载一个运算符可以让代码看起来很古怪，但是不要这样做，因为这会让代码难读，也可能会让你自己感到烦躁。</p><p>还有其他例子，C# 支持但是 Java 不支持的 <code>==</code> 运算符。在 Java 中如果你想比较一下，你必须为每个类写一个 <code>equals()</code> 重写，必须到处写 <code>equals()</code>。如果我想比较 <code>result1</code> 和 <code>result2</code>，我需要这样写：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(result1.<span class="title function_">equals</span>(result2)){</span><br><span class="line">		......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们也可以写 <code>==</code> 运算符重载：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> {</span><br><span class="line">		<span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们需要不等于的运算符，也可以直接调用上面的 <code>==</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> {</span><br><span class="line">		<span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">  	<span class="comment">//return !(*this == other);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>今天的内容是想讨论一下 <code>this</code> 关键字。</p><p>我们在 C++ 中有一个关键字 <code>this</code>，通过它可以访问成员函数。成员函数意思是一个属于某个类的函数或方法。在方法内部我们也可以引用 <code>this</code>，<code>this</code> 是一个指向当前对象实例的指针，这个方法属于这个对象实例。</p><p>所以当然，在 C++ 中我们可以写一个非静态方法，为了调用这个方法我们需要首先实例化一个对象，然后调用这个方法。这个方法必须用一个有效对象来调用，关键字 <code>this</code> 是指向该对象的指针，这实际上对方法的一般工作方式非常重要。</p><p>好了，在我们的代码中我将创建一个 <code>Entity</code> 类：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们当然可以用成员初始化列表，这完全没有问题可以正常工作。然而如果我不想这么做，我想在方法内部写，那可能会遇到一点问题。你可能注意到了，它们的名字完全一样，所以如果我让 <code>x = x</code>，我实际上只是将这个 <code>x</code> 变量赋值给它自己，也就是什么也不做。</p><p>我真正想做的是引用属于这个类的 <code>x</code> 和 <code>y</code>，实际的类成员， <code>this</code> 关键字可以让我们做到这一点。正如我所提到的，这个 <code>this</code> 关键字是指向当前对象的指针，再讲清楚一点：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {</span><br><span class="line">		Entity* e = <span class="keyword">this</span>;</span><br><span class="line">		x = x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这就是 <code>this</code> 的类型（<code>Entity*</code>），技术上讲如果你把鼠标悬停在上面，你会发现它实际上是一个 <code>Entity* const</code>。如果我们现在想要赋值 <code>x</code>，那么我们可以直接用 <code>e-&gt;x</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {</span><br><span class="line">		Entity* e = <span class="keyword">this</span>;</span><br><span class="line">		e-&gt;x = x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了简单一点，我们还可以这样做：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">  	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们有了给这两个变量赋值的方法，这是非常重要的，因为如果不用 <code>this</code> 就无法进行赋值了。如果我们想要写一个返回这些变量之一的函数，在函数后面加上 <code>const</code> 是非常常见的，因为它不会修改这个类：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class Entity {</span><br><span class="line">public:</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line"></span><br><span class="line">    Entity(int x,int y):x(x), y(y) {</span><br><span class="line">        this-&gt;x = x;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   int getX() const {</span></span><br><span class="line"><span class="addition">+       return x;</span></span><br><span class="line"><span class="addition">+   }</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>因此在这个 <code>const</code> 函数中不能将 <code>this</code> 这样赋值给一个 <code>Entity</code>，而应该是 <code>const Entity</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-Entity* e = this;</span></span><br><span class="line"><span class="addition">+const Entity* e = this;</span></span><br></pre></td></tr></tbody></table></figure><p>另一个有用的场合是如果我们想调用这个类之外的函数，那就不是类方法了（类的外部叫函数）。如果我们想在这个类的内部调用一个类外部的函数，其中这个函数将 <code>Entity</code> 作为参数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+class Entity;</span></span><br><span class="line"><span class="addition">+void printEntity(Entity* e);</span></span><br><span class="line"></span><br><span class="line">class Entity {</span><br><span class="line">public:</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line"></span><br><span class="line">    Entity(int x,int y):x(x), y(y) {</span><br><span class="line">        this-&gt;x = x;</span><br><span class="line">        this-&gt;y = y;</span><br><span class="line">        </span><br><span class="line"><span class="addition">+       printEntity(this);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int getX() const {</span><br><span class="line">        const Entity* e = this;</span><br><span class="line">        return x;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="addition">+void printEntity(Entity* e) {</span></span><br><span class="line"><span class="addition">+    // Printing</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    std::cin.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/f1767e7a.html" rel="bookmark">精读 Effective C++</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/62e0ea85.html" rel="bookmark">哪些变量会自动初始化？</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/2fcb9e48.html" rel="bookmark">GStarCAD C++笔试&amp;机试&amp;面试总结</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Cpp/" rel="tag"># Cpp</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/bf22a347.html" rel="prev" title="SIGGRAPH 2021 技术论文预览"><i class="fa fa-chevron-left"></i> SIGGRAPH 2021 技术论文预览</a></div><div class="post-nav-item"><a href="/archives/76d495ae.html" rel="next" title="从苏宁电器到卡巴斯基--半年的职场空窗期">从苏宁电器到卡巴斯基--半年的职场空窗期 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E6%AF%94"><span class="nav-number">2.1.</span> <span class="nav-text">类与结构体对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAC-%E7%9A%84%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">如何写一个C++的类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81"><span class="nav-number">3.</span> <span class="nav-text">静态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB-x2F-%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%96%E7%9A%84%E9%9D%99%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">类/结构体外的静态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB-x2F-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81"><span class="nav-number">3.2.</span> <span class="nav-text">类/结构体中的静态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81"><span class="nav-number">3.3.</span> <span class="nav-text">局部静态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">4.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">5.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">有参构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">5.4.</span> <span class="nav-text">成员初始化列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.5.</span> <span class="nav-text">创建并初始化对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">5.6.</span> <span class="nav-text">new关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">7.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#virtual"><span class="nav-number">8.1.</span> <span class="nav-text">virtual</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#override"><span class="nav-number">8.2.</span> <span class="nav-text">override</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#private"><span class="nav-number">10.1.</span> <span class="nav-text">private</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protected"><span class="nav-number">10.2.</span> <span class="nav-text">protected</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#public"><span class="nav-number">10.3.</span> <span class="nav-text">public</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">11.</span> <span class="nav-text">隐式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2-1"><span class="nav-number">11.1.</span> <span class="nav-text">隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit"><span class="nav-number">11.2.</span> <span class="nav-text">explicit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">12.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#this"><span class="nav-number">12.1.</span> <span class="nav-text">this</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">311</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">79</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/399504060" title="Bilibili → https://space.bilibili.com/399504060" rel="noopener" target="_blank"><i class="fa fa-th-large fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.6m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options={bottom:"64px",right:"unset",left:"32px",time:"0.5s",mixColor:"transparent",backgroundColor:"transparent",buttonColorDark:"#100f2c",buttonColorLight:"#fff",saveInCookies:!0,label:"🌓",autoMatchOsTheme:!0};const darkmode=new Darkmode(options);window.darkmode=darkmode,darkmode.showWidget()</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
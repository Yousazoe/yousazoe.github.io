<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//fastly.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言"><meta property="og:type" content="article"><meta property="og:title" content="A Gentle Introduction to DirectX Raytracing 14"><meta property="og:url" content="https://yousazoe.top/archives/8b6729fe.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor14-Output-20220210163307212-20220210163315447.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor14-Output-20220210163448689.png"><meta property="article:published_time" content="2022-02-10T08:31:33.000Z"><meta property="article:modified_time" content="2022-06-18T12:26:38.173Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor14-Output-20220210163307212-20220210163315447.png"><link rel="canonical" href="https://yousazoe.top/archives/8b6729fe.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>A Gentle Introduction to DirectX Raytracing 14 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/8b6729fe.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">A Gentle Introduction to DirectX Raytracing 14</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-02-10 16:31:33" itemprop="dateCreated datePublished" datetime="2022-02-10T16:31:33+08:00">2022-02-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">光线追踪 (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>14k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>25 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor14-Output-20220210163307212-20220210163315447.png"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><span id="more"></span><blockquote><p>In <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor12/tutorial12.md.html">Tutorial 12</a>, we showed how to do recursive bounces for path tracing using a diffuse Lambertain material model. This tutorial explores how to swap out a Lambertian material model for a more complex model, the <a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">GGX model</a> commonly used today in film and games. Additionally, we extend the one-bounce global illumination with an arbitrary number of bounces.</p></blockquote><p>在<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor12/tutorial12.md.html">教程 12</a>中，我们展示了如何使用漫反射 Lambertain 材料模型为路径跟踪进行递归反弹。本教程探讨如何将 Lambertian 材料模型替换为更复杂的模型，即当今电影和游戏中常用的 <a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">GGX 模型</a>。此外，我们使用任意数量的反弹来扩展单反弹全局照明。</p><h3 id="Changes-to-the-C-Code"><a href="#Changes-to-the-C-Code" class="headerlink" title="Changes to the C++ Code"></a>Changes to the C++ Code</h3><blockquote><p>The C++ code barely changes in this tutorial, other than changing the pass names. Inside <code>GGXGlobalIllumination.cpp</code>, we ask for a few additional fields from our G-buffer in the <code>GGXGlobalIlluminationPass::initialize()</code> method, including the <code>MaterialSpecRough</code> and <code>Emissive</code> fields, which include properties needed to render specular materials and those that emit light directly. This means we can render scenes with no light sources (but materials marked “emissive” will act as lights).</p></blockquote><p>除了更改渲染管线名称外，本教程中的 C++ 代码几乎没有变化。在内部，我们在方法 <code>GGXGlobalIllumination.cpp</code> 中从 G-buffer 中请求一些额外的字段，包括和字段，其中包括渲染镜面材质和直接发光的属性所需的属性。这意味着我们可以在没有光源的情况下渲染场景（但标记为“自发光”的材质将充当灯光）。 <code>GGXGlobalIlluminationPass::initialize()``MaterialSpecRough``Emissive</code></p><blockquote><p>Additionally, the method <code>GGXGlobalIlluminationPass::execute()</code> passes a few additional parameters to our shader, including a maximum ray depth (<code>gMaxDepth</code>) and our additional G-buffer textures.</p></blockquote><p>此外，该方法<code>GGXGlobalIlluminationPass::execute()</code>向我们的着色器传递了一些额外的参数，包括最大光线深度 ( <code>gMaxDepth</code>) 和我们额外的 G 缓冲区纹理。</p><h3 id="New-Microfacet-Functions-in-the-HLSL-Code"><a href="#New-Microfacet-Functions-in-the-HLSL-Code" class="headerlink" title="New Microfacet Functions in the HLSL Code"></a>New Microfacet Functions in the HLSL Code</h3><blockquote><p>A new file in the shader data direction is <code>microfacentBRDFUtils.hlsli</code>, which include a number of utility functions for rendering a GGX material. The form of the GGX BRDF is: <code>D * G * F / (4 * NdotL * NdotV)</code>. This form was introduced by <a target="_blank" rel="noopener" href="https://dl.acm.org/citation.cfm?id=357293">Cook and Torrance</a> (also available <a target="_blank" rel="noopener" href="http://inst.cs.berkeley.edu/~cs294-13/fa09/lectures/cookpaper.pdf">here</a>) and is widely used across many <a target="_blank" rel="noopener" href="http://www.pbr-book.org/3ed-2018/Reflection_Models/Microfacet_Models.html">microfacet BRDF models</a> used today.</p></blockquote><p>着色器新文件是<code>microfacentBRDFUtils.hlsli</code>，其中包括许多用于渲染 GGX 材质的实用程序函数。GGX BRDF 的形式为： <code>D * G * F / (4 * NdotL * NdotV)</code>. 这种形式是由 <a target="_blank" rel="noopener" href="https://dl.acm.org/citation.cfm?id=357293">Cook 和 Torrance</a> 引入的（也可<a target="_blank" rel="noopener" href="http://inst.cs.berkeley.edu/~cs294-13/fa09/lectures/cookpaper.pdf">在此处</a>获得），并广泛 用于当今 使用的许多<a target="_blank" rel="noopener" href="http://www.pbr-book.org/3ed-2018/Reflection_Models/Microfacet_Models.html">微平面 BRDF 模型</a>。</p><blockquote><p>A microfacet BRDF model assumes the surface is made up of a large number of very tiny planar facets that are all perfectly reflective (i.e., they reflect along the mirror direction). In rough, diffuse surfaces these facets are oriented almost uniformly randomly so light is reflected evenly around the hemisphere. On glossy surfaces, these facets are much more likely to lie flat along the geometry. The <code>D</code> term is the microfacet distribution, which controls the probability an incoming ray sees a facet of a particular orientation.</p></blockquote><p>微平面 BRDF 模型假设表面由大量非常微小的平面组成，这些平面都是完全反射的（即，它们沿镜面方向反射）。在粗糙的漫射表面中，这些刻面几乎随机均匀地定向，因此光线在半球周围均匀反射。在有光泽的表面上，这些刻面更有可能沿着几何形状平放。该<code>D</code>术语是微面分布，它控制入射光线看到特定方向的面的概率。</p><blockquote><p>We use a standard form of the GGX normal distribution for D (e.g., math taken from <a target="_blank" rel="noopener" href="http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf">here</a>):</p></blockquote><p>我们使用 D 的标准形式的 GGX 正态分布（例如，从<a target="_blank" rel="noopener" href="http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf">这里</a>获取所需的数学知识）：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ggxNormalDistribution</span><span class="params">( <span class="type">float</span> NdotH, <span class="type">float</span> roughness )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> a2 = roughness * roughness;</span><br><span class="line">	<span class="type">float</span> d = ((NdotH * a2 - NdotH) * NdotH + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> a2 / (d * d * M_PI);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Note: When building path tracers, it is important to maintain numerical robustness to avoid NaNs and Infs. In some circumstances, the last line in the <code>ggxNormalDistribution()</code> function may cause a divide by zero, so you may wish to clamp.</p></blockquote><p>注意：在构建路径跟踪器时，保持数值稳健性以避免 NaN 和 Infs 很重要。在某些情况下，<code>ggxNormalDistribution()</code>函数中的最后一行可能会导致除以零，因此您可能希望进行钳位。</p><blockquote><p>The <code>G</code> term in the Cook-Torrance BRDF model represents geometric masking of the microfacets. I.e., facets of various orientations will not always be visible; they may get occluded by other tiny facets. The model for geometric masking we use is from <a target="_blank" rel="noopener" href="https://onlinelibrary.wiley.com/doi/abs/10.1111/1467-8659.1330233">Schlick’s BRDF model</a> (or [direct PDF](<a target="_blank" rel="noopener" href="http://www.cs.virginia.edu/~jdl/bib/appearance/analytic">http://www.cs.virginia.edu/~jdl/bib/appearance/analytic</a> models/schlick94b.pdf)). Usually other masking terms are used with GGX (see <a target="_blank" rel="noopener" href="http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf">Naty Hoffman’s SIGGRAPH Notes</a>), but this model plugs in robustly without a lot of code massaging, which makes the tutorial code simpler to understand. This formulation for the Schlick approximation comes from Karas’ SIGGRAPH 2013 notes from the Physically Based Shading course:</p></blockquote><p>Cook-Torrance BRDF 模型中的<code>G</code>术语表示微面的几何掩蔽。即，不同方向的刻面并不总是可见的；它们可能会被其他微小的刻面遮挡。我们使用的几何遮罩模型来自<a target="_blank" rel="noopener" href="https://onlinelibrary.wiley.com/doi/abs/10.1111/1467-8659.1330233">Schlick 的 BRDF 模型</a> （或[直接 PDF](<a target="_blank" rel="noopener" href="http://www.cs.virginia.edu/~jdl/bib/appearance/analytic">http://www.cs.virginia.edu/~jdl/bib/appearance/analytic</a> models/schlick94b.pdf)）。通常与 GGX 一起使用其他掩码术语（请参阅<a target="_blank" rel="noopener" href="http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf">Naty Hoffman 的 SIGGRAPH Notes</a>），但该模型在没有大量代码按摩的情况下健壮地插入，这使得教程代码更易于理解。Schlick 近似的这个公式来自基于物理的着色课程的 Karas 的 SIGGRAPH 2013 笔记：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">schlickMaskingTerm</span><span class="params">(<span class="type">float</span> NdotL, <span class="type">float</span> NdotV, <span class="type">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Karis notes they use alpha / 2 (or roughness^2 / 2)</span></span><br><span class="line">	<span class="type">float</span> k = roughness*roughness / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute G(v) and G(l).  These equations directly from Schlick 1994</span></span><br><span class="line">	<span class="comment">//     (Though note, Schlick's notation is cryptic and confusing.)</span></span><br><span class="line">	<span class="type">float</span> g_v = NdotV / (NdotV*(<span class="number">1</span> - k) + k);</span><br><span class="line">	<span class="type">float</span> g_l = NdotL / (NdotL*(<span class="number">1</span> - k) + k);</span><br><span class="line">	<span class="keyword">return</span> g_v * g_l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Finally, the <code>F</code> term in the Cook-Torrance model is the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fresnel_equations">Fresnel term</a>, which describes how materials become more reflective when seen from a grazing angle. Rarely do renderers implement the full Fresnel equations, which account for the wave nature of light. Since most real-time renderers assume <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Geometrical_optics">geometric optics</a>, we can ignore wave effects, and most renderers use <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Schlick's_approximation">Schlick’s approximation</a>, which comes from the same paper references above:</p></blockquote><p>最后，<code>F</code>Cook-Torrance 模型中的术语是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fresnel_equations">菲涅耳术语</a>，它描述了从掠射角度看材料如何变得更具反射性。渲染器很少实现完整的菲涅耳方程，这些方程解释了光的波动性。由于大多数实时渲染器假设<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Geometrical_optics">几何光学</a>，我们可以忽略波动效果，并且大多数渲染器使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Schlick's_approximation">Schlick 近似</a>，它来自上述相同的论文参考：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">schlickFresnel</span><span class="params">(float3 f0, <span class="type">float</span> lDotH)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> f0 + (<span class="built_in">float3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>) - f0) * <span class="built_in">pow</span>(<span class="number">1.0f</span> - lDotH, <span class="number">5.0f</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Finally, in addition to the three functions representing <code>D</code>, <code>G</code>, and <code>F</code>, the <code>microfacetBRDFUtils.hlsli</code> also includes the function <code>getGGXMicrofacet()</code> which gets a random microfacet orientation (i.e., a facet normal) that follows the distribution described by the function <code>ggxNormalDistribution()</code>. This allows us to randomly choose what direction a ray bounces when it leaves a specular surface:</p></blockquote><p>最后，除了表示<code>D</code>、<code>G</code>和的三个函数之外<code>F</code>，<code>microfacetBRDFUtils.hlsli</code>还包括<code>getGGXMicrofacet()</code>获得遵循函数 描述的分布的随机微面方向（即，面法线）的函数<code>ggxNormalDistribution()</code>。这允许我们随机选择光线离开镜面反射面时的反弹方向：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// When using this function to sample, the probability density is:</span></span><br><span class="line"><span class="comment">//      pdf = D * NdotH / (4 * HdotV)</span></span><br><span class="line"><span class="function">float3 <span class="title">getGGXMicrofacet</span><span class="params">(inout uint randSeed, <span class="type">float</span> roughness, float3 hitNorm)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Get our uniform random numbers</span></span><br><span class="line">	float2 randVal = <span class="built_in">float2</span>(<span class="built_in">nextRand</span>(randSeed), <span class="built_in">nextRand</span>(randSeed));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get an orthonormal basis from the normal</span></span><br><span class="line">	float3 B = <span class="built_in">getPerpendicularVector</span>(hitNorm);</span><br><span class="line">	float3 T = <span class="built_in">cross</span>(B, hitNorm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GGX NDF sampling</span></span><br><span class="line">	<span class="type">float</span> a2 = roughness * roughness;</span><br><span class="line">	<span class="type">float</span> cosThetaH = <span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0.0f</span>, (<span class="number">1.0</span>-randVal.x)/((a2<span class="number">-1.0</span>)*randVal.x+<span class="number">1</span>) ));</span><br><span class="line">	<span class="type">float</span> sinThetaH = <span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span> - cosThetaH * cosThetaH));</span><br><span class="line">	<span class="type">float</span> phiH = randVal.y * M_PI * <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get our GGX NDF sample (i.e., the half vector)</span></span><br><span class="line">	<span class="keyword">return</span> T * (sinThetaH * <span class="built_in">cos</span>(phiH)) +</span><br><span class="line">           B * (sinThetaH * <span class="built_in">sin</span>(phiH)) +</span><br><span class="line">           hitNorm * cosThetaH;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Shading-a-Surface-Point"><a href="#Shading-a-Surface-Point" class="headerlink" title="Shading a Surface Point"></a>Shading a Surface Point</h3><blockquote><p>When shading a point on a surface, we need to invoke these microfacet BRDF functions. To reduce the chance of error, we combine these into a function and call this function from multiple locations. In particular, inside the ray generation shader <code>ggxGlobalIllumination.rt.hlsl</code>, shading looks as follows:</p></blockquote><p>当对表面上的点进行着色时，我们需要调用这些微平面 BRDF 函数。为了减少出错的机会，我们将它们组合成一个函数，并从多个位置调用这个函数。特别是，在光线生成着色器<code>ggxGlobalIllumination.rt.hlsl</code>中，着色如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Add any emissive color from primary rays</span></span><br><span class="line">shadeColor = gEmitMult * pixelEmissive.rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do explicit direct lighting to a random light in the scene</span></span><br><span class="line"><span class="keyword">if</span> (gDoDirectGI)</span><br><span class="line">	shadeColor += <span class="built_in">ggxDirect</span>(randSeed, worldPos.xyz, worldNorm.xyz, V,</span><br><span class="line">				         difMatlColor.rgb, specMatlColor.rgb, roughness);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do indirect lighting for global illumination</span></span><br><span class="line"><span class="keyword">if</span> (gDoIndirectGI &amp;&amp; (gMaxDepth &gt; <span class="number">0</span>))</span><br><span class="line">	shadeColor += <span class="built_in">ggxIndirect</span>(randSeed, worldPos.xyz, worldNorm.xyz, V,</span><br><span class="line">				         difMatlColor.rgb, specMatlColor.rgb, roughness, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Basically, the color at any hitpoint is: the color a surface emits, plus any light directly visible from light sources, plus light that bounces in via additional bounces along the path.</p></blockquote><p>基本上，任何命中点的颜色是：表面发出的颜色，加上从光源直接可见的任何光，加上通过沿路径的额外反射而反射的光。</p><blockquote><p>When we fire indirect rays (see <code>indirectRay.hlsli</code>), we shade the closest hit using a similar process:</p></blockquote><p>当我们发射间接光线（参见 参考资料<code>indirectRay.hlsli</code>）时，我们使用类似的过程对最近的命中进行着色：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="built_in">shader</span>(<span class="string">"closesthit"</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndirectClosestHit</span><span class="params">(inout IndirectRayPayload rayData,</span></span></span><br><span class="line"><span class="params"><span class="function">                        BuiltInTriangleIntersectionAttributes attribs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Run a helper functions to extract Falcor scene data for shading</span></span><br><span class="line">	ShadingData shadeData = <span class="built_in">getHitShadingData</span>( attribs, <span class="built_in">WorldRayOrigin</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add emissive color</span></span><br><span class="line">    rayData.color = gEmitMult * shadeData.emissive.rgb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do direct illumination at this hit location</span></span><br><span class="line">    <span class="keyword">if</span> (gDoDirectGI)</span><br><span class="line">    {</span><br><span class="line">        rayData.color += <span class="built_in">ggxDirect</span>(rayData.rndSeed, shadeData.posW,</span><br><span class="line">            shadeData.N, shadeData.V, shadeData.diffuse, shadeData.specular,</span><br><span class="line">            shadeData.roughness);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do indirect illumination (if we haven't traversed too far)</span></span><br><span class="line">	<span class="keyword">if</span> (rayData.rayDepth &lt; gMaxDepth)</span><br><span class="line">	{</span><br><span class="line">		rayData.color += <span class="built_in">ggxIndirect</span>(rayData.rndSeed, shadeData.posW,</span><br><span class="line">            shadeData.N, shadeData.V, shadeData.diffuse, shadeData.specular,</span><br><span class="line">            shadeData.roughness, rayData.rayDepth);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Direct-Lighting-Using-a-GGX-Model"><a href="#Direct-Lighting-Using-a-GGX-Model" class="headerlink" title="Direct Lighting Using a GGX Model"></a>Direct Lighting Using a GGX Model</h3><blockquote><p>Direct lighting using a GGX model looks very similar to the direct lighting using Lambertian from <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor12/tutorial12.md.html">Tutorial 12</a>. In particutlar, we start by picing a random light, extracting it’s information from the Falcor scene representation, and tracing a shadow ray to determine if it is visible.</p></blockquote><p>使用 GGX 模型的直接光照看起来与使用 <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor12/tutorial12.md.html">教程 12</a> 中的 Lambertian 的直接光照非常相似。具体而言，我们首先对随机光进行拍照，从 Falcor 场景表示中提取其信息，然后跟踪阴影光线以确定它是否可见。</p><blockquote><p>Note that with many BRDFs, our GGX model consists of a specular lobe and a diffuse lobe. The math for the diffuse lobe is identical to that in Tutorial 12, we’re just adding a new specular lobe to the diffuse term.</p></blockquote><p>请注意，对于许多 BRDF，我们的 GGX 模型由镜面反射波瓣和漫射波瓣组成。漫反射叶的数学与教程 12 中的相同，我们只是在漫反射项中添加了一个新的镜面反射叶。</p><blockquote><p>If visible, we perform shading using the GGX model (i.e., <code>D * G * F / (4* NdotL * NdotV)</code>). In this case, numerical robustness is improved significantly by cancelling <code>NdotL</code> terms in the GGX lobe to avoid potential divide-by-zero when light hits geometry at a grazing angle. I left in these cancelled <code>NdotL</code> terms in comments to make the math clear.</p></blockquote><p>如果可见，我们使用 GGX 模型（即<code>D * G * F / (4* NdotL * NdotV)</code>）执行着色。在这种情况下，通过取消 GGX 波瓣中的项来显着提高数值鲁棒性，<code>NdotL</code>以避免在光线以掠射角撞击几何体时出现电位除零。我在评论中留下了这些被取消<code>NdotL</code>的术语，以使数学上更清楚。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">ggxDirect</span><span class="params">(inout uint rndSeed, float3 hit, float3 N, float3 V,</span></span></span><br><span class="line"><span class="params"><span class="function">                 float3 dif, float3 spec, <span class="type">float</span> rough)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Pick a random light from our scene to shoot a shadow ray towards</span></span><br><span class="line">	<span class="type">int</span> lightToSample = <span class="built_in">min</span>( <span class="built_in">int</span>(<span class="built_in">nextRand</span>(rndSeed) * gLightsCount),</span><br><span class="line">                             gLightsCount - <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Query the scene to find info about the randomly selected light</span></span><br><span class="line">	<span class="type">float</span> distToLight;</span><br><span class="line">	float3 lightIntensity;</span><br><span class="line">	float3 L;</span><br><span class="line">	<span class="built_in">getLightData</span>(lightToSample, hit, L, lightIntensity, distToLight);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute our lambertion term (N dot L)</span></span><br><span class="line">	<span class="type">float</span> NdotL = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(N, L));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Shoot our shadow ray to our randomly selected light</span></span><br><span class="line">	<span class="type">float</span> shadowMult = <span class="built_in">float</span>(gLightsCount) *</span><br><span class="line">                       <span class="built_in">shadowRayVisibility</span>(hit, L, gMinT, distToLight);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute half vectors and additional dot products for GGX</span></span><br><span class="line">	float3 H = <span class="built_in">normalize</span>(V + L);</span><br><span class="line">	<span class="type">float</span> NdotH = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(N, H));</span><br><span class="line">	<span class="type">float</span> LdotH = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(L, H));</span><br><span class="line">	<span class="type">float</span> NdotV = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(N, V));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Evaluate terms for our GGX BRDF model</span></span><br><span class="line">	<span class="type">float</span>  D = <span class="built_in">ggxNormalDistribution</span>(NdotH, rough);</span><br><span class="line">	<span class="type">float</span>  G = <span class="built_in">ggxSchlickMaskingTerm</span>(NdotL, NdotV, rough);</span><br><span class="line">	float3 F = <span class="built_in">schlickFresnel</span>(spec, LdotH);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Evaluate the Cook-Torrance Microfacet BRDF model</span></span><br><span class="line">	<span class="comment">//     Cancel NdotL here to avoid catastrophic numerical precision issues.</span></span><br><span class="line">	float3 ggxTerm = D*G*F / (<span class="number">4</span> * NdotV <span class="comment">/* * NdotL */</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute our final color (combining diffuse lobe plus specular GGX lobe)</span></span><br><span class="line">	<span class="keyword">return</span> shadowMult * lightIntensity * ( <span class="comment">/* NdotL * */</span> ggxTerm +</span><br><span class="line">                                           NdotL * dif / M_PI);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Indirect-Lighting-Using-a-GGX-Model"><a href="#Indirect-Lighting-Using-a-GGX-Model" class="headerlink" title="Indirect Lighting Using a GGX Model"></a>Indirect Lighting Using a GGX Model</h3><blockquote><p>Bouncing an indirect ray is somewhat more complex. Since we have both a diffuse lobe and a specular lobe, we need to sample them somewhat differently; the cosine sampling used for lambertian shading doesn’t have particularly good characteristics for GGX. One way would shoot two rays: one in the diffuse lobe and one in the specular lobe. But this gets costly, and they converge at different rates.</p></blockquote><p>反射间接光线要复杂一些。由于我们同时有一个漫射波瓣和一个镜面波瓣，我们需要对它们进行稍微不同的采样；用于朗伯着色的余弦采样对于 GGX 没有特别好的特性。一种方法是发射两条光线：一条在漫射波瓣中，一条在镜面波瓣中。但这会变得昂贵，并且它们以不同的速率收敛。</p><blockquote><p>Instead, we randomly pick whether to shoot an indirect diffuse or indirect glossy ray (see <code>ggxIndirect()</code>):</p></blockquote><p>相反，我们随机选择是拍摄间接漫反射还是间接光泽光线（参见 参考资料<code>ggxIndirect()</code>）：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// We have to decide whether we sample our diffuse or specular/ggx lobe.</span></span><br><span class="line"><span class="type">float</span> probDiffuse = <span class="built_in">probabilityToSampleDiffuse</span>(dif, spec);</span><br><span class="line"><span class="type">float</span> chooseDiffuse = (<span class="built_in">nextRand</span>(rndSeed) &lt; probDiffuse);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>In this case, we choose specular or diffuse based on their diffuse and specular albedos, though this isn’t a particularly well thought out or principaled approach:</p></blockquote><p>在这种情况下，我们根据漫反射和镜面反射率选择镜面反射或漫反射，尽管这不是一个经过深思熟虑或原则性的方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">probabilityToSampleDiffuse</span><span class="params">(float3 difColor, float3 specColor)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> lumDiffuse = <span class="built_in">max</span>(<span class="number">0.01f</span>, <span class="built_in">luminance</span>(difColor.rgb));</span><br><span class="line">	<span class="type">float</span> lumSpecular = <span class="built_in">max</span>(<span class="number">0.01f</span>, <span class="built_in">luminance</span>(specColor.rgb));</span><br><span class="line">	<span class="keyword">return</span> lumDiffuse / (lumDiffuse + lumSpecular);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Going back to <code>ggxIndirect()</code>, if we sample our diffuse lobe, the indirect ray looks almost identical to that from <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor12/tutorial12.md.html">Tutorial 12</a>. We shoot a cosine-distributed ray, return the color, and divide by the probability of selecting this ray.</p></blockquote><p>回到<code>ggxIndirect()</code>，如果我们对漫射波瓣进行采样，间接光线看起来与<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor12/tutorial12.md.html">教程 12</a>中的几乎相同。我们射出一条余弦分布的光线，返回颜色，然后除以选择这条光线的概率。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chooseDiffuse)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Shoot a randomly selected cosine-sampled diffuse ray.</span></span><br><span class="line">	float3 L = <span class="built_in">getCosHemisphereSample</span>(rndSeed, N);</span><br><span class="line">	float3 bounceColor = <span class="built_in">shootIndirectRay</span>(hit, L, gMinT, <span class="number">0</span>, rndSeed, rayDepth);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Accumulate the color: (NdotL * incomingLight * dif / pi)</span></span><br><span class="line">	<span class="comment">// Probability of sampling this ray:  (NdotL / pi) * probDiffuse</span></span><br><span class="line">	<span class="keyword">return</span> bounceColor * dif / probDiffuse;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>If we choose to sample the GGX lobe, the behavior is fundamentally identical even though the code is more complex: select a random ray, shoot it and return a color, and divide by the probability of selecting this ray. The key is that when we sample according to <code>getGGXMicrofacet()</code> our probability density for our rays is different (and described by <code>D * NdotH / (4 * LdotH)</code>).</p></blockquote><p>如果我们选择对 GGX 波瓣进行采样，即使代码更复杂，行为也基本相同：选择一条随机光线，拍摄它并返回一种颜色，然后除以选择这条光线的概率。关键是当我们根据<code>getGGXMicrofacet()</code>我们的概率密度对我们的光线进行采样时是不同的（并且由 描述<code>D * NdotH / (4 * LdotH)</code>）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Otherwise we randomly selected to sample our GGX lobe</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Randomly sample the NDF to get a microfacet in our BRDF </span></span><br><span class="line">	float3 H = <span class="built_in">getGGXMicrofacet</span>(rndSeed, rough, N);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute outgoing direction based on this (perfectly reflective) facet</span></span><br><span class="line">	float3 L = <span class="built_in">normalize</span>(<span class="number">2.f</span> * <span class="built_in">dot</span>(V, H) * H - V);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute our color by tracing a ray in this direction</span></span><br><span class="line">	float3 bounceColor = <span class="built_in">shootIndirectRay</span>(hit, L, gMinT, <span class="number">0</span>, rndSeed, rayDepth);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute some dot products needed for shading</span></span><br><span class="line">	<span class="type">float</span>  NdotL = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(N, L));</span><br><span class="line">	<span class="type">float</span>  NdotH = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(N, H));</span><br><span class="line">	<span class="type">float</span>  LdotH = <span class="built_in">saturate</span>(<span class="built_in">dot</span>(L, H));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Evaluate our BRDF using a microfacet BRDF model</span></span><br><span class="line">	<span class="type">float</span>  D = <span class="built_in">ggxNormalDistribution</span>(NdotH, rough);          </span><br><span class="line">	<span class="type">float</span>  G = <span class="built_in">ggxSchlickMaskingTerm</span>(NdotL, NdotV, rough); </span><br><span class="line">	float3 F = <span class="built_in">schlickFresnel</span>(spec, LdotH);                 </span><br><span class="line">	float3 ggxTerm = D * G * F / (<span class="number">4</span> * NdotL * NdotV);        </span><br><span class="line"></span><br><span class="line">	<span class="comment">// What's the probability of sampling vector H from getGGXMicrofacet()?</span></span><br><span class="line">	<span class="type">float</span>  ggxProb = D * NdotH / (<span class="number">4</span> * LdotH);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Accumulate color:  ggx-BRDF * lightIn * NdotL / probability-of-sampling</span></span><br><span class="line">	<span class="comment">//    -&gt; Note: Should really cancel and simplify the math above</span></span><br><span class="line">	<span class="keyword">return</span> NdotL * bounceColor * ggxTerm / (ggxProb * (<span class="number">1.0f</span> - probDiffuse));</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="What-Does-it-Look-Like"><a href="#What-Does-it-Look-Like" class="headerlink" title="What Does it Look Like?"></a>What Does it Look Like?</h3><blockquote><p>That covers the important points of this tutorial. When running, you get the following result:</p></blockquote><p>这涵盖了本教程的重点。运行时，您会得到以下结果：</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor14-Output-20220210163448689.png"></p><blockquote><p>With this tutorial, you can run Falcor’s using a fairly feature-rich path tracer, even if the sampling is extremely naive. Moving forward, which is left as an exercise to the reader, you can add better importance sampling, multiple importance sampling, and using next-event estimation for better explicit direct lighting. Additionally, we haven’t handled refractive materials in this set of tutorials, though as described in Pete Shirley’s <a target="_blank" rel="noopener" href="https://github.com/petershirley/raytracinginoneweekend">Ray Tracing in One Weekend</a>, this is fairly straightforward to add.</p></blockquote><p>通过本教程，您可以使用即使采样非常简单但功能相当丰富的路径跟踪器运行 Falcor。继续前进，作为练习留给读者，您可以添加更好的重要性采样、多重重要性采样，并使用下一个事件估计来获得更好的显式直接照明。此外，在这组教程中，我们没有处理折射材料，尽管如 Pete Shirley <a target="_blank" rel="noopener" href="https://github.com/petershirley/raytracinginoneweekend">Ray Tracing in One Weekend</a> 所述，这很容易添加。</p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/1503bc5d.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 13</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/62048ccb.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 12</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/fb0ddd71.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 11</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/ac35df33.html" rel="prev" title="Cameras and How They Work"><i class="fa fa-chevron-left"></i> Cameras and How They Work</a></div><div class="post-nav-item"><a href="/archives/d33850b7.html" rel="next" title="浅谈游戏中的道德困境">浅谈游戏中的道德困境 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Changes-to-the-C-Code"><span class="nav-number">2.</span> <span class="nav-text">Changes to the C++ Code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#New-Microfacet-Functions-in-the-HLSL-Code"><span class="nav-number">3.</span> <span class="nav-text">New Microfacet Functions in the HLSL Code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shading-a-Surface-Point"><span class="nav-number">4.</span> <span class="nav-text">Shading a Surface Point</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Direct-Lighting-Using-a-GGX-Model"><span class="nav-number">5.</span> <span class="nav-text">Direct Lighting Using a GGX Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Indirect-Lighting-Using-a-GGX-Model"><span class="nav-number">6.</span> <span class="nav-text">Indirect Lighting Using a GGX Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-Does-it-Look-Like"><span class="nav-number">7.</span> <span class="nav-text">What Does it Look Like?</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">273</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.1m</span></div><div class="powered-by">今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//fastly.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//fastly.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//fastly.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="/lib/three/three.min.js"></script><script defer="" src="//fastly.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//fastly.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script async="" src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script>!function(t,h,e,j){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:2272201,hjsv:6},e=h.getElementsByTagName("head")[0],(j=h.createElement("script")).async=1,j.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,e.appendChild(j)}(window,document)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言本节将继续完善环境光遮蔽。随时间累积帧，为 AO 提供每像素任意多条光线。"><meta property="og:type" content="article"><meta property="og:title" content="A Gentle Introduction to DirectX Raytracing 6"><meta property="og:url" content="https://yousazoe.top/archives/489ff1eb.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言本节将继续完善环境光遮蔽。随时间累积帧，为 AO 提供每像素任意多条光线。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor06-Output.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor06-Output-20211222184355008.png"><meta property="article:published_time" content="2021-12-22T10:39:53.000Z"><meta property="article:modified_time" content="2022-09-08T13:25:48.700Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor06-Output.png"><link rel="canonical" href="https://yousazoe.top/archives/489ff1eb.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>A Gentle Introduction to DirectX Raytracing 6 | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/489ff1eb.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">A Gentle Introduction to DirectX Raytracing 6</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-12-22 18:39:53" itemprop="dateCreated datePublished" datetime="2021-12-22T18:39:53+08:00">2021-12-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">光线追踪 (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>12k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>23 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor06-Output.png"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本节将继续完善环境光遮蔽。随时间累积帧，为 AO 提供每像素任意多条光线。</p><span id="more"></span><blockquote><p>In <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor5/tutorial05.md.html">Tutorial 5</a>, we built a hybrid ray tracer that generates a rasterized <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deferred_shading">G-Buffer</a> and then in a second pass shoots rays into the environment to discover nearby occluders. However, for most <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stochastic">stochastic</a> algorithms our random rays introduce a lot of noise. The easiest way to reduce the noise is to improve our approximation by firing more rays — either all at once, or by accumulating them over multiple frames.</p></blockquote><p>在<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor5/tutorial05.md.html">教程5</a>中，我们构建了一个混合光线追踪器，它生成一个栅格化的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deferred_shading">G-Buffer</a>，然后在第二次传递中将光线射入环境以发现附近的遮挡物。然而，对于大多数<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stochastic">随机算法</a>我们的随机射线会引入很多噪声。减少噪点的最简单方法是通过发射更多光线来改善我们的近似值 - 一次全部，或者将它们累积到多个帧中。</p><blockquote><p>In this demo, we are going to create a new <code>RenderPass</code> that keeps internal state to average multiple frames to get a high quality ambient occlusion rendering. We will reuse this <code>SimpleAccumulationPass</code> in most of our subsequent tutorials to allow generation of very high quality images.</p></blockquote><p>在此演示中，我们将创建一个新的 <code>RenderPass</code>，它将内部状态保持在平均多个帧，以获得高质量的环境光遮蔽渲染。我们将在大多数后续教程中重用此 <code>SimpleAccumulationPass</code> 以生成非常高质量的图像。</p><h3 id="Our-Improved-Temporal-Accumulation-Rendering-Pipeline"><a href="#Our-Improved-Temporal-Accumulation-Rendering-Pipeline" class="headerlink" title="Our Improved Temporal Accumulation Rendering Pipeline"></a>Our Improved Temporal Accumulation Rendering Pipeline</h3><blockquote><p>If you open up <code>Tutor06-TemporalAccumulation.cpp</code>, you will find our new pipeline combines the <code>SimpleGBufferPass</code> from <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">Tutorial 3</a>, the <code>AmbientOcclusionPass</code> from <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor5/tutorial05.md.html">Tutorial 5</a> and the new <code>SimpleAccumulationPass</code> we’ll build below.</p></blockquote><p>如果您打开 <code>Tutor06-TemporalAccumulation.cpp</code>，您会发现我们的新管道结合了<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor3/tutorial03.md.html">教程3</a>中的<code>SimpleGBufferPass</code>、<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor5/tutorial05.md.html">教程5</a>中的 <code>AmbientOcclusionPass</code> 和我们将在下面构建的新 <code>SimpleAccumulationPass</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create our rendering pipeline</span></span><br><span class="line">RenderingPipeline *pipeline = <span class="keyword">new</span> <span class="built_in">RenderingPipeline</span>();</span><br><span class="line">pipeline-&gt;<span class="built_in">setPass</span>(<span class="number">0</span>, SimpleGBufferPass::<span class="built_in">create</span>());   </span><br><span class="line">pipeline-&gt;<span class="built_in">setPass</span>(<span class="number">1</span>, AmbientOcclusionPass::<span class="built_in">create</span>());    </span><br><span class="line">pipeline-&gt;<span class="built_in">setPass</span>(<span class="number">2</span>, </span><br><span class="line">    SimpleAccumulationPass::<span class="built_in">create</span>(ResourceManager::kOutputChannel));</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This <code>SimpleAccumulationPass</code> takes as input the shared texture to accumulate. Logically, this pipeline (a) renders a G-buffer, (b) computes ambient occludion, storing the output in <code>kOutputChannel</code>, then (c) accumulates the image in <code>kOutputChannel</code> with the renderings from prior frames and outputs the accumulate result back to <code>kOutputChannel</code>.</p></blockquote><p>这个 <code>SimpleAccumulationPass</code> 将共享纹理作为输入进行累积。从逻辑上讲，此管道（a）渲染出一个 G 缓冲区，（b）计算环境光遮蔽，将输出存储在 <code>kOutputChannel</code> 中，然后（c）将图像与先前帧的渲染一起以 <code>kOutputChannel</code> 为单位累积，并将累积结果输出回 <code>kOutputChannel</code> 。</p><blockquote><p>Of course, our <code>SimpleAccumulationPass</code> is a bit more sophisticated, as it allows clearing the accumulation when you move the camera or make other changes to program settings.</p></blockquote><p>当然，我们的 <code>SimpleAccumulationPass</code> 更复杂一些，因为它允许您在移动相机或对程序设置进行其他更改时清除累积。</p><h3 id="Accumulating-Images-Temporally"><a href="#Accumulating-Images-Temporally" class="headerlink" title="Accumulating Images Temporally"></a>Accumulating Images Temporally</h3><blockquote><p>Continue by looking in <code>SimpleAccumulationPass.h</code>. Unlike the past few demos, this pass does not require any ray tracing. Instead, we use rasterization over the full screen (i.e., the <code>FullscreenLaunch</code> wrapper) to do our temporal accumulation. Thus, this pass is closer in appearance to our sinusoid rendering in <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor2/tutorial02.md.html">Tutorial 2</a>.</p></blockquote><p>继续查看 <code>SimpleAccumulationPass.h</code>。与过去的几个演示不同，此管线不需要任何光线追踪。相反，我们在全屏（即 <code>FullscreenLaunch</code> 包装器）上使用光栅化来执行我们的时间累积。因此，此通道在外观上更接近 <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor2/tutorial02.md.html">教程 2</a> 中的正弦渲染。</p><blockquote><p>Hopefully, the <code>RenderPass</code> declaration boilerplate is starting to look familiar. There are a couple key changes. For instance, this pass overrides a few new <code>RenderPass</code> methods:</p></blockquote><p><code>RenderPass</code> 声明样板开始看起来很熟悉。这里有几个关键的变化，例如此管线将覆盖一些新的 <code>RenderPass</code> 方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span> <span class="keyword">override</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stateRefreshed</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>The <code>resize()</code> callback gets executed when the screen resolution changes. Since our accumulation pass averages results over multiple frames, when the resolution changes we need to update our internal storage to match the new frame size.</p></blockquote><p><code>resize()</code> 回调在屏幕分辨率更改时执行。由于我们的累积传递是多个帧的结果的平均值，因此当分辨率更改时，我们需要更新内部存储以匹配新的帧大小。</p><blockquote><p>The <code>stateRefreshed()</code> callback gets executed whenever any other pass notes that its settings have changed. In this case, our image will likely change significantly and we should reset our accumulated result.</p></blockquote><p>每当任何其他管线注意到其设置已更改时，就会执行 <code>stateRefreshed()</code> 回调。在这种情况下，我们的图像可能会发生重大变化，我们应该重置累积的结果。</p><blockquote><p>We also store various new internal data:</p></blockquote><p>我们还存储各种新的内部数据：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Texture::SharedPtr  mpLastFrame;         <span class="comment">// Our accumulated result</span></span><br><span class="line"><span class="type">uint32_t</span>            mAccumCount = <span class="number">0</span>;     <span class="comment">// Total frames have we accumulated</span></span><br><span class="line">Scene::SharedPtr    mpScene;             <span class="comment">// What scene are we using?</span></span><br><span class="line">mat4                mpLastCameraMatrix;  <span class="comment">// The last camera matrx</span></span><br><span class="line">Fbo::SharedPtr      mpInternalFbo;       <span class="comment">// A temp framebuffer for rendering</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>In particular, we need a place to store our accumulated color from prior frames (we put that in <code>mpLastFrame</code>) and a count of how many frames we have accumulated (in <code>mAccumCount</code>).</p></blockquote><p>特别是，我们需要一个地方来存储从先前帧中累积的颜色（我们将其放在 <code>mpLastFrame</code> 中），并计算我们累积了多少帧（以 <code>mAccumCount</code> 为单位）。).</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Texture::SharedPtr  mpLastFrame;         <span class="comment">// Our accumulated result</span></span><br><span class="line"><span class="type">uint32_t</span>            mAccumCount = <span class="number">0</span>;     <span class="comment">// Total frames have we accumulated</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>To avoid accumulating during motion (which gives an ugly smeared look), we need to detect when the camera moves, so we can stop accumulating. We do this by remember the scene and comparing the current camera state with last frame (<code>mpScene</code> and <code>mpLastCameraMatrix</code>).</p></blockquote><p>为了避免在运动过程中累积（这会产生丑陋的涂抹外观），我们需要检测相机何时移动，以便我们可以停止累积。我们通过记住场景并将当前相机状态与最后一帧 <code>mpScene</code> 和<code>mpLastCameraMatrix</code> 进行比较来做到这一点。).</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Scene::SharedPtr    mpScene;             <span class="comment">// What scene are we using?</span></span><br><span class="line">mat4                mpLastCameraMatrix;  <span class="comment">// The last camera matrx</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>We also need a framebuffer object for our full-screen raster pass, and we create one on initialization (in <code>mpInternalFbo</code>) and reuse it every frame.</p></blockquote><p>我们还需要一个帧缓冲器对象用于全屏光栅传递，我们在初始化时创建一个（在 <code>mpInternalFbo</code> 中），并在每帧重用它。</p><h4 id="Initializing-our-Accumulation-Pass"><a href="#Initializing-our-Accumulation-Pass" class="headerlink" title="Initializing our Accumulation Pass"></a>Initializing our Accumulation Pass</h4><blockquote><p>Our <code>SimpleAccumulationPass::initialize()</code> is straightforward:</p></blockquote><p>我们的 <code>SimpleAccumulationPass::initialize()</code> 很简单：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SimpleAccumulationPass::initialize</span><span class="params">(RenderContext::SharedPtr pRenderContext, </span></span></span><br><span class="line"><span class="params"><span class="function">                                        ResourceManager::SharedPtr pResManager)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// Stash a copy of our resource manager; request needed buffer resources</span></span><br><span class="line">  mpResManager = pResManager;</span><br><span class="line">  mpResManager-&gt;<span class="built_in">requestTextureResource</span>( mAccumChannel );  <span class="comment">// Pass input</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create our graphics state and an accumulation shader</span></span><br><span class="line">  mpGfxState = GraphicsState::<span class="built_in">create</span>();</span><br><span class="line">  mpAccumShader = FullscreenLaunch::<span class="built_in">create</span>(<span class="string">"accumulate.ps.hlsl"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>First we ask to access the texture we’re going to accumulate into. This is the channel name passed as input to our pass constructor in <code>Tutor06-TemporalAccumulation.cpp</code>.</p></blockquote><p>首先，我们要求访问我们将要累积的纹理。这是在 <code>Tutor06-TemporalAccumulation.cpp</code> 中作为输入传递给我们的传递构造函数的管线名称.cpp。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Stash a copy of our resource manager; request needed buffer resources</span></span><br><span class="line">mpResManager = pResManager;</span><br><span class="line">mpResManager-&gt;<span class="built_in">requestTextureResource</span>( mAccumChannel );  <span class="comment">// Pass input</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Then we create a rasterization pipeline graphics state and our wrapper for our fullscreeen accumulation shader.</p></blockquote><p>然后，我们创建一个光栅化图形渲染管线和为全屏积累着色器的封装器。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create our graphics state and an accumulation shader</span></span><br><span class="line">mpGfxState = GraphicsState::<span class="built_in">create</span>();</span><br><span class="line">mpAccumShader = FullscreenLaunch::<span class="built_in">create</span>(<span class="string">"accumulate.ps.hlsl"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="Accumulating-Current-Frame-With-Prior-Frames"><a href="#Accumulating-Current-Frame-With-Prior-Frames" class="headerlink" title="Accumulating Current Frame With Prior Frames"></a>Accumulating Current Frame With Prior Frames</h4><blockquote><p>Now that we initialized our rendering resources, we can shoot do temporal accumulation. Let’s walk through the <code>SimpleAccumulationPass::execute</code> pass below:</p></blockquote><p>现在我们初始化了渲染资源，我们可以进行时间累积了。让我们通过下面的 <code>SimpleAccumulationPass::execute</code> pass进行演示：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SimpleAccumulationPass::execute</span><span class="params">(RenderContext::SharedPtr pRenderContext)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// Get our output buffer; clear it to black.</span></span><br><span class="line">  <span class="keyword">auto</span> accumTex = mpResManager-&gt;<span class="built_in">getTexture</span>(mAccumChannel);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If camera moved, reset accumulation</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">hasCameraMoved</span>()) {</span><br><span class="line">     mAccumCount = <span class="number">0</span>;</span><br><span class="line">     mLastCameraMatrix = mpScene-&gt;<span class="built_in">getActiveCamera</span>()-&gt;<span class="built_in">getViewMatrix</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set our shader variables for our accumulation shader</span></span><br><span class="line">  <span class="keyword">auto</span> shaderVars = mpAccumShader-&gt;<span class="built_in">getVars</span>();</span><br><span class="line">  shaderVars[<span class="string">"PerFrameCB"</span>][<span class="string">"gAccumCount"</span>] = mAccumCount++; </span><br><span class="line">  shaderVars[<span class="string">"gLastFrame"</span>] = mpLastFrame;   <span class="comment">// Running accumulation total</span></span><br><span class="line">  shaderVars[<span class="string">"gCurFrame"</span>]  = accumTex;      <span class="comment">// Current frame to accumulate</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute the accumulation shader</span></span><br><span class="line">  mpGfxState-&gt;<span class="built_in">setFbo</span>( mpInternalFbo );</span><br><span class="line">  mpAccumShader-&gt;<span class="built_in">execute</span>( pRenderContext, mpGfxState );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy accumulated result (to output and our temporary buffer)</span></span><br><span class="line">  <span class="keyword">auto</span> outputTex = mpInternalFbo-&gt;<span class="built_in">getColorTexture</span>(<span class="number">0</span>);</span><br><span class="line">  pRenderContext-&gt;<span class="built_in">blit</span>( outputTex-&gt;<span class="built_in">getSRV</span>(), accumTex-&gt;<span class="built_in">getRTV</span>() );</span><br><span class="line">  pRenderContext-&gt;<span class="built_in">blit</span>( outputTex-&gt;<span class="built_in">getSRV</span>(), mpLastFrame-&gt;<span class="built_in">getRTV</span>() );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>First, we grab our input texture that we’re accumulating.</p></blockquote><p>首先，我们获取我们正在积累的输入纹理。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Get our output buffer; clear it to black.</span></span><br><span class="line"><span class="keyword">auto</span> accumTex = mpResManager-&gt;<span class="built_in">getTexture</span>(mAccumChannel);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Next, we check if we need to reset our accumulation due to any camera movement in the last frame. See the <code>hasCameraMoved()</code> utility below.</p></blockquote><p>接下来，我们检查是否需要由于最后一帧中的任何相机移动而重置累积。请参阅下面的 <code>hasCameraMoved()</code> 函数。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// If camera moved, reset accumulation</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">hasCameraMoved</span>()) {</span><br><span class="line">    mAccumCount = <span class="number">0</span>;</span><br><span class="line">    mLastCameraMatrix = mpScene-&gt;<span class="built_in">getActiveCamera</span>()-&gt;<span class="built_in">getViewMatrix</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Then we run a simple accumulation shader that takes our prior accumulated result, our current frame, and combines them (with appropriate weights) to get the new average considering the additional frame of input.</p></blockquote><p>然后，我们运行一个简单的累积着色器，该着色器采用我们先前的累积结果，即当前帧，并将它们组合在一起（具有适当的权重）以获得新的平均值，同时考虑额外的输入帧。</p><blockquote><p>Finally, we copy our accumulated result back to our output buffer and our temporary buffer (that keeps our running total for next frame). Note, we use a Falcor utility <code>blit()</code> to do this copy.</p></blockquote><p>最后，我们将累积的结果复制回输出缓冲区和临时缓冲区（保留下一帧的运行总计）。请注意，我们使用 Falcor 内置函数 <code>blit()</code> 来执行此复制。</p><blockquote><p><strong>SRV</strong> means <strong>shader resource view</strong>, which is a DirectX term meaning roughly “a texture accessor used for reading in our shader”. <strong>RTV</strong> means <strong>render target view</strong>, which is a DirectX term meaning roughly “a texture accessor used to write to this texture as output”.</p></blockquote><p><strong>SRV</strong> 表示 <strong>着色器资源视图</strong>，这是一个 DirectX 术语，大致意思是”用于在着色器中读取的纹理访问器”。 <strong>RTV</strong> 表示 <strong>渲染目标视图</strong>，这是一个 DirectX 术语，大致意思是”用于写入此纹理作为输出的纹理访问器”。</p><h4 id="Resetting-Accumulation"><a href="#Resetting-Accumulation" class="headerlink" title="Resetting Accumulation"></a>Resetting Accumulation</h4><blockquote><p>When do we need to stop accumulating with prior frames and instead resetart our accumulation from scratch? We identify three cases we want to handle:</p><ul><li>Whenever the camera moves</li><li>Whenever the screen is resized</li><li>Whenever our <code>RenderPasses</code> in our pipline tell us they have changed state.</li></ul></blockquote><p>我们什么时候需要停止使用先前帧的累积，而是从头开始重置累积？我们确定了要处理的三种情况：</p><ul><li>每当相机移动时</li><li>每当调整屏幕大小时</li><li>每当我们的 <code>RenderPasses</code> 告诉我们他们已经改变了状态。</li></ul><blockquote><p>The camera motion is handled in <code>SimpleAccumulationPass::execute</code>, with a little help from the following utility function:</p></blockquote><p>摄像机运动在 <code>SimpleAccumulationPass::execute</code> 中处理，并得到以下实用程序函数的一点帮助：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SimpleAccumulationPass::hasCameraMoved</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// No scene?  No camera?  Then the camera hasn't moved.</span></span><br><span class="line">  <span class="keyword">if</span> (!mpScene || !mpScene-&gt;<span class="built_in">getActiveCamera</span>())</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check:  Has our camera moved?</span></span><br><span class="line">  <span class="keyword">return</span> (mpLastCameraMatrix != mpScene-&gt;<span class="built_in">getActiveCamera</span>()-&gt;<span class="built_in">getViewMatrix</span>());   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>We can reset accumulation when the window is resized by creating a <code>resize()</code> callback, which is explicitly called when the window changes size. This <code>resize()</code> callback is also called on initialization, since the screen dimensions change from 0 pixels to the actual size.</p></blockquote><p>我们可以通过创建 <code>resize()</code> 回调来重置窗口大小时的累积，该回调在窗口更改大小时显式调用。初始化时也会调用此 <code>resize()</code> 回调，因为屏幕尺寸从 0 像素变为实际大小。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SimpleAccumulationPass::resize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span> </span>{</span><br><span class="line">  <span class="comment">// Resize our internal temporary buffer</span></span><br><span class="line">  mpLastFrame = Texture::<span class="built_in">create2D</span>(width, height, ResourceFormat::RGBA32Float, </span><br><span class="line">                                  <span class="number">1</span>, <span class="number">1</span>, <span class="literal">nullptr</span>, ResourceManager::kDefaultFlags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recreate our framebuffer with the new size</span></span><br><span class="line">  mpInternalFbo = ResourceManager::<span class="built_in">createFbo</span>(width, height, </span><br><span class="line">                                             ResourceFormat::RGBA32Float); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Force accumulation to restart by resetting the counter</span></span><br><span class="line">  mAccumCount = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This resizes our two internal resources (the texture <code>mpLastFrame</code> and the framebuffer <code>mpInternalFbo</code>). We use a Falcor utility to create our texture (the last 4 parameters specify how many array slices and mip levels the texture has, what data it is initialized with, and how it can be bound for rendering). We use our resource manager to create our framebuffer object.</p></blockquote><p>这调整了我们的两个内部资源（纹理 <code>mpLastFrame</code> 和framebuffer <code>mpInternalFbo</code>。我们使用 Falcor 实用程序来创建纹理（最后 4 个参数指定纹理具有多少个数组切片和 mip 级别，使用哪些数据进行初始化，以及如何绑定以进行渲染）。我们使用资源管理器来创建帧缓冲区对象。</p><blockquote><p>Finally we reset the <code>mAccumCount</code> which is actually what ensures we don’t reuse any samples from last frame.</p></blockquote><p>最后，我们重置了<code>mAccumCount</code>。这实际上是确保我们不会重用最后一帧中的任何样本的原因。</p><blockquote><p>Our last important C++ class method is <code>stateRefreshed()</code>, which is a callback that gets executed when any other <code>RenderPasses</code> call their <code>setRefreshFlag()</code> method. This pair of functions is a simple way for passes to communicate: <code>setRefreshFlag()</code> says “I just changed state significantly” and <code>stateRefreshed()</code> allows other passes to process this.</p></blockquote><p>我们最后一个重要的 C++ 类方法是 <code>stateRefreshed()</code>，这是一个当任何其他 <code>RenderPasses</code> 它们的 <code>setRefreshFlag()</code> 方法回调时，它会被执行。这对函数是管线通信的简单方法<code>setRefreshFlag()</code> 表示”我刚刚显著更改了状态”，而 <code>stateRefreshed()</code> 允许其他管线处理此内容。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SimpleAccumulationPass::stateRefreshed</span><span class="params">()</span> </span>{</span><br><span class="line">	mAccumCount = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>In this case, our <code>stateRefreshed()</code> callback is very simple… it just resets accumulation by setting <code>mAccumCount</code> back to zero.</p></blockquote><p>在这种情况下，我们的 <code>stateRefreshed()</code> 回调非常简单…它只是通过将 <code>mAccumCount</code> 设置回零来重置累积。</p><h3 id="DirectX-Accumulation-Shader"><a href="#DirectX-Accumulation-Shader" class="headerlink" title="DirectX Accumulation Shader"></a>DirectX Accumulation Shader</h3><blockquote><p>Our accumulation shader is extremely simple:</p></blockquote><p>我们的累积着色器非常简单：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cbuffer PerFrameCB {</span><br><span class="line">    uint gAccumCount;  <span class="comment">// How many frames have we already accumulated?</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Texture2D&lt;float4&gt;   gLastFrame, gCurFrame;  <span class="comment">// Last and current frame inputs</span></span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">main</span><span class="params">(float2 texC : TEXCOORD, float4 pos : SV_Position)</span> : SV_Target0</span></span><br><span class="line"><span class="function">{</span></span><br><span class="line">    uint2 pixelPos = (uint2)pos.xy;          <span class="comment">// Where is this pixel on screen?</span></span><br><span class="line">    float4 curColor = gCurFrame[pixelPos];   <span class="comment">// Pixel color this frame</span></span><br><span class="line">    float4 prevColor = gLastFrame[pixelPos]; <span class="comment">// Pixel color last frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do a weighted sum, weighing last frame's color based on total count</span></span><br><span class="line">	<span class="keyword">return</span> (gAccumCount * prevColor + curColor) / (gAccumCount + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>This shader is simply a weighted sum. Instead of averaging this frame with the last frame, it weights last frame based on the total number of samples it contains. (The current frame always gets a weight of 1.)</p></blockquote><p>此着色器只是一个加权总和。它不是将此帧与最后一帧求平均，而是根据它包含的样本总数对最后一帧加权（当前帧的权重始终为 1）。</p><h3 id="What-Does-it-Look-Like"><a href="#What-Does-it-Look-Like" class="headerlink" title="What Does it Look Like?"></a>What Does it Look Like?</h3><blockquote><p>That covers the important points of this tutorial. When running, you get the following result:</p></blockquote><p>这涵盖了本教程的要点。运行时，您将获得以下结果：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Tutor06-Output-20211222184355008.png"></p><blockquote><p>Hopefully, this tutorial demonstrated:</p><ul><li>How to use a full-screen pass to run a simple post processing pass</li><li>Accumulate multiple frames together temporally</li><li>Use some of the more advanced callbacks in the <code>RenderPass</code> class.</li></ul></blockquote><p>希望本教程能够演示：</p><ul><li>如何使用全屏通道运行简单的后处理管线</li><li>暂时将多个帧累积在一起</li><li>使用 <code>RenderPass</code> 类中的一些更高级的回调。</li></ul><blockquote><p>When you are ready, continue on to <a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor7/tutorial07.md.html">Tutorial 7</a>, which introduces a camera jitter. When combined with the temporal accumulation from this tutorial, this allows you to get high quality antialiasing to avoid the jaggies seen in the image above.</p></blockquote><p>准备就绪后，请继续学习<a target="_blank" rel="noopener" href="http://cwyman.org/code/dxrTutors/tutors/Tutor7/tutorial07.md.html">教程7</a>，其中引入了相机抖动。当与本教程中的时间累积相结合时，这可以让您获得高质量的抗锯齿，以避免上图中看到的锯齿。</p></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/7dbe30e4.html" rel="bookmark">Blockwise Multi-Order Feature Regression for Real-Time Path Tracing Reconstruction</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/971404c0.html" rel="bookmark">Rendering Course by Wangningbei</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/c38cc8b1.html" rel="prev" title="游戏服务器概述"><i class="fa fa-chevron-left"></i> 游戏服务器概述</a></div><div class="post-nav-item"><a href="/archives/270ba5de.html" rel="next" title="Shell Tutorial">Shell Tutorial <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Our-Improved-Temporal-Accumulation-Rendering-Pipeline"><span class="nav-number">2.</span> <span class="nav-text">Our Improved Temporal Accumulation Rendering Pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accumulating-Images-Temporally"><span class="nav-number">3.</span> <span class="nav-text">Accumulating Images Temporally</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Initializing-our-Accumulation-Pass"><span class="nav-number">3.1.</span> <span class="nav-text">Initializing our Accumulation Pass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Accumulating-Current-Frame-With-Prior-Frames"><span class="nav-number">3.2.</span> <span class="nav-text">Accumulating Current Frame With Prior Frames</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Resetting-Accumulation"><span class="nav-number">3.3.</span> <span class="nav-text">Resetting Accumulation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DirectX-Accumulation-Shader"><span class="nav-number">4.</span> <span class="nav-text">DirectX Accumulation Shader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-Does-it-Look-Like"><span class="nav-number">5.</span> <span class="nav-text">What Does it Look Like?</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">289</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.5m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
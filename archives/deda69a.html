<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Twitter@MisterXcv           引言这是一篇关于光线追踪的3D图形程序开发文章，手把手带你实现电影级的光线追踪技术，内容会从简单到复杂，带大家一点点的深入理解PBR渲染，在项目里用到了迪士尼光线追踪，解密电影级别的真实感渲染。"><meta property="og:type" content="article"><meta property="og:title" content="Realistic Rendering"><meta property="og:url" content="https://yousazoe.top/archives/deda69a.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Twitter@MisterXcv           引言这是一篇关于光线追踪的3D图形程序开发文章，手把手带你实现电影级的光线追踪技术，内容会从简单到复杂，带大家一点点的深入理解PBR渲染，在项目里用到了迪士尼光线追踪，解密电影级别的真实感渲染。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/E7NMciRWEAYJDOf.jpeg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802214102469.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802211717822.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802214417506.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220648208.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220702278.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220747279.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220802937.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220839386.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802212128598.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210805204502778.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210805205026763.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210805205039762.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210805205050082.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/v2-b508244cda055ca929ddedb92e8ad087_1440w.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/2020060219245867.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210406170616746.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807112417281.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Disney-Path-Tracing-6.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807145110114.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807144103713.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807144113492.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807150027522.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807150043459.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807150750998.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807151140189.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807151238767.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807152536947.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807152603992.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807153719552.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807153734328.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807154306489.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807175702933.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807175718877.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807175748927.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807175801352.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180047271.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180102706.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180118132.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180132913.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180728514.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807212622207.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807212640079.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210329214557527.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210810105359303.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210810211146335.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210810211316684.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211029203534731.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114220205559.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114220237812.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114220354194.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114220740431.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114222610786.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114222634975.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114222641717.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114222710483.png"><meta property="article:published_time" content="2021-08-02T12:55:16.000Z"><meta property="article:modified_time" content="2022-09-18T15:34:29.938Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Computer Graphics"><meta property="article:tag" content="Ray Tracing"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/E7NMciRWEAYJDOf.jpeg"><link rel="canonical" href="https://yousazoe.top/archives/deda69a.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Realistic Rendering | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/deda69a.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Realistic Rendering</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-08-02 20:55:16" itemprop="dateCreated datePublished" datetime="2021-08-02T20:55:16+08:00">2021-08-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/" itemprop="url" rel="index"><span itemprop="name">光线追踪 (Ray Tracing)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>33k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>59 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/E7NMciRWEAYJDOf.jpeg"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://twitter.com/MisterXcv/status/1419562375842353155">Twitter@MisterXcv</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这是一篇关于光线追踪的3D图形程序开发文章，手把手带你实现电影级的光线追踪技术，内容会从简单到复杂，带大家一点点的深入理解PBR渲染，在项目里用到了迪士尼光线追踪，解密电影级别的真实感渲染。</p><span id="more"></span><h3 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802214102469.png"></p><h4 id="光流量"><a href="#光流量" class="headerlink" title="光流量"></a>光流量</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802211717822.png"></p><p>光流量（Flux）定义就是单位时间内的能量微分：$\Phi=\lim_{\Delta t \to 0}\frac{\Delta Q}{\Delta t} = \frac{dQ}{dt}$。举个例子，一个灯在1小时溢出的能量 $\Phi$​ 为 200000J 的能量处以 3600s，最后得到 55.6w 就是我们需要的光流量。</p><p>能量就等于一段时间内光流量的积分：$Q=\int_{t_0}^{t_1}\Phi(t)dt$​​​​​，光流量根据这个公式很好解释，就是一段时间产生的能量。假如有一个光源，它不断射出能量射出光子，这个光子打到物体的表面会继续反弹，这就是为什么我们会持续看到物体的颜色，这些光子是持续不断地溢出的，所以人眼才会看到颜色是持续不变恒定的。</p><h4 id="辐射照度"><a href="#辐射照度" class="headerlink" title="辐射照度"></a>辐射照度</h4><p>辐射照度（Irradiance）的定义就是单位面积下的光流量：$\frac{\Phi}{A}$​。它只与面积有关，知道了面积和这个面积上的光流量，也就知道了这块面积上的辐照度。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802214417506.png"></p><p>看上图的 $A_1$​ 和 $A_2$，除了点光源所有的光源都是面积光。$A_1$ 中一片面积为 $A$，里面的光流量为 $\Phi$，那么这一片面积光的照度等于 $\frac{\phi}{A}$，正对的地板由于平行关系照度相等，也为 $\frac{\Phi}{A}$ 。</p><p>当面积光如 $A_2$ 侧对地面的时候形成夹角 $\theta$，此时 $A_2$ 的照度根据 Lambert 定律为 $\frac{\Phi}{\frac{A}{\cos\theta}} = \frac{\Phi\cos\theta}{A}$。聚光灯为什么能照亮这么多面积？因为它是弧形的而不是 $A_1$​​ 那种平的，所以才会照亮成图中这个形状。</p><h4 id="辐射强度-amp-立体角"><a href="#辐射强度-amp-立体角" class="headerlink" title="辐射强度 &amp; 立体角"></a>辐射强度 &amp; 立体角</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220648208.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220702278.png"></p><p>下面来说一下什么是立体角。我们看到上图有一块不规则的平面，立体角的定义就是把这个不规则平面投影到一个单位球上，投影得到的面积就是立体角的大小。在二维情况下，把平面投影到单位圆上得到一段圆弧 <code>s</code>，这条弧的长度就是角度；三维情况下这个角度大小就是投影在单位球上的面积，也可以理解为原始的不规则面与球心连接形成锥体，与球体表面相交的面积就是立体角。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220747279.png"></p><p>这是立体角和投影面积的关系：$d\omega = \frac{dA\cos\theta}{r^2}$​​，其中 $dA$​ 就是投影到远处的一块面积，它跟距离 $r$​ 和夹角 $\theta$​​ 有关。当角度固定时，同一个立体角投影的越远，它的投影面积就越大。</p><p>那立体角究竟有什么用呢？它的作用有两个，一个是向外扩散/投影，另一个是向内投影。先说向外投影的情况，假设 p 为点光源，在立体角内会溢出一些光子，这些光子会朝着这个立体角的方向外扩散。根据立体角和面积的关系知道，它扩散的距离越远，那么投影面积就越大，而光子的数量不变，据此就可以算出投影的照度。</p><p>辐射强度（Intensity）定义为每单位方向上的光流量，通常用来表示点光源的。一个点光源没有面积，我们只能知道每个方向均匀溢出多少相等的光流量。</p><p>只要我们知道点光源总共的光流量是多少，那么就知道每个方向的光流量：$\frac{\Phi}{d\omega}$。由于点光源只是一个点，在光线追踪中很难追踪。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220802937.png"></p><h4 id="辐射亮度"><a href="#辐射亮度" class="headerlink" title="辐射亮度"></a>辐射亮度</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802220839386.png"></p><p>辐射亮度（Radiance）定义为 $L(p,\omega)=\lim_{\Delta\omega\to0}\frac{\Delta E_{\omega}(p)}{\Delta \omega} = \frac{dE_{\omega}(p)}{d\omega}$，前面说过辐射照度只和面积有关没有方向，我们并不知道单位方向有多少照度，所以这里有单位方向 $d\omega$。这样亮度就是每单位立体角（$d\omega$）每单位面积（$dA$）有多少的光流量（$d\Phi$）。</p><p>辐射亮度是非常常用的，图中的垂直符号表示把立体角方向上的面积投影到法线方向上，得到的就是垂直面积。</p><h4 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210802212128598.png"></p><p>BRDF 通俗地讲就是光线从一个方向射入打中一个点，再从某一个方向射出，用 BRDF 计算从这个方向射出的量是多少。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210805204502778.png"></p><p>光源从入射方向投射到入射点，先计算它的辐照度 $dE(p, \omega_i)$：该方向的辐射亮度 $L_i(p, \omega_i)$ 乘以法线投影面积 $\cos\theta_id\omega_i$​。得到这一点的照度再跟射出的辐射亮度的比就是 BRDF 的定义：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210805205026763.png"></p><p>BRDF 的定义就是射出的辐射亮度 $L_0(p, \omega_0)$ 的微分比上这一点的辐射照度 $E(p, \omega_i)$ 的微分，这里使微分是因为刚才的光路只贡献了一小部分，那如何才能完整找到光线呢？只有整个半球面所有的方向的辐射亮度的贡献加在一起，才是完整射出的辐射亮度。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210805205039762.png"></p><p>辐射亮度 $L_0(p, \omega_0)$ 等于半球面的所有入射辐射亮度 $L_i(p, \omega_i)$​ 乘以 BRDF $f(p, \omega_0, \omega_i)$​ 乘以投影面积 $\cos\theta_i$ 的积分。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210805205050082.png"></p><p>BRDF 有两个特性：</p><ol><li><p><strong>固定性</strong>：给定两个不同的方向，它们的 BRDF 的值是一样的，我们可以利用这个特性实现反向路径追踪</p></li><li><p><strong>能量守恒</strong>：所有射出能量加起来等于射入的量</p></li></ol><p>每种材质的 BRDF 是不一样的，但还是遵循上面的两个原则，后面遇到不同的材质会讲不同的 BRDF。</p><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在前面的章节我们已经讲过了什么是全局光照，全局光照是怎么来的。这节课我们将更深入分析全局光照，了解程序是如何实现全局光照的。</p><p>回顾一下所谓全局光照，就是说光线从光源出发经过多次反弹以后打到物体表面上的一点，沿着此点反弹进入眼睛，眼睛就可以看到这一点的颜色。那么这个颜色究竟是多少呢？这就是全局光照渲染方程要干的事情，在数学上我们用一条渲染方程式求解答案。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/v2-b508244cda055ca929ddedb92e8ad087_1440w.jpg"></p><h4 id="渲染方程推导"><a href="#渲染方程推导" class="headerlink" title="渲染方程推导"></a>渲染方程推导</h4><p>首先入射点反射的颜色应该就是它的辐射亮度，这里的辐射亮度拆分为两个部分：自发光（自身发光发热所产生的光）和外界进入反弹的辐射亮度。</p><blockquote><p>Light exiting the surface = Emitted + reflected incoming</p></blockquote><p>我们把重点放在反射光上面，它遵循能量守恒，射入一定等于射出，如果射出的量为 1，那么所有射入量的总和也为 1。所以现在要找到所有的入射方向，每个方向携带多少的光。每个入射方向都会给眼睛看到的这个方向做出贡献，用 BRDF 定量它的贡献，只需要知道入射方向、出射方向与法线的角度，我们就知道了这个入射方向给出射方向贡献的辐射亮度是多少，也就有了这条方程式：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/2020060219245867.png"></p><p>这就是大名鼎鼎的渲染方程：</p><p>$L_o(x, \vec\omega)=\underbrace{L_e(x, \vec\omega)}<em>{emitted} + \underbrace{\int</em>{\Omega} L_i(x, \vec\omega’)f_r(\vec\omega,x,\vec\omega’)\cos\theta d\vec\omega’}_{reflected \space incoming \space light}$</p><p>其中 $L_r$（$L_o$）是辐射亮度，$L_i$ 是每个方向的辐射亮度，$f_r(\vec\omega,x,\vec\omega’)$​ 是 BRDF，$\cos\theta$ 是入射方向与法线的夹角作面积投影，积分空间是法线构成的整个半球面 $\Omega$​。</p><p>我们最开始提出的问题是射入眼睛的颜色等于多少，就等于这个方程左边的辐射亮度，只要我们能把右边解出来，那么这一点的颜色就被解出来了。剩下的问题就是这个渲染方程是否可解，在半球面空间中 $d\vec\omega’$ 可以通过枚举得到，而 BRDF 则可以通过材质得知，$\cos \theta$ 也是已知，唯一不确定的就是入射方向的辐射亮度 $L_i(x,\vec\omega’)$​，除非直接打中光源，但光线一般都是经过多次反射之后才进入这一点，所以这个 $L_i$ 一般都是不知道的，这个时候就是光线追踪登场的时刻了。</p><h4 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h4><p>首先我们从眼睛出发看到物体上的一点，根据渲染方程在半球面每个方向逐一枚举找到所有入射方向的辐射亮度，选中一个方向以此类推重复该过程直至遇到光源：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210406170616746.png"></p><p>这个过程看起来一棵多叉树，根结点就是求解从眼睛出发某一方向的辐射亮度，无限展开直到遇到光源才会终止一个节点。理论上这是可以求解的，但实际上又不行，有一个类似于“先有鸡还是先有蛋”的循环依赖问题，父节点向子节点要结果，子节点又向父节点要结果，形成了一种死循环，现实中也已经被证实是不可行的。</p><p><strong>光线追踪的缺陷</strong>：</p><ul><li>高维积分</li><li>循环依赖</li><li>渲染方程不可解</li></ul><h3 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>上一章节我们提出如何用光线追踪解决渲染方程，因为循环依赖的问题造成无解，是不可行的，要实现这个方程只能阉割掉一些特性。因此我们提出一个更好的方法：路径追踪，本节会讲解路径追踪的原理，改写渲染方程为基于路径的积分形式。</p><h4 id="路径照度"><a href="#路径照度" class="headerlink" title="路径照度"></a>路径照度</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807112417281.png"></p><p>这是某部卡通电影的截图，首先我们看见有几面窗，其中的白光可以用照度仪测出辐射照度（单位面积的光通量）。这个照度是可以投影的，从窗户这一片光投影到地板把地毯打亮，这时地毯也会有照度并且继续投影，打到了角色的脸上产生高光，以此类推。</p><p>从这个例子就可以看到面积光是可以通过投影的方式照亮周围的场景。</p><h4 id="路径微分"><a href="#路径微分" class="headerlink" title="路径微分"></a>路径微分</h4><p>通过第一灵感我们得到了路径追踪，现在我们来证明这个方法是可行的。对窗户面积进行面积微分，选取其中一点 $dA$​，连接窗户–地毯–人脸–摄像机，这样一条长度为 3 的路径就有了，路径追踪的算法也成型了：在场景里面找到一些点，把这些点连接成路径，我们只需要计算这条路径对这个相机方向的辐射亮度的贡献。</p><p>然而路径多种多样，问题就转化为了找到所有在这个方向做出贡献的路径，这也是路径追踪的核心思想。那么如何找到相机中的一点与光源连接的路径呢？我们可以拆分这个问题，路径是有长度的，它的长度可以是 2、3、4、5、6……我们可以分别找到长度为 2、3、4、5、6……的所有路径。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/Disney-Path-Tracing-6.jpg"></p><p>这个思路非常简单，那它为什么要比光线追踪好呢？它的好处在于你选择路径的时候路径永远是单向的，不会出现光线追踪中循环依赖的问题；同时它随机的主角也变了，在光线追踪中随机的是半球面的每一个方向，而现在随机的是场景中的某一个点。</p><h4 id="路径追踪渲染方程"><a href="#路径追踪渲染方程" class="headerlink" title="路径追踪渲染方程"></a>路径追踪渲染方程</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807145110114.png"></p><p>现在我们尝试改写路径追踪的渲染方程，已有的渲染方程是基于方向的立体角积分形式，下面我们来看看路径追踪。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807144103713.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807144113492.png"></p><p>先来看路径长度等于 2 的情况，其中 $p$​​ 为眼睛，看到的是 $p’$，$p’’$ 为光源。连接 $p’p’’$ 形成一条路径，将连接形成的向量带入渲染方程，可以发现 BRDF、辐射亮度 $L_i$ 和入射角 $\cos\theta$ 都不用改，真正需要修改的是 $\int_{\Omega}$ 和 $d\omega_i$。</p><p>积分的主角从方向变为了路径追踪中的点，基于立体角的微分也需要改成基于面积的微分。在前面的章节我们知道了立体角和面积的关系：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807150027522.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807150043459.png"></p><p>将 $d\omega$ 替换为面积 $A$ 再乘以可见性 $V(p’’,p)$ 得到路径追踪的渲染方程：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807150750998.png"></p><p>最后将可见性与面积替换两个部分合并成 $G(p, p’)$：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807151140189.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807151238767.png"></p><p>这样就得到了新的路径长度为 2 的渲染方程：这个方向射出的辐射亮度 $L(p’ \to p)$​​ 等于所有点空间 $\int_A$ 中路径的 BRDF $f_A(p’’\to p’ \to p)$ 乘上入射的辐射亮度 $L(p’’ \to p’)$ 乘上面积微分 $dA(p’’)$。</p><p>接着来看长度为 3 的路径追踪方程。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807152536947.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807152603992.png"></p><p>我们已经计算好了长度为 2 的路径的辐射亮度贡献，图中 $p_3$ 为光源。路径长度为 3 的辐射亮度贡献为 $p_3$ 到 $p_2$ 的辐射贡献亮度乘以 $\vec{p_3p_2}$、$\vec{p_2p_1}$ 这两个方向的 BRDF 和 $G$ 值乘以 $p_2$ 到 $p_1$ 的 BRDF……</p><p>n - 1 次反射我们可以找到长度为 n 的路径，渲染方程如下：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807153719552.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807153734328.png"></p><p>总结一下，路径追踪的核心思想就是基于面积的辐射亮度投影，可以假象为从光源出发拆分成一些点面积微分，这些点经过多次投影形成路径最后找到相机，渲染方程就能改写为路径形式的渲染方程。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807154306489.png"></p><p><strong>核心</strong>：</p><ul><li><p>基于面积的辐射亮度投影</p><p>从光源面投影到某个面，再继续投影……这些点 $dA$ 形成路径</p><p>路径是单向的不会死循环</p></li><li><p>以路径的辐射亮度为贡献</p><p>计算整条路径的光线传输（radiance）</p></li><li><p>路径积分的渲染方程</p><p>采样路径足够多，就能近似结果</p></li></ul><p><strong>随机</strong>：</p><ul><li>场景的点 $dA$ 看作样本，随机选择 n 个点连接出路径</li><li>计算这些路径的 radiance 贡献</li><li>样本空间是场景的点，积累所以路径的贡献</li></ul><h3 id="引擎框架概览"><a href="#引擎框架概览" class="headerlink" title="引擎框架概览"></a>引擎框架概览</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807175702933.png"></p><p>首先在网上下载一个最新版本的 CMake：<a target="_blank" rel="noopener" href="https://github.com/Kitware/CMake/releases/download/v3.21.1/cmake-3.21.1-windows-x86_64.zip">下载地址</a></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807175718877.png"></p><p>解压成为一个目录，进入 <code>/bin</code>，该目录就是 CMake程序的目录：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807175748927.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807175801352.png"></p><p>复制该目录的路径，这里我的路径为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">E:\Dev\CMake\cmake-3.21.1-windows-x86_64\cmake-3.21.1-windows-x86_64\bin</span><br></pre></td></tr></tbody></table></figure><p>右键此电脑，找到高级设置添加路径：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180047271.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180102706.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180118132.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180132913.png"></p><p>接着进入我们的项目，测试 CMake 命令：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd ...</span><br><span class="line">cmake</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807180728514.png"></p><p>点击 <code>build_debug</code>，弹出命令行自动构建项目：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807212622207.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210807212640079.png"></p><p>这里我一开始遇到了小小的问题，CMake 无法找到我的 VisualStudio，所以我重新安装了一下就好了。最后设置 <code>app</code> 为启动项目，项目成功运行。</p><h4 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h4><p><code>main.cpp</code> 是整个程序的入口，在这里我们快速讲一下整个框架是如何初始化的。</p><h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><p>先说头文件，分别为渲染界面的 GUI 系统、中间件目录下的相机控制器以及 Shader：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"Demo.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gui/GuiSystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;middleware/camera/CameraControllerView.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;render/Shader.hpp&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>进入主函数 <code>main()</code>，第一步是初始化整个图形引擎：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">gfx::<span class="built_in">setup</span>();</span><br></pre></td></tr></tbody></table></figure><p>第二步是创建一个窗口，分辨率默认 720P，并创建一个输入宽高和 Title 的窗口实例：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> window_width = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> window_height = <span class="number">768</span>;</span><br><span class="line"><span class="keyword">auto</span> window = hw::Window{ hw::<span class="built_in">VideoMode</span>(window_width, window_height), <span class="string">"Solar RenderingEngine"</span> };</span><br></pre></td></tr></tbody></table></figure><p>然后我们开始用之前的窗口创建程序，其中 <code>App</code> 的定义在 <code>Demo.hpp</code> 中：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">App</span></span><br><span class="line">{</span><br><span class="line">	hw::Window&amp; window;</span><br><span class="line">	std::optional&lt;hw::Event&gt; event;</span><br><span class="line">	tutorial::gfx::Swapchain swapchain;</span><br><span class="line">	tutorial::graphics::Camera camera;</span><br><span class="line">	tutorial::ecs::Transform camera_trans;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>整个程序包含了窗口 <code>window</code>、鼠标键盘的消息事件<code>event</code>、交换链 <code>swapchain</code> 和相机 <code>camera</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Demo(name) void name(App&amp; app,  bool init)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Demo</span>(___PathTracerSimple);</span><br><span class="line"><span class="built_in">Demo</span>(___PbrPathTracer);</span><br></pre></td></tr></tbody></table></figure><p>我们将完成两个 Demo，分别是路径追踪渲染器 <code>___PathTracerSimple</code> 和 基于物理的真实感渲染器 <code>___PbrPathTracer</code>。</p><p>完整的 <code>Demo.hpp</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;core/Types.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;hw/Window.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;hw/Event.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gfx/Gfx.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math/Math3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;../thirdparty/imgui/imgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ecs/Transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;render/TextureLoader.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;render/Camera.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">App</span></span><br><span class="line">{</span><br><span class="line">	hw::Window&amp; window;</span><br><span class="line">	std::optional&lt;hw::Event&gt; event;</span><br><span class="line">	tutorial::gfx::Swapchain swapchain;</span><br><span class="line">	tutorial::graphics::Camera camera;</span><br><span class="line">	tutorial::ecs::Transform camera_trans;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Demo(name) void name(App&amp; app,  bool init)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Demo</span>(___PathTracerSimple);</span><br><span class="line"><span class="built_in">Demo</span>(___PbrPathTracer);</span><br></pre></td></tr></tbody></table></figure><p>回到 <code>mian.cpp</code> 的交换链这里，用图形引擎创建交换链 <code>swapchain</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">App app{ window };</span><br><span class="line">app.swapchain = gfx::<span class="built_in">create_swapchain</span>(app.window.<span class="built_in">getSystemHandle</span>(), window_width, window_height);</span><br><span class="line"><span class="keyword">auto</span>&amp; swapchain = app.swapchain;</span><br></pre></td></tr></tbody></table></figure><p>GUI 系统是在 <code>gui</code> 命名空间下的，这里我们用即时模式的 GUI：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">gui::GuiSystem gui_sys{  };</span><br><span class="line"><span class="keyword">if</span> (!gui_sys.<span class="built_in">setup</span>(window)) {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h5><p>接着我们来看相机，最常用的就是四个数据：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> _fovy;  <span class="comment">// full angle</span></span><br><span class="line"><span class="type">float</span> _aspect_ratio;</span><br><span class="line"><span class="type">float</span> _znear;</span><br><span class="line"><span class="type">float</span> _zfar;</span><br></pre></td></tr></tbody></table></figure><p><code>_fovy</code> 就是相机的视角，<code>_aspect_ratio</code> 为宽高比例，<code>_znear</code> 和 <code>_zfar</code> 分别是近、远平面，这几个参数构成了我们整个视锥。</p><p>首先我们引用 <code>app</code> 的相机，设定宽高比 <code>_aspect_ratio</code> 为之前的 720P分辨率、视角定为 $\frac{\pi}{3}$​ 60度、远平面随便设置为 1000 构成视锥：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// camera</span></span><br><span class="line">graphics::Camera&amp; camera = app.camera;</span><br><span class="line">camera.<span class="built_in">set_aspect_ratio</span>(<span class="built_in">float</span>(window_width) / <span class="built_in">float</span>(window_height));</span><br><span class="line">camera.<span class="built_in">set_fov</span>(math::PI / <span class="number">3.f</span>);</span><br><span class="line">camera.<span class="built_in">set_zfar</span>(<span class="number">1000.f</span>);</span><br></pre></td></tr></tbody></table></figure><p>接着我们来做相机的坐标变换，包括位置和旋转角度。相机位置放置在 (0, 0, -5)（我们使用左手系），<code>set_rot()</code> 设置三轴不发生旋转。接着我们定义一个相机控制器 <code>camera_control</code>，它会改变相机的位置、朝向和移动速度，这里的 <code>__lookat_dist</code> 是锁定的距离：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">ecs::Transform&amp; camera_trans = app.camera_trans;</span><br><span class="line">camera_trans.<span class="built_in">set_pos</span>({ <span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span> });</span><br><span class="line">camera_trans.<span class="built_in">set_rot</span>({ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> });</span><br><span class="line">render::CameraController camera_control{ camera, camera_trans, <span class="number">1.f</span> };</span><br><span class="line">camera_control._lookat_dist = <span class="number">-5.0f</span>;</span><br><span class="line">camera_control._lookat_mode = <span class="literal">true</span>;</span><br></pre></td></tr></tbody></table></figure><p>下面来看看每帧的循环，在 <code>while(1)</code> 循环中每帧都会从系统那里读取轮询消息，执行窗口关闭事件并将消息缓存到 <code>app</code> 里面，最后调用各大模块去处理这个消息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">	hw::Event event;</span><br><span class="line">	<span class="keyword">if</span> (window.<span class="built_in">pollEvent</span>(event))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (event.type == hw::Event::Closed) {</span><br><span class="line">			window.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	app.event = event;</span><br><span class="line">	gui_sys.<span class="built_in">handle_input</span>(event);</span><br><span class="line">	camera_control.<span class="built_in">handle_input_events</span>(event);</span><br><span class="line">	......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里 <code>F1</code> 是隐藏/显示场景的UI：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.type == hw::Event::EventType::KeyPressed)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (hw::Keyboard::Key::F1 == event.key.code) {</span><br><span class="line">		gui_sys.show_gui ^= <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果没有找到事件就把消息设置为空：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">	app.event = {};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后就是 UI 系统和相机控制器的更新，以及图形引擎的刷新：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">gui_sys.<span class="built_in">update</span>();</span><br><span class="line">camera_control.<span class="built_in">update</span>(<span class="number">0.16f</span>);</span><br><span class="line"></span><br><span class="line">gfx::<span class="built_in">next_frame</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (running)</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">demo_entry</span>(app, init);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (init) init = <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure><p>最后我们会在 demo 里渲染出来我们要的结果并保存在后台缓存上，UI 会渲染在我们的结果之上：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> backbuffer = swapchain.<span class="built_in">backbuffer</span>();</span><br><span class="line">gfx::<span class="built_in">bind_framebuffer</span>(backbuffer);</span><br><span class="line">gui_sys.<span class="built_in">render</span>();</span><br><span class="line">gfx::<span class="built_in">present</span>(swapchain);</span><br></pre></td></tr></tbody></table></figure><p>完整的 <code>main.cpp</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"Demo.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gui/GuiSystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;middleware/camera/CameraControllerView.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;render/Shader.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> demo_entry = ___PathTracerSimple;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> tutorial;</span><br><span class="line">	gfx::<span class="built_in">setup</span>();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> window_width = <span class="number">1024</span>;</span><br><span class="line">	<span class="type">int</span> window_height = <span class="number">768</span>;</span><br><span class="line">	<span class="keyword">auto</span> window = hw::Window{ hw::<span class="built_in">VideoMode</span>(window_width, window_height), <span class="string">"Solar RenderingEngine"</span> };</span><br><span class="line">	App app{ window };</span><br><span class="line">	app.swapchain = gfx::<span class="built_in">create_swapchain</span>(app.window.<span class="built_in">getSystemHandle</span>(), window_width, window_height);</span><br><span class="line">	<span class="keyword">auto</span>&amp; swapchain = app.swapchain;</span><br><span class="line"></span><br><span class="line">	gui::GuiSystem gui_sys{  };</span><br><span class="line">	<span class="keyword">if</span> (!gui_sys.<span class="built_in">setup</span>(window)) {</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// camera</span></span><br><span class="line">	graphics::Camera&amp; camera = app.camera;</span><br><span class="line">	camera.<span class="built_in">set_aspect_ratio</span>(<span class="built_in">float</span>(window_width) / <span class="built_in">float</span>(window_height));</span><br><span class="line">	camera.<span class="built_in">set_fov</span>(math::PI / <span class="number">3.f</span>);</span><br><span class="line">	camera.<span class="built_in">set_zfar</span>(<span class="number">1000.f</span>);</span><br><span class="line">	ecs::Transform&amp; camera_trans = app.camera_trans;</span><br><span class="line">	camera_trans.<span class="built_in">set_pos</span>({ <span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span> });</span><br><span class="line">	camera_trans.<span class="built_in">set_rot</span>({ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> });</span><br><span class="line">	render::CameraController camera_control{ camera, camera_trans, <span class="number">1.f</span> };</span><br><span class="line">	camera_control._lookat_dist = <span class="number">-5.0f</span>;</span><br><span class="line">	camera_control._lookat_mode = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">bool</span> init = <span class="literal">true</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		hw::Event event;</span><br><span class="line">		<span class="keyword">if</span> (window.<span class="built_in">pollEvent</span>(event))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (event.type == hw::Event::Closed) {</span><br><span class="line">				window.<span class="built_in">close</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">			app.event = event;</span><br><span class="line">			gui_sys.<span class="built_in">handle_input</span>(event);</span><br><span class="line">			camera_control.<span class="built_in">handle_input_events</span>(event);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (event.type == hw::Event::EventType::KeyPressed)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (hw::Keyboard::Key::F1 == event.key.code) {</span><br><span class="line">					gui_sys.show_gui ^= <span class="number">1</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			app.event = {};</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		gui_sys.<span class="built_in">update</span>();</span><br><span class="line">		camera_control.<span class="built_in">update</span>(<span class="number">0.16f</span>);</span><br><span class="line"></span><br><span class="line">		gfx::<span class="built_in">next_frame</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (running)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">demo_entry</span>(app, init);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (init) init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> backbuffer = swapchain.<span class="built_in">backbuffer</span>();</span><br><span class="line">		gfx::<span class="built_in">bind_framebuffer</span>(backbuffer);</span><br><span class="line">		gui_sys.<span class="built_in">render</span>();</span><br><span class="line">		gfx::<span class="built_in">present</span>(swapchain);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	gfx::<span class="built_in">shutdown</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="开始demo"><a href="#开始demo" class="headerlink" title="开始demo"></a>开始demo</h4><p>我们打开 <code>SimplePathTracer.cpp</code>，每一帧都要进入 <code>___PathTracerSimple()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> ___PathTracerSimple(App&amp; app,  <span class="type">bool</span> init)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (init)</span><br><span class="line">	{</span><br><span class="line">		uniforms::<span class="built_in">setup</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们来编写一个 Shader 并缓存输出到屏幕：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">void ___PathTracerSimple(App&amp; app,  bool init)</span><br><span class="line">{</span><br><span class="line"><span class="addition">+	static Shader shader{"simple/PathTracerSimple"};</span></span><br><span class="line"><span class="addition">+	static auto main_fb = __frame_buffer_HDR(1024);</span></span><br><span class="line"></span><br><span class="line">	if (init)</span><br><span class="line">	{</span><br><span class="line">		uniforms::setup();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后创建一个 1024*1024 帧缓存贴图，用来保存每个像素的渲染结果。</p><h4 id="渲染相机"><a href="#渲染相机" class="headerlink" title="渲染相机"></a>渲染相机</h4><p>接下来是相机，引擎提供了一个 <code>RenderCamera</code> 的类，我们直接拿来用：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">void ___PathTracerSimple(App&amp; app,  bool init)</span><br><span class="line">{</span><br><span class="line">	static Shader shader{"simple/PathTracerSimple"};</span><br><span class="line">	static auto main_fb = __frame_buffer_HDR(1024);</span><br><span class="line"></span><br><span class="line">	if (init)</span><br><span class="line">	{</span><br><span class="line">		uniforms::setup();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line"><span class="addition">+	RenderCamera camera{ app.camera, app.camera_trans };</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之前的相机 <code>camera</code> 仅仅定义了视锥，我们还需要相机相关的渲染数据，这里的 <code>RenderCamera</code> 就是用于构造相机相关的渲染数据。</p><h4 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h4><p>设置视口，包括摄像机 <code>camera</code> 和缓存 <code>main_fb</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">void ___PathTracerSimple(App&amp; app,  bool init)</span><br><span class="line">{</span><br><span class="line">	static Shader shader{"simple/PathTracerSimple"};</span><br><span class="line">	static auto main_fb = __frame_buffer_HDR(1024);</span><br><span class="line"></span><br><span class="line">	if (init)</span><br><span class="line">	{</span><br><span class="line">		uniforms::setup();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	RenderCamera camera{ app.camera, app.camera_trans };</span><br><span class="line">	</span><br><span class="line"><span class="addition">+	GFX_BEGIN</span></span><br><span class="line"><span class="addition">+	Viewport vp1{camera, main_fb};</span></span><br><span class="line"><span class="addition">+	GFX_END</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这里我们已经加入两个标志：<code>GFX_BEGIN</code>、<code>GFX_END</code>，在其中使用 Shader 绘制一些东西，包括 CPU 和 Shader 之间的一些交互。</p><h4 id="光线追踪模块"><a href="#光线追踪模块" class="headerlink" title="光线追踪模块"></a>光线追踪模块</h4><h5 id="入口架构"><a href="#入口架构" class="headerlink" title="入口架构"></a>入口架构</h5><p>在我们编写简单的 Shader 之前，先来做一些预备工作。这个入口用于产生光线，会包括两个部分：</p><ul><li>filter 绘制全屏的 quad 顶点 shader</li><li>光线追踪的着色部分 shader</li></ul><h5 id="全屏shader"><a href="#全屏shader" class="headerlink" title="全屏shader"></a>全屏shader</h5><p>四边形投影的顶点 Shader 已经实现了，我们打开 Shader 目录中的 common 找到 <code>PostProcessVs.fx</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VERTEX_SHADER</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> float4 g_pos[] =</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">float4</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="built_in">float4</span>(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="built_in">float4</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="built_in">float4</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> float2 g_texcoord[] =</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">float2</span>(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="built_in">float2</span>(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">	<span class="built_in">float2</span>(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="built_in">float2</span>(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(uint vertexID : SV_VertexID,</span></span></span><br><span class="line"><span class="params"><span class="function">	out float4 ndc_pos : SV_Position,</span></span></span><br><span class="line"><span class="params"><span class="function">	out float2 texcoord : TEXTURE0</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ndc_pos = g_pos[vertexID];</span><br><span class="line">	texcoord = g_texcoord[vertexID];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>可以看到它的代码非常简洁，其中 <code>main()</code> 就是顶点入口函数。<code>vertexID</code> 就是顶点的 ID，我们会在 C++ 中输入四个顶点，通过顶点的 ID 找到它的坐标 <code>g_pos[]</code>，在全局已经定义好这四个点的位置，纹理坐标 <code>g_texcoord[]</code> 也很简单，这样就分别输出四个顶点的坐标和纹理坐标。</p><p>我们再来看看引擎中是怎么实现的，打开 <code>src/render/Filter.cpp</code>，包含了引擎提供给我们的接口，用 Shader 渲染全屏的矩形：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Filter::draw</span><span class="params">(<span class="type">const</span> gfx::RTV&amp; dst, <span class="type">const</span> gfx::Viewport&amp; rect, ShaderVersion shader)</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    gfx::<span class="built_in">bind_framebuffer</span>(gfx::empty_v&lt;gfx::DSV&gt;, { dst });</span><br><span class="line">    gfx::<span class="built_in">set_viewport</span>(rect);</span><br><span class="line">    <span class="built_in">draw</span>(shader);</span><br><span class="line">    gfx::<span class="built_in">unbind_framebuffer</span>(gfx::empty_v&lt;gfx::DSV&gt;, { dst });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参数包括 Shader 本身的 <code>shader</code>、视口大小 <code>rect</code> 以及渲染到目标的缓存 <code>dst</code>。完整的 <code>Filter.cpp</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;render/Filter.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tutorial::graphics</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">Filter::draw</span><span class="params">(ShaderVersion shader)</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		gfx::<span class="built_in">bind_shader</span>(shader.<span class="built_in">fetch</span>());</span><br><span class="line">		gfx::<span class="built_in">set_primitive_type</span>(gfx::PrimType::PRIM_TRISTRIP);</span><br><span class="line">		gfx::<span class="built_in">set_blend_mode</span>(gfx::BlendMode::Replace);</span><br><span class="line">		gfx::<span class="built_in">set_depth_test</span>(<span class="literal">false</span>, <span class="literal">false</span>, gfx::DepthFunc::DSS_DEPTHFUNC_ALWAYS);</span><br><span class="line">		gfx::<span class="built_in">set_rasterize_mode</span>(gfx::PolyCullMode::PCM_NONE, gfx::PolyFillMode::PFM_SOLID, <span class="literal">true</span>);</span><br><span class="line">		gfx::<span class="built_in">bind_vertex_buffer</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">		gfx::<span class="built_in">bind_index_buffer</span>(<span class="literal">nullptr</span>);</span><br><span class="line">		gfx::<span class="built_in">draw</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">Filter::draw</span><span class="params">(<span class="type">const</span> gfx::RTV&amp; dst, <span class="type">const</span> gfx::Viewport&amp; rect, ShaderVersion shader)</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		gfx::<span class="built_in">bind_framebuffer</span>(gfx::empty_v&lt;gfx::DSV&gt;, { dst });</span><br><span class="line">		gfx::<span class="built_in">set_viewport</span>(rect);</span><br><span class="line">		<span class="built_in">draw</span>(shader);</span><br><span class="line">		gfx::<span class="built_in">unbind_framebuffer</span>(gfx::empty_v&lt;gfx::DSV&gt;, { dst });</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">Filter::draw</span><span class="params">(<span class="type">const</span> Viewport&amp; dst, ShaderVersion shader)</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="built_in">draw</span>(dst.target, dst.rect, shader);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="追踪器"><a href="#追踪器" class="headerlink" title="追踪器"></a>追踪器</h5><p>在 <code>app</code> 中有一个 <code>ScreenRayTracer.hpp</code> 文件，打开发现只有数学库：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math/Math3d.hpp&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>首先包含一些必要的头文件：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;math/Math3d.hpp&gt;</span><br><span class="line"><span class="addition">+#include&lt;render/Filter.hpp&gt;</span></span><br><span class="line"><span class="addition">+#include&lt;render/Viewport.hpp&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>接着我们定义一个 <code>ScreenRayTracer</code> 的类：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math/Math3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;render/Filter.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;render/Viewport.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tutorial::graphics</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">ScreenRayTracer</span> </span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">ScreenRayTracer</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(Viewport&amp; viewport, ShaderVersion shader)</span></span>;</span><br><span class="line">	};	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接口包含一个视口 <code>viewport</code> 和一个 <code>shader</code>，用一个 Shader 渲染一个全屏的矩形，后面的光线追踪 Shader 就是在这里绘制全屏渲染。</p><p>接着打开 <code>ScreenRayTracer.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"ScreenRayTracer.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;core/Random.hpp&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>我们在这里定义 RayTracer 模块的接口。由于整个程序只有一个模块，所以这里我们采用单例模式。</p><p>我们第一次用到的时候才会去初始化，定义一个辅助的结构体 <code>SetupScreenRayTracer</code>，它在第一次进入 <code>draw()</code> 时会初始化一个实例，调用构造函数。</p><p>完整的 <code>ScreenRayTracer.cpp</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"ScreenRayTracer.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;core/Random.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tutorial::graphics</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SetupScreenRayTracer</span></span><br><span class="line">	{ </span><br><span class="line">		<span class="built_in">SetupScreenRayTracer</span>() <span class="keyword">noexcept</span></span><br><span class="line">		{</span><br><span class="line">			<span class="type">static</span> <span class="type">bool</span> _init = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (_init) <span class="keyword">return</span>;</span><br><span class="line">				_init = <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ScreenRayTracer::draw</span><span class="params">(Viewport&amp; viewport, ShaderVersion shader)</span> </span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="type">static</span> SetupScreenRayTracer __done;</span><br><span class="line">		Filter::<span class="built_in">draw</span>(viewport.target, viewport.rect, shader);    </span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="相机-1"><a href="#相机-1" class="headerlink" title="相机"></a>相机</h3><p>这部分会讲解 3D 相机的原理，如何成像投影。</p><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p>在 GAMES101 里很详细的说明过：</p><ul><li><a href="https://yousazoe.top/archives/e520f1c.html">Review of Linear Algebra</a></li></ul><h4 id="空间变换"><a href="#空间变换" class="headerlink" title="空间变换"></a>空间变换</h4><p>不过多介绍了，同样之前的 GAMES101 讲的很详细了：</p><ul><li><a href="https://yousazoe.top/archives/3fd6625d.html">Transformation</a></li><li><a href="https://yousazoe.top/archives/e1a90797.html">Transformation Cont</a></li></ul><h4 id="全局-amp-局部空间"><a href="#全局-amp-局部空间" class="headerlink" title="全局 &amp; 局部空间"></a>全局 &amp; 局部空间</h4><p>全局空间又叫世界空间，也就是一个世界/场景所在的空间，一个场景只有一个全局空间。而局部空间是由某个物体以自己为原点、以自身为参考系所形成的空间。</p><p>至于什么时候使用全局空间，什么时候使用局部空间要看具体情况，哪一个更加方便，这两个空间都是可以作为参考的对象。在 3D 建模中是在局部空间建模，模型中的每个点都相对于局部空间；而在游戏里这个模型会移动的，移动时每一个顶点都要转变为全局空间。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210329214557527.png"></p><h4 id="相机空间"><a href="#相机空间" class="headerlink" title="相机空间"></a>相机空间</h4><p>假设有一个世界坐标系，全局空间下有很多物体，这些物体又经过相机的拍摄形成一张图像。首先相机要捕捉这些看到的物体，它会把它看到的物体投影到屏幕上，为了方便起见才有了相机空间。</p><p>相机空间是以相机为原点形成的局部空间，我们做投影的时候一般是在相机空间做投影，这样子会比较方便，因为相机只需要拍摄它看得见的物体，相机后面的物体没有必要做投影和渲染。</p><p>从全局空间到相机空间涉及到了空间的变换，之前的课程我们已经学习了空间变换，实质上就是做矩阵乘法，我们只需要找到从世界空间到相机空间的变化矩阵就可以了。这个变化涉及到两个矩阵，一个是相机空间到世界空间（local to world matrix），还有一个是从世界空间到相机空间（view matrix），前者需要相机的旋转、平移，后者则是和前者操作相反：</p><p>$M = R \times T$</p><p>$V \times M = world_v \space \to \space V = world_v \times M^{-1}$​</p><h4 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h4><p>图形流水线是图形渲染里很重要的东西，在这里你会知道 GPU 是怎么做渲染的。我们的程序输入数据给 GPU，经过很多步骤会在屏幕里画出一个个像素，而这个流程就是图形渲染管线。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210810105359303.png"></p><p>其中 vertex shader 和 pixel shader 是可以自己改的，所以这两个地方也叫做 可编程管线。</p><p>首先 vertex shader 就是处理顶点的流程，你的程序会告诉 GPU 绘制什么顶点。比如说在一个 3D 空间里有一个立方体，这个 3D 模型数据由美术绘制好后输入给 GPU，GPU 经过顶点组装整合出顶点数据，包括顶点位置、纹理坐标和法线等各种数据，它会逐个顶点输入到顶点 shader。最常见的动画、地形和植物都是在顶点 shader 这里完成的，最后输出剪裁空间。</p><p>如果绘制的是 3D 几何体，那么还要加上相机的变换，最后还有 3D 的透视投影变换，从 3D 转回 2D；如果只是绘制 2D 的几何则不需要这两步，直接输出每个顶点就可以了。</p><br><p>GPU 这里还要做剪裁，在一个范围内（剪裁空间）如果一组顶点中有一些在范围之外，那么就需要把这些范围之外的顶点剪裁掉，剩下的这一部分才是要绘制的，剪裁剩下的三角形才会执行后面的操作。</p><p>剪裁完之后需要透视除法，而这两步在 GPU 中是黑盒子，你看不了也改不了。之前我们讲齐次坐标 $(x, y, z, w)$ 与 $(\frac{x}{w}, \frac{y}{w}, \frac{z}{w}, 1)$​​ 是一样的，透视除法就是在把一个四维坐标做除法，输出 ndc 空间（Normalized Device），这个空间下的 $x,y$​ 范围都是在 [-1, 1] 内，$z$ 的范围是在 [0, 1] 内。</p><br><p>经过透视除法，3D 的几何就会变为 2D 的几何，这时就会开始进行背面剔除，把背对相机的三角形剔除掉节省性能。同时还需要告诉 GPU 怎样才算三角形的正面和背面，假如我们约定好经过投影之后一个三角形顶点顺序顺时针为正（通过三角面的法线判断），那么 GPU 会把所有逆时针的三角形剔除掉。</p><p>接下来是光栅化。所谓光栅化就是扫描线，一个三角形经过投影之后得到一个 2D 的三角形，光栅化就是把这个三角形自上而下逐行扫描并细分为一个个像素，对每个点进行插值。三角形顶点本身是有坐标、纹理坐标和法线，像素数据就是经过这些顶点差值而来。</p><br><p>光栅化的每一个像素都会经过 pixel shader，这个地方就是自己定义着色器的地方，它跟渲染关联非常大。之后进入深度测试，避免重复写入，假如场景里有一座山，这座山前面有一些树，如果我先绘制树再绘制山，一部分山就会被树挡住，而被挡住这一部分是没必要再绘制的。</p><p>测试通过会进入 alpha 混合阶段，也是最终输出颜色的阶段。</p><h4 id="透视原理"><a href="#透视原理" class="headerlink" title="透视原理"></a>透视原理</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210810211146335.png"></p><p>透视是物体成像的一种方式，规律是距离眼睛越近的物体成像体积越大，距离眼睛越远的东西就会变得越小。比如下面两条铁轨应该是平行的，但在人眼看来它是两条直线不断绘制，到无限远的地方趋向于一个点，这就是所谓近大远小。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210810211316684.png"></p><p>这里复习 GAMES101 的 <a href="https://yousazoe.top/archives/e1a90797.html">Transformation Cont</a> 这一章节，详细讲了透视原理。</p><h4 id="接口设计实现"><a href="#接口设计实现" class="headerlink" title="接口设计实现"></a>接口设计实现</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Ray <span class="title">pixel_to_ray</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> float2 pixel, <span class="comment">// [0...width), [0...height)</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> unit2 resolution,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> float3 ws_camera_pos,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> Mat4f camera_to_world,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> Mat4f project_matrix</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>pixel</code> 为屏幕的像素，<code>resolution</code> 为屏幕的分辨率，<code>ws_camera_pos</code> 是相机的世界坐标，最后两个矩阵是相机空间到世界空间的矩阵 <code>camera_to_world</code> 和相机空间到投影空间的透视投影矩阵 <code>project_matrix</code>。</p><p>首先把像素 <code>pixel</code> 的 <code>x</code>、<code>y</code> 拿出来，<code>z</code> 等于近平面：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> x = pixel.x;</span><br><span class="line"><span class="type">float</span> y = pixel.y;</span><br><span class="line"><span class="type">float</span> z = <span class="number">1.f</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>tan_fov</code> 为相机视口，60度转化为弧度制，<code>ratio</code> 就是屏幕的宽度和高度的比：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> tan_fov = <span class="built_in">tan</span>(<span class="number">60.f</span> * PI / <span class="number">180.0f</span> * <span class="number">0.5f</span>);</span><br><span class="line"><span class="type">float</span> ratio = (<span class="type">float</span>)resolution.x / (<span class="type">float</span>)resolution.y;</span><br></pre></td></tr></tbody></table></figure><p>之后从视口空间变换到相机空间：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">x = (x / resolution.x * <span class="number">2</span> - <span class="number">1</span>) * tan_fov * ratio;</span><br><span class="line">y = (-(y / resolution.y * <span class="number">2</span> - <span class="number">1</span>)) * tan_fov;</span><br></pre></td></tr></tbody></table></figure><p>完整的 <code>Camera.fx</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Ray <span class="title">pixel_to_ray</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> float2 pixel, <span class="comment">// [0...width), [0...height)</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> unit2 resolution,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> float3 ws_camera_pos,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> Mat4f camera_to_world,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> <span class="type">const</span> Mat4f project_matrix</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> x = pixel.x;</span><br><span class="line">	<span class="type">float</span> y = pixel.y;</span><br><span class="line">	<span class="type">float</span> z = <span class="number">1.f</span>;</span><br><span class="line">	<span class="type">float</span> tan_fov = <span class="built_in">tan</span>(<span class="number">60.f</span> * PI / <span class="number">180.0f</span> * <span class="number">0.5f</span>);</span><br><span class="line">    <span class="type">float</span> ratio = (<span class="type">float</span>)resolution.x / (<span class="type">float</span>)resolution.y;</span><br><span class="line">    x = (x / resolution.x * <span class="number">2</span> - <span class="number">1</span>) * tan_fov * ratio;</span><br><span class="line">    y = (-(y / resolution.y * <span class="number">2</span> - <span class="number">1</span>)) * tan_fov;</span><br><span class="line">    float3 mouse3D = <span class="built_in">float</span>(x, y, z);</span><br><span class="line">    float3 ray_dir = <span class="built_in">normalize</span>(<span class="built_in">mul</span>(mouse3D, (float3x3)camera_to_world));</span><br><span class="line">    </span><br><span class="line">    Ray ray = {ws_camera_pos, <span class="built_in">normalize</span>(ray_dir)};</span><br><span class="line">    <span class="keyword">return</span> ray;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到 <code>ScreenRayTracer.cpp</code>，这里的变量名称跟 Shader 定义一样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">_ws_camera_pos = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_ws_camera_pos"</span>, gfx::UniformType::Var);</span><br><span class="line">_camera_to_world = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_camera_to_world"</span>, gfx::UniformType::Var);</span><br><span class="line">_project_matrix = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_project_matrix"</span>, gfx::UniformType::Var);</span><br><span class="line">_resolution = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_resolution"</span>, gfx::UniformType::Var);</span><br><span class="line">_pt_seed = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_pt_seed"</span>, gfx::UniformType::Var);</span><br></pre></td></tr></tbody></table></figure><p>分别是相机世界空间位置、相机局部空间到世界空间的变换矩阵、投影矩阵、分辨率大小和一个随机种子，我们在 C++ 中把这些计算好然后传给 Shader：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">void ScreenRayTracer::draw(Viewport&amp; viewport, ShaderVersion shader) </span><br><span class="line">{</span><br><span class="line">	static SetupScreenRayTracer __done;</span><br><span class="line"><span class="addition">+	const auto&amp; cam_trasform = viewport.camera.transform.world_matrix;</span></span><br><span class="line"><span class="addition">+	math::Vec3f world_cam_pos{ cam_trasform[3][0], cam_trasform[3][1], cam_trasform[3][2] };</span></span><br><span class="line"><span class="addition">+	std::array resolution = { viewport.rect.width, viewport.rect.height };</span></span><br><span class="line"><span class="addition">+	static Random random;</span></span><br><span class="line"><span class="addition">+	math::Vec2f rand_vec{ random.get(0.0f, 1.0f), random.get(0.0f, 1.0f) };</span></span><br><span class="line"><span class="addition">+	gfx::set_uniform(_resolution, resolution);	</span></span><br><span class="line"><span class="addition">+	gfx::set_uniform(_ws_camera_pos, world_cam_pos);</span></span><br><span class="line"><span class="addition">+	gfx::set_uniform(_camera_to_world, cam_trasform);</span></span><br><span class="line"><span class="addition">+	gfx::set_uniform(_project_matrix, viewport.camera.projection_matrix);</span></span><br><span class="line"><span class="addition">+	gfx::set_uniform(_pt_seed, rand_vec);</span></span><br><span class="line">	Filter::draw(viewport.target, viewport.rect, shader);    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整的 <code>ScreenRayTracer.cpp</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"ScreenRayTracer.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;core/Random.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tutorial::graphics</span><br><span class="line">{</span><br><span class="line">	<span class="type">static</span> gfx::UniformHandle _ws_camera_pos;</span><br><span class="line">	<span class="type">static</span> gfx::UniformHandle _camera_to_world;</span><br><span class="line">	<span class="type">static</span> gfx::UniformHandle _project_matrix;</span><br><span class="line">	<span class="type">static</span> gfx::UniformHandle _resolution;</span><br><span class="line">	<span class="type">static</span> gfx::UniformHandle _pt_seed;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SetupScreenRayTracer</span></span><br><span class="line">	{ </span><br><span class="line">		<span class="built_in">SetupScreenRayTracer</span>() <span class="keyword">noexcept</span></span><br><span class="line">		{</span><br><span class="line">			<span class="type">static</span> <span class="type">bool</span> _init = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (_init) <span class="keyword">return</span>;</span><br><span class="line">			_ws_camera_pos = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_ws_camera_pos"</span>, gfx::UniformType::Var);</span><br><span class="line">			_camera_to_world = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_camera_to_world"</span>, gfx::UniformType::Var);</span><br><span class="line">			_project_matrix = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_project_matrix"</span>, gfx::UniformType::Var);</span><br><span class="line">			_resolution = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_resolution"</span>, gfx::UniformType::Var);</span><br><span class="line">			_pt_seed = gfx::UniformHash::<span class="built_in">get</span>(<span class="string">"_pt_seed"</span>, gfx::UniformType::Var);</span><br><span class="line">			_init = <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ScreenRayTracer::draw</span><span class="params">(Viewport&amp; viewport, ShaderVersion shader)</span> </span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="type">static</span> SetupScreenRayTracer __done;</span><br><span class="line">		<span class="type">const</span> <span class="keyword">auto</span>&amp; cam_trasform = viewport.camera.transform.world_matrix;</span><br><span class="line">		math::Vec3f world_cam_pos{ cam_trasform[<span class="number">3</span>][<span class="number">0</span>], cam_trasform[<span class="number">3</span>][<span class="number">1</span>], cam_trasform[<span class="number">3</span>][<span class="number">2</span>] };</span><br><span class="line">		std::array resolution = { viewport.rect.width, viewport.rect.height };</span><br><span class="line">		<span class="type">static</span> Random random;</span><br><span class="line">		math::Vec2f rand_vec{ random.<span class="built_in">get</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>), random.<span class="built_in">get</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>) };</span><br><span class="line">		gfx::<span class="built_in">set_uniform</span>(_resolution, resolution);	</span><br><span class="line">		gfx::<span class="built_in">set_uniform</span>(_ws_camera_pos, world_cam_pos);</span><br><span class="line">		gfx::<span class="built_in">set_uniform</span>(_camera_to_world, cam_trasform);</span><br><span class="line">		gfx::<span class="built_in">set_uniform</span>(_project_matrix, viewport.camera.projection_matrix);</span><br><span class="line">		gfx::<span class="built_in">set_uniform</span>(_pt_seed, rand_vec);</span><br><span class="line">		Filter::<span class="built_in">draw</span>(viewport.target, viewport.rect, shader);    </span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h4><p>首先定义 <code>Entity</code>，由类型 <code>type</code> 和索引 <code>index</code> 构成：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> type;  </span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>继续定义球形 <code>SphereMesh</code>，由球心 <code>position</code>、半径 <code>radius</code> 和材质索引 <code>material</code> 组成：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SphereMesh</span></span><br><span class="line">{</span><br><span class="line">	float3 position;</span><br><span class="line">	<span class="type">float</span> radius;</span><br><span class="line">	<span class="type">int</span> material;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着定义四边形，包括起点<code>position</code> 、<code>uv</code> 和材质索引 <code>material</code> ：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QuadMesh</span> </span><br><span class="line">{</span><br><span class="line">	float3 position;</span><br><span class="line">	float3 u;</span><br><span class="line">	float3 v;</span><br><span class="line">	<span class="type">int</span> material;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>需要注意一点 Shader 是没有构造函数的，创建这样的结构体需要自己写一个构造函数，这里我直接写在全局：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">SphereMesh ___SphereMesh(in float3 position, <span class="type">float</span> radius, <span class="type">int</span> material) {</span><br><span class="line">	SphereMesh ball = (SphereMesh)<span class="number">0</span>;</span><br><span class="line">	ball.position = position;</span><br><span class="line">	ball.radius = radius;</span><br><span class="line">	ball.material = material;</span><br><span class="line">	<span class="keyword">return</span> ball;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QuadMesh ___QuadMesh(in float3 position, float3 u, float3 v, <span class="type">int</span> material) {</span><br><span class="line">	QuadMesh quad = (QuadMesh)<span class="number">0</span>;</span><br><span class="line">	quad.position = position;</span><br><span class="line">	quad.u = u;</span><br><span class="line">	quad.v = v;</span><br><span class="line">	quad.material = material;</span><br><span class="line">	<span class="keyword">return</span> quad;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我就实现完了几何体的定义和构造函数。完整的 <code>Entity.fx</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> type;  </span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SphereMesh</span></span><br><span class="line">{</span><br><span class="line">	float3 position;</span><br><span class="line">	<span class="type">float</span> radius;</span><br><span class="line">	<span class="type">int</span> material;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QuadMesh</span> </span><br><span class="line">{</span><br><span class="line">	float3 position;</span><br><span class="line">	float3 u;</span><br><span class="line">	float3 v;</span><br><span class="line">	<span class="type">int</span> material;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">SphereMesh ___SphereMesh(in float3 position, <span class="type">float</span> radius, <span class="type">int</span> material) {</span><br><span class="line">	SphereMesh ball = (SphereMesh)<span class="number">0</span>;</span><br><span class="line">	ball.position = position;</span><br><span class="line">	ball.radius = radius;</span><br><span class="line">	ball.material = material;</span><br><span class="line">	<span class="keyword">return</span> ball;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QuadMesh ___QuadMesh(in float3 position, float3 u, float3 v, <span class="type">int</span> material) {</span><br><span class="line">	QuadMesh quad = (QuadMesh)<span class="number">0</span>;</span><br><span class="line">	quad.position = position;</span><br><span class="line">	quad.u = u;</span><br><span class="line">	quad.v = v;</span><br><span class="line">	quad.material = material;</span><br><span class="line">	<span class="keyword">return</span> quad;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Light"><a href="#Light" class="headerlink" title="Light"></a>Light</h4><p>光源有两种类型：面积光和点光源：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> QuadLight = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SphereLight = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>前面我们只会用到四边形的面积光。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Light</span></span><br><span class="line">{</span><br><span class="line">	float3 position;</span><br><span class="line">	<span class="type">float</span> radius;</span><br><span class="line">	float3 energy;</span><br><span class="line">	<span class="type">float</span> type; <span class="comment">// 0 : quad, 1 : sphere</span></span><br><span class="line">	float3 u;</span><br><span class="line">	<span class="type">float</span> area;</span><br><span class="line">	float3 v;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>position</code> 为光源的位置，<code>radius</code> 为光源的半径，<code>energy</code> 为光源的辐射亮度，<code>type</code> 就是前面的光源的类型。</p><p>接着我们实现一个构造函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Light ___QuadLight(</span><br><span class="line">	in float3 position, </span><br><span class="line">	in float3 energy,</span><br><span class="line">	in float3 u,</span><br><span class="line">	in float3 v</span><br><span class="line">) </span><br><span class="line">{</span><br><span class="line">	Light light = (Light)<span class="number">0</span>;</span><br><span class="line">	light.position = position;</span><br><span class="line">	light.energy = energy;</span><br><span class="line">	light.u = u;</span><br><span class="line">	light.v = v;</span><br><span class="line">	light.type = QuadLight;</span><br><span class="line">	<span class="keyword">return</span> light;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就完成了四边形光源的定义和构造函数，完整的 <code>Light.fx</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> QuadLight = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SphereLight = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Light</span></span><br><span class="line">{</span><br><span class="line">	float3 position;</span><br><span class="line">	<span class="type">float</span> radius;</span><br><span class="line">	float3 energy;</span><br><span class="line">	<span class="type">float</span> type; <span class="comment">// 0 : quad, 1 : sphere</span></span><br><span class="line">	float3 u;</span><br><span class="line">	<span class="type">float</span> area;</span><br><span class="line">	float3 v;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Light ___QuadLight(</span><br><span class="line">	in float3 position, </span><br><span class="line">	in float3 energy,</span><br><span class="line">	in float3 u,</span><br><span class="line">	in float3 v</span><br><span class="line">) </span><br><span class="line">{</span><br><span class="line">	Light light = (Light)<span class="number">0</span>;</span><br><span class="line">	light.position = position;</span><br><span class="line">	light.energy = energy;</span><br><span class="line">	light.u = u;</span><br><span class="line">	light.v = v;</span><br><span class="line">	light.type = QuadLight;</span><br><span class="line">	<span class="keyword">return</span> light;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后我们在 <code>Scene.fx</code> 定义场景的数据结构：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Scene</span></span><br><span class="line">{</span><br><span class="line">	uint nball;</span><br><span class="line">	uint nquad;</span><br><span class="line">	uint nlight;</span><br><span class="line">	uint pad;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这个结构体记录了多少个球体 <code>nball</code>、四边形 <code>nquad</code>、光源<code>nlight</code>。</p><p>我们要宏定义这几个几何体的灯光：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SphereMeshBuffer(xxx) SphereMesh xxx[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QuadMeshBuffer(xxx) QuadMesh xxx[6]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LightBuffer(xxx) Light xxx[1]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h4><p>我们还需要在 <code>PathTracerSimple.fx</code> 定义材质，这次只有一个基础的颜色：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span> { float3 baseColor; };</span><br><span class="line">Material ___Material(float3 baseColor) </span><br><span class="line">{ </span><br><span class="line">	Material material; </span><br><span class="line">	material.baseColor = baseColor; </span><br><span class="line">	<span class="keyword">return</span> material;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaterialBuffer(xxx) Material xxx[4]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h4><p>现在我们来实现相交测试。当一条射线打中某个物体的时候记录这一点的信息，包括表面信息 <code>Surface</code> 和相交信息 <code>Hit</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Surface</span></span><br><span class="line">{</span><br><span class="line">	float3 position;</span><br><span class="line">	<span class="type">int</span> material;   <span class="comment">// material</span></span><br><span class="line">	float3 normal;</span><br><span class="line">	float3 ffnormal;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>ffnormal</code> 作为法线用于判断内外侧。</p><p>接着定义相交信息，当一条射线打中一个物体的时候我们需要知道这个射线到这个物体的距离 <code>hit_dist</code>、物体实例 <code>entity</code> 以及打中物体表面信息 <code>surface</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Hit</span></span><br><span class="line">{</span><br><span class="line">	Entity entity;</span><br><span class="line">	<span class="type">float</span> hit_dist;</span><br><span class="line">	<span class="type">bool</span> hit;</span><br><span class="line">	Surface surface;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>设置 <code>Hit</code> 构造函数为什么都没打中：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Hit <span class="title">NotHit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">static</span> Surface surface = (Surface)<span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> Hit not_hit = { { <span class="number">0</span>, <span class="number">-1</span> }, INFINITY, <span class="literal">false</span>, surface };</span><br><span class="line">	<span class="keyword">return</span> not_hit;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h4><p>打开 <code>Geometry.fx</code>，这个文件定义了常用的 3D 几何体和数学辅助函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line"><span class="comment">//static const float INFINITY = 1e9;</span></span><br><span class="line"><span class="comment">//static const float EPS = 0.01f;</span></span><br><span class="line"><span class="comment">//static const float PI = 3.14159265358979323f;</span></span><br><span class="line"><span class="comment">//static const float TWO_PI = 6.28318530717958648f;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span> { float3 min; float3 max; };</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ray</span> { float3 origin; float3 direction; };</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sphere</span> { float3 position; <span class="type">float</span> radius; };</span><br></pre></td></tr></tbody></table></figure><p>射线和球体的相交测试原理在 <a href="https://yousazoe.top/archives/cb66e903.html#%E5%8A%A0%E5%85%A5%E7%90%83%E4%BD%93">Ray Tracing in One Weekend</a> 中有详细的数学推导，在此我们直接实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// return hit distance, or INFINITY if not intersect</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ray_sphere_intersect</span><span class="params">(float3 pos, <span class="type">float</span> radius, in Ray r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	float3 op = pos - r.origin;</span><br><span class="line">	<span class="type">float</span> eps = <span class="number">0.001</span>;</span><br><span class="line">	<span class="type">float</span> b = <span class="built_in">dot</span>(op, r.direction);</span><br><span class="line">	<span class="type">float</span> det = b * b - <span class="built_in">dot</span>(op, op) + radius * radius;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (det &lt; <span class="number">0.0</span>)</span><br><span class="line">		<span class="keyword">return</span> INFINITY;</span><br><span class="line"></span><br><span class="line">	det = <span class="built_in">sqrt</span>(det);</span><br><span class="line">	<span class="type">float</span> t1 = b - det;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (t1 &gt; eps)</span><br><span class="line">		<span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> t2 = b + det;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (t2 &gt; eps)</span><br><span class="line">		<span class="keyword">return</span> t2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> INFINITY;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该函数返回相交的距离，假如一条射线与球做相交，它会直接返回这一段距离 <code>det</code>；否则返回无限大 <code>INFINITY</code>。</p><p>还有射线和多边形的相交测试实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// return hit distance, or INFINITY if not intersect</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ray_rect_intersect</span><span class="params">(in float3 pos, in float3 u, in float3 v, in float3 n, in Ray r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> dt = <span class="built_in">dot</span>(r.direction, n);</span><br><span class="line">	<span class="type">float</span> w = <span class="built_in">dot</span>(n, pos);</span><br><span class="line">	<span class="type">float</span> t = (w - <span class="built_in">dot</span>(n, r.origin)) / dt;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (t &gt; EPS)</span><br><span class="line">	{</span><br><span class="line">		float3 p = r.origin + r.direction * t;</span><br><span class="line">		float3 op = p - pos;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// op project onto u,v, and its length &lt;= |u| and |v|</span></span><br><span class="line">		<span class="comment">// 0 &lt;= dot(nomalize(u), op) &lt;= length(u)</span></span><br><span class="line">		<span class="comment">// ---&gt;  0 &lt;= dot(normalize(u)/length(u), op) &lt;= 1</span></span><br><span class="line">		<span class="comment">// ---&gt;  0 &lt;= dot(u/dot(u,u), op) &lt;= 1</span></span><br><span class="line">		u = u / <span class="built_in">dot</span>(u, u);</span><br><span class="line">		v = v / <span class="built_in">dot</span>(v, v);</span><br><span class="line">		<span class="type">float</span> a1 = <span class="built_in">dot</span>(u, op);</span><br><span class="line">		[branch]</span><br><span class="line">		<span class="keyword">if</span> (a1 &gt;= <span class="number">0</span> &amp;&amp; a1 &lt;= <span class="number">1</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="type">float</span> a2 = <span class="built_in">dot</span>(v, op);</span><br><span class="line">			[branch]</span><br><span class="line">			<span class="keyword">if</span> (a2 &gt;= <span class="number">0</span> &amp;&amp; a2 &lt;= <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> INFINITY;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整的 <code>Geometry.fx</code> 如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line"><span class="comment">//static const float INFINITY = 1e9;</span></span><br><span class="line"><span class="comment">//static const float EPS = 0.01f;</span></span><br><span class="line"><span class="comment">//static const float PI = 3.14159265358979323f;</span></span><br><span class="line"><span class="comment">//static const float TWO_PI = 6.28318530717958648f;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span> { float3 min; float3 max; };</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ray</span> { float3 origin; float3 direction; };</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sphere</span> { float3 position; <span class="type">float</span> radius; };</span><br><span class="line"></span><br><span class="line"><span class="comment">// return hit distance, or INFINITY if not intersect</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ray_sphere_intersect</span><span class="params">(float3 pos, <span class="type">float</span> radius, in Ray r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	float3 op = pos - r.origin;</span><br><span class="line">	<span class="type">float</span> eps = <span class="number">0.001</span>;</span><br><span class="line">	<span class="type">float</span> b = <span class="built_in">dot</span>(op, r.direction);</span><br><span class="line">	<span class="type">float</span> det = b * b - <span class="built_in">dot</span>(op, op) + radius * radius;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (det &lt; <span class="number">0.0</span>)</span><br><span class="line">		<span class="keyword">return</span> INFINITY;</span><br><span class="line"></span><br><span class="line">	det = <span class="built_in">sqrt</span>(det);</span><br><span class="line">	<span class="type">float</span> t1 = b - det;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (t1 &gt; eps)</span><br><span class="line">		<span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> t2 = b + det;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (t2 &gt; eps)</span><br><span class="line">		<span class="keyword">return</span> t2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> INFINITY;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// return hit distance, or INFINITY if not intersect</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ray_rect_intersect</span><span class="params">(in float3 pos, in float3 u, in float3 v, in float3 n, in Ray r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> dt = <span class="built_in">dot</span>(r.direction, n);</span><br><span class="line">	<span class="type">float</span> w = <span class="built_in">dot</span>(n, pos);</span><br><span class="line">	<span class="type">float</span> t = (w - <span class="built_in">dot</span>(n, r.origin)) / dt;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (t &gt; EPS)</span><br><span class="line">	{</span><br><span class="line">		float3 p = r.origin + r.direction * t;</span><br><span class="line">		float3 op = p - pos;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// op project onto u,v, and its length &lt;= |u| and |v|</span></span><br><span class="line">		<span class="comment">// 0 &lt;= dot(nomalize(u), op) &lt;= length(u)</span></span><br><span class="line">		<span class="comment">// ---&gt;  0 &lt;= dot(normalize(u)/length(u), op) &lt;= 1</span></span><br><span class="line">		<span class="comment">// ---&gt;  0 &lt;= dot(u/dot(u,u), op) &lt;= 1</span></span><br><span class="line">		u = u / <span class="built_in">dot</span>(u, u);</span><br><span class="line">		v = v / <span class="built_in">dot</span>(v, v);</span><br><span class="line">		<span class="type">float</span> a1 = <span class="built_in">dot</span>(u, op);</span><br><span class="line">		[branch]</span><br><span class="line">		<span class="keyword">if</span> (a1 &gt;= <span class="number">0</span> &amp;&amp; a1 &lt;= <span class="number">1</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="type">float</span> a2 = <span class="built_in">dot</span>(v, op);</span><br><span class="line">			[branch]</span><br><span class="line">			<span class="keyword">if</span> (a2 &gt;= <span class="number">0</span> &amp;&amp; a2 &lt;= <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> INFINITY;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//GEOMETRY</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h4><p>回到 <code>Scene.fx</code>，所有的几何求交都会在这里实现。</p><p>首先从光源求交开始，定义一个 <code>trace_light()</code> 函数返回光源到交点距离：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">trace_light</span><span class="params">(in <span class="type">const</span> Ray ray, in <span class="type">const</span> Light light)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">switch</span> (light.type)</span><br><span class="line">	{</span><br><span class="line">        <span class="keyword">case</span> QuadLight:</span><br><span class="line">        {</span><br><span class="line">            float3 u = light.u;</span><br><span class="line">            float3 v = light.v;</span><br><span class="line">            float3 normal = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(u, v));</span><br><span class="line">            [branch] <span class="keyword">if</span> (<span class="built_in">dot</span>(normal, ray.direction) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> INFINITY;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray_rect_intersect</span>(light.position, u, v, normal, ray);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> INFINITY;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用 <code>uv</code> 向量算出法线朝向，判断射线是否与法线同向：不同向才说明打中它的正面；同向直接返回无穷远。</p><p>定义一个 <code>trace_scene_lights()</code> 函数，输入整个场景 <code>scene</code> 和光源数组 <code>lights</code>，读写相交信息 <code>hit</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace_scene_lights</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	in <span class="type">const</span> Ray ray, </span></span></span><br><span class="line"><span class="params"><span class="function">	in Scene scene,</span></span></span><br><span class="line"><span class="params"><span class="function">	in LightBuffer(lights),</span></span></span><br><span class="line"><span class="params"><span class="function">	inout Hit hit</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> t = hit.hit_dist;</span><br><span class="line">	uint light_count = scene.nlight;</span><br><span class="line">	[loop]</span><br><span class="line">	<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; light_count; ++i)</span><br><span class="line">	{</span><br><span class="line">		Light light = lights[i];</span><br><span class="line">		<span class="type">float</span> d = <span class="built_in">trace_light</span>(ray, light);</span><br><span class="line">		[branch]</span><br><span class="line">		<span class="keyword">if</span> (d &lt; t)</span><br><span class="line">		{</span><br><span class="line">			t = d;</span><br><span class="line">			hit.entity.index = i;</span><br><span class="line">			hit.entity.type = LIGHT_ENTITY;</span><br><span class="line">			hit.hit_dist = t;</span><br><span class="line">			hit.hit = <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过保留最短相交距离，我们完成了整个场景与光源的相交测试。最后我们要实现射线与场景球体的相交测试：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace_scene_lights</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	in <span class="type">const</span> Ray ray, </span></span></span><br><span class="line"><span class="params"><span class="function">	in Scene scene,</span></span></span><br><span class="line"><span class="params"><span class="function">	in LightBuffer(lights),</span></span></span><br><span class="line"><span class="params"><span class="function">	inout Hit hit</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> t = hit.hit_dist;</span><br><span class="line">	uint light_count = scene.nlight;</span><br><span class="line">	[loop]</span><br><span class="line">	<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; light_count; ++i)</span><br><span class="line">	{</span><br><span class="line">		Light light = lights[i];</span><br><span class="line">		<span class="type">float</span> d = <span class="built_in">trace_light</span>(ray, light);</span><br><span class="line">		[branch]</span><br><span class="line">		<span class="keyword">if</span> (d &lt; t)</span><br><span class="line">		{</span><br><span class="line">			t = d;</span><br><span class="line">			hit.entity.index = i;</span><br><span class="line">			hit.entity.type = LIGHT_ENTITY;</span><br><span class="line">			hit.hit_dist = t;</span><br><span class="line">			hit.hit = <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>遍历整个光源，对于每个光源调用刚才的 <code>trace_light()</code> 函数算出射线到光源的距离。当相交距离小于 <code>t</code> 的时候才会把这个光源记录下来，同时也保留当前的相交距离作为最近的相交距离。</p><p>这样我们就完成了整个场景光源的相交测试，接下来我们来实现场景与球体的相交测试。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace_scene_sphere</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	in <span class="type">const</span> Ray ray, </span></span></span><br><span class="line"><span class="params"><span class="function">	in Scene scene,</span></span></span><br><span class="line"><span class="params"><span class="function">	in SphereMeshBuffer(balls),</span></span></span><br><span class="line"><span class="params"><span class="function">	inout Hit hit</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> t = hit.hit_dist;</span><br><span class="line">	[loop]</span><br><span class="line">	<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; scene.nball; ++i)</span><br><span class="line">	{</span><br><span class="line">		SphereMesh mesh = balls[i];</span><br><span class="line">		<span class="type">float</span> d = <span class="built_in">ray_sphere_intersect</span>(mesh.position, mesh.radius, ray);</span><br><span class="line">		[branch] <span class="keyword">if</span> (d &lt; t)</span><br><span class="line">		{</span><br><span class="line">			t = d;</span><br><span class="line">			hit.entity.index = i;</span><br><span class="line">			hit.entity.type = SPHERE_ENTITY;</span><br><span class="line">			hit.surface.position = ray.origin + ray.direction * d;</span><br><span class="line">			hit.surface.normal = <span class="built_in">normalize</span>(hit.surface.position - mesh.position);</span><br><span class="line">			hit.surface.ffnormal = <span class="built_in">dot</span>(hit.surface.normal, ray.direction) &lt;= <span class="number">0.0</span> ? hit.surface.normal : hit.surface.normal * <span class="number">-1.0</span>;</span><br><span class="line">			hit.surface.material = mesh.material;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (t &lt; hit.hit_dist) {</span><br><span class="line">		hit.hit_dist = t;</span><br><span class="line">		hit.hit = <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输入整个球形数组，读写 <code>hit</code> 信息。保留最近的相交信息，逐个遍历最近的球体，对于球体网格调用球体和射线的相交测试，算出相交距离 <code>d</code>：如果该距离小于最近距离，那么保存该 <code>entity</code>，同时记录最小相交距离 <code>t = d</code>。</p><h4 id="Mask"><a href="#Mask" class="headerlink" title="Mask"></a>Mask</h4><p>我们还需要设计场景的 <code>entity</code> 与射线做相交测试。</p><p>打开 <code>simple-6-scene/Entity.fx</code>，里面定义了 <code>entity</code> 的类型，通过位操作符算出二进制的掩码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// enum EntityType</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MESH_ENTITY = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LIGHT_ENTITY = <span class="number">2</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SPHERE_ENTITY = <span class="number">5</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> QUAD_ENTITY = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MASK_MESH = <span class="number">1</span> &lt;&lt; MESH_ENTITY;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MASK_LIGHT = <span class="number">1</span> &lt;&lt; LIGHT_ENTITY;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MASK_SPHERE = <span class="number">1</span> &lt;&lt; SPHERE_ENTITY;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MASK_QUAD = <span class="number">1</span> &lt;&lt; QUAD_ENTITY;</span><br></pre></td></tr></tbody></table></figure><h4 id="Init-Scene"><a href="#Init-Scene" class="headerlink" title="Init Scene"></a>Init Scene</h4><p>回到 <code>Shader.fx</code> 文件，实现一条射线怎么和几何体的 <code>entity</code> 相交测试：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace_scene</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	in <span class="type">const</span> Ray ray,</span></span></span><br><span class="line"><span class="params"><span class="function">	in <span class="type">const</span> <span class="type">float</span> max_dist, <span class="comment">// search distance</span></span></span></span><br><span class="line"><span class="params"><span class="function">	in Scene scene, </span></span></span><br><span class="line"><span class="params"><span class="function">	in SphereMeshBuffer(balls), in QuadMeshBuffer(quads),</span></span></span><br><span class="line"><span class="params"><span class="function">	in LightBuffer(lights),</span></span></span><br><span class="line"><span class="params"><span class="function">	in <span class="type">const</span> uint mask,</span></span></span><br><span class="line"><span class="params"><span class="function">	out Hit hit</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	hit = <span class="built_in">NotHit</span>();</span><br><span class="line">	hit.hit_dist = max_dist;</span><br><span class="line"> </span><br><span class="line">	[branch] <span class="keyword">if</span> ((mask &amp; MASK_SPHERE) &gt; <span class="number">0</span>) { <span class="built_in">trace_scene_sphere</span>(ray, scene, balls, hit); }</span><br><span class="line">	[branch] <span class="keyword">if</span> ((mask &amp; MASK_QUAD) &gt; <span class="number">0</span>) { <span class="built_in">trace_scene_quad</span>(ray, scene, quads, hit); }</span><br><span class="line">	[branch] <span class="keyword">if</span> ((mask &amp; MASK_LIGHT) &gt; <span class="number">0</span>) { <span class="built_in">trace_scene_lights</span>(ray, scene, lights, hit); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后我们来搭建场景，首先进行初始化：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// init scene</span></span><br><span class="line">Scene scene = (Scene)<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>定义材质：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">MaterialBuffer</span>(materials);</span><br><span class="line">materials[<span class="number">0</span>] = ___Material(<span class="built_in">float3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">materials[<span class="number">1</span>] = ___Material(<span class="built_in">float3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">materials[<span class="number">2</span>] = ___Material(<span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">materials[<span class="number">3</span>] = ___Material(<span class="built_in">float3</span>(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>));</span><br><span class="line"><span class="type">int</span> white = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> red = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> blue = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> grey = <span class="number">3</span>;</span><br></pre></td></tr></tbody></table></figure><p>初始化几何体数组，包括一个球体和六面墙：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">SphereMeshBuffer</span>(balls);</span><br><span class="line">balls[<span class="number">0</span>] = ___SphereMesh(<span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">-1.5</span>, <span class="number">0</span>), <span class="number">1</span>, white);</span><br><span class="line">balls[<span class="number">0</span>].material = <span class="number">0</span>; </span><br><span class="line">scene.nball = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuadMeshBuffer</span>(quads);</span><br><span class="line">quads[<span class="number">0</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">-2.5f</span>, <span class="number">2.5f</span>, <span class="number">2.5f</span>), <span class="built_in">float3</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">-5</span>, <span class="number">0</span>), grey);  <span class="comment">// front </span></span><br><span class="line">quads[<span class="number">1</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">-2.5f</span>, <span class="number">2.5f</span>, <span class="number">-2.5f</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">-5</span>, <span class="number">0</span>), red);  <span class="comment">// left</span></span><br><span class="line">quads[<span class="number">2</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">2.5f</span>, <span class="number">2.5f</span>, <span class="number">2.5f</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">-5</span>, <span class="number">0</span>), blue);		<span class="comment">// right</span></span><br><span class="line">quads[<span class="number">3</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">-2.5f</span>, <span class="number">-2.5f</span>, <span class="number">2.5f</span>), <span class="built_in">float3</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>), grey);	<span class="comment">// down</span></span><br><span class="line">quads[<span class="number">4</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">-2.5f</span>, <span class="number">2.5f</span>, <span class="number">-2.5f</span>), <span class="built_in">float3</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), grey);		<span class="comment">// up</span></span><br><span class="line">quads[<span class="number">5</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">2.5f</span>, <span class="number">2.5f</span>, <span class="number">-2.5f</span>), <span class="built_in">float3</span>(<span class="number">-5</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>), grey);	<span class="comment">// back</span></span><br><span class="line">scene.nquad = <span class="number">6</span>;</span><br></pre></td></tr></tbody></table></figure><p>加入场景光源：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// lights</span></span><br><span class="line"><span class="built_in">LightBuffer</span>(lights);</span><br><span class="line">lights[<span class="number">0</span>] =</span><br><span class="line">    ___QuadLight(</span><br><span class="line">    <span class="built_in">float3</span>(<span class="number">-1.f</span>, <span class="number">1.5f</span>, <span class="number">-2.5f</span>), <span class="built_in">float3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">3.14</span>,</span><br><span class="line">    <span class="built_in">float3</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line">scene.nlight = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>这样场景就初始化完毕了。</p><h4 id="Output-Scene"><a href="#Output-Scene" class="headerlink" title="Output Scene"></a>Output Scene</h4><p>现在我们来测试一下场景。</p><p>我们已经知道从相机出发的射线，现在要和场景求交，调用 <code>trace_scene()</code> 函数把几何体和光源都放进去，掩码为 <code>MASK_ALL</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// first hit</span></span><br><span class="line">Hit hit;</span><br><span class="line"><span class="built_in">trace_scene</span>(ray, INFINITY, scene, balls, quads, lights, MASK_ALL, hit);</span><br></pre></td></tr></tbody></table></figure><p>如果没有打中，直接返回黑色：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hit.hit)</span><br><span class="line">{</span><br><span class="line">    ......</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果打中，判断类型：</p><ul><li>如果是灯光，就返回其辐射亮度</li><li>如果是几何体，读取表面材质，返回 <code>baseColor</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hit.hit)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (hit.entity.type == LIGHT_ENTITY) {</span><br><span class="line">        <span class="type">int</span> index = hit.entity.index;</span><br><span class="line">        <span class="keyword">return</span> lights[index].energy;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hit.entity.type == SPHERE_ENTITY || hit.entity.type == QUAD_ENTITY) {</span><br><span class="line">        Material material = materials[hit.surface.material];</span><br><span class="line">        <span class="keyword">return</span> material.baseColor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">SamplerState _samp_point: <span class="built_in">register</span>(s0);</span><br><span class="line">cbuffer Frame</span><br><span class="line">{</span><br><span class="line">	uint _frame_index;</span><br><span class="line">	float2 _seed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span> { float3 baseColor; };</span><br><span class="line">Material ___Material(float3 baseColor) </span><br><span class="line">{ </span><br><span class="line">	Material material; </span><br><span class="line">	material.baseColor = baseColor; </span><br><span class="line">	<span class="keyword">return</span> material;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaterialBuffer(xxx) Material xxx[4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">pathtracing</span><span class="params">(in Ray ray, inout Random random)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// init scene</span></span><br><span class="line">	Scene scene = (Scene)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MaterialBuffer</span>(materials);</span><br><span class="line">	materials[<span class="number">0</span>] = ___Material(<span class="built_in">float3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	materials[<span class="number">1</span>] = ___Material(<span class="built_in">float3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	materials[<span class="number">2</span>] = ___Material(<span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">	materials[<span class="number">3</span>] = ___Material(<span class="built_in">float3</span>(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>));</span><br><span class="line">	<span class="type">int</span> white = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> red = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> blue = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> grey = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SphereMeshBuffer</span>(balls);</span><br><span class="line">	balls[<span class="number">0</span>] = ___SphereMesh(<span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">-1.5</span>, <span class="number">0</span>), <span class="number">1</span>, white);</span><br><span class="line">	balls[<span class="number">0</span>].material = <span class="number">0</span>; </span><br><span class="line">	scene.nball = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">QuadMeshBuffer</span>(quads);</span><br><span class="line">	quads[<span class="number">0</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">-2.5f</span>, <span class="number">2.5f</span>, <span class="number">2.5f</span>), <span class="built_in">float3</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">-5</span>, <span class="number">0</span>), grey);  <span class="comment">// front </span></span><br><span class="line">	quads[<span class="number">1</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">-2.5f</span>, <span class="number">2.5f</span>, <span class="number">-2.5f</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">-5</span>, <span class="number">0</span>), red);  <span class="comment">// left</span></span><br><span class="line">	quads[<span class="number">2</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">2.5f</span>, <span class="number">2.5f</span>, <span class="number">2.5f</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">-5</span>, <span class="number">0</span>), blue);		<span class="comment">// right</span></span><br><span class="line">	quads[<span class="number">3</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">-2.5f</span>, <span class="number">-2.5f</span>, <span class="number">2.5f</span>), <span class="built_in">float3</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>), grey);	<span class="comment">// down</span></span><br><span class="line">	quads[<span class="number">4</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">-2.5f</span>, <span class="number">2.5f</span>, <span class="number">-2.5f</span>), <span class="built_in">float3</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), grey);		<span class="comment">// up</span></span><br><span class="line">	quads[<span class="number">5</span>] = ___QuadMesh(<span class="built_in">float3</span>(<span class="number">2.5f</span>, <span class="number">2.5f</span>, <span class="number">-2.5f</span>), <span class="built_in">float3</span>(<span class="number">-5</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>), grey);	<span class="comment">// back</span></span><br><span class="line">	scene.nquad = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lights</span></span><br><span class="line">	<span class="built_in">LightBuffer</span>(lights);</span><br><span class="line">	lights[<span class="number">0</span>] =</span><br><span class="line">		___QuadLight(</span><br><span class="line">			<span class="built_in">float3</span>(<span class="number">-1.f</span>, <span class="number">1.5f</span>, <span class="number">-2.5f</span>), <span class="built_in">float3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">3.14</span>,</span><br><span class="line">			<span class="built_in">float3</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">		);</span><br><span class="line">	scene.nlight = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// first hit</span></span><br><span class="line">	Hit hit;</span><br><span class="line">	<span class="built_in">trace_scene</span>(ray, INFINITY, scene, balls, quads, lights, MASK_ALL, hit);</span><br><span class="line">	<span class="keyword">if</span> (hit.hit)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (hit.entity.type == LIGHT_ENTITY) {</span><br><span class="line">			<span class="type">int</span> index = hit.entity.index;</span><br><span class="line">			<span class="keyword">return</span> lights[index].energy;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (hit.entity.type == SPHERE_ENTITY || hit.entity.type == QUAD_ENTITY) {</span><br><span class="line">			Material material = materials[hit.surface.material];</span><br><span class="line">			<span class="keyword">return</span> material.baseColor;</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">pathtrace_loop</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	in Ray ray,</span></span></span><br><span class="line"><span class="params"><span class="function">	in float2 uv,</span></span></span><br><span class="line"><span class="params"><span class="function">	in uint2 resolution</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Random random = { uv, _seed };</span><br><span class="line">	float3 color = <span class="built_in">pathtracing</span>(ray, random);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">float4</span>(color, <span class="number">1.0f</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终效果如下：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211029203534731.png"></p><h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>本节会介绍蒙特卡罗积分，详情请参见 <a href="https://yousazoe.top/archives/f262b578.html">GAMES101</a> 不再赘述。</p><h4 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114220205559.png"></p><p>随机变量可以拆开为 <strong>随机</strong> 和 <strong>变量</strong>。</p><p>之所以是变量，是因为每次随机出来的结果都不一样，它能变的范围（样本空间）是有限的。</p><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114220237812.png"></p><h4 id="蒙特卡洛积分-1"><a href="#蒙特卡洛积分-1" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114220354194.png"></p><p>蒙特卡罗提出一种随机采样方式，利用随机采样估算这个范围的积分，当 $N$ 足够大时就会接近这个积分。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114220740431.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114222610786.png"></p><h4 id="高维积分"><a href="#高维积分" class="headerlink" title="高维积分"></a>高维积分</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114222634975.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114222641717.png"></p><h4 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211114222710483.png"></p><table><thead><tr><th align="center">X</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center"><strong>P</strong></td><td align="center">0.2</td><td align="center">0.5</td><td align="center">0.1</td><td align="center">0.2</td></tr><tr><td align="center"><strong>C</strong></td><td align="center">0.2</td><td align="center">0.7</td><td align="center">0.8</td><td align="center">1.0</td></tr></tbody></table><p>重要性采样就是一个带着权重的随机。</p><h3 id="路径追踪基础框架"><a href="#路径追踪基础框架" class="headerlink" title="路径追踪基础框架"></a>路径追踪基础框架</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><h4 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h4><h4 id="路径追踪实现"><a href="#路径追踪实现" class="headerlink" title="路径追踪实现"></a>路径追踪实现</h4><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><h3 id="微表面"><a href="#微表面" class="headerlink" title="微表面"></a>微表面</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><h4 id="微表面-1"><a href="#微表面-1" class="headerlink" title="微表面"></a>微表面</h4><h4 id="NDF"><a href="#NDF" class="headerlink" title="NDF"></a>NDF</h4><h4 id="PDF-和-CDF"><a href="#PDF-和-CDF" class="headerlink" title="PDF 和 CDF"></a>PDF 和 CDF</h4><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h3 id="迪士尼原则"><a href="#迪士尼原则" class="headerlink" title="迪士尼原则"></a>迪士尼原则</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><h4 id="迪士尼原则-1"><a href="#迪士尼原则-1" class="headerlink" title="迪士尼原则"></a>迪士尼原则</h4><h4 id="直接光BRDF"><a href="#直接光BRDF" class="headerlink" title="直接光BRDF"></a>直接光BRDF</h4><h3 id="双向追踪"><a href="#双向追踪" class="headerlink" title="双向追踪"></a>双向追踪</h3><h3 id="路径追踪性能"><a href="#路径追踪性能" class="headerlink" title="路径追踪性能"></a>路径追踪性能</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h4 id="改写渲染方程"><a href="#改写渲染方程" class="headerlink" title="改写渲染方程"></a>改写渲染方程</h4><h4 id="减枝函数"><a href="#减枝函数" class="headerlink" title="减枝函数"></a>减枝函数</h4><h4 id="灯光估算"><a href="#灯光估算" class="headerlink" title="灯光估算"></a>灯光估算</h4><h4 id="采样灯光优化"><a href="#采样灯光优化" class="headerlink" title="采样灯光优化"></a>采样灯光优化</h4></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/7dbe30e4.html" rel="bookmark">Blockwise Multi-Order Feature Regression for Real-Time Path Tracing Reconstruction</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/971404c0.html" rel="bookmark">Rendering Course by Wangningbei</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/8b6729fe.html" rel="bookmark">A Gentle Introduction to DirectX Raytracing 14</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Computer-Graphics/" rel="tag"># Computer Graphics</a> <a href="/tags/Ray-Tracing/" rel="tag"># Ray Tracing</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/6ec960b4.html" rel="prev" title="Two Pointers"><i class="fa fa-chevron-left"></i> Two Pointers</a></div><div class="post-nav-item"><a href="/archives/dd9fb894.html" rel="next" title="“饥荒”风格的俯视角2.5D实现">“饥荒”风格的俯视角2.5D实现 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7"><span class="nav-number">2.</span> <span class="nav-text">全局光照</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%89%E6%B5%81%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">光流量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%90%E5%B0%84%E7%85%A7%E5%BA%A6"><span class="nav-number">2.2.</span> <span class="nav-text">辐射照度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%90%E5%B0%84%E5%BC%BA%E5%BA%A6-amp-%E7%AB%8B%E4%BD%93%E8%A7%92"><span class="nav-number">2.3.</span> <span class="nav-text">辐射强度 &amp; 立体角</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%90%E5%B0%84%E4%BA%AE%E5%BA%A6"><span class="nav-number">2.4.</span> <span class="nav-text">辐射亮度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BRDF"><span class="nav-number">2.5.</span> <span class="nav-text">BRDF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">渲染方程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">3.2.</span> <span class="nav-text">渲染方程推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA"><span class="nav-number">3.3.</span> <span class="nav-text">光线追踪</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA"><span class="nav-number">4.</span> <span class="nav-text">路径追踪</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">4.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E7%85%A7%E5%BA%A6"><span class="nav-number">4.2.</span> <span class="nav-text">路径照度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%BE%AE%E5%88%86"><span class="nav-number">4.3.</span> <span class="nav-text">路径微分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">路径追踪渲染方程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88"><span class="nav-number">5.</span> <span class="nav-text">引擎框架概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-number">5.1.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">5.2.</span> <span class="nav-text">主循环</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">5.2.1.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E6%9C%BA"><span class="nav-number">5.2.3.</span> <span class="nav-text">相机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%A7%8Bdemo"><span class="nav-number">5.3.</span> <span class="nav-text">开始demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E7%9B%B8%E6%9C%BA"><span class="nav-number">5.4.</span> <span class="nav-text">渲染相机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E5%8F%A3"><span class="nav-number">5.5.</span> <span class="nav-text">视口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E6%A8%A1%E5%9D%97"><span class="nav-number">5.6.</span> <span class="nav-text">光线追踪模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E6%9E%B6%E6%9E%84"><span class="nav-number">5.6.1.</span> <span class="nav-text">入口架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%8Fshader"><span class="nav-number">5.6.2.</span> <span class="nav-text">全屏shader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%BD%E8%B8%AA%E5%99%A8"><span class="nav-number">5.6.3.</span> <span class="nav-text">追踪器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E6%9C%BA-1"><span class="nav-number">6.</span> <span class="nav-text">相机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97"><span class="nav-number">6.1.</span> <span class="nav-text">矩阵运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2"><span class="nav-number">6.2.</span> <span class="nav-text">空间变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80-amp-%E5%B1%80%E9%83%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">6.3.</span> <span class="nav-text">全局 &amp; 局部空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E6%9C%BA%E7%A9%BA%E9%97%B4"><span class="nav-number">6.4.</span> <span class="nav-text">相机空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="nav-number">6.5.</span> <span class="nav-text">图形渲染管线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%8F%E8%A7%86%E5%8E%9F%E7%90%86"><span class="nav-number">6.6.</span> <span class="nav-text">透视原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.7.</span> <span class="nav-text">接口设计实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF"><span class="nav-number">7.</span> <span class="nav-text">场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Entity"><span class="nav-number">7.1.</span> <span class="nav-text">Entity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Light"><span class="nav-number">7.2.</span> <span class="nav-text">Light</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Material"><span class="nav-number">7.3.</span> <span class="nav-text">Material</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Surface"><span class="nav-number">7.4.</span> <span class="nav-text">Surface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Geometry"><span class="nav-number">7.5.</span> <span class="nav-text">Geometry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scene"><span class="nav-number">7.6.</span> <span class="nav-text">Scene</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mask"><span class="nav-number">7.7.</span> <span class="nav-text">Mask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Init-Scene"><span class="nav-number">7.8.</span> <span class="nav-text">Init Scene</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Output-Scene"><span class="nav-number">7.9.</span> <span class="nav-text">Output Scene</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86"><span class="nav-number">8.</span> <span class="nav-text">蒙特卡洛积分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">8.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F"><span class="nav-number">8.2.</span> <span class="nav-text">随机变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%9F%E6%9C%9B"><span class="nav-number">8.3.</span> <span class="nav-text">期望</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86-1"><span class="nav-number">8.4.</span> <span class="nav-text">蒙特卡洛积分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BB%B4%E7%A7%AF%E5%88%86"><span class="nav-number">8.5.</span> <span class="nav-text">高维积分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7"><span class="nav-number">8.6.</span> <span class="nav-text">重要性采样</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6"><span class="nav-number">9.</span> <span class="nav-text">路径追踪基础框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="nav-number">9.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4"><span class="nav-number">9.2.</span> <span class="nav-text">切线空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.3.</span> <span class="nav-text">路径追踪实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84"><span class="nav-number">10.</span> <span class="nav-text">重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E8%A1%A8%E9%9D%A2"><span class="nav-number">11.</span> <span class="nav-text">微表面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="nav-number">11.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E8%A1%A8%E9%9D%A2-1"><span class="nav-number">11.2.</span> <span class="nav-text">微表面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NDF"><span class="nav-number">11.3.</span> <span class="nav-text">NDF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PDF-%E5%92%8C-CDF"><span class="nav-number">11.4.</span> <span class="nav-text">PDF 和 CDF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.5.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AA%E5%A3%AB%E5%B0%BC%E5%8E%9F%E5%88%99"><span class="nav-number">12.</span> <span class="nav-text">迪士尼原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="nav-number">12.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AA%E5%A3%AB%E5%B0%BC%E5%8E%9F%E5%88%99-1"><span class="nav-number">12.2.</span> <span class="nav-text">迪士尼原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%85%89BRDF"><span class="nav-number">12.3.</span> <span class="nav-text">直接光BRDF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E8%BF%BD%E8%B8%AA"><span class="nav-number">13.</span> <span class="nav-text">双向追踪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E6%80%A7%E8%83%BD"><span class="nav-number">14.</span> <span class="nav-text">路径追踪性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">14.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E5%86%99%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B"><span class="nav-number">14.2.</span> <span class="nav-text">改写渲染方程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E6%9E%9D%E5%87%BD%E6%95%B0"><span class="nav-number">14.3.</span> <span class="nav-text">减枝函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%81%AF%E5%85%89%E4%BC%B0%E7%AE%97"><span class="nav-number">14.4.</span> <span class="nav-text">灯光估算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%87%E6%A0%B7%E7%81%AF%E5%85%89%E4%BC%98%E5%8C%96"><span class="nav-number">14.5.</span> <span class="nav-text">采样灯光优化</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">292</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">46</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://img.yousazoe.top/uPic/img/blog/icon/beian.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.5m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="https://img.yousazoe.top/uPic/img/blog/icon/mona-loading-default.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:5,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
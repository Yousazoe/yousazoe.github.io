<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="google-site-verification" content="35AYyqm-wpmGmXtkn-vQMrk7AkFl1Do55uHdlLLLT38"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Tiny Rooms by        Mohamed Chahin             引言C++标准库是C++程序员不可或缺的生产工具和技术宝库。其中的大体量成份，我们称为STL (Standard Template Library/标准模板库)。本文将深入分析 STL 标准库的六大部件及其之间的体系结构，并分析其源码，引导高阶泛型编程。"><meta property="og:type" content="article"><meta property="og:title" content="C++ Standard Library — Architecure &amp; Sources"><meta property="og:url" content="https://yousazoe.top/archives/98f44102.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="Tiny Rooms by        Mohamed Chahin             引言C++标准库是C++程序员不可或缺的生产工具和技术宝库。其中的大体量成份，我们称为STL (Standard Template Library/标准模板库)。本文将深入分析 STL 标准库的六大部件及其之间的体系结构，并分析其源码，引导高阶泛型编程。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/b77dbf102453055.5f36c4990a869.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906102913525.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906103815683.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906104000424.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906110405583.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906110525902.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818213821799.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906111140094.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906114540397.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906152950430.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906154201276.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906155032175.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906160423988.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906161139170.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906173733638.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913081549907.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913172720069.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913172836892.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210915160929212.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916082733065.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916085445065.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916090747900.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916090854402.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916094933120.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916101440893.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916105218926.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916123624139.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916123947888.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916130207004.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916135336928.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916145439152.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916145506560.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916145649120.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916150348487.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916151042722.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916153144631.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916160614948.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916162200162.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/screencapture-github-steveLauwh-SGI-STL-2021-09-16-16_37_51.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916165044167.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916165721581.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916170857569.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916173525585.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917102319890.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917102450587.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917104119548.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917105643673.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917111411824.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917111649689.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917160550577.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917161613907.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917162308050.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917172229186.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210924184235750.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210924185219469.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925075404870.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925075704829.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925080830869.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925080936413.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925083430687.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925151647456.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925151941560.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925152638431.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925160128071.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925163213666.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925202619896.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925202757213.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927084846862.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927085420980.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927092407060.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927093708321.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927094804904.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927101352083.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927105610255.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927151345295.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927152003950.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927153322493.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927160551596.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927160839254.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927164037962.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927173548762.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927181518803.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927190401542.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004093111089.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004093516701.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004094605009.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004100226806.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004100812113.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004100948733.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004102845916.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004105631641.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004111906773.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004113050415.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004153343297.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004154545763.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004155818960.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004155854034.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004155924506.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004160020239.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004160113973.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004165153504.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004165228283.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004171516603.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004171604398.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211027101201781.png"><meta property="article:published_time" content="2021-09-06T02:12:15.000Z"><meta property="article:modified_time" content="2022-07-18T03:00:58.793Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Cpp"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/b77dbf102453055.5f36c4990a869.png"><link rel="canonical" href="https://yousazoe.top/archives/98f44102.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>C++ Standard Library — Architecure &amp; Sources | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/98f44102.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++ Standard Library — Architecure &amp; Sources</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-09-06 10:12:15" itemprop="dateCreated datePublished" datetime="2021-09-06T10:12:15+08:00">2021-09-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E4%BE%AF%E6%8D%B7C-%E7%B3%BB%E5%88%97-HouJie-C-Series/" itemprop="url" rel="index"><span itemprop="name">侯捷C++系列 (HouJie C++ Series)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>50k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>1:30</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/b77dbf102453055.5f36c4990a869.png"></p><div align="center"><font size="3"><i><a target="_blank" rel="noopener" href="https://www.behance.net/gallery/102453055/Tiny-Rooms">Tiny Rooms</a> by <a target="_blank" rel="noopener" href="https://www.behance.net/MChahin">Mohamed Chahin</a></i></font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>C++标准库是C++程序员不可或缺的生产工具和技术宝库。其中的大体量成份，我们称为STL (Standard Template Library/标准模板库)。本文将深入分析 STL 标准库的六大部件及其之间的体系结构，并分析其源码，引导高阶泛型编程。</p><span id="more"></span><h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><blockquote><p>使用一个东西，却不明白它的道理，不高明！</p></blockquote><h4 id="你應具備的基礎"><a href="#你應具備的基礎" class="headerlink" title="你應具備的基礎"></a>你應具備的基礎</h4><ul><li>C++ 基本語法（包括如何正確使用<strong>模板，templates</strong>）</li></ul><h4 id="我們的目標"><a href="#我們的目標" class="headerlink" title="我們的目標"></a>我們的目標</h4><ul><li><strong>level 0</strong>: 淺嘗 C++ 標準庫</li><li><strong>level 1</strong>: 深入認識 C++ 標準庫</li><li><strong>level 2</strong>: 良好使用 C++ 標準庫</li><li><strong>level 3</strong>: 擴充 C++ 標準庫</li></ul><h4 id="C-Standard-Library-vs-Standard-Template-Library"><a href="#C-Standard-Library-vs-Standard-Template-Library" class="headerlink" title="C++ Standard Library vs. Standard Template Library"></a>C++ Standard Library vs. Standard Template Library</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906102913525.png"></p><h4 id="C-標準庫，版本"><a href="#C-標準庫，版本" class="headerlink" title="C++ 標準庫，版本"></a>C++ 標準庫，版本</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906103815683.png"></p><p>标准库的版本不会影响代码编写，各式各样的编辑器或是开发平台中标准库的用法都是一样的。</p><h4 id="重要網頁，CPlusPlus-com"><a href="#重要網頁，CPlusPlus-com" class="headerlink" title="重要網頁，CPlusPlus.com"></a>重要網頁，CPlusPlus.com</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906104000424.png"></p><h4 id="重要網頁，CppReference-com"><a href="#重要網頁，CppReference-com" class="headerlink" title="重要網頁，CppReference.com"></a>重要網頁，CppReference.com</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906110405583.png"></p><h4 id="重要網頁，gcc-gnu-org"><a href="#重要網頁，gcc-gnu-org" class="headerlink" title="重要網頁，gcc.gnu.org"></a>重要網頁，gcc.gnu.org</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906110525902.png"></p><h4 id="書目誌"><a href="#書目誌" class="headerlink" title="書目誌"></a>書目誌</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210818213821799.png"></p><h3 id="STL-体系结构基础介绍"><a href="#STL-体系结构基础介绍" class="headerlink" title="STL 体系结构基础介绍"></a>STL 体系结构基础介绍</h3><h4 id="STL-六大部件"><a href="#STL-六大部件" class="headerlink" title="STL 六大部件"></a>STL 六大部件</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906111140094.png"></p><p>程序的主体是由数据结构和算法构成，C++ 中全世界最好的团队把非常重要的算法和容器都做了出来，也是六大部件中最重要的两个。</p><p>我们最开始接触的应该是容器（Containers），容器要放东西，东西要占内存，所以容器的好处在于帮我们把内存的问题解决了。你看不到内存，只需要把东西放进容器或者取出就好了，所以它的背后需要有另外的东西去支持：分配器（Allocator），分配器是用来支持容器的。</p><p>容器里面放入的数据需要操作，有一些操作是在容器本身做，还有更多的操作被独立出来变成一个个模版函数放在算法（Algorithms）里。说到算法大家可能想到课上学的排序：冒泡排序、快速排序、希尔排序……搜索有线性查找、二分查找等等都包含在算法里。在面向对象的思想里鼓励类中存放数据和函数，而现在我们看到数据在容器内，操作数据的动作算法却不在这个类中，所以它的设计观念和方式和面向对象是不一样的。</p><p>算法与容器的桥梁是迭代器（Iterators），它就好像是一种泛化的指针。除此之外还有两个东西：适配器（Adapters）和仿函数（Functors），其中仿函数作用像是一个函数，适配器则是帮助我们转换：</p><ul><li>容器适配器（Container Adapters）</li><li>迭代器适配器（Iterator Adapters）</li><li>仿函数适配器（Functor Adapters）</li></ul><h4 id="STL-六大部件關係"><a href="#STL-六大部件關係" class="headerlink" title="STL 六大部件關係"></a>STL 六大部件關係</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906114540397.png"></p><p>这里的容器使用的是 <code>vector</code>，而第二个参数 <code>allocator&lt;int&gt;</code> 则是允许你放一个分配器帮助其分配内存，你可以不写，在源代码里会有默认的分配器，所以大部分人都不会写这个模版参数。</p><p>接下来我需要操作它。这里选择的算法是 <code>count_if</code>，功能是计算出符合条件的元素有几个。之后我们使用迭代器传入之前元素 <code>vi</code> 的头 <code>vi.begin()</code> 和尾 <code>vi.end()</code>，放置的条件是小于 40 的元素，外加的 <code>not1()</code> 则条件变为大于等于 40。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">6</span>] = {<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>};</span><br><span class="line">    vector&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia + <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line">            <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="複雜度，Complexity，Big-oh"><a href="#複雜度，Complexity，Big-oh" class="headerlink" title="複雜度，Complexity，Big-oh"></a>複雜度，Complexity，Big-oh</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906152950430.png"></p><p>没有完美的容器，只有合适的容器，具体情况具体分析。</p><ul><li>$O(1) \space\space O(c)$ 常數時間</li><li>$O(n)$ 線性時間</li><li>$O(\log_2{n})$ 次線性時間</li><li>$O(n^2)$ 平方時間</li><li>$O(n^3)$ 立法時間</li><li>$O(2^n)$ 指數時間</li><li>$O(n\log_2{n})$ 介於線性及二次方成長的中間之行為模式</li></ul><h4 id="“前閉後開”區間"><a href="#“前閉後開”區間" class="headerlink" title="“前閉後開”區間"></a>“前閉後開”區間</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906154201276.png"></p><p>所有的容器都有头有尾，提供 <code>begin()</code>、<code>end()</code> 这两个函数。头大家是没有疑虑的，而尾指的是最后一个元素的后一个位置，而不是最后一个元素本身，形成前闭后开区间。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line">...</span><br><span class="line">Container&lt;T&gt;::iterator ite = c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; ite != c.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">	...</span><br></pre></td></tr></tbody></table></figure><h4 id="range-based-for-statement-since-C-11"><a href="#range-based-for-statement-since-C-11" class="headerlink" title="range-based for statement (since C++11)"></a>range-based for statement (since C++11)</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906155032175.png"></p><p>C++11 有一个新特性可以简化上面的迭代器写法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(decl : coll) {</span><br><span class="line">	statement</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>举几个具体的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : {<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>}) {</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem : vec) {</span><br><span class="line">    std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : vec) {</span><br><span class="line">    elem *= <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="auto-keyword"><a href="#auto-keyword" class="headerlink" title="auto keyword"></a>auto keyword</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906160423988.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">list&lt;string&gt; c;</span><br><span class="line">...</span><br><span class="line">list&lt;string&gt;::iterator ite;</span><br><span class="line">ite = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br></pre></td></tr></tbody></table></figure><p>对于 <code>auto</code> 关键字我们可以这样更改，但对于优秀的程序员还是需要知道变量的类型比较好，而为了写作舒适可以适量使用：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">list&lt;string&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> ite = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br></pre></td></tr></tbody></table></figure><h3 id="容器与各种测试"><a href="#容器与各种测试" class="headerlink" title="容器与各种测试"></a>容器与各种测试</h3><h4 id="容器-結構與分類"><a href="#容器-結構與分類" class="headerlink" title="容器-結構與分類"></a>容器-結構與分類</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906161139170.png"></p><p>这张图涵盖了容器的结构以及分类，最重要的是它内存中长什么样，元素间是什么样的关系（连续还是指针）。</p><p>容器分类大致分为两种：</p><ul><li><p><strong>Sequence Containers</strong> 序列式容器</p><p>这种容器适合做快速地查找。查找是很重要的事情，小时候听人家说电脑主要是放大量的资料以及很容易去找东西，当时我想电脑这么尖端科技的东西只是用来做这么简单的东西吗？后来发现生活中许多事情其实就是排序查找的一个过程</p></li><li><p><strong>Associative Containers</strong> 关联式容器</p></li><li><p><strong>Unordered Containers</strong> 不定序容器</p><p>C++11 （图中红框标记的均为新特性）新出现的容器，个人认为这种分类方法并不是很好，它其实就是一种关联式容器。元素放进这个容器没有一定的次序，其实就是用哈希表做的容器</p></li></ul><h5 id="Sequence-Containers"><a href="#Sequence-Containers" class="headerlink" title="Sequence Containers"></a>Sequence Containers</h5><p>在 Sequence Containers 中第一种就是 Array 数组，这个数组是把语言的数组包装为类。Array 就是一个连续空间，你要多大就分配多大，体现在图中就是封闭的两端，前面和后面是无法扩充的。</p><p>第二种容器则是 Vector，图中的起点是封闭的，而后面是可以扩充的，当它空间不够时会自动增长（容器分配器来处理这件事）。</p><p>第三种容器叫做 Deque，队列本来是先进先出，而这里是双向队列，图中展示出两端可进可出。它的弹性非常大非常好啊，但是怎么可能有一个内存可以前后都可以扩充的呢？再后面我们会讲它是怎么做的。</p><p>下面的容器是 List，每一个元素并没有连续地挂在一起，中间都是用指针串联起来，而且指针都是双向的。在源代码中它其实是一个双向环状链表，在使用上只需要知道它是双向的就可以了。</p><p>C++11 新加了单向链表 Forward-List，每一个元素的指针都是单向，而选择 List 耗用的内存一定比你使用 Forward-List 要多。</p><h5 id="Associative-Containers"><a href="#Associative-Containers" class="headerlink" title="Associative Containers"></a>Associative Containers</h5><p>对于大量查找来讲最有价值的是 Associative Containers，它主要表现为 Set 和 Map，内部是用高度平衡的红黑树（一种特殊的二分树）做的，避免了最坏的查找情况。</p><h4 id="測試程序"><a href="#測試程序" class="headerlink" title="測試程序"></a>測試程序</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">get_a_target_long</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">long</span> target = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"target (0~"</span> &lt;&lt; RAND_MAX &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">get_a_target_string</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">long</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">"target (0~"</span> &lt;&lt; RAND_MAX &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%ld"</span>, target);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareLongs</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">long</span>*)a - *(<span class="type">long</span>*)b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareString</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*(string*) a &gt; *(string*) b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(string*) a &lt; *(string*) b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>主函数部分如下，之后在 <code>switch</code> 语句中添加即可：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"\n\ntest_containers()......... \n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"select: \n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"       \t(1)array          \t(2)vector             \t(3)list               \t(4)forward_list \t(5)deque\t(6)multiset \n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"       \t(7)multimap       \t(8)unordered_multiset \t(9)unordered_multimap \t(10)slist \n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"       \t(11)hash_multiset \t(12)hash_multimap     \t(13)set               \t(14)map         \t(15)unordered_set \n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"       \t(16)unordered_map \t(17)stack             \t(18)queue \n\n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">" (2),(3),(5),(6),(8) will test also moveable elements. \n"</span>;</span><br><span class="line">    cin &gt;&gt; choice;</span><br><span class="line">    <span class="keyword">if</span> ( choice != <span class="number">1</span> ) { 	<span class="comment">//1 ==&gt; array, use ASIZE</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"how many elements: "</span>;</span><br><span class="line">        cin &gt;&gt; value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (choice) {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-array"><a href="#使用容器-array" class="headerlink" title="使用容器 array"></a>使用容器 array</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210906173733638.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">array&lt;<span class="type">long</span>, ASIZE&gt; c;</span><br><span class="line"><span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ASIZE; ++i) {</span><br><span class="line">	c[i] = <span class="built_in">rand</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先创建数组并用 <code>rand()</code> 随机数给数组赋值，<code>clock()</code> 记录耗时节点检测时间。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"milli-second : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"array.size() = "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"array.front() = "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"array.back() = "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"array.data() = "</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>这部分掉用了数组 array 的内置函数：</p><ul><li><code>size()</code>：数组大小</li><li><code>front()</code>：数组的头部元素</li><li><code>back()</code>：数组的尾部元素</li><li><code>data()</code>：数组在内存的起点地址</li></ul><p>接下来我使用 <code>qsort()</code> 进行排序，参数有数组的起点地址 <code>data()</code>、元素多少 <code>ASIZE</code>、每一个元素的大小 <code>sizeof(long)</code> 以及怎么比大小 <code>compareLongs()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">qsort</span>(c.<span class="built_in">data</span>(), ASIZE, <span class="built_in">sizeof</span>(<span class="type">long</span>), compareLongs);</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">// qsort, bsearch, NULL</span></span></span><br><span class="line"><span class="keyword">namespace</span> arrayTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_array</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_array().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        array&lt;<span class="type">long</span>, ASIZE&gt; c;</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ASIZE; ++i) {</span><br><span class="line">            c[i] = <span class="built_in">rand</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-second : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"array.size() = "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"array.front() = "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"array.back() = "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"array.data() = "</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">qsort</span>(c.<span class="built_in">data</span>(), ASIZE, <span class="built_in">sizeof</span>(<span class="type">long</span>), compareLongs);</span><br><span class="line">        <span class="type">long</span>* pItem = (<span class="type">long</span>*)<span class="built_in">bsearch</span>(&amp;target, (c.<span class="built_in">data</span>()), ASIZE, <span class="built_in">sizeof</span>(<span class="type">long</span>), compareLongs);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"qsort() + bsearch(), millli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-vector"><a href="#使用容器-vector" class="headerlink" title="使用容器 vector"></a>使用容器 vector</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913081549907.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_vector</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">	......</span><br><span class="line">}	</span><br></pre></td></tr></tbody></table></figure><p>这里的 <code>value</code> 是指 <code>main</code> 函数中接收的容器大小。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		<span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">		c.<span class="built_in">push_back</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">abort</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>push_back()</code> 是容器放元素到尾部的动作，它没有 “push_front()”，因为 <code>vector</code> 的结构是左闭右开向右增长，如果向头部插入一个元素必须将后面所有元素右移一格，当数量级上去比如一百万个元素会很耗时间。绝大部分容器都有 <code>push_back()</code> 函数。</p><p><code>vector</code> 以两倍速度增长空间：1、2、4、8……以此类推。</p><p><code>try</code> 和 <code>catch</code> 的作用是抓取异常 <code>exception</code> 发生。为什么我要这么设计呢？当空间不够用时可能会发生异常，从注释也可以得到异常出现的边界情况：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// i= 58389486 then std::bad_alloc</span></span><br></pre></td></tr></tbody></table></figure><p>这样就可以得到容器最大的容量是多少，发生异常时利用 <code>abort()</code> 退出程序。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"vector.size() = "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"vector.front() = "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"vector.back() = "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"vector.data() = "</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"vector.capacity() = "</span> &lt;&lt; c.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>这里 <code>size()</code> 和 <code>capacity()</code> 的区别是实际元素的个数和容器容量。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913172720069.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">timeStart = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">auto</span> pItem = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">cout &lt;&lt; <span class="string">"::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">	cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p><code>::</code> 的作用在于如果在 <code>vectorTest</code> 作用域中找不到 <code>find()</code>，那么它会继续在全局范围内寻找。</p><p>这个 <code>find()</code> 传回的是一个 <code>iterator</code>，但前面我们说过迭代器写起来很长，我们可以使用 <code>auto</code> 关键字代替。当迭代器找到这个值时则解参考取值，否则打印未找到。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">timeStart = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">string* qItem = (string*)<span class="built_in">bsearch</span>(&amp;target, (c.<span class="built_in">data</span>()), c.<span class="built_in">size</span>(), <span class="built_in">sizeof</span>(string), compareString);</span><br><span class="line">cout &lt;&lt; <span class="string">"bsearch(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (qItem != <span class="literal">NULL</span>)</span><br><span class="line">	cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *qItem &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br></pre></td></tr></tbody></table></figure><p>上下两端用不同的方法来看看查找的速度，标准库的 <code>find()</code> 使用的是按序查找，比较吃运气；后面这种使用排序 + 二分查找。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>    <span class="comment">// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>     <span class="comment">// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">// sort()</span></span></span><br><span class="line"><span class="keyword">namespace</span> vectorTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_vector</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_vector().........\n"</span>;</span><br><span class="line">        vector&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">push_back</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="comment">// i= 58389486 then std::bad_alloc</span></span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"vector.size() = "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"vector.front() = "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"vector.back() = "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"vector.data() = "</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"vector.capacity() = "</span> &lt;&lt; c.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        string* qItem = (string*)<span class="built_in">bsearch</span>(&amp;target, (c.<span class="built_in">data</span>()), c.<span class="built_in">size</span>(), <span class="built_in">sizeof</span>(string), compareString);</span><br><span class="line">        cout &lt;&lt; <span class="string">"bsearch(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (qItem != <span class="literal">NULL</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *qItem &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        c.<span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-list"><a href="#使用容器-list" class="headerlink" title="使用容器 list"></a>使用容器 list</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210913172836892.png"></p><p>刚刚我们看过了 array 和 vector，后面的测试都是一样的形式：以一种问答的形式询问要测试的容器以及容器的容量 <code>value</code>，然后用随机数填充容器并进行测试。</p><p>接下来我们来看看容器 list 双向链表。链表和刚刚的 vector 不太一样，vector 在放满后成长两倍，但它不可能在这个位置上成长，一定是在另外一个位置上找一个两倍大的空间，然后再把原来的元素一个个搬过来。所以成长这个过程是非常缓慢的。list 又不一样，它是一个萝卜一个坑，每放一个元素就在空间中找到一个节点大小。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"list.size() = "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"list.max_size() = "</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"list.front() = "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"list.back() = "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>链表居然有 <code>max_size()</code>，出乎我的意料。按照链表的结构，它的元素是动态分配，应该是只要内存能够供应就可以一直要，之后我们看到源码再来回顾这件事情。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">c.<span class="built_in">sort</span>();</span><br></pre></td></tr></tbody></table></figure><p>我们调用的不是标准库的全局排序函数，而是容器内的排序函数 <code>sort()</code>。当全局和容器都有排序函数时使用容器内置的排序函数会比较快。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>   <span class="comment">// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>    <span class="comment">// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// find()</span></span></span><br><span class="line"><span class="keyword">namespace</span> listTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_list</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_list().........\n"</span>;</span><br><span class="line">        list&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">push_back</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"list.size() = "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"list.max_size() = "</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"list.front() = "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"list.back() = "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        c.<span class="built_in">sort</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"c.sort(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-forward-list"><a href="#使用容器-forward-list" class="headerlink" title="使用容器 forward_list"></a>使用容器 forward_list</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210915160929212.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		<span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">		c.<span class="built_in">push_front</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">abort</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里放入元素使用的是 <code>push_front()</code> 而不是之前的 <code>push_back()</code>。还需要注意一下如图所示它没有 <code>back()</code> 或是 <code>size()</code>，注释中许多方法是不提供的。</p><p>完整的代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> forwardlistTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_forward_list</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_forward_list().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        forward_list&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">push_front</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"forward_list.max_size()= "</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"forward_list.front()= "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        c.<span class="built_in">sort</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"c.sort(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-deque"><a href="#使用容器-deque" class="headerlink" title="使用容器 deque"></a>使用容器 deque</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916082733065.png" alt="image-20210916082733065"></p><p>下一个 deque 非常有趣，它是一个双向开口可进可出的结构。但是我们知道一个容器占用内存之后是不能再扩充，再扩充就可能碰到别人占用的内存，所以像 vector 需要在别的地方找到一块内存把原来的搬过去。</p><p>deque 的两边都可以扩充，图中的结构可以比较明确的表现出来。上图一共有五段 buffer，一个段落放了八个元素，deque 就是这样一段一段构成的，我们在术语上把它叫作分段延续。然而它的延续只是一种假象，之后我们会在源码部分解析。它每次扩充一个 buffer，所有的 buffer 通过指针依次连接。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916085445065.png"></p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> dequeTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_deque</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_deque().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        deque&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">push_back</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"deque.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"deque.front()= "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"deque.back()= "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"deque.max_size()= "</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">"sort(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        c.<span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-stack"><a href="#使用容器-stack" class="headerlink" title="使用容器 stack"></a>使用容器 stack</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916090747900.png"></p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> stackTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_stack</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_stack().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">push</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"stack.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"stack.top()="</span> &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"stack.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"stack.top()="</span> &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-queue"><a href="#使用容器-queue" class="headerlink" title="使用容器 queue"></a>使用容器 queue</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916090854402.png"></p><p>由于这两种容器里面没有自己的数据结构，所以很多人从技术上不把这两个容器叫作容器，而是把它叫作容器的适配器 Adapters。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> queueTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_queue</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_queue().......... \n"</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">push</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"queue.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"queue.front()= "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"queue.back()= "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"queue.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"queue.front()= "</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"queue.back()= "</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>前面介绍的那些容器需要再次提醒，有些容器因为它功能上的限制不允许在前段或后段加元素，所以它们不提供 iterator 的操作。以先进后出的 stack 为例，如果它提供迭代器，你很可能用它去改变元素或者删除插入某些元素，而这些操作又会破坏容器先进后出的独特性质，queue 的先进先出也是一样。</p><h4 id="使用容器-multist"><a href="#使用容器-multist" class="headerlink" title="使用容器 multist"></a>使用容器 multist</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916094933120.png"></p><p>multiset 可以把它想象成小型的关联数据库，底层结构是红黑树，它的查找是非常快的。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"\ntest_multiset().......... \n"</span>;</span><br><span class="line"></span><br><span class="line">multiset&lt;string&gt; c;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		<span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">		c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">abort</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的安插元素使用的是 <code>insert()</code>，那么它安插的是头是尾呢？都不是，它会安插到它该安插的位置，这棵树是有一定的规则可循的。</p><p>完整的代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> multisetTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_multiset</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_multiset().......... \n"</span>;</span><br><span class="line"></span><br><span class="line">        multiset&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"multiset.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"multiset.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> qItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *qItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>红黑树是高度平衡的，查找也非常快，元素安插的速度慢一些。当你可以接受安插元素慢一些而更关注后面查找的速度，关联式容器是非常不错的选择。</p><h4 id="使用容器-multimap"><a href="#使用容器-multimap" class="headerlink" title="使用容器 multimap"></a>使用容器 multimap</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916101440893.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"> cout &lt;&lt; <span class="string">"\ntest_multimap().........\n"</span>;</span><br><span class="line"></span><br><span class="line">multimap&lt;<span class="type">long</span>, string&gt; c;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		<span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">		c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">abort</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里插入必须将键值对的形式组合起来，再调用 <code>insert()</code>。key 一定是唯一的，value则是随机数不唯一。</p><p>完整的代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> multimapTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_multimap</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_multimap().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        multimap&lt;<span class="type">long</span>, string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"multimap.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"multimap.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, value = "</span> &lt;&lt; (*pItem).second &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        c.<span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-unordered-multiset"><a href="#使用容器-unordered-multiset" class="headerlink" title="使用容器 unordered_multiset"></a>使用容器 unordered_multiset</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916105218926.png"></p><p>接下来的 unordered_multiset 底层不是用红黑树做支撑，而是哈希表。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"unordered_multiset.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"unordered_multiset.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"unordered_multiset.bucket_count()="</span> &lt;&lt; c.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"unordered_multiset.load_factor()="</span> &lt;&lt; c.<span class="built_in">load_factor</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"unordered_multiset.max_load_factor()="</span> &lt;&lt; c.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"unordered_multiset.max_bucket_count()="</span> &lt;&lt; c.<span class="built_in">max_bucket_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>这里 <code>bucket_count()</code> 是篮子的个数，看图发现篮子比元素个数还要多，这个合理吗？合理，图中有的篮子挂了许多元素，而有的篮子没有挂载元素，代码中也把前 20 个篮子有几个元素打印出来：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) {</span><br><span class="line">	cout &lt;&lt; <span class="string">"bucket #"</span> &lt;&lt; i &lt;&lt; <span class="string">" has "</span> &lt;&lt; c.<span class="built_in">bucket_size</span>(i) &lt;&lt; <span class="string">" elements."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以篮子比元素多不是什么了不起的事情。事实上篮子一定比元素多，这是它在设计上一个内部的考量：为了查找速度，每一个篮子链表不能太长，经验法则告诉大家如果元素个数大于篮子，那么这个篮子就要重新扩充为大约两倍。</p><p>而 <code>load_factor()</code> 是载重因子，我们之后再去谈它。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916123624139.png"></p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> unordered_multisetTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_unordered_multiset</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_unordered_multiset().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        unordered_multiset&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_multiset.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_multiset.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_multiset.bucket_count()="</span> &lt;&lt; c.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_multiset.load_factor()="</span> &lt;&lt; c.<span class="built_in">load_factor</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_multiset.max_load_factor()="</span> &lt;&lt; c.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_multiset.max_bucket_count()="</span> &lt;&lt; c.<span class="built_in">max_bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"bucket #"</span> &lt;&lt; i &lt;&lt; <span class="string">" has "</span> &lt;&lt; c.<span class="built_in">bucket_size</span>(i) &lt;&lt; <span class="string">" elements."</span> &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> qItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"c.find(), ,milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (qItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *qItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        c.<span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-unordered-multimap"><a href="#使用容器-unordered-multimap" class="headerlink" title="使用容器 unordered_multimap"></a>使用容器 unordered_multimap</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916123947888.png"></p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> unordered_multimapTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_unordered_multimap</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_unordered_multimap().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        unordered_multimap&lt;<span class="type">long</span>, string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_multimap.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_multimap.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"c.find(), value="</span> &lt;&lt; (*pItem).second &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当你需要大量搜寻某些元素时，可以考虑关联式容器，有用红黑树做底层的，有用哈希表散列表做底层的。</p><h4 id="使用容器-set"><a href="#使用容器-set" class="headerlink" title="使用容器 set"></a>使用容器 set</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916130207004.png"></p><p>前面四种容器前面都有 multi 字眼允许重复的 key 存在，接下来的四种容器的 key 必须是独一无二的。</p><p>因为 key 不可以重复，而随机数很有可能出现重复，所以在这里 set 放进去的一定不是原来的数量。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> setTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_set</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_set().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        set&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"set.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"set.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> qItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-map"><a href="#使用容器-map" class="headerlink" title="使用容器 map"></a>使用容器 map</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916135336928.png"></p><p>刚刚在讲 set 的时候说一共放进去 32768 个元素，现在我也放 100 万次，按道理讲我现在放进去东西容器的大小也应该 32768，但 map 大小却是 100 万。原因是键值对的 key 是 for loop 中的 <code>i</code>，并不会重复，而 value 重复并不影响，所以可以放入 100 万个 value 进去。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mapTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_map</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_set().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">long</span>, string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"set.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"set.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, value="</span> &lt;&lt; (*pItem).second &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>后面的 unordered_set 和 unordered_map 和之前类似。</p><h4 id="使用容器-unordered-set"><a href="#使用容器-unordered-set" class="headerlink" title="使用容器 unordered_set"></a>使用容器 unordered_set</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916145439152.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916145506560.png"></p><p>完整源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> unordered_setTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_unordered_set</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_unordered_set().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt;  p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_set.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_set.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_set.bucket_count()="</span> &lt;&lt; c.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_set.load_factor()="</span> &lt;&lt; c.<span class="built_in">load_factor</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_set.max_load_factor()="</span> &lt;&lt; c.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"unordered_set.max_bucket_count()="</span> &lt;&lt; c.<span class="built_in">max_bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"bucket #"</span> &lt;&lt; i &lt;&lt; <span class="string">" has "</span> &lt;&lt; c.<span class="built_in">bucket_size</span>(i) &lt;&lt; <span class="string">" elements.\n"</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        string target = <span class="built_in">get_a_target_string</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = ::<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用容器-unordered-map"><a href="#使用容器-unordered-map" class="headerlink" title="使用容器 unordered_map"></a>使用容器 unordered_map</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916145649120.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> unordered_mapTest {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_unordered_map</span><span class="params">(<span class="type">long</span>&amp; value)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"\ntest_unordered_map().........\n"</span>;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">long</span>, string&gt; c;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, <span class="built_in">rand</span>());</span><br><span class="line">                c[i] = <span class="built_in">string</span>(buf);</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">catch</span> (exception&amp; p) {</span><br><span class="line">                cout &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"map.size()="</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"map.max_size()="</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">        cout &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">"found, value="</span> &lt;&lt; (*pItem).second &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用分配器-allocator"><a href="#使用分配器-allocator" class="headerlink" title="使用分配器 allocator"></a>使用分配器 allocator</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916150348487.png"></p><p>前面我们介绍的都是容器，容器的背后需要一个东西来支持内存的使用，这个东西就是分配器。在理想的情况下我们最好是不知道这个东西，你不用写出来容器就有一个默认的分配器。从图中可以知道每一个容器都声明为模板，它们的默认参数都是 <code>std::allocator</code>。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916151042722.png"></p><p>除了标准库的分配器，gnu 还给了许多分配器：</p><ul><li><code>array_allocator</code> 队列分配器</li><li><code>mt_allocator</code> 多线程分配器</li><li><code>debug_allocator</code> 调试分配器</li><li><code>pool_allocator</code> 内存池分配器</li><li>……</li></ul><p>它们都放在 <code>#include &lt;ext/...&gt;</code> 底下，是非标准库 <code>_gnu_cxx::</code> 的。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916153144631.png"></p><p>图中代码以 list 双向链表为例，创建出这些容器之后，测试程序会询问我要选择多少个元素并使用不同分配器分配内存，这也是搭配不同分配器在容器上的写法。</p><p>有一个疑惑：有没有可能直接使用容器？当然是可以的，分配器就提供两个函数 <code>allocate()</code> 和 <code>deallocate()</code>。有没有必要呢？没有必要，因为真正的工具是容器，实在没有必要用它背后的分配器去拿内存、还内存。右侧代码对每一个容器都见一个分配器，调用 <code>allocate()</code> 和 <code>deallocate()</code>。</p><p>为什么说不值得呢？因为如果不使用容器你可能会使用 <code>new</code> 搭配 <code>delete</code>，或者 <code>malloc</code> 搭配 <code>free</code>。而如果还需要记住指针带着的字节，显然没有人受得了。总之就是不建议使用分配器，负担会很重，在程序中应该尽量使用容器，而小量的内存需求则应该选择传统的 <code>new</code> 搭配 <code>delete</code>，或者 <code>malloc</code> 搭配 <code>free</code>。</p><h3 id="源代码分布"><a href="#源代码分布" class="headerlink" title="源代码分布"></a>源代码分布</h3><p>上几讲我们写了一个测试程序，用了标准库中很多容器以及分配器，对体系结构我们有了一些了解，整个 STL 六大部件有着非常紧密的联系。但是要深入了解这些体系结构，我们必须要看源代码。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916160614948.png"></p><p>源码在你面前，只要能看得懂，还有什么秘密可言呢？你需要相当程度的了解 STL才能够把它用的非常好，才能选择一个好的算法，选择一个好的容器。从另外一个角度来看，标准库对于 C++ 从业者是一个宝库，如果我们可以看懂源代码我们可以学到很多很多技巧，包括算法的技术、容器和数据结构的技术以及语言本身的技巧。</p><h4 id="你應該具備的基礎"><a href="#你應該具備的基礎" class="headerlink" title="你應該具備的基礎"></a>你應該具備的基礎</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916162200162.png"></p><h4 id="標準庫版本"><a href="#標準庫版本" class="headerlink" title="標準庫版本"></a>標準庫版本</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/screencapture-github-steveLauwh-SGI-STL-2021-09-16-16_37_51.png"></p><h3 id="OOP-面向对象编程-vs-GP-泛型编程"><a href="#OOP-面向对象编程-vs-GP-泛型编程" class="headerlink" title="OOP 面向对象编程 vs. GP 泛型编程"></a>OOP 面向对象编程 vs. GP 泛型编程</h3><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916165044167.png"></p><p>整个 C++ 标准库并不是用面向对象设计出来的。面向对象需要类，然后要有继承关系，最重要的是还有一些扮演重要角色的虚函数，在早期的标准库版本它的继承关系非常少，所以比较容易看，现在我们来谈谈 OOP 和 GP 差别在哪里。</p><p>以 OOP 的理念来说数据需要结合方法，所以 <code>sort()</code> 函数被设计在 <code>list</code> 内如上图所示。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916165721581.png"></p><p>GP 的设计中 <code>vector</code> 和 <code>deque</code> 都没有 <code>sort()</code>，排序操作被单独设计为两个版本的全局函数：第一个版本参数为数据的头和尾，这样就可以定位出整个数据的范围；第二个版本则是增加了排序条件。GP 的理念是将数据和操作分开，那操作又是如何得到数据本身呢？</p><p>还记得第一节课讲的嘛？左边是容器 Containers，右边是算法 Algorithms，两者需要迭代器 Iterators 来联系。所以当我们要对这种容器做排序的时候，我们一般这么写：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">::<span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br></pre></td></tr></tbody></table></figure><p>调用 <code>sort()</code> 全局函数并且把它要操作的范围告诉它，调用容器的 <code>begin()</code> 和 <code>end()</code> 得到头尾两根泛化指针（或是迭代器），右手边的算法就可以开始排序了。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916170857569.png"></p><p><code>sort()</code> 函数可能非常复杂，不容易找到关键的地方。我们以最简单的取最大最小的源代码为例：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 <code>min()</code> 函数中接收 <code>a</code> 和 <code>b</code> 两个参数，找出谁比较小。它接收模板类型 <code>T</code> 的参数，当然类型必须相同，至于怎么比大小只要用 <code>&lt;</code> 操作符。如果传进来的是 <code>int</code> 整型，那么数字之间本来就可以比大小，语言已经规定好了。</p><p>如果传进来的是两个 <code>stone</code> 石头，这不是我 <code>min()</code> 需要关心的事情，石头怎么比大小由石头自己决定，具体来讲是重载 <code>&lt;</code> 操作符。因为这个思路，在标准库里操作符重载扮演非常重要的角色。</p><p>回来之前，为什么 <code>list</code> 不能使用 <code>::sort()</code> 排序？可以看到源码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="type">void</span> _introsort_loop(RandomAccessIterator first, RandomAccessIterator last, T*, Size depth_limit) {</span><br><span class="line">    ...</span><br><span class="line">    RandomAccessIterator cut = _unguarded_partition(first, last, <span class="built_in">T</span>(_median(*first, *(first + (last - first)/<span class="number">2</span>), *(last - <span class="number">1</span>))));    </span><br><span class="line">    ...    </span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><p>这里出现了 <code>first + (last - first)/2</code> 这样一个动作，只有随机访问迭代器 <code>RandomAccessIterator</code> 才能进行这样的加减乘除运算，而链表 <code>list</code> 是以指针串起一个个节点，它并不是连续的空间，所以它的迭代器不能够跳来跳去的，不能够 +5 亦或是 +10。这样看下来标准库的 <code>sort()</code> 算法需要一定的条件，而这个条件是链表 <code>list</code> 提供的迭代器所不能满足的。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210916173525585.png"></p><p>所谓算法，最终涉及的操作无非是比大小。查找一个东西，如果它既不大于也不小于，那就是等于咯。如果是排序，也就是把大大小小的位置移动，也都是在比大小。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">strLonger</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"max of zoo and hello:"</span> &lt;&lt; <span class="built_in">max</span>(<span class="built_in">string</span>(<span class="string">"zoo"</span>), <span class="built_in">string</span>(<span class="string">"hello"</span>)) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"longest of zoo and hello:"</span> &lt;&lt; <span class="built_in">max</span>(<span class="built_in">string</span>(<span class="string">"zoo"</span>), <span class="built_in">string</span>(<span class="string">"hello"</span>), strLonger) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">comp</span>(a, b)? b : a;  </span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><h3 id="操作符重载及模板基础"><a href="#操作符重载及模板基础" class="headerlink" title="操作符重载及模板基础"></a>操作符重载及模板基础</h3><h4 id="Operator-Overloading-操作符重載"><a href="#Operator-Overloading-操作符重載" class="headerlink" title="Operator Overloading 操作符重載"></a>Operator Overloading 操作符重載</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917102319890.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917102450587.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_list_iterator</span> {</span><br><span class="line">    <span class="keyword">typedef</span> _list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T 	value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> _list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    </span><br><span class="line">    link_type node;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> { <span class="keyword">return</span> (*node).data; }</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;()  <span class="type">const</span> { <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); }</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()			{ node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>; }</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>)		{ self tmp = *<span class="keyword">this</span>; ++*t; }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Templates-模板"><a href="#Templates-模板" class="headerlink" title="Templates 模板"></a>Templates 模板</h4><h4 id="Class-Templates-類模板"><a href="#Class-Templates-類模板" class="headerlink" title="Class Templates 類模板"></a>Class Templates 類模板</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917104119548.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(T r = <span class="number">0</span>, T i = <span class="number">0</span>): <span class="built_in">re</span>(r), <span class="built_in">im</span>(i) {}        </span><br><span class="line">    </span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);</span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> re; }</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> im; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T re, im;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> complex&amp; _doapl(complex*, <span class="type">const</span> complex&amp;);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">    <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">cc1</span><span class="params">(<span class="number">2.5</span>, <span class="number">1.5</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">2</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里复数的设计使用了模板，我们可以把这些部分先保留，这就形成了一个类模板。在使用时需要告诉编译器要把 <code>T</code> 替换为什么，上面的例子分别是 <code>double</code> 和 <code>int</code>。</p><h4 id="Function-Templates-函數模板"><a href="#Function-Templates-函數模板" class="headerlink" title="Function Templates 函數模板"></a>Function Templates 函數模板</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917105643673.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stone</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stone</span>(<span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> we): _w(w), _h(h), _weight(we) {}</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> stone&amp; rhs) <span class="type">const</span> { <span class="keyword">return</span> _weight &lt; rhs._weight; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _w, _h, _weight;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">stone <span class="title">r1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span>, <span class="title">r2</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span>, r3</span>;</span><br><span class="line">r3 = <span class="built_in">min</span>(r1, r2);</span><br></pre></td></tr></tbody></table></figure><p><code>min()</code> 这个写法更泛化，传进来的 <code>a</code> 和 <code>b</code> 都无所谓暂定为 <code>T</code>，而比大小则依赖于小于号 <code>&lt;</code>。</p><p>现在我有一个 <code>stone</code> 石头类，调用 <code>min()</code> 编译器会在调用时候对函数模版进行实参推导，把 <code>T</code> 推导为 <code>stone</code>。推出之后里面比大小会去看 <code>stone</code> 设计的时候有没有操作符重载，发现是以石头的重量比大小。</p><h4 id="Member-Templates-成員模板"><a href="#Member-Templates-成員模板" class="headerlink" title="Member Templates 成員模板"></a>Member Templates 成員模板</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917111411824.png"></p><h4 id="Specialization-特化"><a href="#Specialization-特化" class="headerlink" title="Specialization 特化"></a>Specialization 特化</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917111649689.png"></p><p>类模板又有一个独特的小东西：泛化和特化。GP 泛型编程也叫泛化，刚刚提的类模板里的 <code>T</code> 允许绑定任何东西，可是我们在设计类模板的时候通常会有这样的疑惑：我可能设计出非常泛化的版本，接收任何指令的 <code>T</code>，但设计者想到如果遇到某一个独特的 type 我有另外一种更棒的做法，这样我想要写出专属的独特做法该怎么办呢？</p><p>比如计算机图形学中绘制一条直线，数学上的直线方程是一种泛化；应用到电脑绘图里它的每一个点坐标都是整数，我们就可以用特殊的算法绘制直线，这就是特化。</p><p>C++ 为我们提供了这个方式，图中从语法上讲由于泛化类型 <code>class type</code> 已经被绑定为 <code>int</code> 了，于是就被抽空为 <code>template&lt;&gt;</code>。使用上如果为 <code>&lt;Foo&gt;</code> ，那么就执行泛化模版；若为 <code>int</code> 或 <code>double</code> 则执行相应的特化模板。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917160550577.png"></p><p>STL 标准库的源代码更有说服力：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt; <span class="keyword">struct</span> <span class="title class_">hash</span> {}</span><br><span class="line"></span><br><span class="line">_STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt; {</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">char</span> x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">short</span>&gt; {</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">short</span> x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt; {</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; {</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; {</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">long</span>&gt; {</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">long</span> x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; {</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这一部分正是哈希表/散列表的源代码。<code>_STL_TEMPLATE_NULL</code> 其实是一个 typedef 被转换为 <code>template&lt;&gt;</code>，表示我们要特化以下类型：</p><ul><li><code>char</code></li><li><code>short</code></li><li><code>unsigned short</code></li><li><code>int</code></li><li><code>unsigned int</code></li><li><code>long</code></li><li><code>unsigned long</code></li></ul><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917161613907.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">class</span> <span class="title class_">allocator</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocator&lt;void&gt; specialization</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span>&lt;<span class="type">void</span>&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span>		size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>	difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>*		pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> <span class="type">void</span>* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>		value_type;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rebind</span> { <span class="keyword">typedef</span> allocator&lt;_Tp1&gt; other; };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面是泛化的类模版 <code>allocator</code>，它可以接收任意的 <code>T</code>。但如果这个 <code>T</code> 为 <code>void</code> 则执行下面的特化模版。</p><h4 id="Partial-Specialization-偏特化"><a href="#Partial-Specialization-偏特化" class="headerlink" title="Partial Specialization 偏特化"></a>Partial Specialization 偏特化</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917162308050.png"></p><p>特化又被一些人称为全特化，全部、完整的特化，那么自然就有局部的特化：偏特化。</p><p>左侧可以看到 <code>vector</code> 有一个泛化版本，它接收两个模版参数 <code>T</code> 和 <code>Alloc</code>，下面的版本两个模版参数绑定其中一个为 <code>bool</code>。也就是说 <code>vector</code> 可以绑定任意类型去作为元素，但如果我指定 <code>T</code> 为 <code>bool</code>，标准库会有一个特别的设计，可能是效率更高，也可能是空间利用率变高。</p><p>另外还有一种范围的偏特化。<code>interator_traits</code> 有一个泛化版本接收任意参数，而下面如果接收的是指针，则有特殊的设计，但此时 <code>T</code> 是什么仍然不知道。同理另一个偏特化版本针对常量指针，又略有不同。</p><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>以 STL 的运用角度而言，空间配置器是最不需要介绍的东西，它总是隐藏在容器的背后默默工作付出；但若以 STL 的实现角度而言，第一个需要介绍的就是空间分配器，因为整个 STL 的操作对象都存放在容器之内，而容器需要一定的空间。</p><h4 id="operator-new-和-malloc"><a href="#operator-new-和-malloc" class="headerlink" title="operator new 和 malloc"></a>operator new 和 malloc</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210917172229186.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span></span></span><br><span class="line"><span class="function">    _<span class="title">THROW0</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// try to allocate size bytes</span></span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="keyword">while</span>((p == <span class="built_in">malloc</span>(size)) == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// buy more memory or return null pointer</span></span><br><span class="line">        <span class="function">_TRY_BEGIN</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(_callnewh(size) == <span class="number">0</span>)</span> <span class="keyword">break</span></span>;</span><br><span class="line">        _CATCH(std::bad_alloc) <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">        _CATCH_END;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// inline versions of the nothrow_t versions of new &amp; delete operators</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* _RTLENTRY <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span> &amp;)</span> </span>{</span><br><span class="line">    size = size ? size : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以观察到 <code>new</code> 调用了 <code>malloc</code> 分配内存，在磁盘中如图所示还包含许多额外开销 overhead：红色的边界 Cookie、灰色的 Debug 以及绿色的调整边界 Pad。这些细节会在内存管理章节详细讲解，我们现在只需要知道 <code>malloc</code> 给你的比你所要的大小还多不少。</p><h4 id="VC6-STL-对-allocator-的使用"><a href="#VC6-STL-对-allocator-的使用" class="headerlink" title="VC6 STL 对 allocator 的使用"></a>VC6 STL 对 allocator 的使用</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210924184235750.png"></p><p>上图是 VC6 中四个容器对 allocator 的使用，它们默认使用的分配器是 <code>allocator</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_A</span> = allocator&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector {</span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_A</span> = allocator&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> list {</span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_A</span> = allocator&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> deque {</span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span> = less&lt;_K&gt;,</span><br><span class="line">	<span class="keyword">class</span> _A = allocator&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> set {</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210924185219469.png"></p><p>分配器最重要的两个函数：<code>allocate()</code> 和 <code>deallocate()</code>。其中 <code>allocate()</code> 调用了 <code>_Allocate()</code>，深入定义看到调用的是 <code>::operator new</code>，<code>::operator delete</code> 也是同理，没有任何特殊的设计。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocator</span>(p, <span class="number">512</span>);</span><br></pre></td></tr></tbody></table></figure><p>它很难用的地方在于必须告诉它当初要了多少空间，而非我们平时直接释放指针，但容器使用它没有这方面的困扰。</p><h4 id="BC5-STL-对-allocator-的使用"><a href="#BC5-STL-对-allocator-的使用" class="headerlink" title="BC5 STL 对 allocator 的使用"></a>BC5 STL 对 allocator 的使用</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925075404870.png"></p><p>所有的容器第二个模版参数默认都是 <code>allocator&lt;T&gt;</code>，我们来看看有没有什么独特的设计。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925075704829.png"></p><p>和之前一样，这个 <code>allocator</code> 最重要的两个函数就是 <code>allocate()</code> 和 <code>deallocate()</code>，也是调用 <code>::operator new</code> 和 <code>::operator delete</code>，没有任何特殊的设计。</p><p>BC++ 比 VC 贴心的地方在于 <code>allocator</code> 的第二参数有默认值为 0，而 VC 没有默认值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocator</span>(p, <span class="number">512</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925080830869.png"></p><h4 id="G2-9-STL-对-allocator-的使用"><a href="#G2-9-STL-对-allocator-的使用" class="headerlink" title="G2.9 STL 对 allocator 的使用"></a>G2.9 STL 对 allocator 的使用</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925080936413.png"></p><p>虽然 G2.9 给出了合乎标准库规范的分配器设计，但在容器中使用的却是另一个分配器 <code>alloc</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span>* p = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">alloc::<span class="built_in">deallocate</span>(p, <span class="number">512</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925083430687.png"></p><p>这个特殊分配器 <code>alloc</code> 主要诉求是减少 <code>malloc</code> 次数从而减少额外开销 overhead。它设计了 16 条链表，每条链表负责特定大小的区块，大小以 8 的倍数增长（这也是为什么空间分配会有 Pad）。</p><h4 id="G4-9-STL-对-allocator-的使用"><a href="#G4-9-STL-对-allocator-的使用" class="headerlink" title="G4.9 STL 对 allocator 的使用"></a>G4.9 STL 对 allocator 的使用</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925151647456.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925151941560.png"></p><p>G4.9 分配器又回到了 VC/BC 的情况，使用 <code>::operator new</code> 和 <code>::operator delete</code>，没有任何特殊的设计。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925152638431.png"></p><p>之前 G2.9 的 <code>alloc</code> 依然在 G4.9 保留，名称换为了 <code>_pool_alloc</code>。如果想使用，用例如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;string, _gnu_cxx::_poll_alloc&lt;string&gt;&gt; vec;</span><br></pre></td></tr></tbody></table></figure><h3 id="容器之间的实现关系与分类"><a href="#容器之间的实现关系与分类" class="headerlink" title="容器之间的实现关系与分类"></a>容器之间的实现关系与分类</h3><p>现在我们来谈谈六大部件中的容器。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925160128071.png"></p><p>这张图在第一讲出现过，大家可以感受到各个容器大致的结构以及内存分配。</p><h4 id="容器，結構與分類"><a href="#容器，結構與分類" class="headerlink" title="容器，結構與分類"></a>容器，結構與分類</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925163213666.png"></p><p>上图让我们体会到不同容器之间的关联性。</p><p>这里的 <code>rb_tree</code> 与 <code>set</code>、<code>map</code> 是复合关系而非继承，所以我们可以说 <code>set</code> 或 <code>map</code> 里有一个红黑树 <code>rb_tree</code> 作为支撑来管理各个元素。同样的我们可以说 <code>heap</code> 或 <code>priority_queue</code> 里有一个 <code>vector</code> ，<code>stack</code> 或 <code>queue</code> 里头有一个 <code>deque</code>。</p><p>题外话，如果想在 Class A 中调用 Class B 的方法，我们可以选择继承或者拥有。在 G2.9 的标准库设计中尽量避免使用继承。</p><h4 id="容器及其迭代器"><a href="#容器及其迭代器" class="headerlink" title="容器及其迭代器"></a>容器及其迭代器</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925202619896.png"></p><h3 id="深度探索-list"><a href="#深度探索-list" class="headerlink" title="深度探索 list"></a>深度探索 list</h3><p>我们第一个要谈的容器是 list，因为它最具代表性。</p><h4 id="容器-list"><a href="#容器-list" class="headerlink" title="容器 list"></a>容器 list</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210925202757213.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list {</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> _list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">......    </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>list</code> 中包含一个 <code>_link_node</code> 类型的 <code>node</code> 指针，其中 <code>_link_node</code> 的定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_list_node</span> {</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以 <code>list</code> 本身是一个指针，指向结构体 <code>_list_node</code>，其中包含了数据本身 <code>data</code> 和双向链表的正/逆向指针 <code>next</code>、<code>prev</code>。可以观察到 G2.9 版本中两个指针都是 <code>void*</code> 类型，在程序中还要去转型，而后面的 G4.9 有了明显的改善。</p><p>在 <code>list</code> 中可以调用起点和终点，就是通过迭代器实现的。因为链表是非连续空间，所以迭代器不能够是指针：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_list_iterator</span> {</span><br><span class="line">    <span class="keyword">typedef</span> T	value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">......        </span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure><p>我们在第一节讲过前闭后开区间，这里环状双向链表的空白节点体现出的就是最后一个元素的下一个元素不属于容器本身，图中用灰色加以表示。</p><h4 id="list’s-iterator"><a href="#list’s-iterator" class="headerlink" title="list’s iterator"></a>list’s iterator</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927084846862.png"></p><p>迭代器里会有大量的操作符重载用于模拟指针，这里我们以 <code>operator++</code> 为例：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">    node = (link_type)((*node).next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>node</code> 被赋值为自己的下个节点 <code>next</code>，从而达到 <code>operator++</code> 的目的。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927085420980.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) {</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> (*node).data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em>prefix form</em> 和 <em>postfix form</em> 区别于一个实际上并没有用的实际参数，postfix 中的 <code>++*this</code> 调用了 prefix 的 <code>operator++</code>。需要注意到前向和后向 <code>self&amp;</code> 和 <code>self</code> 的不同，这是操作符重载向整数的致敬，整数怎么做那么我们就跟着怎么做：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">++++i;	<span class="comment">// ++(++i)</span></span><br><span class="line">i++++;	<span class="comment">// (i++)++ ERROR!</span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> ite = c.<span class="built_in">begin</span>();    </span><br><span class="line">++++ite; <span class="comment">// ++(++ite) </span></span><br><span class="line">ite++++; <span class="comment">// (ite++)++ ERROR!</span></span><br></pre></td></tr></tbody></table></figure><p>C++ 不允许后++两次，所以迭代器设计也遵循了这个原则。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927092407060.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> (*node).data;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">list&lt;Foo&gt;::iterator ite;</span><br><span class="line">...</span><br><span class="line">*ite;</span><br><span class="line">ite-&gt;<span class="built_in">method</span>();</span><br><span class="line"><span class="comment">// (*ite).method();</span></span><br><span class="line"><span class="comment">// (&amp;(*ite))-&gt;method();</span></span><br><span class="line"></span><br><span class="line">ite-&gt;field = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// (*ite).field = 7;</span></span><br><span class="line"><span class="comment">// (&amp;(*ite))-&gt;field = 7;</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927093708321.png"></p><p>新版本 G4.9 的迭代器设计中取消了三个参数（即 <code>T</code>、<code>&amp;T</code> 和 <code>*T</code>），只保留一个模版参数 <code>T</code>，传进去之后再定义指针和引用，可读性更高并且易于理解。不仅如此，新版节点的设计被分为 <code>_List_node_base</code> 与 <code>_List_node</code>，链表的指针指向自己而非空指针。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927094804904.png"></p><p>但是 G4.9 也把一些很单纯的东西变得很复杂。在 G2.9 只有 <code>list</code> 包含一个节点 <code>list_node</code>，而新版 <code>list</code> 继承于一个 <code>_List_base</code> 基类，其内置的一个 <code>_List_impl</code> 又继承了分配器，并且内含了 <code>_List_node_base</code>，非常复杂。</p><h3 id="迭代器设计原则"><a href="#迭代器设计原则" class="headerlink" title="迭代器设计原则"></a>迭代器设计原则</h3><h4 id="Iterator-需要遵守的原則"><a href="#Iterator-需要遵守的原則" class="headerlink" title="Iterator 需要遵守的原則"></a>Iterator 需要遵守的原則</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927101352083.png"></p><p>迭代器是容器与算法之间的桥梁，比如让算法知道它要处理的元素范围，通常我们会传入容器的 <code>begin()</code> 和 <code>end()</code> 两个迭代器交给算法去处理。并且算法需要知道迭代器有哪些性质，它需要进行一些最优的操作动作。</p><p>我们举 <code>rotate()</code> 算法为例，<code>rotate()</code> 调用了 <code>std::_rotate()</code>，其参数调用了 <code>_iterator_category()</code>。在图中第一步的萃取器调用了函数 <code>_iterator_category()</code> 想获得迭代器的分类，所谓分类指的是它移动的性质，有的迭代器只能勇往直前向前走；有的还可以后退；有的还可以跳着走……这就是分类，所以这里获取分类以便采取最优的操作策略。第二、三步还想知道它的 <code>difference_type</code> 和 <code>value_type</code>，比如我在容器中放入一百万个字符串 <code>string</code>，那么 <code>value_type</code> 就是 <code>string</code>；<code>difference_type</code> 则是表示两个迭代器的距离。</p><p>这张图可以看出算法 <code>rotate()</code> 需要知道 <code>iterator</code> 的三个 associated types，所以算法提出问题，迭代器需要有能力回答问题。这样的提问在 C++ 标准库开发过程中设计出五种，本例出现三种，另外两种未在标准库中被使用：<code>reference</code> 和 <code>pointer</code>。</p><h4 id="Iterator-必須提供的-5-種-associated-types"><a href="#Iterator-必須提供的-5-種-associated-types" class="headerlink" title="Iterator 必須提供的 5 種 associated types"></a>Iterator 必須提供的 5 種 associated types</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927105610255.png"></p><p>回到 G2.9 链表的迭代器设计：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_list_iterator</span> {</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag</span><br><span class="line">        			  iterator_category;	<span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">typedef</span> T		  value_type;			<span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr		  pointer;				<span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref		  reference;			<span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;		<span class="comment">// (5)</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>G4.9 也是同理，在迭代器这里必须 typedef 这五个 associated types。</p><p>值得注意的是 <code>difference_type</code> 使用的类型是 <code>ptr_diff</code>，在标准库的某一个头文件中由某个现成的类型比如 <code>unsign_long</code> 定义。而 <code>iterator_category</code> 的类型为 <code>bidirectional_iterator_tag</code>，表示双向。</p><p>回到算法这一端，模版迭代器以 <code>I</code> 表示，提问只需要 <code>I::...</code> 就可以获取想要的 type：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">algorithm</span><span class="params">(I first, I last)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    I::iterator_category</span><br><span class="line">    I::pointer</span><br><span class="line">    I::reference</span><br><span class="line">    I::value_type</span><br><span class="line">    I::difference</span><br><span class="line">    I::difference_type</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Traits-特性-特徵-特質"><a href="#Traits-特性-特徵-特質" class="headerlink" title="Traits 特性 特徵 特質"></a>Traits 特性 特徵 特質</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927151345295.png"></p><p>如果 Iterator 不是 class，例如自然指针，这时我们就需要萃取机 Iterator Traits 识别这几种情况。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927152003950.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> {</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial specialization</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; {</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; {</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, ...&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(...)</span> </span>{</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了解决自然指针的情况我们设置了中间层 Traits，由萃取机转问迭代器问题，利用偏特化语法分离出指针作回答。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927153322493.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> {</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// partial specialization for regular pointers</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; {</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T		  value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T*		  pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp;		  reference;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial specialization for regular const pointers</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; {</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T		  value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T*  pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T&amp;  reference;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果是指针，那么迭代器类型 <code>iterator_category</code> 是 <code>random_access_iterator_tag</code>。</p><h4 id="各式各樣的-Traits"><a href="#各式各樣的-Traits" class="headerlink" title="各式各樣的 Traits"></a>各式各樣的 Traits</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927160551596.png"></p><h3 id="深度探索-vector"><a href="#深度探索-vector" class="headerlink" title="深度探索 vector"></a>深度探索 vector</h3><h4 id="容器-vector"><a href="#容器-vector" class="headerlink" title="容器 vector"></a>容器 vector</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927160839254.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span>		size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>	difference_type;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	iterator end_of_storage;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{ <span class="keyword">return</span> start; }</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{ <span class="keyword">return</span> finish; }</span><br><span class="line">	</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>());</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>());</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	reference <span class="keyword">operator</span>[](size_type n) {</span><br><span class="line">		<span class="keyword">return</span> *(<span class="built_in">begin</span>() + n);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>vector</code> 通过三根指针控制整个容器，因此 <code>vector</code> 对象本身的大小就是 <code>start</code>、<code>end</code> 以及 <code>end_of_storage</code> 三根指针，在 32 位电脑上一个指针是 4 个字节，一共 12 字节。</p><p>我们还注意到只要是连续空间特性的容器，就必须提供 <code>operator[]</code> 的运算符重载。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927164037962.png"></p><p><code>push_back()</code> 先检查有没有空间放入新的元素，如果有空间就放入元素；否则调用 <code>insert_aux()</code> 函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(finish != end_of_storage) {  <span class="comment">// 尚有备用空间</span></span><br><span class="line">		<span class="built_in">construct</span>(finish, x);</span><br><span class="line">		++finish;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// 已无备用空间</span></span><br><span class="line">		<span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(interator position, <span class="type">const</span> T&amp; x) {</span><br><span class="line">	<span class="keyword">if</span>(finish != end_of_storage) {  <span class="comment">// 尚有备用空间</span></span><br><span class="line">		<span class="comment">// 在备用空间起始处构建一个元素，并以vector最后以最后一个元素值为其初值</span></span><br><span class="line">        <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">		++finish;</span><br><span class="line">		T x_copy = x;</span><br><span class="line">		<span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">		*position = x_copy;</span><br><span class="line">	} <span class="keyword">else</span> {  <span class="comment">// 已无备用空间</span></span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的疑惑是前面已经检查过是否有备用空间了，在函数中为何又一次重复判断呢？原因在于 <code>insert_aux()</code> 不仅被 <code>push_back()</code> 调用，还会被其他函数调用需要对备用空间做检查。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927173548762.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> {  <span class="comment">// 已无备用空间</span></span><br><span class="line">	<span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">	<span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 如果原大小为0，则分配1个元素大小</span></span><br><span class="line">	<span class="comment">// 如果原大小不为0，则分配原大小的两倍</span></span><br><span class="line">	</span><br><span class="line">	iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">	iterator new_finish = new_start;</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		...</span><br><span class="line">	} <span class="built_in">catch</span>(...) {</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 析构并释放原vector</span></span><br><span class="line">	<span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">deallocate</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调整迭代器指向新vector</span></span><br><span class="line">	start = new_start;</span><br><span class="line">	finish = new_finish;</span><br><span class="line">	end_of_storage = new_start + len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先调用 <code>size()</code> 记下原来的大小 <code>old_size</code>，然后判断 <code>old_size</code> 是否为 0：如果原大小为 0，则分配 1 个元素的大小；否则分配原大小的两倍，也就是我们之前提到的两倍成长。</p><p>假设 vector 现在有 8 个元素，放入第 9 个元素进去以两倍成长。于是空间大小由 8 变为 16，然后要把原来的元素拷贝到新的地方，再把第 9 个元素放入新空间中：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 将原vector的内容拷贝到新vector</span></span><br><span class="line">	new_start = <span class="built_in">uninitialized_copy</span>(position, start, new_start);</span><br><span class="line">	<span class="built_in">construct</span>(new_finish, x);  <span class="comment">// 为新元素设定初值x</span></span><br><span class="line">	++new_finish;</span><br><span class="line">	<span class="comment">// 将安插点的原内容也拷贝过来</span></span><br><span class="line">	new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">	</span><br><span class="line">} <span class="built_in">catch</span>(...) {</span><br><span class="line">	<span class="comment">// "commit or rollback" semantics</span></span><br><span class="line">	<span class="built_in">destory</span>(new_start, new_finish);</span><br><span class="line">	data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">	<span class="keyword">throw</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 <code>try</code> 语句中先调用 <code>uninitialized()</code> 将原来的内容拷贝到新的vector，后将新的元素设定初值。后面代码将安插点后的原内容也拷贝过来，这是因为这个函数可能会被 <code>insert(p, x)</code> 调用。</p><p>所以 vector 非常容易使用，概念也非常简单。但要注意一点，源代码表明每次扩容就会有大量元素拷贝移动，而元素的拷贝会调用拷贝构造函数，原先的空间也要一个个删除调用析构函数，在使用时需要注意这其中的成本问题。</p><h4 id="vector’s-iterator"><a href="#vector’s-iterator" class="headerlink" title="vector’s iterator"></a>vector’s iterator</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927181518803.png"></p><p>接下来我们看看 vector 的迭代器。</p><p>既然 vector 是连续空间，那么它的迭代器就不必设计的太复杂，前面的链表的迭代器就是特殊设计保证前后迭代。在 G2.9 使用指针实现了 vector 的迭代器：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;  <span class="comment">// T*</span></span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之前的 Traits 源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> {</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// partial specialization for regular pointers</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; {</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T		  value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T*		  pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp;		  reference;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial specialization for regular const pointers</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; {</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T		  value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T*  pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T&amp;  reference;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210927190401542.png"></p><p>相比 G2.9，G4.9 的设计更复杂抽象。<code>vector</code> 继承自 <code>_Vector_base</code>父类，父类内含一个 <code>_Vector_impl</code>，而 <code>_Vector_impl</code> 继承自 <code>std::allocator</code>。</p><p>这里比较有意思的是 <code>_Vector_impl</code> 是 <code>public</code> 继承，在面向对象的概念里强调“是一种”的关系，而这里的继承只是为了让 <code>_Vector_base</code> 能够用到分配器，所以应该使用 <code>private</code> 继承，在这里设计的并不理想。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004093111089.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004093516701.png"></p><p>G2.9 版非常单纯，新版曲曲折折绕了一大堆路，最终实现实际上和原来是一样的。结论是乱七八糟，舍近求远，何必如此？</p><h3 id="深度探索-array"><a href="#深度探索-array" class="headerlink" title="深度探索 array"></a>深度探索 array</h3><h4 id="容器-array"><a href="#容器-array" class="headerlink" title="容器 array"></a>容器 array</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004094605009.png"></p><p><code>array</code> 比起 <code>vector</code> 又更简单，因为它是 C 语言和 C++ 本身存在的数组，但是为什么要把这个东西包装成容器来用呢？如果不这么包装，<code>array</code> 就被摒弃于整个六大结构之外了，无法享受到算法、仿函数的便利。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span> {</span><br><span class="line">	<span class="keyword">typedef</span> _Tp			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp*		pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Support for zero-sized arrays mandatory</span></span><br><span class="line">	value_type _M_instance[_Nm? _Nm : <span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		<span class="keyword">return</span> <span class="title">iterator</span><span class="params">(&amp;_M_instance[<span class="number">0</span>])</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		<span class="keyword">return</span> <span class="title">iterator</span><span class="params">(&amp;_M_instance[_Nm])</span></span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用方法如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; myArray;</span><br><span class="line"><span class="keyword">auto</span> ite = myArray.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// array&lt;int, 10&gt;::iterator ite = ...</span></span><br><span class="line">ite += <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; *ite;</span><br></pre></td></tr></tbody></table></figure><p>相比其他容器的可扩充性，<code>array</code> 必须指定大小 <code>_Nm</code>，其数据为数组 <code>_M_instance[_Nm]</code>。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004100226806.png"></p><p>在 G4.9 版本数据类型为 <code>_AT_Type::_Type</code>，而 <code>_array_traits</code> 的源代码显示模版为 <code>_Tp</code>。如此复杂的设计真的有之前的版本好么，这里我要打一个问号。</p><h3 id="深度探索-forward-list"><a href="#深度探索-forward-list" class="headerlink" title="深度探索 forward_list"></a>深度探索 forward_list</h3><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004100812113.png"></p><p>之前已经介绍过双向链表了，设计思路上是完全一样的，就不再赘述。</p><h3 id="深度探索-deque"><a href="#深度探索-deque" class="headerlink" title="深度探索 deque"></a>深度探索 deque</h3><h4 id="容器-deque"><a href="#容器-deque" class="headerlink" title="容器 deque"></a>容器 deque</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004100948733.png"></p><p><code>deque</code> 的组织方式是分段然后串联起来：有许多连续空间的 <code>buffer</code> 存放真正的数据，由一个控制中心 <code>map</code> 来管理这些空间（底层实现使用的是 <code>vector</code>），连续是假象分段是事实。迭代器为了维持这种假象，走到边界（<code>first</code> 或 <code>last</code>）时必须有能力跳到下个节点/缓冲区 <code>node</code> 去，而 <code>cur</code> 表示正在指向的元素。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004102845916.png"></p><p>容器包含四个数据：首尾迭代器 <code>start</code>、<code>finish</code>、控制中心指针 <code>map</code> 以及大小 <code>map_size</code>。因为控制中心底层由 <code>vector</code> 实现，如果向图中放置100万个元素，<code>map</code> 也会以两倍空间增长直至容量足够。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> pointer* map_pointer;	<span class="comment">// T**</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	map_pointer map;</span><br><span class="line">	size_type map_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">return</span> start</span>;</span><br><span class="line">	<span class="function">iterator <span class="title">finish</span><span class="params">()</span> <span class="keyword">return</span> finish</span>;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> finish - start</span>;</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="deque’s-iterator"><a href="#deque’s-iterator" class="headerlink" title="deque’s iterator"></a>deque’s iterator</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004105631641.png"></p><p>迭代器包含之前提到的四个指针，大小为 16 个字节。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_deque_iterator</span> {</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;	<span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type;									<span class="comment">// (2)</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;									<span class="comment">// (3)</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;									<span class="comment">// (4)</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;								</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;						<span class="comment">// (5)</span></span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _deque_iterator self;</span><br><span class="line"></span><br><span class="line">	T* cur;</span><br><span class="line">	T* first;</span><br><span class="line">	T* last;</span><br><span class="line">	map_pointer node;</span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这里的 <code>BufSiz</code> 用于计算缓冲区可以容纳多少元素，如果不为 0 则由使用者自己传入 <code>n</code> 设置；否则看看元素多大：如果元素大于 512 字节，它就让一个缓冲区只放一个元素；如果元素小于 512，那么一个缓冲区放 <code>512/value_type</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> _deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz) {</span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">0</span>? n : (sz &lt; <span class="number">512</span>? <span class="built_in">size_t</span>(<span class="number">512</span> / sz): <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="deque-lt-T-gt-insert"><a href="#deque-lt-T-gt-insert" class="headerlink" title="deque<T>::insert()"></a>deque&lt;T&gt;::insert()</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004111906773.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在position处安插一个元素，其值为x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) {	<span class="comment">// 如果安插点是deque最前端</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);					<span class="comment">// 交给push_front()做</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) {	<span class="comment">// 如果安插点是deque最尾端</span></span><br><span class="line">        <span class="built_in">push_back</span>(x);							<span class="comment">// 交给push_front()做</span></span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004113050415.png"></p><p>这里的巧妙之处在于 <code>deque</code> 可以判断从哪里插入是最优策略。在代码中首先判断 <code>index</code> 与前后之间的位置关系，如果头端移动元素较少则在头部插入第一个元素，然后到插入点之前全部前移；如果尾端移动元素较少则在尾部插入最后一个元素，插入点之后全部后移。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSiz&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type&amp; x) {</span><br><span class="line">	difference_type index = pos - start;	<span class="comment">// 安插点之前的元素个数</span></span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) {				<span class="comment">// 如果安插点之前的元素个数较少</span></span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());				<span class="comment">// 在最前端加入与第一元素同值的元素</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1);			<span class="comment">// 元素搬移</span></span><br><span class="line">    } <span class="keyword">else</span> {								<span class="comment">// 安插点之后的元素个数较少</span></span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());					<span class="comment">// 在尾端加入与最末元素同值的元素</span></span><br><span class="line">        ...</span><br><span class="line">		<span class="built_in">copy_backward</span>(pos, back2, back1)</span><br><span class="line">    }</span><br><span class="line">    *pos = x_copy;							<span class="comment">// 在安插点上设定新值</span></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="deque-如何模擬連續空間"><a href="#deque-如何模擬連續空間" class="headerlink" title="deque 如何模擬連續空間"></a>deque 如何模擬連續空間</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004153343297.png"></p><p>对于 <code>deque</code> 剩下一个主题是它怎么模拟连续空间。当然实现上依赖于迭代器的加加减减等等，它一定能够检查边界，跳到另一个缓冲区这些隐藏功能，让使用者不知不觉。</p><p><code>front()</code> 传回头元素，<code>back()</code> 传回 <code>finish</code> （最后一个元素的下一位置）倒退的前一个位置 <code>tmp</code>。而 <code>size()</code> 计算中的减法一定做了运算符重载，它要去看这两个迭代器中间有多少个缓冲区，再把缓冲区个数乘以缓冲区内元素的个数。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>[](size_type n) {</span><br><span class="line">    <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="keyword">return</span> *start</span>;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>{</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> finish - start</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> finish </span>== start;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004154545763.png"></p><p>这里的 <code>*</code> 是对迭代器取值 <code>cur</code>，<code>-&gt;</code> 借用了 <code>*</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">return</span> *cur;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br></pre></td></tr></tbody></table></figure><p>两个迭代器相减算出元素的思路如前面所述：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span> {</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.code - <span class="number">1</span>) <span class="comment">// 两个iterator之间的buffer总长度</span></span><br><span class="line">        + (cur - first)											<span class="comment">// 两个iterator自己的buffer长度</span></span><br><span class="line">        + (x.last - x.cur);										</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004155818960.png"></p><p>这里都是后加加调用前加加，后减减调用前减减。作为一个迭代器加加就是移到后一个元素去，所以 <code>cur</code> 指向后一个元素，此时判断是否到达了边界，若到达则跳转至下一节点的起点位置。减减同理，如果到达边界则跳转至前一节点的末尾：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>{</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first +</span><br><span class="line">           <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">    ++cur;					<span class="comment">// 切换至下一元素</span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) {		<span class="comment">// 如果抵达缓冲区尾端</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + <span class="number">1</span>); <span class="comment">// 就跳至下一节点（缓冲区）的起点</span></span><br><span class="line">        cur = first;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+++(<span class="type">int</span>) {</span><br><span class="line">	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--() {		</span><br><span class="line">    <span class="keyword">if</span> (cur == first) {		<span class="comment">// 如果目前在缓冲区首端</span></span><br><span class="line">        <span class="built_in">set_node</span>(node - <span class="number">1</span>); <span class="comment">// 就跳至前一节点（缓冲区）的最末端</span></span><br><span class="line">        cur = last;</span><br><span class="line">    }</span><br><span class="line">    --cur;					<span class="comment">// 往前移一元素</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>) {</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004155854034.png"></p><p>刚才的 <code>++</code>、<code>--</code> 都是移动一个位置，而 <code>deque</code> 号称是连续空间，所以应该可以移动 n 个位置而不是每次移动一个位置。通过判断计算完后 <code>offset</code> 是否还在同一个缓冲区，如果不在需要计算正确的缓冲区：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) {</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;=<span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()))</span><br><span class="line">        <span class="comment">// 目标位置在同一缓冲区内</span></span><br><span class="line">        cur += n;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 目标位置不在同一缓冲区内</span></span><br><span class="line">        difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">            										: -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 切换至正确的缓冲区</span></span><br><span class="line">    	<span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">        <span class="comment">// 切换至正确的元素</span></span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> {</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004155924506.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004160020239.png"></p><p>在 G4.9 版本设计结构同样相当复杂，容器由单一的类变为上图的复杂情况：<code>deque</code> 继承自一个基类 <code>_Deque_base</code>，而 <code>_Deque_base</code> 又包含了 <code>_Deque_impl</code>，这个 <code>_Deque_impl</code> 包含了迭代器 <code>_Deque_iterator</code> 并继承了分配器 <code>std::allocator</code>。</p><p>新版本不允许指派 buffer size 有好有坏，好处在于没必要让使用者知道这些复杂的事情；坏处则在于对于很清楚里面结构的人也许我可以调整缓冲区里面元素的个数，第三参数可以用于调试，而现在没有这个途径了。</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004160113973.png"></p><h4 id="容器-queue"><a href="#容器-queue" class="headerlink" title="容器 queue"></a>容器 queue</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004165153504.png"></p><p><code>queue</code> 的数据类型为 <code>Sequence</code>，底层容器就是 <code>deque</code>，我们只需要封装其中的一些功能就可以使用，调用 <code>c</code> 的功能函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue {</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;	<span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> c.<span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> c.<span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="keyword">return</span> c.<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> c.<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> <span class="keyword">return</span> c.<span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> c.<span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> c.<span class="title">psuh_back</span><span class="params">(x)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> c.<span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="容器-stack"><a href="#容器-stack" class="headerlink" title="容器 stack"></a>容器 stack</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004165228283.png"></p><p><code>stack</code> 也是一样的道理，源代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack {</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;	<span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> c.<span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> c.<span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span> <span class="keyword">return</span> c.<span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">return</span> c.<span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> c.<span class="title">psuh_back</span><span class="params">(x)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> c.<span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004171516603.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211004171604398.png"></p><h3 id="深度探索-RB-tree"><a href="#深度探索-RB-tree" class="headerlink" title="深度探索 RB-tree"></a>深度探索 RB-tree</h3><h4 id="容器-rb-tree"><a href="#容器-rb-tree" class="headerlink" title="容器 rb-tree"></a>容器 rb-tree</h4><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20211027101201781.png"></p><p>之前探讨的容器都是循序式容器，从这一章开始我们开始讨论关联式容器。关联式的容器非常有用，因为它查找和元素安插非常快，甚至可以把它想象为小型数据库。</p><p>关联式容器底层实现在标准库中使用的是红黑树和哈希表，许多容器在此基础上被封装。</p><h3 id="深度探索-set"><a href="#深度探索-set" class="headerlink" title="深度探索 set"></a>深度探索 set</h3><h3 id="深度探索-hashtable"><a href="#深度探索-hashtable" class="headerlink" title="深度探索 hashtable"></a>深度探索 hashtable</h3></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/c1beecdf.html" rel="bookmark">Infinite Dev Log</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/63b4255a.html" rel="bookmark">TEXTURES</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/a8dbb28c.html" rel="bookmark">Shader Abstraction and Uniforms</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Cpp/" rel="tag"># Cpp</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/a7618f6e.html" rel="prev" title="精心设计的双人乐园--It Takes Two"><i class="fa fa-chevron-left"></i> 精心设计的双人乐园--It Takes Two</a></div><div class="post-nav-item"><a href="/archives/f263fa3f.html" rel="next" title="未来信号空间站笔试总结">未来信号空间站笔试总结 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D"><span class="nav-number">2.</span> <span class="nav-text">开始之前</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E6%87%89%E5%85%B7%E5%82%99%E7%9A%84%E5%9F%BA%E7%A4%8E"><span class="nav-number">2.1.</span> <span class="nav-text">你應具備的基礎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E5%80%91%E7%9A%84%E7%9B%AE%E6%A8%99"><span class="nav-number">2.2.</span> <span class="nav-text">我們的目標</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-Standard-Library-vs-Standard-Template-Library"><span class="nav-number">2.3.</span> <span class="nav-text">C++ Standard Library vs. Standard Template Library</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%A8%99%E6%BA%96%E5%BA%AB%EF%BC%8C%E7%89%88%E6%9C%AC"><span class="nav-number">2.4.</span> <span class="nav-text">C++ 標準庫，版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%B6%B2%E9%A0%81%EF%BC%8CCPlusPlus-com"><span class="nav-number">2.5.</span> <span class="nav-text">重要網頁，CPlusPlus.com</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%B6%B2%E9%A0%81%EF%BC%8CCppReference-com"><span class="nav-number">2.6.</span> <span class="nav-text">重要網頁，CppReference.com</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%B6%B2%E9%A0%81%EF%BC%8Cgcc-gnu-org"><span class="nav-number">2.7.</span> <span class="nav-text">重要網頁，gcc.gnu.org</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B8%E7%9B%AE%E8%AA%8C"><span class="nav-number">2.8.</span> <span class="nav-text">書目誌</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.</span> <span class="nav-text">STL 体系结构基础介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#STL-%E5%85%AD%E5%A4%A7%E9%83%A8%E4%BB%B6"><span class="nav-number">3.1.</span> <span class="nav-text">STL 六大部件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL-%E5%85%AD%E5%A4%A7%E9%83%A8%E4%BB%B6%E9%97%9C%E4%BF%82"><span class="nav-number">3.2.</span> <span class="nav-text">STL 六大部件關係</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A4%87%E9%9B%9C%E5%BA%A6%EF%BC%8CComplexity%EF%BC%8CBig-oh"><span class="nav-number">3.3.</span> <span class="nav-text">複雜度，Complexity，Big-oh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E5%89%8D%E9%96%89%E5%BE%8C%E9%96%8B%E2%80%9D%E5%8D%80%E9%96%93"><span class="nav-number">3.4.</span> <span class="nav-text">“前閉後開”區間</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#range-based-for-statement-since-C-11"><span class="nav-number">3.5.</span> <span class="nav-text">range-based for statement (since C++11)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#auto-keyword"><span class="nav-number">3.6.</span> <span class="nav-text">auto keyword</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">容器与各种测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-%E7%B5%90%E6%A7%8B%E8%88%87%E5%88%86%E9%A1%9E"><span class="nav-number">4.1.</span> <span class="nav-text">容器-結構與分類</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Sequence-Containers"><span class="nav-number">4.1.1.</span> <span class="nav-text">Sequence Containers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Associative-Containers"><span class="nav-number">4.1.2.</span> <span class="nav-text">Associative Containers</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%AC%E8%A9%A6%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.2.</span> <span class="nav-text">測試程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-array"><span class="nav-number">4.3.</span> <span class="nav-text">使用容器 array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-vector"><span class="nav-number">4.4.</span> <span class="nav-text">使用容器 vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-list"><span class="nav-number">4.5.</span> <span class="nav-text">使用容器 list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-forward-list"><span class="nav-number">4.6.</span> <span class="nav-text">使用容器 forward_list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-deque"><span class="nav-number">4.7.</span> <span class="nav-text">使用容器 deque</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-stack"><span class="nav-number">4.8.</span> <span class="nav-text">使用容器 stack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-queue"><span class="nav-number">4.9.</span> <span class="nav-text">使用容器 queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-multist"><span class="nav-number">4.10.</span> <span class="nav-text">使用容器 multist</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-multimap"><span class="nav-number">4.11.</span> <span class="nav-text">使用容器 multimap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-unordered-multiset"><span class="nav-number">4.12.</span> <span class="nav-text">使用容器 unordered_multiset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-unordered-multimap"><span class="nav-number">4.13.</span> <span class="nav-text">使用容器 unordered_multimap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-set"><span class="nav-number">4.14.</span> <span class="nav-text">使用容器 set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-map"><span class="nav-number">4.15.</span> <span class="nav-text">使用容器 map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-unordered-set"><span class="nav-number">4.16.</span> <span class="nav-text">使用容器 unordered_set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-unordered-map"><span class="nav-number">4.17.</span> <span class="nav-text">使用容器 unordered_map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%86%E9%85%8D%E5%99%A8-allocator"><span class="nav-number">4.18.</span> <span class="nav-text">使用分配器 allocator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E5%B8%83"><span class="nav-number">5.</span> <span class="nav-text">源代码分布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E6%87%89%E8%A9%B2%E5%85%B7%E5%82%99%E7%9A%84%E5%9F%BA%E7%A4%8E"><span class="nav-number">5.1.</span> <span class="nav-text">你應該具備的基礎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%99%E6%BA%96%E5%BA%AB%E7%89%88%E6%9C%AC"><span class="nav-number">5.2.</span> <span class="nav-text">標準庫版本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOP-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-vs-GP-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">OOP 面向对象编程 vs. GP 泛型编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8A%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80"><span class="nav-number">7.</span> <span class="nav-text">操作符重载及模板基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Operator-Overloading-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">Operator Overloading 操作符重載</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Templates-%E6%A8%A1%E6%9D%BF"><span class="nav-number">7.2.</span> <span class="nav-text">Templates 模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-Templates-%E9%A1%9E%E6%A8%A1%E6%9D%BF"><span class="nav-number">7.3.</span> <span class="nav-text">Class Templates 類模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-Templates-%E5%87%BD%E6%95%B8%E6%A8%A1%E6%9D%BF"><span class="nav-number">7.4.</span> <span class="nav-text">Function Templates 函數模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Member-Templates-%E6%88%90%E5%93%A1%E6%A8%A1%E6%9D%BF"><span class="nav-number">7.5.</span> <span class="nav-text">Member Templates 成員模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Specialization-%E7%89%B9%E5%8C%96"><span class="nav-number">7.6.</span> <span class="nav-text">Specialization 特化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Partial-Specialization-%E5%81%8F%E7%89%B9%E5%8C%96"><span class="nav-number">7.7.</span> <span class="nav-text">Partial Specialization 偏特化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">分配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#operator-new-%E5%92%8C-malloc"><span class="nav-number">8.1.</span> <span class="nav-text">operator new 和 malloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VC6-STL-%E5%AF%B9-allocator-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.2.</span> <span class="nav-text">VC6 STL 对 allocator 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BC5-STL-%E5%AF%B9-allocator-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.3.</span> <span class="nav-text">BC5 STL 对 allocator 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G2-9-STL-%E5%AF%B9-allocator-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.4.</span> <span class="nav-text">G2.9 STL 对 allocator 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G4-9-STL-%E5%AF%B9-allocator-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.5.</span> <span class="nav-text">G4.9 STL 对 allocator 的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">9.</span> <span class="nav-text">容器之间的实现关系与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%EF%BC%8C%E7%B5%90%E6%A7%8B%E8%88%87%E5%88%86%E9%A1%9E"><span class="nav-number">9.1.</span> <span class="nav-text">容器，結構與分類</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">9.2.</span> <span class="nav-text">容器及其迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-list"><span class="nav-number">10.</span> <span class="nav-text">深度探索 list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-list"><span class="nav-number">10.1.</span> <span class="nav-text">容器 list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E2%80%99s-iterator"><span class="nav-number">10.2.</span> <span class="nav-text">list’s iterator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">11.</span> <span class="nav-text">迭代器设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator-%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E5%8E%9F%E5%89%87"><span class="nav-number">11.1.</span> <span class="nav-text">Iterator 需要遵守的原則</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator-%E5%BF%85%E9%A0%88%E6%8F%90%E4%BE%9B%E7%9A%84-5-%E7%A8%AE-associated-types"><span class="nav-number">11.2.</span> <span class="nav-text">Iterator 必須提供的 5 種 associated types</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Traits-%E7%89%B9%E6%80%A7-%E7%89%B9%E5%BE%B5-%E7%89%B9%E8%B3%AA"><span class="nav-number">11.3.</span> <span class="nav-text">Traits 特性 特徵 特質</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E5%BC%8F%E5%90%84%E6%A8%A3%E7%9A%84-Traits"><span class="nav-number">11.4.</span> <span class="nav-text">各式各樣的 Traits</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-vector"><span class="nav-number">12.</span> <span class="nav-text">深度探索 vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-vector"><span class="nav-number">12.1.</span> <span class="nav-text">容器 vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector%E2%80%99s-iterator"><span class="nav-number">12.2.</span> <span class="nav-text">vector’s iterator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-array"><span class="nav-number">13.</span> <span class="nav-text">深度探索 array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-array"><span class="nav-number">13.1.</span> <span class="nav-text">容器 array</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-forward-list"><span class="nav-number">14.</span> <span class="nav-text">深度探索 forward_list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-deque"><span class="nav-number">15.</span> <span class="nav-text">深度探索 deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-deque"><span class="nav-number">15.1.</span> <span class="nav-text">容器 deque</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque%E2%80%99s-iterator"><span class="nav-number">15.2.</span> <span class="nav-text">deque’s iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque-lt-T-gt-insert"><span class="nav-number">15.3.</span> <span class="nav-text">deque&lt;T&gt;::insert()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque-%E5%A6%82%E4%BD%95%E6%A8%A1%E6%93%AC%E9%80%A3%E7%BA%8C%E7%A9%BA%E9%96%93"><span class="nav-number">15.4.</span> <span class="nav-text">deque 如何模擬連續空間</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-queue"><span class="nav-number">15.5.</span> <span class="nav-text">容器 queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-stack"><span class="nav-number">15.6.</span> <span class="nav-text">容器 stack</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-RB-tree"><span class="nav-number">16.</span> <span class="nav-text">深度探索 RB-tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-rb-tree"><span class="nav-number">16.1.</span> <span class="nav-text">容器 rb-tree</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-set"><span class="nav-number">17.</span> <span class="nav-text">深度探索 set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-hashtable"><span class="nav-number">18.</span> <span class="nav-text">深度探索 hashtable</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://img.yousazoe.top/uPic/img/blog/icon/icon.jpeg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">279</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://img.yousazoe.top/js/twopeople1.js"></script><script src="https://img.yousazoe.top/js/zdog.dist.js"></script><script id="rendered-js" src="https://img.yousazoe.top/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><link rel="preconnect" href="https://www.netlify.com"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.1m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="js/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:inline"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="//img.yousazoe.top/js/three.min.js"></script><script defer="" src="//img.yousazoe.top/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script src="https://img.yousazoe.top/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/hijiki.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
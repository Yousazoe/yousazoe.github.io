<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><meta name="baidu-site-verification" content="slBbq5f8WxljPytW"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css"><link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//unpkg.com/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//unpkg.com/pace-js@1.2.4/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yousazoe.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="引言这是伪随机噪音系列教程的第二篇。这次我们会修改hash算法让他能在空间中创建任意的形状。"><meta property="og:type" content="article"><meta property="og:title" content="Hashing Space Hashing in an Arbitrary Grid"><meta property="og:url" content="https://yousazoe.top/archives/a3a6db15.html"><meta property="og:site_name" content="Fl0w3r"><meta property="og:description" content="引言这是伪随机噪音系列教程的第二篇。这次我们会修改hash算法让他能在空间中创建任意的形状。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tutorial-image-20220205161035131.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scale-normal.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scale-double.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scale-quarter-misalinged.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scale-quarter-aligned.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/domain-configuration.png"><meta property="og:image" content="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/hashing-space/grid-transformation/domain-rotation-y30.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/domain-rotation-x90.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/shape-rotated-y30.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/shape-transformed.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/displacement-inspector.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/displacement-game.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/transposing-matrix.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/uv-sphere.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/torus.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/shape-inspector.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scaled-normals-incorrect.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scaled-normals-correct.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/octahedron-plane.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/octahedron-folded-open.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/octahedron-closed.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/octahedron-sphere.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/uv-sphere-20220205165423884.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/instance-scale-inspector.png"><meta property="article:published_time" content="2022-02-05T08:09:09.000Z"><meta property="article:modified_time" content="2022-07-07T14:11:09.930Z"><meta property="article:author" content="Yousazoe"><meta property="article:tag" content="Game Develop"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tutorial-image-20220205161035131.jpg"><link rel="canonical" href="https://yousazoe.top/archives/a3a6db15.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>Hashing Space Hashing in an Arbitrary Grid | Fl0w3r</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Fl0w3r" type="application/atom+xml"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Fl0w3r</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">carpe diem</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Links</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>Photos</a></li><li class="menu-item menu-item-artitalk"><a href="/artitalk/" rel="section"><i class="fa fa-calendar fa-fw"></i>Artitalk</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-document"><a href="/docs/" rel="section"><i class="fas fa-book fa-fw"></i>Document</a></li><li class="menu-item menu-item-qexoadmin"><a href="https://blog-yousazoe-qexo.vercel.app/" rel="noopener" target="_blank"><i class="fa fa-database fa-fw"></i>QexoAdmin</a></li><li class="menu-item menu-item-gametracker"><a href="https://yousazoe.notion.site/yousazoe/b05999823bd14b57a7a6cd81fba1a1af?v=21c3398e0bdb429c9b8157b7bf12ff6a" rel="noopener" target="_blank"><i class="fas fa-trophy fa-fw"></i>GameTracker</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://yousazoe.top/archives/a3a6db15.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><meta itemprop="name" content="Yousazoe"><meta itemprop="description" content="done is better than perfect"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Fl0w3r"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Hashing Space Hashing in an Arbitrary Grid</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-02-05 16:09:09" itemprop="dateCreated datePublished" datetime="2022-02-05T16:09:09+08:00">2022-02-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-Game-Development/" itemprop="url" rel="index"><span itemprop="name">游戏开发 (Game Development)</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fas fa-pen"></i></span><span>29k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span>53 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/tutorial-image-20220205161035131.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这是伪随机噪音系列教程的第二篇。这次我们会修改hash算法让他能在空间中创建任意的形状。</p><span id="more"></span><ul><li>将Hash效果转换到3D空间中</li><li>创建各种形状的立体模型</li><li>手动制作向量化的Jobs</li><li>创建一个形状生成器job模板类</li></ul><blockquote><p>如果你觉得这篇教程不错,请去支持原作者：</p><ul><li><a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/hashing-space/">Pseudorandom Noise-Hashing Space</a></li></ul></blockquote><h3 id="网格变换-Grid-Transformation"><a href="#网格变换-Grid-Transformation" class="headerlink" title="网格变换(Grid Transformation)"></a>网格变换(Grid Transformation)</h3><p>在前一个教程里,我们通过Hash算法计算UV值后给对每一个采样点赋予了不同的颜色和位置,每一个采样点都拥有了自己的Hash值.在本教程中,我们将会用空间hash效果来替换原来的平面hash效果.让hash值的计算不依赖采样点,这样可以使hash的值,不影响最终的分辨率和所生成的形状.</p><h4 id="调整缩放-Changing-Scale"><a href="#调整缩放-Changing-Scale" class="headerlink" title="调整缩放(Changing Scale)"></a>调整缩放(Changing Scale)</h4><p>为了说明Hash算法的效果可以与分辨率解耦,让我们先把有效分辨率翻倍,在HashJob类的<code>Execute</code>方法中,在Eat之前将UV值翻倍.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//i = 32</span></span><br><span class="line">    <span class="comment">//v = 1/32 * 32 +0.00001f = 1</span></span><br><span class="line">    <span class="comment">//u = 32 - 32 * 1 - 32 / 2 = -16</span></span><br><span class="line">    <span class="comment">//v = 1 - 32 / 2 = -15</span></span><br><span class="line">    <span class="built_in">int</span> v = (<span class="built_in">int</span>)floor(invResolution * i + <span class="number">0.00001f</span>);</span><br><span class="line">    <span class="built_in">int</span> u = i - resolution * v - resolution / <span class="number">2</span>;</span><br><span class="line">    v -= resolution / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	u *= <span class="number">2</span>;</span><br><span class="line">	v *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	hashes[i] = hash.Eat(u).Eat(v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scale-normal.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scale-double.png"></p><p>翻倍UV坐标会得到一个不同的效果,但是看上去并没有本质上的不同.我们只是放大了hash效果的<strong>域(domain)</strong>,并且以两倍的速度让域移动以生成可视化的效果.我们还可以做缩小处理,比如像下面这样将坐标除以4.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">u /= <span class="number">4</span>;</span><br><span class="line">v /= <span class="number">4</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>来自特兹卡特的提醒</strong></p><p>域(domain)这个概念该怎么理解?</p><p>打个比方,整个Hash生成的可视化平面就如同一张带有花纹的无限大的桌面,但是我们只能通过一块方形的窗口,才能看到上面的花纹.这个窗口就是域.移动这个窗口的位置,就能看到桌面上不同地方的花纹,窗口的大小也就是我们能看到的范围的大小.</p></blockquote><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scale-quarter-misalinged.png"></p><p>这是同一个参数4x4采样所呈现的效果,看上去好像是我们降低了它的分辨率一样.但是实际上是由于整数除法在0附近四舍五入之后造成的结果,所以看上去图像就不规则和重复了.</p><p>这两个问题都可以通过这样的方法来解决,先将UV坐标先看做<strong>float</strong>类型,把计算结果标准化到[-0.5,0.5]之间,最后使用<code>floor</code>把<strong>float</strong>类型的计算结果转换成<strong>int</strong>.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//i = 128</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//vf = 1/32*128+0.00001f = 4.0f</span></span><br><span class="line">	<span class="built_in">float</span> vf = floor(invResolution * i + <span class="number">0.00001f</span>);</span><br><span class="line">    <span class="comment">//uf = 1/32*(128-32*4.0f+0.5f)-0.5f = 1/64-32/64 = -31/64</span></span><br><span class="line">	<span class="built_in">float</span> uf = invResolution * (i - resolution * vf + <span class="number">0.5f</span>) - <span class="number">0.5f</span>;</span><br><span class="line">    <span class="comment">//vf = 1/32*(4.0f+0.5f)-0.5f = 1/32*4.5f-0.5f = 9/64-32/64 = -23/64</span></span><br><span class="line">	vf = invResolution * (vf + <span class="number">0.5f</span>) - <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> u = (<span class="built_in">int</span>)floor(uf);</span><br><span class="line">	<span class="built_in">int</span> v = (<span class="built_in">int</span>)floor(vf);</span><br><span class="line"></span><br><span class="line">	hashes[i] = hash.Eat(u).Eat(v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了把坐标刻度转换成相同的,我们需要在<code>floor</code>之前先乘以我们当前所使用的分辨率(32),再除以4来达到缩小到1/4的效果.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//uf = -31/64*32/4=-31/8=-3.875=-4</span></span><br><span class="line"><span class="comment">//vf = -23/64*32/4=-23/8=-2.875=-3</span></span><br><span class="line"><span class="built_in">int</span> u = (<span class="built_in">int</span>)floor(uf * <span class="number">32f</span> / <span class="number">4f</span>);</span><br><span class="line"><span class="built_in">int</span> v = (<span class="built_in">int</span>)floor(vf * <span class="number">32f</span> / <span class="number">4f</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scale-quarter-aligned.png"></p><h4 id="域的变换-Domain-Transformation"><a href="#域的变换-Domain-Transformation" class="headerlink" title="域的变换(Domain Transformation)"></a>域的变换(Domain Transformation)</h4><p>现在要把域的硬编码型配置,改为动态型配置,而且不再局限于只能对域进行缩放,而是要把它当做一个普通的3D空间来看待,可以对其应用各种移动,旋转和缩放,就像变换游戏中的对象一样.不过我们并不能只靠Unity自带的Transform来完成这个功能,所以还需要制定一个SpaceTRS结构体,里面包含一组坐标变换所需的字段.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SpaceTRS</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> float3 translation, rotation, scale;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在HashVisualization类中添加一个SpaceTRS的字段并初始化,将<strong>scale</strong>设置为8,暂时用硬编码匹配当前的设置.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">SpaceTRS domain = <span class="keyword">new</span> SpaceTRS</span><br><span class="line">{</span><br><span class="line">	scale = <span class="number">8f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>为了使上面的序列化功能可以运行,我们需要在SpaceTRS类的头上加一个Attribute修饰符<strong>System.SerializeField</strong>.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SpaceTRS { … }</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/domain-configuration.png"></p><p>想要应用一个3D空间中的位移变换,或者把对象设置到某个点上,需要一个4x4的变换矩阵和一组向量(vector)数据进行乘法计算.添加一个返回<strong>float4x4</strong>的公共<code>get</code>方法.旋转参数必须是一个四元数.可以用Unity自带的四元数函数<code>quaternion.EulerZXY</code>来生成它,不过还需要使用<code>math.radians</code>函数把输入的数据先转换为弧度.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> float4x4 Matrix</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">get</span> { <span class="keyword">return</span> float4x4.TRS(translation, quaternion.EulerZXY(math.radians(rotation)), scale);}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为<strong>位移旋转缩放矩阵</strong>(变换矩阵)的第四行永远都是{0,0,0,1},所以我们可以缩减一下数据量,用一个<strong>float3x4</strong>的矩阵来代替.不过并没有这两种类型的矩阵的直接转换方式,我们需要调用<code>math.float3x4</code>来手动创建,把第四列的参数按照如下方式填入函数中,矩阵中这4列的命名是c0,c1,c2,c3.因为我们只需要前3个数据,所以只需调用xyz这个属性.</p><blockquote><p><strong>来自特兹卡特的提醒</strong></p><p>我翻译到这里发现这一堆内容纯属废话,当然原作者是把看教程的人当完全不懂的人一样来对待,才写得如此详细.</p><p>但是如果你连基本的<strong>3D空间变换</strong>都不懂就来看这里的内容,仅靠作者这点只言片语的描述来理解,纯属自己折磨自己,[点此链接](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started/07 Transformations/)先去学基本变换吧.</p></blockquote><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> float3x4 Matrix</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">get</span></span><br><span class="line">	{</span><br><span class="line">		float4x4 m = float4x4.TRS(</span><br><span class="line">			translation,</span><br><span class="line">			quaternion.EulerZXY(math.radians(rotation)),</span><br><span class="line">			scale);</span><br><span class="line">		<span class="keyword">return</span> math.float3x4(m.c0.xyz, m.c1.xyz, m.c2.xyz, m.c3.xyz);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用矩阵的数据-Applying-the-Matrix"><a href="#应用矩阵的数据-Applying-the-Matrix" class="headerlink" title="应用矩阵的数据(Applying the Matrix)"></a>应用矩阵的数据(Applying the Matrix)</h4><p>为了在<code>HashJob.Execute</code>中应用变换矩阵,我们必须得有一个<strong>float3</strong>的坐标数据.使用[-0.5,0.5]范围内的UV坐标来创建一个XZ平面上的坐标数据,然后使用XZ这两个分量来计算坐标的hash值.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">float</span> vf = floor(invResolution * i + <span class="number">0.00001f</span>);</span><br><span class="line">	<span class="built_in">float</span> uf = invResolution * (i - resolution * vf + <span class="number">0.5f</span>) - <span class="number">0.5f</span>;</span><br><span class="line">	vf = invResolution * (vf + <span class="number">0.5f</span>) - <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">	float3 p = float3(uf, <span class="number">0f</span>, vf);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> u = (<span class="built_in">int</span>)floor(p.x);</span><br><span class="line">	<span class="built_in">int</span> v = (<span class="built_in">int</span>)floor(p.z);</span><br><span class="line"></span><br><span class="line">	hashes[i] = hash.Eat(u).Eat(v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着增加一个<strong>float3x4</strong>类型的<strong>domainTRS</strong>的字段到job类中,然后在<code>Execute</code>中将矩阵和坐标点相乘.这个<code>mul</code>方法需要一个<strong>float4</strong>类型的数据而非<strong>float3</strong>类型,所以我们把<strong>float4</strong>的第四个数据设置为1,这个1最终会与矩阵的第四列相乘,而且并不会对最终数据产生任何影响,所以Burst编译器将会优化这个操作.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> float3x4 domainTRS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">	float3 p = mul(domainTRS, float4(uf, <span class="number">0f</span>, vf, <span class="number">1f</span>));</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你现在去看Burst编译器编译后的代码,你会发现我们的job不再会进行向量化优化.因为现在操作的对象是一个vector类型而不是一个值.现在先不管他,后面再处理.</p><p>为了应用这个域变换的效果,把<strong>domain.Matrix</strong>添加到<strong>HashJob</strong>的构造函数中.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HashJob</span><br><span class="line">{</span><br><span class="line">	hashes = hashes,</span><br><span class="line">	resolution = resolution,</span><br><span class="line">	invResolution = <span class="number">1f</span> / resolution,</span><br><span class="line">	hash = SmallXXHash.Seed(seed),</span><br><span class="line">	domainTRS = domain.Matrix</span><br><span class="line">}.ScheduleParallel(hashes.Length, resolution, <span class="literal">default</span>).Complete();</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/hashing-space/grid-transformation/domain-rotation-y30.png"></p><p>现在我们就可以移动,旋转,缩放这个域了.这里看到的效果就是经过移动,旋转和缩放后的.如果把这域向右移动,就会感觉到hash图像在向左移动,因为这个平面本身是固定不动的.同样的,旋转操作也会出现反向效果,增加缩放值会使图像变小.</p><h4 id="3D-Hashing"><a href="#3D-Hashing" class="headerlink" title="3D Hashing"></a>3D Hashing</h4><p>现在做好的空间变换功能可以在3D空间中运行,比如,在Y方向上移动这个显示范围,但是不会有任何的变化,因为我们的hash计算只依赖于X和Z轴.同样,如果你绕X轴旋转hash方块会拉长,从中心延伸到平面边缘.</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/domain-rotation-x90.png"></p><p>为了使3D的hash效果更加完善,我们需要将3个坐标都进行处理.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> u = (<span class="built_in">int</span>)floor(p.x);</span><br><span class="line"><span class="built_in">int</span> v = (<span class="built_in">int</span>)floor(p.y);</span><br><span class="line"><span class="built_in">int</span> w = (<span class="built_in">int</span>)floor(p.z);</span><br><span class="line"></span><br><span class="line">hashes[i] = hash.Eat(u).Eat(v).Eat(w);</span><br></pre></td></tr></tbody></table></figure><p>现在绕Y轴旋转也会产生hash正确的效果了,并且绕任一轴旋转90度还能看到一个方形的hash切片效果.</p><h3 id="采样形状-Sample-Shapes"><a href="#采样形状-Sample-Shapes" class="headerlink" title="采样形状(Sample Shapes)"></a>采样形状(Sample Shapes)</h3><p>鉴于我们有了一个3D的hash效果,就不在仅限于平面上操作它,我们可以创建其他的Job功能来制作任意的形状了.</p><h4 id="形状生成器-Shapes-Job"><a href="#形状生成器-Shapes-Job" class="headerlink" title="形状生成器(Shapes Job)"></a>形状生成器(Shapes Job)</h4><p>我们不需要创建许多不同版本的HashJob,而需要把创建hash形状的job和采样hash体积的功能分开.先建立一个静态类Shapes,目前只需要包含一个Job结构体,来生成平面型的采样点并保存在一个<strong>NativeArray</strong>结构中.对于域的变换操作并不是这里的工作,所以就只需要分辨率和分辨率倒数这两个数据.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">using Unity.Burst;</span><br><span class="line">using Unity.Collections;</span><br><span class="line">using Unity.Jobs;</span><br><span class="line">using Unity.Mathematics;</span><br><span class="line"></span><br><span class="line">using static Unity.Mathematics.math;</span><br><span class="line"></span><br><span class="line">public static class Shapes</span><br><span class="line">{</span><br><span class="line">	[BurstCompile(FloatPrecision.Standard, FloatMode.Fast, CompileSynchronously = true)]</span><br><span class="line">	public struct Job : IJobFor</span><br><span class="line">	{</span><br><span class="line">		[WriteOnly]</span><br><span class="line">		NativeArray&lt;float3&gt; positions;</span><br><span class="line"></span><br><span class="line">		public float resolution, invResolution;</span><br><span class="line"></span><br><span class="line">		public void Execute(int i)</span><br><span class="line">		{</span><br><span class="line">			float2 uv;</span><br><span class="line">			uv.y = floor(invResolution * i + 0.00001f);</span><br><span class="line">			uv.x = invResolution * (i - resolution * uv.y + 0.5f) - 0.5f;</span><br><span class="line">			uv.y = invResolution * (uv.y + 0.5f) - 0.5f;</span><br><span class="line"></span><br><span class="line">			positions[i] = float3(uv.x, 0f, uv.y);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>紧接着增加一个静态方法<code>ScheduleParallel</code>,用来负责Job的生成和调度,返回值是<strong>JobHandle</strong>.这个方法并不需要分辨率倒数这个参数,因为可以在内部自行计算.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Job : IJobFor</span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobHandle <span class="title">ScheduleParallel</span>(<span class="params">NativeArray&lt;float3&gt; positions, <span class="built_in">int</span> resolution, JobHandle dependency</span>)</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Job</span><br><span class="line">		{</span><br><span class="line">			positions = positions,</span><br><span class="line">			resolution = resolution,</span><br><span class="line">			invResolution = <span class="number">1f</span> / resolution</span><br><span class="line">		}.ScheduleParallel(positions.Length, resolution, dependency);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="生成位置点-Generating-Positions"><a href="#生成位置点-Generating-Positions" class="headerlink" title="生成位置点(Generating Positions)"></a>生成位置点(Generating Positions)</h4><p>我们将向HashJob加一些新的东西来处理位置点,添加一个Shader的注册ID(<strong>_Positions</strong>),一个NativeArray&lt;<strong>float3**&gt;和一个装位置点的</strong>ComputeBuffer**.并做好初始化和清理工作.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> hashesId = Shader.PropertyToID(<span class="string">"_Hashes"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> configId = Shader.PropertyToID(<span class="string">"_Config"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> positionsId = Shader.PropertyToID(<span class="string">"_Positions"</span>);</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">NativeArray&lt;<span class="built_in">uint</span>&gt; hashes;</span><br><span class="line"></span><br><span class="line">NativeArray&lt;float3&gt; positions;</span><br><span class="line"></span><br><span class="line">ComputeBuffer hashesBuffer, positionsBuffer;</span><br><span class="line"></span><br><span class="line">MaterialPropertyBlock propertyBlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">int</span> length = resolution * resolution;</span><br><span class="line">	hashes = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">uint</span>&gt;(length, Allocator.Persistent);</span><br><span class="line">	positions = <span class="keyword">new</span> NativeArray&lt;float3&gt;(length, Allocator.Persistent);</span><br><span class="line">	hashesBuffer = <span class="keyword">new</span> ComputeBuffer(length, <span class="number">4</span>);</span><br><span class="line">	positionsBuffer = <span class="keyword">new</span> ComputeBuffer(length, <span class="number">3</span> * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">{</span><br><span class="line">	hashes.Dispose();</span><br><span class="line">	positions.Dispose();</span><br><span class="line">	hashesBuffer.Release();</span><br><span class="line">	positionsBuffer.Release();</span><br><span class="line">	hashesBuffer = <span class="literal">null</span>;</span><br><span class="line">	positionsBuffer = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>OnEnable</code>中把Shape的创建操作放在Hash之前,再将生成的<strong>handle</strong>传给<strong>HashJob</strong>,因为位置点(<strong>positions</strong>)的数据必须先被处理,后续还需要把这个位置点(<strong>positions</strong>)的数据传给GPU.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">JobHandle handle = Shapes.Job.ScheduleParallel(positions, resolution, <span class="literal">default</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> HashJob</span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">}.ScheduleParallel(hashes.Length, resolution, handle).Complete();</span><br><span class="line"></span><br><span class="line">hashesBuffer.SetData(hashes);</span><br><span class="line">positionsBuffer.SetData(positions);</span><br><span class="line"></span><br><span class="line">propertyBlock ??= <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">propertyBlock.SetBuffer(hashesId, hashesBuffer);</span><br><span class="line">propertyBlock.SetBuffer(positionsId, positionsBuffer);</span><br></pre></td></tr></tbody></table></figure><p>修改对应的Shader代码,利用刚刚传进来的位置点数据,来代替之前的硬编码平面数据,这样就能用上垂直方向(Z轴)上的数据了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)</span></span><br><span class="line">	StructuredBuffer&lt;<span class="built_in">uint</span>&gt; _Hashes;</span><br><span class="line">	StructuredBuffer&lt;float3&gt; _Positions;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">float4 _Config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureProcedural</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)</span></span><br><span class="line">		<span class="comment">//float v = floor(_Config.y * unity_InstanceID + 0.00001);</span></span><br><span class="line">		<span class="comment">//float u = unity_InstanceID - _Config.x * v;</span></span><br><span class="line">		</span><br><span class="line">		unity_ObjectToWorld = <span class="number">0.0</span>;</span><br><span class="line">		unity_ObjectToWorld._m03_m13_m23_m33 = float4(</span><br><span class="line">			_Positions[unity_InstanceID],</span><br><span class="line">			<span class="number">1.0</span></span><br><span class="line">		);</span><br><span class="line">		unity_ObjectToWorld._m13 += _Config.z * ((<span class="number">1.0</span> / <span class="number">255.0</span>) * (_Hashes[unity_InstanceID] &gt;&gt; <span class="number">24</span>) - <span class="number">0.5</span>);</span><br><span class="line">		unity_ObjectToWorld._m00_m11_m22 = _Config.y;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用位置点作为输入-Using-Positions-as-Input"><a href="#使用位置点作为输入-Using-Positions-as-Input" class="headerlink" title="使用位置点作为输入(Using Positions as Input)"></a>使用位置点作为输入(Using Positions as Input)</h4><p>在HashJob添加一个<strong>positions</strong>字段来作为位置的输入,然后只需要查询到在GPU中生成好的数据就行了,而不是自己去算一个.然后对域应用这个坐标点作为变换.现在hash算法不再依赖采样分辨率,可以移除相关的数据和操作了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">ReadOnly</span>]</span><br><span class="line"><span class="keyword">public</span> NativeArray&lt;float3&gt; positions;</span><br><span class="line">		</span><br><span class="line">[<span class="meta">WriteOnly</span>]</span><br><span class="line"><span class="keyword">public</span> NativeArray&lt;<span class="built_in">uint</span>&gt; hashes;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public int resolution;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//public float invResolution;</span></span><br><span class="line">		</span><br><span class="line"><span class="keyword">public</span> SmallXXHash hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> float3x4 domainTRS;</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//float vf = floor(invResolution * i + 0.00001f);</span></span><br><span class="line">	<span class="comment">//float uf = invResolution * (i - resolution * vf + 0.5f) - 0.5f;</span></span><br><span class="line">	<span class="comment">//vf = invResolution * (vf + 0.5f) - 0.5f;</span></span><br><span class="line"></span><br><span class="line">	float3 p = mul(domainTRS, float4(positions[i], <span class="number">1f</span>));</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再修改<code>OnEable</code>中的相关位置.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HashJob</span><br><span class="line">{</span><br><span class="line">	positions = positions,</span><br><span class="line">	hashes = hashes,</span><br><span class="line">	<span class="comment">//resolution = resolution,</span></span><br><span class="line">	<span class="comment">//invResolution = 1f / resolution,</span></span><br><span class="line">	hash = SmallXXHash.Seed(seed),</span><br><span class="line">	domainTRS = domain.Matrix</span><br><span class="line">}.ScheduleParallel(hashes.Length, resolution, handle).Complete();</span><br></pre></td></tr></tbody></table></figure><p>现在我们依然可以看到可视化的Hash效果,不过现在是依靠两个Job功能在计算,而不是原来的一个.</p><h4 id="形状变换-Shape-Transformation"><a href="#形状变换-Shape-Transformation" class="headerlink" title="形状变换(Shape Transformation)"></a>形状变换(Shape Transformation)</h4><p>我们在采样时对域应用了变换,同样也能在生成形状时应用变换.在Shapes.Job中增加一个<strong>float3x4</strong>字段,然后在<code>Execute</code>函数中做如下操作来计算最终位置.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> float3x4 positionTRS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">	positions[i] = mul(positionTRS, float4(uv.x, <span class="number">0f</span>, uv.y, <span class="number">1f</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下就可以直接用Transform的矩阵数据来控制,并且可以很好的进行变换而不是被固定在原点上.为了让操作更加方便,添加一个<strong>float4x4</strong>参数到<code>ScheduleParallel</code>方法中,并提取出3x4的数据对Job进行初始化.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobHandle <span class="title">ScheduleParallel</span>(<span class="params">NativeArray&lt;float3&gt; positions, <span class="built_in">int</span> resolution, float4x4 trs, JobHandle dependency</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Job</span><br><span class="line">	{</span><br><span class="line">		positions = positions,</span><br><span class="line">		resolution = resolution,</span><br><span class="line">		invResolution = <span class="number">1f</span> / resolution,</span><br><span class="line">		positionTRS = float3x4(trs.c0.xyz, trs.c1.xyz, trs.c2.xyz, trs.c3.xyz)</span><br><span class="line">	}.ScheduleParallel(positions.Length, resolution, dependency);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>HashVisualization.OnEnable</code>函数中做调度操作时,就需要把<strong>local-to-world</strong>矩阵传递给形参.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">JobHandle handle = Shapes.Job.ScheduleParallel(positions, resolution, transform.localToWorldMatrix, <span class="literal">default</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/shape-rotated-y30.png"></p><p>现在进行变换操作时,形状效果就会做出相应的改变,至少会在进入PlayMode时改变一次.但是请注意看,每一个单独的cube现在还是轴对齐和未缩放状态.</p><blockquote><p>我们可以同时旋转和缩放整个图形吗?</p><p>可以,通过向GPU传入一个合适的矩阵,然后用Shader进行最终的计算就行了.但是如果传入的缩放值不是等比例的,就会出现一些问题,目前我们先假定缩放是等比例的.</p></blockquote><h4 id="更新位置-Updating-Positions"><a href="#更新位置-Updating-Positions" class="headerlink" title="更新位置(Updating Positions)"></a>更新位置(Updating Positions)</h4><p>为了让变换效果可以在PlayMode下运行,必须把Job功能从<code>OnEnable</code>转移到<code>Update</code>中,由于并不需要每一帧都更新数据,在HashVisualization添加一个<strong>bool</strong>字段<strong>isDirty</strong>来控制更新的频率,当可视化效果发生数据变化时(isDirty)才进行更新.因为在<code>OnEnable</code>被调用时总是需要更新,所以在这里把isDirty赋值为true.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> isDirty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">{</span><br><span class="line">	isDirty = <span class="literal">true</span>;</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>Update</code>中检查<strong>isDirty</strong>字段,如果为true就调用更新流程并且把它设置为false.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (isDirty)</span><br><span class="line">	{</span><br><span class="line">		isDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		JobHandle handle = Shapes.Job.ScheduleParallel(positions, resolution, transform.localToWorldMatrix, <span class="literal">default</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> HashJob</span><br><span class="line">		{</span><br><span class="line">			positions = positions,</span><br><span class="line">			hashes = hashes,</span><br><span class="line">			hash = SmallXXHash.Seed(seed),</span><br><span class="line">			domainTRS = domain.Matrix</span><br><span class="line">		}.ScheduleParallel(hashes.Length, resolution, handle).Complete();</span><br><span class="line"></span><br><span class="line">		hashesBuffer.SetData(hashes);</span><br><span class="line">		positionsBuffer.SetData(positions);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	Graphics.DrawMeshInstancedProcedural(…);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这就意味着我们不再需要在<code>OnEnable</code>中执行上面的工作了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">	<span class="comment">//JobHandle handle = Shapes.Job.ScheduleParallel(</span></span><br><span class="line">	<span class="comment">//	positions, resolution, transform.localToWorldMatrix, default</span></span><br><span class="line">	<span class="comment">//);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//new HashJob {</span></span><br><span class="line">	<span class="comment">//	…</span></span><br><span class="line">	<span class="comment">//}.ScheduleParallel(hashes.Length, resolution, handle).Complete();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//hashesBuffer.SetData(hashes);</span></span><br><span class="line">	<span class="comment">//positionsBuffer.SetData(positions);</span></span><br><span class="line"></span><br><span class="line">	propertyBlock ??= <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后在<code>Update</code>里,还要在(整体的)变换发生后刷新可视化效果,这一步是由<code>Transform.hasChanged</code>属性控制的,当变化发生后,它会自动被设置为true.但是它并不会被自动设置回false,所以需要在检测到变化发生后手动将它改回去.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDirty || transform.hasChanged)</span><br><span class="line">{</span><br><span class="line">	isDirty = <span class="literal">false</span>;</span><br><span class="line">	transform.hasChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在,在PlayMode中所有的数据变化都会被立即响应并绘制(包括对整体的3D变换),我们就可以方便地研究立体的hash(HashVolume)效果了.</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/shape-transformed.png"></p><h4 id="偏移-Displacement"><a href="#偏移-Displacement" class="headerlink" title="偏移(Displacement)"></a>偏移(Displacement)</h4><p>如果这个平面可以朝向任意方向,那我们基于hash计算所得到的偏移效果就应该取决于平面的法线而不是世界坐标系下的Y轴.一般来说单个采样点的位置是取决于整个形状样子的,但是有可能这个形状就根本不是一个平面,所以在这种情况下,每一个单独的采样点都必须有自己的移动规则.为了做到这个效果,我们先用一个<strong>displacement</strong>字段来替换掉<strong>verticalOffset</strong>,这样就能使采样点不再依赖分辨率,而是变成像是在世界坐标系下的单位.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//[SerializeField, Range(-2f, 2f)]</span></span><br><span class="line"><span class="comment">//float verticalOffset = 1f;</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField, Range(-0.5f, 0.5f)</span>]</span><br><span class="line"><span class="built_in">float</span> displacement = <span class="number">0.1f</span>;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">	</span><br><span class="line">	propertyBlock ??= <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">	propertyBlock.SetVector(configId, <span class="keyword">new</span> Vector4(resolution, <span class="number">1f</span> / resolution, displacement));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/displacement-inspector.png"></p><p>我们需要让采样点沿着形状的表面法向量移动,所以<code>Shapes.Job</code>得输出一个法线数据.在当前例子的情况下,XZ平面的法线方向就是垂直于这个平面向上.按照下面的方式修改代码.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Job : IJobFor</span><br><span class="line">{</span><br><span class="line">	[<span class="meta">WriteOnly</span>]</span><br><span class="line">	NativeArray&lt;float3&gt; positions, normals;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">float</span> resolution, invResolution;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> float3x4 positionTRS;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">	{</span><br><span class="line">		…</span><br><span class="line">		positions[i] = mul(positionTRS, float4(uv.x, <span class="number">0f</span>, uv.y, <span class="number">1f</span>));</span><br><span class="line">		normals[i] = normalize(mul(positionTRS, float4(<span class="number">0f</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>)));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobHandle <span class="title">ScheduleParallel</span>(<span class="params">NativeArray&lt;float3&gt; positions, NativeArray&lt;float3&gt; normals, <span class="built_in">int</span> resolution,float4x4 trs, JobHandle dependency</span>)</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Job</span><br><span class="line">		{</span><br><span class="line">			positions = positions,</span><br><span class="line">			normals = normals,</span><br><span class="line">			…</span><br><span class="line">		}.ScheduleParallel(positions.Length, resolution, dependency);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于这个偏移效果是在GPU上完成的,所以我们需要修改HashVisualization类,把法线数据发送到GPU,就像发送位置点数据.注册一个对应Shader的ID,设置<strong>normals</strong>和<strong>normalsBuffer</strong>.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> hashesId = Shader.PropertyToID(<span class="string">"_Hashes"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> positionsId = Shader.PropertyToID(<span class="string">"_Positions"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> normalsId = Shader.PropertyToID(<span class="string">"_Normals"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> configId = Shader.PropertyToID(<span class="string">"_Config"</span>);</span><br><span class="line">	</span><br><span class="line">…</span><br><span class="line">	</span><br><span class="line">NativeArray&lt;float3&gt; positions, normals;</span><br><span class="line"></span><br><span class="line">ComputeBuffer hashesBuffer, positionsBuffer, normalsBuffer;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">{</span><br><span class="line">	isDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> length = resolution * resolution;</span><br><span class="line">	hashes = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">uint</span>&gt;(length, Allocator.Persistent);</span><br><span class="line">	positions = <span class="keyword">new</span> NativeArray&lt;float3&gt;(length, Allocator.Persistent);</span><br><span class="line">	normals = <span class="keyword">new</span> NativeArray&lt;float3&gt;(length, Allocator.Persistent);</span><br><span class="line">	hashesBuffer = <span class="keyword">new</span> ComputeBuffer(length, <span class="number">4</span>);</span><br><span class="line">	positionsBuffer = <span class="keyword">new</span> ComputeBuffer(length, <span class="number">3</span> * <span class="number">4</span>);</span><br><span class="line">	normalsBuffer = <span class="keyword">new</span> ComputeBuffer(length, <span class="number">3</span> * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	propertyBlock ??= <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">	propertyBlock.SetBuffer(hashesId, hashesBuffer);</span><br><span class="line">	propertyBlock.SetBuffer(positionsId, positionsBuffer);</span><br><span class="line">	propertyBlock.SetBuffer(normalsId, normalsBuffer);</span><br><span class="line">	…</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">{</span><br><span class="line">	hashes.Dispose();</span><br><span class="line">	positions.Dispose();</span><br><span class="line">	normals.Dispose();</span><br><span class="line">	hashesBuffer.Release();</span><br><span class="line">	positionsBuffer.Release();</span><br><span class="line">	normalsBuffer.Release();</span><br><span class="line">	hashesBuffer = <span class="literal">null</span>;</span><br><span class="line">	positionsBuffer = <span class="literal">null</span>;</span><br><span class="line">	normalsBuffer = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>Update</code>中把法线数据传入Job,然后设置到<strong>normalsBuffer</strong>里.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">JobHandle handle = Shapes.Job.ScheduleParallel(positions, normals, resolution, transform.localToWorldMatrix, <span class="literal">default</span>);</span><br><span class="line">			</span><br><span class="line"><span class="keyword">new</span> HashJob</span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">}.ScheduleParallel(hashes.Length, resolution, handle).Complete();</span><br><span class="line"></span><br><span class="line">hashesBuffer.SetData(hashes);</span><br><span class="line">positionsBuffer.SetData(positions);</span><br><span class="line">normalsBuffer.SetData(normals);</span><br></pre></td></tr></tbody></table></figure><p>接着修改Shader代码,让采样点沿着法线移动而不是垂直移动.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)</span></span><br><span class="line">	StructuredBuffer&lt;<span class="built_in">uint</span>&gt; _Hashes;</span><br><span class="line">	StructuredBuffer&lt;float3&gt; _Positions, _Normals;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">float4 _Config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureProcedural</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)</span></span><br><span class="line">		unity_ObjectToWorld = <span class="number">0.0</span>;</span><br><span class="line">		unity_ObjectToWorld._m03_m13_m23_m33 = float4(</span><br><span class="line">			_Positions[unity_InstanceID],</span><br><span class="line">			<span class="number">1.0</span></span><br><span class="line">		);</span><br><span class="line">		unity_ObjectToWorld._m03_m13_m23 +=</span><br><span class="line">			(_Config.z * ((<span class="number">1.0</span> / <span class="number">255.0</span>) * (_Hashes[unity_InstanceID] &gt;&gt; <span class="number">24</span>) - <span class="number">0.5</span>)) *</span><br><span class="line">			_Normals[unity_InstanceID];</span><br><span class="line">		unity_ObjectToWorld._m00_m11_m22 = _Config.y;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/displacement-game.png"></p><h4 id="边界-Bounds"><a href="#边界-Bounds" class="headerlink" title="边界(Bounds)"></a>边界(Bounds)</h4><p>对Hash可视化效果的对象的变换也必须要同时匹配对应的边界.我们必须使用变换以后的坐标点来作为边界的中心点.但是边界的范围大小就比较复杂了,因为边界定义的是一个轴对称的立方体包围盒,而我们生成的形状对象是可以旋转和缩放,如果这个形状对象是另一个可视化对象的子对象,边界计算还会更加复杂.所以我们决定使用Transform类的<strong>lossyScale</strong>属性,获得它的绝对值并用<code>cmax</code>函数做处理,然后翻倍处理后的数据,再加上偏移数据,最后使用这个计算好的结果作为3个维度上的边界数据.虽然这并不是匹配的最紧密,但是这样的方式方便计算,并且已经够用了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Graphics.DrawMeshInstancedProcedural(</span><br><span class="line">	instanceMesh, <span class="number">0</span>, material,</span><br><span class="line">	<span class="keyword">new</span> Bounds(transform.position,float3(<span class="number">2f</span> * cmax(abs(transform.lossyScale)) + displacement)),</span><br><span class="line">	hashes.Length, propertyBlock</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>我们并不需要每一帧都重新计算边界,只需要在数据发生变化时才重新计算.所以用一个字段把他存起来方便更新操作.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Bounds bounds;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (isDirty || transform.hasChanged)</span><br><span class="line">	{</span><br><span class="line">		…</span><br><span class="line"></span><br><span class="line">		bounds = <span class="keyword">new</span> Bounds(transform.position, float3(<span class="number">2f</span> * cmax(abs(transform.lossyScale)) + displacement));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	Graphics.DrawMeshInstancedProcedural(instanceMesh, <span class="number">0</span>, material, bounds, hashes.Length, propertyBlock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="手动向量化-Manual-Vectorization"><a href="#手动向量化-Manual-Vectorization" class="headerlink" title="手动向量化(Manual Vectorization)"></a>手动向量化(Manual Vectorization)</h3><p>如前面所说,Job代码中的自动向量化在我们使用vector类型时就已经失效了.典型的可自动向量化是利用对<strong>float4</strong>或者<strong>int4</strong>等数据类型的打包计算代替对单个<strong>float</strong>或<strong>int</strong>类型的计算,也就是利用SIMD指令并行计算4个数据.不幸的是这个自动优化效果对于我们使用<strong>float3</strong>类型的位置和法线数据来说已经不起作用了.但是我们可以通过手动操作一下使向量化计算成为可能.</p><h4 id="向量化的Hash-Vectorized-Hash"><a href="#向量化的Hash-Vectorized-Hash" class="headerlink" title="向量化的Hash(Vectorized Hash)"></a>向量化的Hash(Vectorized Hash)</h4><p>我们的SmallXXHash在设计之初就考虑了向量化.为了完成手动向量化的功能,先复制一份SmallXXHash的代码并重新命名为SmallXXHash4,用这个新的类来对4个值参数进行向量化计算.此外还需要包含<strong>Mathematics</strong>库.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> SmallXXHash { … }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> SmallXXHash4 { … }</span><br></pre></td></tr></tbody></table></figure><p>在这个新类中需要用vector类型的数据替换掉所有的单值类型.由于没有byte型的vertor类型,就需要把对应的方法删掉,<strong>primeA</strong>在此类当中没有用,也一并删掉.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> SmallXXHash4</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const uint primeA = 0b10011110001101110111100110110001;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeB = <span class="number">0b10000101111010111100101001110111</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeC = <span class="number">0b11000010101100101010111000111101</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeD = <span class="number">0b00100111110101001110101100101111</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">uint</span> primeE = <span class="number">0b00010110010101100110011110110001</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">readonly</span> <span class="built_in">uint</span> accumulator;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SmallXXHash4</span>(<span class="params"><span class="built_in">uint</span> accumulator</span>)</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>.accumulator = accumulator;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">SmallXXHash4</span>(<span class="params"><span class="built_in">uint</span> accumulator</span>)</span> =&gt; <span class="keyword">new</span> SmallXXHash4(accumulator);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SmallXXHash4 <span class="title">Seed</span>(<span class="params"><span class="built_in">int</span> seed</span>)</span> =&gt; (<span class="built_in">uint</span>)seed + primeE;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="built_in">uint</span> <span class="title">RotateLeft</span>(<span class="params"><span class="built_in">uint</span> data, <span class="built_in">int</span> steps</span>)</span> =&gt; (data &lt;&lt; steps) | (data &gt;&gt; <span class="number">32</span> - steps);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SmallXXHash4 <span class="title">Eat</span>(<span class="params"><span class="built_in">int</span> data</span>)</span> =&gt; RotateLeft(accumulator + (<span class="built_in">uint</span>)data * primeC, <span class="number">17</span>) * primeD;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//public SmallXXHash Eat(byte data) =&gt;</span></span><br><span class="line">	<span class="comment">//	RotateLeft(accumulator + data * primeE, 11) * primeA;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">uint</span>(<span class="params">SmallXXHash4 hash</span>)</span> { … }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下一步,把所有的<strong>int</strong>和<strong>uint</strong>类型替换为<strong>int4</strong>和<strong>uint4</strong>.唯一不用改的就是<strong>steps</strong>参数,因为他必须是<strong>int</strong>类型.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">readonly</span> uint4 accumulator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SmallXXHash4</span>(<span class="params">uint4 accumulator</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>.accumulator = accumulator;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">SmallXXHash4</span>(<span class="params">uint4 accumulator</span>)</span> =&gt; <span class="keyword">new</span> SmallXXHash4(accumulator);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SmallXXHash4 <span class="title">Seed</span>(<span class="params">int4 seed</span>)</span> =&gt; (uint4)seed + primeE;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">static</span> uint4 <span class="title">RotateLeft</span>(<span class="params">uint4 data, <span class="built_in">int</span> steps</span>)</span> =&gt; (data &lt;&lt; steps) | (data &gt;&gt; <span class="number">32</span> - steps);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SmallXXHash4 <span class="title">Eat</span>(<span class="params">int4 data</span>)</span> =&gt; RotateLeft(accumulator + (uint4)data * primeC, <span class="number">17</span>) * primeD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">uint4</span>(<span class="params">SmallXXHash4 hash</span>)</span></span><br><span class="line">{</span><br><span class="line">	uint4 avalanche = hash.accumulator;</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样手动向量化工作就完成了.让我们添加一个隐式转换来方便地使用这个类的功能.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> SmallXXHash</span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">SmallXXHash4</span>(<span class="params">SmallXXHash hash</span>)</span> =&gt; <span class="keyword">new</span> SmallXXHash4(hash.accumulator);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>我们可以反过来转换这两个类型吗?</p><p>从单个值类型转换到向量化类型只需要简单的复制内部的值就行了,但是反过来需要把4个值变为一个,并没有直接的方法可以做到这一点,所以不行.</p></blockquote><h4 id="向量化的HashJob-Vectorized-Hash-Job"><a href="#向量化的HashJob-Vectorized-Hash-Job" class="headerlink" title="向量化的HashJob(Vectorized Hash Job)"></a>向量化的HashJob(Vectorized Hash Job)</h4><p>接下来,我们将对HashJob类进行向量化.先把hash的输入输出字段全部变成4合1模式的类型.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">WriteOnly</span>]</span><br><span class="line"><span class="keyword">public</span> NativeArray&lt;uint4&gt; hashes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SmallXXHash4 hash;</span><br></pre></td></tr></tbody></table></figure><p>我们还需要并行处理4个点的数据.4合1的坐标点数据可以被存储在一个float3x4的矩阵当中,其中每一列包含一组坐标点位置数据.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">ReadOnly</span>]</span><br><span class="line"><span class="keyword">public</span> NativeArray&lt;float3x4&gt; positions;</span><br></pre></td></tr></tbody></table></figure><p>然而,为了向量化计算,<code>Execute</code>函数需要为x,y,z三个轴向单独生成向量,而不是一个向量装一个点.我们可以通过生成一个位置矩阵的转置矩阵来获得需要的数据格式布局<strong>float4x3</strong>,接着我们就可以使用向量化的方式计算u,v,w.这里先暂时忽略域的变换操作.</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/transposing-matrix.png"></p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	float4x3 p = transpose(positions[i]);</span><br><span class="line"></span><br><span class="line">	int4 u = (int4)floor(p.c0);</span><br><span class="line">	int4 v = (int4)floor(p.c1);</span><br><span class="line">	int4 w = (int4)floor(p.c2);</span><br><span class="line"></span><br><span class="line">	hashes[i] = hash.Eat(u).Eat(v).Eat(w);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们把向量化的数据传给<code>Update</code>中的HashJob.因为已经有了所需的数据了,只需要把位置数据重新解释为带有4个<strong>float3</strong>类型的组合.NativeArray提供泛型方法<code>Reinterpret</code>用于直接转换,参数需要填入原始数据类型的总长度.由于这种组合方式的hash值数据长度已经变成了以前的1/4了,所以我们也要把长度除以4.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HashJob</span><br><span class="line">{</span><br><span class="line">	positions = positions.Reinterpret&lt;float3x4&gt;(<span class="number">3</span> * <span class="number">4</span>),</span><br><span class="line">	hashes = hashes.Reinterpret&lt;uint4&gt;(<span class="number">4</span>),</span><br><span class="line">	hash = SmallXXHash.Seed(seed),</span><br><span class="line">	domainTRS = domain.Matrix</span><br><span class="line">}.ScheduleParallel(hashes.Length / <span class="number">4</span>, resolution, handle).Complete();</span><br></pre></td></tr></tbody></table></figure><p>注意数组的长度必须能被4整除,否则就会出大问题.一定要确保分辨率是偶数.</p><h4 id="向量化的变换-Vectorized-Transformation"><a href="#向量化的变换-Vectorized-Transformation" class="headerlink" title="向量化的变换(Vectorized Transformation)"></a>向量化的变换(Vectorized Transformation)</h4><p>没有任何现成的数学方法可以让一个3x4和4x3的变换矩阵相乘.所以添加一个<code>TransformPositions</code>方法到HashJob类中自行计算.用这两个矩阵作为函数的参数,最后返回一个转换后的4x3-XYZ列矩阵.现在先让它返回一个未经变换的数据.在<code>Execute</code>中做如下操作.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">float4x3 <span class="title">TransformPositions</span>(<span class="params">float3x4 trs, float4x3 p</span>)</span> =&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	float4x3 p = TransformPositions(domainTRS, transpose(positions[i]));</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个变换计算是一个常规矩阵乘法,第四列的平移计算只是单纯的加法.从之前的矩阵乘法描述中我们可以得知,最后一部分是与常数1相乘,所以我们可以省略掉这部分计算.</p><p>因为位置数据矩阵(p)已经被向量化了,所以乘法是对它的整列进行计算,而不是对单个数据.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">float4x3 <span class="title">TransformPositions</span>(<span class="params">float3x4 trs, float4x3 p</span>)</span> =&gt; float4x3(</span><br><span class="line">	trs.c0.x * p.c0 + trs.c1.x * p.c1 + trs.c2.x * p.c2 + trs.c3.x,</span><br><span class="line">	trs.c0.y * p.c0 + trs.c1.y * p.c1 + trs.c2.y * p.c2 + trs.c3.y,</span><br><span class="line">	trs.c0.z * p.c0 + trs.c1.z * p.c1 + trs.c2.z * p.c2 + trs.c3.z</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>现在我们的可视化效果依然可以正常运行,唯一的变化是HashJob类已经被向量化改装了.不过Burst编译器诊断的结果任然显示并没有向量化,因为它不知道我们手动做了这个操作.汇编编译器会知道我们确实使用了SIMD指令集,将会并行生成4个hash值.</p><h4 id="向量化的形状生成-Vectorized-Shapes-Job"><a href="#向量化的形状生成-Vectorized-Shapes-Job" class="headerlink" title="向量化的形状生成(Vectorized Shapes Job)"></a>向量化的形状生成(Vectorized Shapes Job)</h4><p>最后轮到向量化<code>Shapes.Job</code>了.方法也是一样的.首先变<strong>positions</strong>和<strong>normals</strong>的数据类型为<strong>float3x4</strong>.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">WriteOnly</span>]</span><br><span class="line">NativeArray&lt;float3x4&gt; positions, normals;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobHandle <span class="title">ScheduleParallel</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	NativeArray&lt;float3x4&gt; positions,</span></span></span><br><span class="line"><span class="params"><span class="function">	NativeArray&lt;float3x4&gt; normals,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="built_in">int</span> resolution,</span></span></span><br><span class="line"><span class="params"><span class="function">	float4x4 trs,</span></span></span><br><span class="line"><span class="params"><span class="function">	JobHandle dependency</span>)</span> { … }</span><br></pre></td></tr></tbody></table></figure><p>在<code>Execute</code>,用一个4x2的列矩阵来对UV坐标进行向量化.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">float4x2 uv;</span><br><span class="line">uv.c1 = floor(invResolution * i + <span class="number">0.00001f</span>);</span><br><span class="line">uv.c0 = invResolution * (i - resolution * uv.c1 + <span class="number">0.5f</span>) - <span class="number">0.5f</span>;</span><br><span class="line">uv.c1 = invResolution * (uv.c1 + <span class="number">0.5f</span>) - <span class="number">0.5f</span>;</span><br></pre></td></tr></tbody></table></figure><p>我们必须用向量化的索引值来代替原来的单个索引值.用原索引乘以<strong>4f</strong>再加上<strong>float(0,1,2,3)</strong>.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">float4 i4 = <span class="number">4f</span> * i + float4(<span class="number">0f</span>, <span class="number">1f</span>, <span class="number">2f</span>, <span class="number">3f</span>);</span><br><span class="line">uv.c1 = floor(invResolution * i4 + <span class="number">0.00001f</span>);</span><br><span class="line">uv.c0 = invResolution * (i4 - resolution * uv.c1 + <span class="number">0.5f</span>) - <span class="number">0.5f</span>;</span><br></pre></td></tr></tbody></table></figure><p>下一步,我们还需要一个TRS变换矩阵,但是需要同时处理位置和法线数据.为了在一个函数里面完成两个功能,先把<code>TransformPositions</code>从HashJob里复制到Shapes.Job里,然后改名为<code>TransformVectors</code>,最后还需要一个默认为1的w分量,与位置数据相乘.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">float4x3 <span class="title">TransformVectors</span>(<span class="params">float3x4 trs, float4x3 p, <span class="built_in">float</span> w = <span class="number">1f</span></span>)</span> =&gt; float4x3(</span><br><span class="line">	trs.c0.x * p.c0 + trs.c1.x * p.c1 + trs.c2.x * p.c2 + trs.c3.x * w,</span><br><span class="line">	trs.c0.y * p.c0 + trs.c1.y * p.c1 + trs.c2.y * p.c2 + trs.c3.y * w,</span><br><span class="line">	trs.c0.z * p.c0 + trs.c1.z * p.c1 + trs.c2.z * p.c2 + trs.c3.z * w</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>在<code>Execute</code>中使用平面坐标生成一个4x3-XYZ-列矩阵,并对其应用TRS变换,然后转置这个结果使它可以被赋值到<strong>positions</strong>变量上进行输出.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">positions[i] = transpose(TransformVectors(positionTRS, float4x3(uv.c0, <span class="number">0f</span>, uv.c1)));</span><br></pre></td></tr></tbody></table></figure><p>用同样的方法对法线数据做处理,但是这次<code>TransformVectors</code>函数的第三个参数要填0,这样会忽略掉位移变换的结果.Burst编译器会优化掉所有与常数0相乘的代码.接下来标准化(normalize)法线数据,然后把它们存储到一个3x4的矩阵里面.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">float3x4 n = transpose(TransformVectors(positionTRS, float4x3(<span class="number">0f</span>, <span class="number">1f</span>, <span class="number">0f</span>), <span class="number">0f</span>));</span><br><span class="line">normals[i] = float3x4(normalize(n.c0), normalize(n.c1), normalize(n.c2), normalize(n.c3));</span><br></pre></td></tr></tbody></table></figure><h4 id="向量化的数组-Vectorized-Arrays"><a href="#向量化的数组-Vectorized-Arrays" class="headerlink" title="向量化的数组(Vectorized Arrays)"></a>向量化的数组(Vectorized Arrays)</h4><p>因为在两个Job功能里都需要向量化的数组,所以我们直接定义这样的数组类型而不要动态转换.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">NativeArray&lt;uint4&gt; hashes;</span><br><span class="line"></span><br><span class="line">NativeArray&lt;float3x4&gt; positions, normals;</span><br></pre></td></tr></tbody></table></figure><p>在<code>OnEnable</code>里创建数组和缓冲区之前,需要把长度除以4.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">{</span><br><span class="line">	isDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> length = resolution * resolution;</span><br><span class="line">	length /= <span class="number">4</span>;</span><br><span class="line">	hashes = <span class="keyword">new</span> NativeArray&lt;uint4&gt;(length, Allocator.Persistent);</span><br><span class="line">	positions = <span class="keyword">new</span> NativeArray&lt;float3x4&gt;(length, Allocator.Persistent);</span><br><span class="line">	normals = <span class="keyword">new</span> NativeArray&lt;float3x4&gt;(length, Allocator.Persistent);</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了匹配ComputeBuffer的大小,我们必须要把容量设置为之前的4倍.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">hashesBuffer = <span class="keyword">new</span> ComputeBuffer(length * <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">positionsBuffer = <span class="keyword">new</span> ComputeBuffer(length * <span class="number">4</span>, <span class="number">3</span> * <span class="number">4</span>);</span><br><span class="line">normalsBuffer = <span class="keyword">new</span> ComputeBuffer(length * <span class="number">4</span>, <span class="number">3</span> * <span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure><p>还需要把传入缓冲区的数据重新解释成对应的数据类型.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">hashesBuffer.SetData(hashes.Reinterpret&lt;<span class="built_in">uint</span>&gt;(<span class="number">4</span> * <span class="number">4</span>));</span><br><span class="line">positionsBuffer.SetData(positions.Reinterpret&lt;float3&gt;(<span class="number">3</span> * <span class="number">4</span> * <span class="number">4</span>));</span><br><span class="line">normalsBuffer.SetData(normals.Reinterpret&lt;float3&gt;(<span class="number">3</span> * <span class="number">4</span> * <span class="number">4</span>));</span><br></pre></td></tr></tbody></table></figure><blockquote><p>我们可以直接把向量化后的数据传入到ComputeBuffer中吗?</p><p>CPU和GPU对数据格式都有自己的解析方法,所以在某些时候会遇到数据错位的情况.所以我们必须确保传入ComputerBuffer的数据未被向量化.</p></blockquote><p>我们同样可以支持奇数分辨率.例如假设分辨率是3,那么初始化长度就是9,但是向量化之后的长度是2,只能容纳前8个数据.不过我们可以增加1个长度来容纳第9个数据,这就意味着我们还要增加4个位置,其中3个是冗余的,不过这多出来的数据是微不足道的开销.我们可以让向量化的方式匹配所有分辨率,只需要在<code>OnEnable</code>中处理一下奇偶问题.(length &amp; 1)等于0为偶数,等于1为奇数.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> length = resolution * resolution;</span><br><span class="line">length = length / <span class="number">4</span> + (length &amp; <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>在<code>Update</code>中,我们不再需要为HashJob的初始化重新解释数据了.还要修改一下调度时的数组长度,因为它已经在向量化中被重新计算了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HashJob</span><br><span class="line">{</span><br><span class="line">	positions = positions,</span><br><span class="line">	hashes = hashes,</span><br><span class="line">	hash = SmallXXHash.Seed(seed),</span><br><span class="line">	domainTRS = domain.Matrix</span><br><span class="line">}.ScheduleParallel(hashes.Length, resolution, handle).Complete();</span><br></pre></td></tr></tbody></table></figure><p>最后,为了正确地绘制实例,在<code>DrawMeshInstancedProcedural</code>传入分辨率的平方作为参数.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Graphics.DrawMeshInstancedProcedural(</span><br><span class="line">	instanceMesh, <span class="number">0</span>, material,</span><br><span class="line">	<span class="keyword">new</span> Bounds(</span><br><span class="line">		transform.position,</span><br><span class="line">		float3(<span class="number">2f</span> * cmax(transform.lossyScale) + displacement)</span><br><span class="line">	),</span><br><span class="line">	resolution * resolution, propertyBlock</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h3 id="更多的形状-More-Shapes"><a href="#更多的形状-More-Shapes" class="headerlink" title="更多的形状(More Shapes)"></a>更多的形状(More Shapes)</h3><p>现在两个Job功能都已经向量化了,下一步要制作两个可选的形状生成器.虽然可以创建额外的Job功能类来完成,但是大部分的代码结构都是一样的.所以我们选择用模板代码来写.</p><h4 id="平面结构-Plane-Struct"><a href="#平面结构-Plane-Struct" class="headerlink" title="平面结构(Plane Struct)"></a>平面结构(Plane Struct)</h4><p>为了支持更多的形状生成,我们把位置和法线生成功能提到更高一层上来,拿到Shapes类中.每一个不同的Shape都可以使用自己独特的方法来生成数据,但是我们准备将这个功能以UV为基础来实现.为了避免重复的编码,我们直接从<code>Job.Execute</code>中复制计算UV部分的代码,放到<strong>Shapes</strong>类里这个名叫<code>IndexTo4UV</code>的静态方法中.修改一下UV的范围,把后面的-0.5的代码删掉,让它从[-0.5,0.5]变为[0,1],</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Shapes</span></span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> float4x2 <span class="title">IndexTo4UV</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">float</span> resolution, <span class="built_in">float</span> invResolution</span>)</span></span><br><span class="line">	{</span><br><span class="line">		float4x2 uv;</span><br><span class="line">		float4 i4 = <span class="number">4f</span> * i + float4(<span class="number">0f</span>, <span class="number">1f</span>, <span class="number">2f</span>, <span class="number">3f</span>);</span><br><span class="line">		uv.c1 = floor(invResolution * i4 + <span class="number">0.00001f</span>);</span><br><span class="line">		uv.c0 = invResolution * (i4 - resolution * uv.c1 + <span class="number">0.5f</span>);</span><br><span class="line">		uv.c1 = invResolution * (uv.c1 + <span class="number">0.5f</span>);</span><br><span class="line">		<span class="keyword">return</span> uv;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每个形状(Shape)中唯一特别的东西是它们要如何设置自己的位置和法线数据.为了传递这些不同的数据,新建一个<strong>Point4</strong>的结构体来完成此任务,里面包含向量化的位置和法线字段.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Shapes</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">struct</span> Point4</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">public</span> float4x3 positions, normals;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从<code>Job.Execute</code>中提取生成平面的代码,新建一个<strong>Plane</strong>结构体,包含一个使用这段代码的函数<code>GetPoint4</code>,输入参数分别为索引,分辨率,分辨率倒数,返回值为<strong>Point4</strong>.因为上面修改过UV的范围,这里就得减去0.5来使得平面的中心点维持在原点.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Plane</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Point4 <span class="title">GetPoint4</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">float</span> resolution, <span class="built_in">float</span> invResolution</span>)</span></span><br><span class="line">	{</span><br><span class="line">		float4x2 uv = IndexTo4UV(i, resolution, invResolution);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Point4</span><br><span class="line">		{</span><br><span class="line">			positions = float4x3(uv.c0 - <span class="number">0.5f</span>, <span class="number">0f</span>, uv.c1 - <span class="number">0.5f</span>),</span><br><span class="line">			normals = float4x3(<span class="number">0f</span>, <span class="number">1f</span>, <span class="number">0f</span>)</span><br><span class="line">		};</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Plane</strong>结构体不包含任何字段,唯一的作用就是提供<code>GetPoint4</code>方法.我们可以在<code>Job.Execute</code>中使用**default(Plane)**来调用此方法,它将代替以前与平面相关的代码.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//float4x2 uv;</span></span><br><span class="line">	<span class="comment">//float4 i4 = 4f * i + float4(0f, 1f, 2f, 3f);</span></span><br><span class="line">	<span class="comment">//uv.c1 = floor(invResolution * i4 + 0.00001f);</span></span><br><span class="line">	<span class="comment">//uv.c0 = invResolution * (i4 - resolution * uv.c1 + 0.5f) - 0.5f;</span></span><br><span class="line">	<span class="comment">//uv.c1 = invResolution * (uv.c1 + 0.5f) - 0.5f;</span></span><br><span class="line">			</span><br><span class="line">	Point4 p = <span class="literal">default</span>(Plane).GetPoint4(i, resolution, invResolution);</span><br><span class="line"></span><br><span class="line">	positions[i] = transpose(TransformVectors(positionTRS, p.positions));</span><br><span class="line"></span><br><span class="line">	float3x4 n = transpose(TransformVectors(positionTRS, p.normals, <span class="number">0f</span>));</span><br><span class="line">	normals[i] = float3x4(normalize(n.c0), normalize(n.c1), normalize(n.c2), normalize(n.c3));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="形状的接口-Shape-Interface"><a href="#形状的接口-Shape-Interface" class="headerlink" title="形状的接口(Shape Interface)"></a>形状的接口(Shape Interface)</h4><p>现在的目标是,能使用不同的形状结构体来生成不同的形状.为了做出这样的泛型功能,我们需要做一个接口功能,来规定公共的方法和字段.</p><p>接口使用<strong>interface</strong>关键字来声明,约定俗成使用I作为名称前缀.因此我们将其命名为IShap,在里面仅声明一个<code>GetPoint4</code>函数名称,没有代码部分,以分号结束.接口里的成员默认访问类型是public,所以不需要访问修饰符.<strong>Plane</strong>需要继承于这个接口并实现其中的功能.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IShape</span></span><br><span class="line">{</span><br><span class="line">	<span class="function">Point4 <span class="title">GetPoint4</span> (<span class="params"><span class="built_in">int</span> i, <span class="built_in">float</span> resolution, <span class="built_in">float</span> invResolution</span>)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Plane : IShape</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Point4 <span class="title">GetPoint4</span> (<span class="params"><span class="built_in">int</span> i, <span class="built_in">float</span> resolution, <span class="built_in">float</span> invResolution</span>)</span> { … }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="泛型Job-Generic-Job"><a href="#泛型Job-Generic-Job" class="headerlink" title="泛型Job(Generic Job)"></a>泛型Job(Generic Job)</h4><p>下一步是把Job功能泛型化,将其转化为模板类型.我们将泛型类型参数写在尖括号中,并将其附加到Job的类型声明里.约定俗成,类型参数名称是一个字母,由于这个参数将表示一个形状的类型,让我们将其命名为S.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Job&lt;S&gt; : IJobFor { … }</span><br></pre></td></tr></tbody></table></figure><p>我们将通过两种方式来限制泛型<strong>S</strong>的类型.第一,我们希望它是一个<strong>struct</strong>类型.第二,它必须是<strong>IShape</strong>类型.通过使用<strong>where</strong>关键字来完成这个操作.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Job&lt;S&gt; : IJobFor <span class="keyword">where</span> S : <span class="keyword">struct</span>, IShape { … }</span><br></pre></td></tr></tbody></table></figure><p>现在我们就可以在<code>Execute</code>中使用这个泛型类型来代替硬编码了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	Point4 p = <span class="literal">default</span>(S).GetPoint4(i, resolution, invResolution);</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在就必须要在<code>ScheduleParallel</code>方法调用时明确指出Job的泛型类型,就如同我们创建<strong>NativeArray</strong>类型或者其他泛型对象那样.这里也应该是与Job的类型相同,我们任然传入类型S.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Job&lt;S&gt;</span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line">}.ScheduleParallel(positions.Length, resolution, dependency);</span><br></pre></td></tr></tbody></table></figure><p>最后,为了实现这个泛型功能,我们需要在<code>HashVisualization.Update</code>中写清楚形状的具体类型信息.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">JobHandle handle = Shapes.Job&lt;Shapes.Plane&gt;.ScheduleParallel(positions, normals, resolution, transform.localToWorldMatrix, <span class="literal">default</span>);</span><br></pre></td></tr></tbody></table></figure><p>请注意,这时在Burst编译器里面我们的类型信息变成了<strong>Shapes.Job`1[Shapes.Plane]而不是原来的Shapes.Job</strong>,其他的汇编代码与以前相同.</p><h4 id="球和环-Sphere-and-Torus"><a href="#球和环-Sphere-and-Torus" class="headerlink" title="球和环(Sphere and Torus)"></a>球和环(Sphere and Torus)</h4><p>现在就可以很方便的增加更多的形状生成器了.让我们再写两个,先从球体开始,可以从<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/">Mathematical Surfaces</a>教程中把代码复制过来使用.唯一不同的地方在于不同的UV范围,我们需要翻倍在sin和cos中的参数,还需要交换sin和cos的位置来计算<strong>s</strong>和<strong>c1</strong>.我们将半径设置为0.5以便使球体的直径与标准方块相同.</p><p>因为这是一个球体,所以我们可以直接使用位置点数据作为法线数据.不过向量的长度是0.5,然而这不是问题,因为在变换应用之后,会标准化这个数据.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Plane : IShape { … }</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Sphere : IShape</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Point4 <span class="title">GetPoint4</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">float</span> resolution, <span class="built_in">float</span> invResolution</span>)</span></span><br><span class="line">	{</span><br><span class="line">		float4x2 uv = IndexTo4UV(i, resolution, invResolution);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">float</span> r = <span class="number">0.5f</span>;</span><br><span class="line">		float4 s = r * sin(PI * uv.c1);</span><br><span class="line"></span><br><span class="line">		Point4 p;</span><br><span class="line">		p.positions.c0 = s * sin(<span class="number">2f</span> * PI * uv.c0);</span><br><span class="line">		p.positions.c1 = r * cos(PI * uv.c1);</span><br><span class="line">		p.positions.c2 = s * cos(<span class="number">2f</span> * PI * uv.c0);</span><br><span class="line">		p.normals = p.positions;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要使用这个球体形状来生成可视化效果,只需要在<code>HashVisualization.Update</code>中修改泛型参数类型.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">JobHandle handle = Shapes.Job&lt;Shapes.Sphere&gt;.ScheduleParallel(positions, normals, resolution, transform.localToWorldMatrix, <span class="literal">default</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/uv-sphere.png"></p><p>第二个形状做一个环,依然是从<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/">Mathematical Surfaces</a>教程中复制代码过来,并再次翻倍sin和cos中的参数.<strong>r1</strong>赋值0.375,<strong>r2</strong>赋值0.125.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Torus : IShape</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Point4 <span class="title">GetPoint4</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">float</span> resolution, <span class="built_in">float</span> invResolution</span>)</span></span><br><span class="line">	{</span><br><span class="line">		float4x2 uv = IndexTo4UV(i, resolution, invResolution);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">float</span> r1 = <span class="number">0.375f</span>;</span><br><span class="line">		<span class="built_in">float</span> r2 = <span class="number">0.125f</span>;</span><br><span class="line">		float4 s = r1 + r2 * cos(<span class="number">2f</span> * PI * uv.c1);</span><br><span class="line"></span><br><span class="line">		Point4 p;</span><br><span class="line">		p.positions.c0 = s * sin(<span class="number">2f</span> * PI * uv.c0);</span><br><span class="line">		p.positions.c1 = r2 * sin(<span class="number">2f</span> * PI * uv.c1);</span><br><span class="line">		p.positions.c2 = s * cos(<span class="number">2f</span> * PI * uv.c0);</span><br><span class="line">		p.normals = p.positions;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>环表面的法线要比球体稍微复杂一些,它们并不是指向形状的中心,而是指向环表面内部的中心环.这里我们并不需要担心重复的计算代码,因为Burst编译器会优化掉它.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">p.normals = p.positions;</span><br><span class="line">p.normals.c0 -= r1 * sin(<span class="number">2f</span> * PI * uv.c0);</span><br><span class="line">p.normals.c2 -= r1 * cos(<span class="number">2f</span> * PI * uv.c0);</span><br></pre></td></tr></tbody></table></figure><p>现在只需要换个类型数据就能画环了.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">JobHandle handle = Shapes.Job&lt;Shapes.Torus&gt;.ScheduleParallel(positions, normals, resolution, transform.localToWorldMatrix, <span class="literal">default</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/torus.png"></p><h4 id="可选形状-Selecting-Shapes"><a href="#可选形状-Selecting-Shapes" class="headerlink" title="可选形状(Selecting Shapes)"></a>可选形状(Selecting Shapes)</h4><p>为了让我们可以在Unity编辑器里面切换不同的形状.需要增加代码控制在调用<code>ScheduleParallel</code>方法时传入的类型数据.我们再次使用<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/">Mathematical Surfaces</a>教程中的方法,采用枚举选择和静态委托数组的方式.</p><p>在<strong>Shapes</strong>中添加一个<code>ScheduleDelegate</code>的委托方法来匹配<code>ScheduleParallel</code>方法.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> JobHandle <span class="title">ScheduleDelegate</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	NativeArray&lt;float3x4&gt; positions, NativeArray&lt;float3x4&gt; normals,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="built_in">int</span> resolution, float4x4 trs, JobHandle dependency</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p>哪些形状可以使用取决于<strong>HashVisualization</strong>类,所以我们需要添加一组枚举和对应它的静态数组,数组中是对应的代理函数.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Shape { Plane, Sphere, Torus }</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Shapes.ScheduleDelegate[] shapeJobs =</span><br><span class="line">{</span><br><span class="line">	Shapes.Job&lt;Shapes.Plane&gt;.ScheduleParallel,</span><br><span class="line">	Shapes.Job&lt;Shapes.Sphere&gt;.ScheduleParallel,</span><br><span class="line">	Shapes.Job&lt;Shapes.Torus&gt;.ScheduleParallel</span><br><span class="line">};</span><br><span class="line">	</span><br><span class="line">…</span><br><span class="line">	</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Shape shape;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/shape-inspector.png"></p><p>然后修改一下<code>Update</code>中对应的位置,让枚举值可以控制代理函数.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">JobHandle handle = shapeJobs[(<span class="built_in">int</span>)shape](positions, normals, resolution, transform.localToWorldMatrix, <span class="literal">default</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="处理法线-Transformed-Normals"><a href="#处理法线-Transformed-Normals" class="headerlink" title="处理法线(Transformed Normals)"></a>处理法线(Transformed Normals)</h4><p>目前看似差不多了,但是有一个地方还会出问题.就是对球体和环使用非对称的缩放.比如一个几乎扁平的球体,偏移的效果任然是从球体中心计算的,而不是球体表面.结果就是偏移效果过于扁了.</p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scaled-normals-incorrect.png"></p><p>这个问题出现的原因是非对称的缩放搞乱了法线方向.它们必须与一个不同的变换矩阵相乘.为了解决这个问题,需要在<code>Shapes.Job</code>中增加一个法线的变换矩阵来计算法线.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> float3x4 positionTRS, normalTRS;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">	float3x4 n = transpose(TransformVectors(normalTRS, p.normals, <span class="number">0f</span>));</span><br><span class="line">	…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了生成正确的表面法线,我们需要在<code>ScheduleParallel</code>函数中使用<code>transpose(inverse(trs))</code>计算TRS矩阵的逆矩阵的转置矩阵.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobHandle <span class="title">ScheduleParallel</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	NativeArray&lt;float3x4&gt; positions, NativeArray&lt;float3x4&gt; normals,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="built_in">int</span> resolution,	float4x4 trs, JobHandle dependency</span>)</span></span><br><span class="line">{</span><br><span class="line">	float4x4 tim = transpose(inverse(trs));</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Job&lt;S&gt;</span><br><span class="line">	{</span><br><span class="line">		…</span><br><span class="line">		positionTRS = float3x4(trs.c0.xyz, trs.c1.xyz, trs.c2.xyz, trs.c3.xyz),</span><br><span class="line">		normalTRS = float3x4(tim.c0.xyz, tim.c1.xyz, tim.c2.xyz, tim.c3.xyz)</span><br><span class="line">	}.ScheduleParallel(positions.Length, resolution, dependency);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/scaled-normals-correct.png"></p><h4 id="正八面结构的球体-Octahedron-Sphere"><a href="#正八面结构的球体-Octahedron-Sphere" class="headerlink" title="正八面结构的球体(Octahedron Sphere)"></a>正八面结构的球体(Octahedron Sphere)</h4><p>我们现在生成的球体被称为UV球体,它是由一圈一圈的环叠在一起而构成,并在这样的环在极点上会退化为点.点的分布会极度不均匀,在赤道附近稀疏,在极点附近密集.让我们采用另一种方式来生成—正八面体.</p><p>想要做一个正八面结构的球体,首先需要在圆点上生成一个八面体,然后标准化它上面所有的点.可以通过简单几步从[0,1]的UV坐标来生成.让我们先从中心点在原点的XY平面开始.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Sphere : IShape</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Point4 <span class="title">GetPoint4</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">float</span> resolution, <span class="built_in">float</span> invResolution</span>)</span></span><br><span class="line">	{</span><br><span class="line">		float4x2 uv = IndexTo4UV(i, resolution, invResolution);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//float r = 0.5f;</span></span><br><span class="line">		<span class="comment">//float4 s = r * sin(PI * uv.c1);</span></span><br><span class="line"></span><br><span class="line">		Point4 p;</span><br><span class="line">		p.positions.c0 = uv.c0 - <span class="number">0.5f</span>;</span><br><span class="line">		p.positions.c1 = uv.c1 - <span class="number">0.5f</span>;</span><br><span class="line">		p.positions.c2 = <span class="number">0f</span>;</span><br><span class="line">		p.normals = p.positions;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/octahedron-plane.png"></p><p>第二步是沿着Z方向移动采样点来创建切型面,把z设置为0.5,然后依次减去x和z的绝对值.这样就生成了一个八面体的一半.另一半是开放的.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">p.positions.c2 = <span class="number">0.5f</span> - abs(p.positions.c0) - abs(p.positions.c1);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/octahedron-folded-open.png"></p><p>在Z轴的正方向八面体已经完成了.为了在负方向上完成整个图形,需要一个Z负轴上的偏移量.确保最小值为0来使正方向不受影响.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">p.positions.c2 = <span class="number">0.5f</span> - abs(p.positions.c0) - abs(p.positions.c1);</span><br><span class="line">float4 offset = max(-p.positions.c2, <span class="number">0f</span>);</span><br></pre></td></tr></tbody></table></figure><p>我们需要分别在X,Y轴上加减这个变量.比如X轴是负,就加,反之则减.Y轴也是一样.可以用<code>select</code>函数来方便的完成这个操作.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">float4 offset = max(-p.positions.c2, <span class="number">0f</span>);</span><br><span class="line">p.positions.c0 += <span class="keyword">select</span>(-offset, offset, p.positions.c0 &lt; <span class="number">0f</span>);</span><br><span class="line">p.positions.c1 += <span class="keyword">select</span>(-offset, offset, p.positions.c</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/octahedron-closed.png"></p><p>最后,想要把正八面体变成半径为0.5的球体,需要用0.5除以向量的长度,我们由勾股定理可以得知计算公式,使用<code>rsqrt</code>函数来完成平方求倒的组合计算.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">p.positions.c1 += <span class="keyword">select</span>(-offset, offset, p.positions.c1 &lt; <span class="number">0f</span>);</span><br><span class="line"></span><br><span class="line">float4 scale = <span class="number">0.5f</span> * rsqrt(</span><br><span class="line">		p.positions.c0 * p.positions.c0 +</span><br><span class="line">		p.positions.c1 * p.positions.c1 +</span><br><span class="line">		p.positions.c2 * p.positions.c2</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">p.positions.c0 *= scale;</span><br><span class="line">p.positions.c1 *= scale;</span><br><span class="line">p.positions.c2 *= scale;</span><br><span class="line">p.normals = p.positions;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/octahedron-sphere.png"></p><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/uv-sphere-20220205165423884.png"></p><p>与UV球体相比,八面体球体有6个聚集位而不是只有极点上的2个,这样点的分布就更加均匀.</p><h4 id="整体缩放-Instance-Scale"><a href="#整体缩放-Instance-Scale" class="headerlink" title="整体缩放(Instance Scale)"></a>整体缩放(Instance Scale)</h4><p>球体和环的采样点比平面来说更加的分散,更难感觉出它们的表面.</p><p>最后通过向<strong>HashVisualization</strong>类添加一个可配置选项来结束这篇教程,这个动态配置可以让可视化效果的实例更坚实,或者更稀疏.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">SerializeField, Range(0.1f, 10f)</span>]</span><br><span class="line"><span class="built_in">float</span> instanceScale = <span class="number">2f</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/instance-scale-inspector.png"></p><p>实例的缩放需要在<code>OnEnable</code>中除以分辨率然后送到GPU中去计算,而不是除以分辨率的倒数.</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">propertyBlock.SetVector(configId, <span class="keyword">new</span> Vector4(resolution, instanceScale / resolution, displacement));</span><br></pre></td></tr></tbody></table></figure></div><div class="popular-posts-header">Related Posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/d33850b7.html" rel="bookmark">浅谈游戏中的道德困境</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/539ed278.html" rel="bookmark">让巨大化角色充满真实感的五大法则</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/archives/dea9e249.html" rel="bookmark">Hashing Small xxHash</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/Game-Develop/" rel="tag"># Game Develop</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/dea9e249.html" rel="prev" title="Hashing Small xxHash"><i class="fa fa-chevron-left"></i> Hashing Small xxHash</a></div><div class="post-nav-item"><a href="/archives/a07b951f.html" rel="next" title="马斯洛需求分析下的《哆啦A梦：伴我同行》">马斯洛需求分析下的《哆啦A梦：伴我同行》 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E6%A0%BC%E5%8F%98%E6%8D%A2-Grid-Transformation"><span class="nav-number">2.</span> <span class="nav-text">网格变换(Grid Transformation)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E7%BC%A9%E6%94%BE-Changing-Scale"><span class="nav-number">2.1.</span> <span class="nav-text">调整缩放(Changing Scale)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%9F%E7%9A%84%E5%8F%98%E6%8D%A2-Domain-Transformation"><span class="nav-number">2.2.</span> <span class="nav-text">域的变换(Domain Transformation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%9F%A9%E9%98%B5%E7%9A%84%E6%95%B0%E6%8D%AE-Applying-the-Matrix"><span class="nav-number">2.3.</span> <span class="nav-text">应用矩阵的数据(Applying the Matrix)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3D-Hashing"><span class="nav-number">2.4.</span> <span class="nav-text">3D Hashing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%87%E6%A0%B7%E5%BD%A2%E7%8A%B6-Sample-Shapes"><span class="nav-number">3.</span> <span class="nav-text">采样形状(Sample Shapes)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A2%E7%8A%B6%E7%94%9F%E6%88%90%E5%99%A8-Shapes-Job"><span class="nav-number">3.1.</span> <span class="nav-text">形状生成器(Shapes Job)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E4%BD%8D%E7%BD%AE%E7%82%B9-Generating-Positions"><span class="nav-number">3.2.</span> <span class="nav-text">生成位置点(Generating Positions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%8D%E7%BD%AE%E7%82%B9%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5-Using-Positions-as-Input"><span class="nav-number">3.3.</span> <span class="nav-text">使用位置点作为输入(Using Positions as Input)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A2%E7%8A%B6%E5%8F%98%E6%8D%A2-Shape-Transformation"><span class="nav-number">3.4.</span> <span class="nav-text">形状变换(Shape Transformation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E4%BD%8D%E7%BD%AE-Updating-Positions"><span class="nav-number">3.5.</span> <span class="nav-text">更新位置(Updating Positions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E7%A7%BB-Displacement"><span class="nav-number">3.6.</span> <span class="nav-text">偏移(Displacement)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C-Bounds"><span class="nav-number">3.7.</span> <span class="nav-text">边界(Bounds)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%90%91%E9%87%8F%E5%8C%96-Manual-Vectorization"><span class="nav-number">4.</span> <span class="nav-text">手动向量化(Manual Vectorization)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%8C%96%E7%9A%84Hash-Vectorized-Hash"><span class="nav-number">4.1.</span> <span class="nav-text">向量化的Hash(Vectorized Hash)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%8C%96%E7%9A%84HashJob-Vectorized-Hash-Job"><span class="nav-number">4.2.</span> <span class="nav-text">向量化的HashJob(Vectorized Hash Job)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%8C%96%E7%9A%84%E5%8F%98%E6%8D%A2-Vectorized-Transformation"><span class="nav-number">4.3.</span> <span class="nav-text">向量化的变换(Vectorized Transformation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%8C%96%E7%9A%84%E5%BD%A2%E7%8A%B6%E7%94%9F%E6%88%90-Vectorized-Shapes-Job"><span class="nav-number">4.4.</span> <span class="nav-text">向量化的形状生成(Vectorized Shapes Job)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84-Vectorized-Arrays"><span class="nav-number">4.5.</span> <span class="nav-text">向量化的数组(Vectorized Arrays)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%BD%A2%E7%8A%B6-More-Shapes"><span class="nav-number">5.</span> <span class="nav-text">更多的形状(More Shapes)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E9%9D%A2%E7%BB%93%E6%9E%84-Plane-Struct"><span class="nav-number">5.1.</span> <span class="nav-text">平面结构(Plane Struct)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A2%E7%8A%B6%E7%9A%84%E6%8E%A5%E5%8F%A3-Shape-Interface"><span class="nav-number">5.2.</span> <span class="nav-text">形状的接口(Shape Interface)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8BJob-Generic-Job"><span class="nav-number">5.3.</span> <span class="nav-text">泛型Job(Generic Job)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%83%E5%92%8C%E7%8E%AF-Sphere-and-Torus"><span class="nav-number">5.4.</span> <span class="nav-text">球和环(Sphere and Torus)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E5%BD%A2%E7%8A%B6-Selecting-Shapes"><span class="nav-number">5.5.</span> <span class="nav-text">可选形状(Selecting Shapes)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%B3%95%E7%BA%BF-Transformed-Normals"><span class="nav-number">5.6.</span> <span class="nav-text">处理法线(Transformed Normals)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%85%AB%E9%9D%A2%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%83%E4%BD%93-Octahedron-Sphere"><span class="nav-number">5.7.</span> <span class="nav-text">正八面结构的球体(Octahedron Sphere)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E7%BC%A9%E6%94%BE-Instance-Scale"><span class="nav-number">5.8.</span> <span class="nav-text">整体缩放(Instance Scale)</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yousazoe" src="https://tva1.sinaimg.cn/large/008eGmZEly1gn2f3efk0dj30lc0lcq31.jpg"><p class="site-author-name" itemprop="name">Yousazoe</p><div class="site-description" itemprop="description">done is better than perfect</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">277</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:zoeyousa@gmail.com" title="E-Mail → mailto:zoeyousa@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://github.com/Yousazoe" title="GitHub → https://github.com/Yousazoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/YousaZoe" title="Twitter → https://twitter.com/YousaZoe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo → https://www.weibo.com/6034231696/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198856466228/" title="Steam → https://steamcommunity.com/profiles/76561198856466228/" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://www.chess.com/member/yousazoe" title="Chess → https://www.chess.com/member/yousazoe" rel="noopener" target="_blank"><i class="fa fa-chess-pawn fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="./image/loading.gif" data-original="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div><div class="cc-license animated" itemprop="sponsor"><span class="exturl cc-opacity" title="Deploy with Netlify → https://www.netlify.com" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20="><img width="80" src="./image/loading.gif" data-original="https://www.netlify.com/img/global/badges/netlify-dark.svg" alt="Netlify"></span></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="translate-style">繁/简：<a id="translateLink" href="javascript:translatePage();">繁体</a></div><script type="text/javascript" src="/js/tw_cn.js"></script><script type="text/javascript">var defaultEncoding=2,translateDelay=0,cookieDomain="https://tding.top/",msgToTraditionalChinese="繁体",msgToSimplifiedChinese="简体",translateButtonId="translateLink";translateInitilization()</script><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2021009930号 </a><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/备案图标.png" style="display:inline-block"></div><div class="copyright">© 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yousazoe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">4.1m</span></div><div class="powered-by"><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img src="./image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" width="53" height="18" style="fill:currentColor;display:inline-block"></a></span><span class="post-meta-divider">|</span>今早雾霾蔽日，但是不要害怕，太阳依旧在云端</div><div class="busuanzi-count"><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script><script src="//npm.elemecdn.com/pjax/pjax.min.js"></script><script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//unpkg.com/lozad@1.16.0/dist/lozad.min.js"></script><script src="//lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
    $(document).ready(function () {

    if(location.href.indexOf("#reloaded")==-1){
        location.href=location.href+"#reloaded";
        location.reload();
    }
}）
#在这后面可以加入程序的其他代码  


  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });

  
  NexT.boot.refresh();
  
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  
  NexT.utils.updateSidebarPosition();
});</script><script defer="" src="/lib/three/three.min.js"></script><script defer="" src="//fastly.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script><script data-pjax="">!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script data-pjax="">document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),r=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script data-pjax="">document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//lib.baomitu.com/mermaid/8.4.8/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><div id="pjax"></div><script type="text/javascript" src="/js/cursor/fireworks.js"></script><script async="" src="//code.tidio.co/ij6vccjedzwoh5yxyoc9qbw6tycfnwjj.js"></script><script>!function(t,h,e,j){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:2272201,hjsv:6},e=h.getElementsByTagName("head")[0],(j=h.createElement("script")).async=1,j.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,e.appendChild(j)}(window,document)</script><script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:100,height:200},mobile:{show:!0},log:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
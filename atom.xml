<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fl0w3r</title>
  
  <subtitle>carpe diem</subtitle>
  <link href="https://yousazoe.top/atom.xml" rel="self"/>
  
  <link href="https://yousazoe.top/"/>
  <updated>2023-05-05T12:43:30.683Z</updated>
  <id>https://yousazoe.top/</id>
  
  <author>
    <name>Yousazoe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>精读 Effective C++</title>
    <link href="https://yousazoe.top/archives/f1767e7a.html"/>
    <id>https://yousazoe.top/archives/f1767e7a.html</id>
    <published>2023-03-05T11:58:25.000Z</published>
    <updated>2023-05-05T12:43:30.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://books.apple.com/us/book/effective-modern-c/id950075232"><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP9/CPP8.png"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>深入 C++ 的诸多设计细节，了解实际场景的最佳实践，以面向对象的方式重新认识 C++。</p><span id="more"></span><h3 id="将-C-视作一系列的语言"><a href="#将-C-视作一系列的语言" class="headerlink" title="将 C++ 视作一系列的语言"></a>将 C++ 视作一系列的语言</h3><blockquote><p>Item 1: View C++ as a federation of languages</p></blockquote><p>最初，C++ 只是 C 语言加上一些面向对象的特性，所以 C++ 的原名是 “C with Classes”。 现在的 C++ 已经逐渐成熟，成为一门 <strong>多范式的程序设计语言</strong>（multiparadigm programming language）。同时支持过程式、面向对象、函数式、泛型编程，以及元编程。</p><p>C++ 的灵活使得它在很多问题上并没有统一的规则，而是取决于具体的程序设计范式和当前架构的设计意图。这样的情况下，我们最好把 C++ 看做是一系列的编程语言，而非一种特定的编程语言。</p><p>C++ 有四种主要的子语言：</p><ul><li><code>C</code>：C++ 是基于 C 设计的，你可以只使用 C++ 中 C 的那部分语法。此时你会发现你的程序反映的完全是C的特征：没有模板、没有异常、没有重载。 </li><li><code>Object-Oriented C++</code>：面向对象程序设计也是 C++ 的设计初衷：构造与析构、封装与继承、多态、动态绑定的虚函数。 </li><li><code>Template C++</code>：这是 C++ 的泛型编程部分，多数程序员很少涉及，但模板在很多情况下仍然很方便。另外 <strong>模板元编程</strong>（template metaprogramming）也是一个新兴的程序设计范式，虽然有点非主流。 </li><li><code>STL</code>：这是一个特殊的模板库，它的容器、迭代器和算法优雅地结合在一起，只是在使用时你需要遵循它的程序设计惯例。当然你也可以基于其他想法来构建模板库。</li></ul><p>总之 C++ 并非单一的一门语言，它有很多不同的规则集。因而C++可以被视为四种主要子语言的集合，每个子语言都有自己的程序设计惯例。</p><p>C++ 程序设计的惯例并非一成不变，而是取决于你使用C++语言的哪一部分。例如， 在基于C语言的程序设计中，基本类型传参时传值比传引用更有效率。 然而当你接触Object-Oriented C++时会发现，传常量指针是更好的选择。 但是你如果又碰到了STL，其中的迭代器和函数对象都是基于C语言的指针而设计的， 这时又回到了原来的规则：传值比传引用更好。</p><h3 id="避免使用-define"><a href="#避免使用-define" class="headerlink" title="避免使用 define"></a>避免使用 <code>define</code></h3><blockquote><p>Item 2: Prefer consts, enums, and inlines to #defines</p></blockquote><p>尽量使用常量、枚举和内联函数，代替 <code>#define</code>。我们知道 <code>#define</code> 定义的宏会在编译时进行替换，属于模块化程序设计的概念。 宏是全局的，面向对象程序设计中破坏了封装。因此在 C++ 中尽量避免它！</p><p>接着我们具体来看 <code>#define</code> 造成的问题。</p><h4 id="不易理解"><a href="#不易理解" class="headerlink" title="不易理解"></a>不易理解</h4><p>众所周知，由于预处理器会直接替换的原因，宏定义最好用括号括起来。#define函数将会产生出乎意料的结果：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) a &gt; b ? a : b</span></span><br><span class="line"><span class="built_in">MAX</span>(i++, j)</span><br></pre></td></tr></tbody></table></figure><p><code>i</code> 自加次数将取决于 <code>j</code> 的大小，然而调用者并不知情。宏的行为不易理解，本质上是因为宏并非 C++ 语言的一部分，它只是源代码的预处理手段。</p><h4 id="不利于调试"><a href="#不利于调试" class="headerlink" title="不利于调试"></a>不利于调试</h4><p>宏替换发生在编译时，语法检查之前。因此相关的编译错误中不会出现宏名称，我们不知道是哪个宏出了问题。例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PERSON alice</span></span><br><span class="line">PERSON = bob;</span><br></pre></td></tr></tbody></table></figure><p>如果 <code>alice</code> 未定义，<code>PERSON=bob;</code> 便会出错：use of undeclared identifier ‘alice’。 然而我们可能不知道 <code>alice</code> 是什么东西，<code>PERSON</code> 才是我们定义的“变量”。</p><p>宏替换是在预处理过程中进行的，原则上讲编译器不知道宏的概念。然而，在现代的编译器中（例如Apple LLVM version 6.0）， 编译器会记录宏替换信息，在编译错误中给出宏的名称：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">test.cpp:<span class="number">8</span>:<span class="number">5</span>: error: use of undeclared identifier <span class="string">'alice'</span></span><br><span class="line">    PERSON  = bob;</span><br><span class="line">    ^</span><br><span class="line">test.cpp:<span class="number">4</span>:<span class="number">16</span>: note: expanded from macro <span class="string">'PERSON'</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERSON alice;</span></span><br><span class="line">               ^</span><br></pre></td></tr></tbody></table></figure><p>于是，Meyers 提到的这个问题已经不存在了。然而作者的本意在于：尽量使用编译器，而不是预处理器。 因为 <code>#define</code> 并不是 C++ 语言的一部分。</p><h4 id="enum-比-const-更好用"><a href="#enum-比-const-更好用" class="headerlink" title="enum 比 const 更好用"></a><code>enum</code> 比 <code>const</code> 更好用</h4><p>既然 <code>#define</code> 不能封装在一个类中，我们可以用 <code>static const</code> 来定义一个常量，并把它的作用于局限在当前类：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NUM = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> a[NUM];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>通常 C++ 要求所有的声明都给出定义，然而数值类型（<code>char</code>, <code>int</code>, <code>long</code>）的静态常量可以只给声明。这里的 <code>NUM</code> 就是一个例子。 然而，如果你想取 <code>NUM</code> 的地址，则会得到编译错误：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  "C::NUM", referenced from:</span><br><span class="line">      _main in a-88bbac.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></tbody></table></figure><p>因此如果你要取地址，那么就给出它的定义：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NUM = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> a[NUM];</span><br><span class="line">};</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> C::NUM;</span><br></pre></td></tr></tbody></table></figure><p>因为声明 <code>NUM</code> 时已经给定了初始值，定义时不允许再次给初始值。 如果使用 <code>enum</code>，事情会简单很多：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>{</span><br><span class="line">    <span class="keyword">enum</span> { NUM = <span class="number">3</span> };</span><br><span class="line">    <span class="type">int</span> a[NUM];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="尽量使用常量"><a href="#尽量使用常量" class="headerlink" title="尽量使用常量"></a>尽量使用常量</h3><blockquote><p>Item 3: Use const whenever possible</p></blockquote><p>尽量使用常量。不需多说，这是 <strong>防卫型</strong>（defensive）程序设计的原则， 尽量使用常量限定符，从而防止客户错误地使用你的代码。</p><h4 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a>常量的声明</h4><p>总结一下各种指针的声明方式吧：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = greeting;                    <span class="comment">// non-const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = greeting;              <span class="comment">// non-const pointer, const data</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> p = greeting;             <span class="comment">// const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> p = greeting;       <span class="comment">// const pointer, const data</span></span><br></pre></td></tr></tbody></table></figure><p><code>const</code> 出现在 <code>*</code> 左边则被指向的对象是常量，出现在 <code>*</code> 右边则指针本身是常量。 然而对于常量对象，有人把 <code>const</code> 放在类型左边，有人把 <code>const</code> 放在 <code>*</code> 左边，都是可以的：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>;   <span class="comment">// f1 takes a pointer to a constant Widget object</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> *pw)</span></span>;   <span class="comment">// 等效</span></span><br></pre></td></tr></tbody></table></figure><p>STL 的 <code>iterator</code> 也是类似的，如果你希望指针本身是常量，可以声明 <code>const iterator</code>； 如果你希望指针指向的对象是常量，请使用 <code>const_iterator</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iter acts like a T* const</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">*iter = <span class="number">10</span>;                              <span class="comment">// OK, changes what iter points to</span></span><br><span class="line">++iter;                                  <span class="comment">// error! iter is const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cIter acts like a const T*</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();</span><br><span class="line">*cIter = <span class="number">10</span>;                             <span class="comment">// error! *cIter is const</span></span><br><span class="line">++cIter;                                 <span class="comment">// fine, changes cIter</span></span><br></pre></td></tr></tbody></table></figure><p>返回值声明为常量可以防止你的代码被错误地使用，例如实数相加的方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></tbody></table></figure><p>当用户错误地使用 <code>=</code> 时：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line"><span class="keyword">if</span> (a * b = c){</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译器便会给出错误：不可赋值给常量。</p><h4 id="常量成员方法"><a href="#常量成员方法" class="headerlink" title="常量成员方法"></a>常量成员方法</h4><p>声明常量成员函数是为了确定哪些方法可以通过常量对象来访问，另外一方面让接口更加易懂： 很容易知道哪些方法会改变对象，哪些不会。</p><p>成员方法添加常量限定符属于函数重载。常量对象只能调用常量方法， 非常量对象优先调用非常量方法，如不存在会调用同名常量方法。 常量成员函数也可以在类声明外定义，但声明和定义都需要指定 <code>const</code> 关键字。 例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>   <span class="comment">// operator[] for</span></span><br><span class="line">    { <span class="keyword">return</span> text[position]; }                           <span class="comment">// const objects</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)               <span class="comment">// operator[] for</span></span><br><span class="line">    { <span class="keyword">return</span> text[position]; }                           <span class="comment">// non-const objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"World"</span>)</span></span>;</span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">'x'</span>;             <span class="comment">// fine — writing a non-const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">'x'</span>;            <span class="comment">// error! — writing a const TextBlock</span></span><br></pre></td></tr></tbody></table></figure><h4 id="比特常量和逻辑常量"><a href="#比特常量和逻辑常量" class="headerlink" title="比特常量和逻辑常量"></a>比特常量和逻辑常量</h4><p><strong>比特常量</strong>（bitwise constness）：如果一个方法不改变对象的任何非静态变量，那么该方法是常量方法。 比特常量是 C++ 定义常量的方式，然而一个满足比特常量的方法，却不见得表现得像个常量， 尤其是数据成员是指针时：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>{</span><br><span class="line"><span class="type">char</span>* text;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> pos) <span class="type">const</span>{</span><br><span class="line">        <span class="keyword">return</span> text[pos];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> TextBlock tb;</span><br><span class="line"><span class="type">char</span> *p = &amp;tb[<span class="number">1</span>];</span><br><span class="line">*p = <span class="string">'a'</span>;</span><br></pre></td></tr></tbody></table></figure><p>因为 <code>char* text</code> 并未发生改变，所以编译器认为我们的操作都是合法的。 然而我们定义了一个常量对象 tb，只调用它的常量方法，却能够修改tb的数据。 对数据的操作甚至可以放在 <code>operator[]()</code> 方法里面。</p><p>这一点不合理之处引发了 <strong>逻辑常量</strong>（logical constness）的讨论：常量方法可以修改数据成员， 只要客户检测不到变化就可以。可是常量方法修改数据成员 C++ 编译器不会同意的！这时我们需要 <code>mutable</code> 限定符：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *pText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> std::<span class="type">size_t</span> textLength;         <span class="comment">// these data members may</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> lengthIsValid;             <span class="comment">// always be modified</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="type">const</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (!lengthIsValid) {</span><br><span class="line">        textLength = std::<span class="built_in">strlen</span>(pText);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;          </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="避免常量-x2F-非常量方法的重复"><a href="#避免常量-x2F-非常量方法的重复" class="headerlink" title="避免常量/非常量方法的重复"></a>避免常量/非常量方法的重复</h4><p>通常我们需要定义成对的常量和普通方法，只是返回值的修改权限不同。 当然我们不希望重新编写方法的逻辑。最先想到的方法是常量方法调用普通方法，然而这是 C++ 语法不允许的。 于是我们只能用普通方法调用常量方法，并做相应的类型转换：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos){</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">            [pos]   </span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li><code>*this</code> 的类型是 <code>TextBlock</code>，先把它强制隐式转换为 <code>const TextBlock</code>，这样我们才能调用那个常量方法</li><li>调用 <code>operator[](size_t) const</code>，得到的返回值类型为 <code>const char&amp;</code></li><li>把返回值去掉 <code>const</code> 属性，得到类型为 <code>char&amp;</code> 的返回值</li></ol></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://books.apple.com/us/book/effective-modern-c/id950075232&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CPP9/CPP8.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;深入 C++ 的诸多设计细节，了解实际场景的最佳实践，以面向对象的方式重新认识 C++。&lt;/p&gt;</summary>
    
    
    
    <category term="精读 Effective C++ (Effective C++)" scheme="https://yousazoe.top/categories/%E7%B2%BE%E8%AF%BB-Effective-C-Effective-C/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>维拓标准接口开发项目总结</title>
    <link href="https://yousazoe.top/archives/4bc24537.html"/>
    <id>https://yousazoe.top/archives/4bc24537.html</id>
    <published>2023-03-04T08:13:29.000Z</published>
    <updated>2023-05-05T12:43:30.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/116635445/Becoming-Someone-New-1-5-by-James-Lipnickas-2021"><img data-src="https://img.yousazoe.top/uPic/img/blog/GSTAR2/GSTAR2.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>维拓标准接口的开发也基本完成了，这也是我首次用 C# 完成定制项目。之前 Unity 学的很多东西都忘掉了，再捡起来用还是有些吃力，所以写了这篇博客总结一下。</p><span id="more"></span><h3 id="C-程序配置与-lt-bindingRedirect-gt"><a href="#C-程序配置与-lt-bindingRedirect-gt" class="headerlink" title="C#程序配置与 <bindingRedirect/>"></a>C#程序配置与 <code>&lt;bindingRedirect/&gt;</code></h3><p>在完成部分接口把程序打包成exe时重新校对了一下 NewtonJson 的版本，之前在 Nuget 上下载的是 13 版本，但是 GStarCAD 目录下的版本是 12。将版本调整之后 exe 无法正常使用：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">未经处理的异常:SystemI0.Fi1eLoadException:未能加载文件或程序集“Newtonsoft.Json，Version=13.0.0.0 Culture=neutral Pub1icKeyToken=30ad4fe6b2a6aeed”或它的某一个依赖项。找到的程序集清单定义与程序集引用不匹配。(异常来自 HRESULT:0x80131040)---&gt;SystemIO.Fi1eLoadException:未能加载文件或程序集“Newtonsoft.Ison，Version=12.0.0.0，Culture=neutral, PublicKe yToken=30ad4fe6b2a6aeed”或它的某一个依赖项。找到的程序集清单定义与程序集引用不匹配。(异常来自 HRESULT:0x80131040)</span><br></pre></td></tr></tbody></table></figure><p>再次检查 Nuget 版本已经调整过来了，但是编译之后的 exe 还是会报错 NewtonJson 版本错误。其实只需要调整一下 <code>app.config</code> 文件：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startup</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">supportedRuntime</span> <span class="attr">version</span>=<span class="string">"v4.0"</span> <span class="attr">sku</span>=<span class="string">".NETFramework,Version=v4.8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">runtime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assemblyBinding</span> <span class="attr">xmlns</span>=<span class="string">"urn:schemas-microsoft-com:asm.v1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependentAssembly</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">assemblyIdentity</span> <span class="attr">name</span>=<span class="string">"Newtonsoft.Json"</span> <span class="attr">publicKeyToken</span>=<span class="string">"30ad4fe6b2a6aeed"</span> <span class="attr">culture</span>=<span class="string">"neutral"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bindingRedirect</span> <span class="attr">oldVersion</span>=<span class="string">"0.0.0.0-13.0.0.0"</span> <span class="attr">newVersion</span>=<span class="string">"13.0.0.0"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependentAssembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assemblyBinding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">runtime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>问题在于 <code>&lt;bindingRedirect/&gt;</code> 这个标签，<a href="https://learn.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/bindingredirect-element">微软官方API文档</a> 这里有比较详细的解释。</p><blockquote><p>将一个程序集版本重定向到另一个版本。</p></blockquote><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bindingRedirect</span></span></span><br><span class="line"><span class="tag"><span class="attr">oldVersion</span>=<span class="string">"existing assembly version"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">newVersion</span>=<span class="string">"new assembly version"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>oldVersion</code>：指定最初请求的程序集的版本。 程序集版本号的格式为 <code>major.minor.build.revision</code>。 该版本号的每个部分的有效值介于 0 和 65535 之间。</li><li><code>newVersion</code>：指定要用来取代最初请求的版本的程序集版本（格式为：<code>n.n.n.n</code>） ，此值可以指定 oldVersion 之前的版本。</li></ul><p>官方还给出了一个示例演示如何将一个程序集版本重定向到另一个版本：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">runtime</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">assemblyBinding</span> <span class="attr">xmlns</span>=<span class="string">"urn:schemas-microsoft-com:asm.v1"</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">dependentAssembly</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">assemblyIdentity</span> <span class="attr">name</span>=<span class="string">"myAssembly"</span>  </span></span><br><span class="line"><span class="tag">                              <span class="attr">publicKeyToken</span>=<span class="string">"32ab4ba45e0a69a1"</span>  </span></span><br><span class="line"><span class="tag">                              <span class="attr">culture</span>=<span class="string">"neutral"</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">bindingRedirect</span> <span class="attr">oldVersion</span>=<span class="string">"1.0.0.0"</span>  </span></span><br><span class="line"><span class="tag">                             <span class="attr">newVersion</span>=<span class="string">"2.0.0.0"</span>/&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependentAssembly</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">assemblyBinding</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">runtime</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>所以把这个标签删掉，程序就可以正常运行了，这是一个知识盲点记录下来。</p><h3 id="PLM接口使用"><a href="#PLM接口使用" class="headerlink" title="PLM接口使用"></a>PLM接口使用</h3><h3 id="NewtonSoftJson自定义Convertor序列化Json"><a href="#NewtonSoftJson自定义Convertor序列化Json" class="headerlink" title="NewtonSoftJson自定义Convertor序列化Json"></a>NewtonSoftJson自定义Convertor序列化Json</h3><p>这个项目一个比较关键的过程就是去解析图纸数据并转换为 Json 格式，前面 PLM 接口负责解析数据，那么该如何将这些数据转换为 Json 呢？</p><p>查阅官网的 <a href="https://www.newtonsoft.com/json/help/html/CustomJsonConverter.htm">Custom JsonConverter</a>，给出了一个比较完整的示例：</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KeysJsonConverter</span> : <span class="title">JsonConverter</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Type[] _types;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeysJsonConverter</span>(<span class="params"><span class="keyword">params</span> Type[] types</span>)</span></span><br><span class="line">    {</span><br><span class="line">        _types = types;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">WriteJson</span>(<span class="params">JsonWriter writer, <span class="built_in">object</span> <span class="keyword">value</span>, JsonSerializer serializer</span>)</span></span><br><span class="line">    {</span><br><span class="line">        JToken t = JToken.FromObject(<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.Type != JTokenType.Object)</span><br><span class="line">        {</span><br><span class="line">            t.WriteTo(writer);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            JObject o = (JObject)t;</span><br><span class="line">            IList&lt;<span class="built_in">string</span>&gt; propertyNames = o.Properties().Select(p =&gt; p.Name).ToList();</span><br><span class="line"></span><br><span class="line">            o.AddFirst(<span class="keyword">new</span> JProperty(<span class="string">"Keys"</span>, <span class="keyword">new</span> JArray(propertyNames)));</span><br><span class="line"></span><br><span class="line">            o.WriteTo(writer);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">ReadJson</span>(<span class="params">JsonReader reader, Type objectType, <span class="built_in">object</span> existingValue, JsonSerializer serializer</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">"Unnecessary because CanRead is false. The type will skip the converter."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanRead</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">CanConvert</span>(<span class="params">Type objectType</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> _types.Any(t =&gt; t == objectType);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; Roles { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee</span><br><span class="line">{</span><br><span class="line">    FirstName = <span class="string">"James"</span>,</span><br><span class="line">    LastName = <span class="string">"Newton-King"</span>,</span><br><span class="line">    Roles = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="string">"Admin"</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> json = JsonConvert.SerializeObject(employee, Formatting.Indented, <span class="keyword">new</span> KeysJsonConverter(<span class="keyword">typeof</span>(Employee)));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(json);</span><br><span class="line"><span class="comment">// {</span></span><br><span class="line"><span class="comment">//   "Keys": [</span></span><br><span class="line"><span class="comment">//     "FirstName",</span></span><br><span class="line"><span class="comment">//     "LastName",</span></span><br><span class="line"><span class="comment">//     "Roles"</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   "FirstName": "James",</span></span><br><span class="line"><span class="comment">//   "LastName": "Newton-King",</span></span><br><span class="line"><span class="comment">//   "Roles": [</span></span><br><span class="line"><span class="comment">//     "Admin"</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">Employee newEmployee = JsonConvert.DeserializeObject&lt;Employee&gt;(json, <span class="keyword">new</span> KeysJsonConverter(<span class="keyword">typeof</span>(Employee)));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(newEmployee.FirstName);</span><br><span class="line"><span class="comment">// James</span></span><br></pre></td></tr></tbody></table></figure><h3 id="UML类图绘制"><a href="#UML类图绘制" class="headerlink" title="UML类图绘制"></a>UML类图绘制</h3></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/116635445/Becoming-Someone-New-1-5-by-James-Lipnickas-2021&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GSTAR2/GSTAR2.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;维拓标准接口的开发也基本完成了，这也是我首次用 C# 完成定制项目。之前 Unity 学的很多东西都忘掉了，再捡起来用还是有些吃力，所以写了这篇博客总结一下。&lt;/p&gt;</summary>
    
    
    
    <category term="CAD二次开发 (GStarCAD ObjectARX Dev)" scheme="https://yousazoe.top/categories/CAD%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91-GStarCAD-ObjectARX-Dev/"/>
    
    
    <category term="C#" scheme="https://yousazoe.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>哪些变量会自动初始化？</title>
    <link href="https://yousazoe.top/archives/62e0ea85.html"/>
    <id>https://yousazoe.top/archives/62e0ea85.html</id>
    <published>2023-02-19T09:18:03.000Z</published>
    <updated>2023-05-05T12:43:30.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/142965367/Good-Days"><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP8/CPP8.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在 C 语言中的全局变量和静态变量都是会自动初始化为 0，堆和栈中的局部变量不会初始化而拥有不可预测的值。 C++ 保证了所有对象与对象成员都会初始化，但其中基本数据类型的初始化还得依赖于构造函数。 下文来详细探讨 C 风格的”默认初始化”行为，以及 C++ 中成员变量的初始化规则。</p><span id="more"></span><h3 id="初始化的语法"><a href="#初始化的语法" class="headerlink" title="初始化的语法"></a>初始化的语法</h3><p>很多人至今不知道 C++ 中如何正确地初始化一个变量，我们首先来解决语法的问题。 C语言中在声明时用 <code>=</code> 即可完成初始化操作。但我们偏向于使用 C++ 风格（本文中均指面向对象程序设计风格）来初始化内置类型：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// C 风格</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 风格</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br></pre></td></tr></tbody></table></figure><p>在 C 语言中 <code>int a;</code> 表示声明了整型 <code>a</code> 但未初始化，而 C++ 中的对象总是会被初始化的，无论是否写了圆括号或者是否写了参数列表，例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> basic_var;      <span class="comment">// 未初始化：应用"默认初始化"机制</span></span><br><span class="line">CPerson person;     <span class="comment">// 初始化：以空的参数列表调用构造函数</span></span><br></pre></td></tr></tbody></table></figure><h3 id="默认初始化规则"><a href="#默认初始化规则" class="headerlink" title="默认初始化规则"></a>默认初始化规则</h3><p>定义基本数据类型变量（单个值、数组）的同时可以指定初始值，如果未指定 C++ 会去执行默认初始化(default-initialization)。 那么什么是”默认初始化”呢？</p><p>栈中的变量（函数体中的自动变量）和堆中的变量（动态内存）会保有不确定的值；<br>全局变量和静态变量（包括局部静态变量）会初始化为零。<br>C++11: If no initializer is specified for an object, the object is default-initialized; if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value. Note: Objects with static or thread storage duration are zero-initialized, see 3.6.2.</p><p>所以函数体中的变量定义是这样的规则：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;                    <span class="comment">// 不确定值</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">int</span>();            <span class="comment">// 0</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;         <span class="comment">// 不确定值</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>();       <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="静态和全局变量的初始化"><a href="#静态和全局变量的初始化" class="headerlink" title="静态和全局变量的初始化"></a>静态和全局变量的初始化</h3><p>未初始化的和初始化为零的静态/全局变量编译器是同样对待的，把它们存储在进程的BSS段（这是全零的一段内存空间）中。所以它们会被”默认初始化”为零。</p><p>来看例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> g_var;</span><br><span class="line"><span class="type">int</span> *g_pointer;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_static;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> l_var;</span><br><span class="line">    <span class="type">int</span> *l_pointer;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> l_static;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;g_var&lt;&lt;endl&lt;&lt;g_pointer&lt;&lt;endl&lt;&lt;g_static&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;l_var&lt;&lt;endl&lt;&lt;l_pointer&lt;&lt;endl&lt;&lt;l_static&lt;&lt;endl;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0                   // 全局变量</span><br><span class="line">0x0                 // 全局指针  </span><br><span class="line">0                   // 全局静态变量</span><br><span class="line">32767               // 局部变量</span><br><span class="line">0x7fff510cfa68      // 局部指针</span><br><span class="line">0                   // 局部静态变量</span><br></pre></td></tr></tbody></table></figure><p>动态内存中的变量在上述代码中没有给出，它们和局部变量（自动变量）具有相同的”默认初始化”行为。</p><h3 id="成员变量的初始化"><a href="#成员变量的初始化" class="headerlink" title="成员变量的初始化"></a>成员变量的初始化</h3><p>成员变量分为成员对象和内置类型成员，其中成员对象总是会被初始化的。而我们要做的就是在构造函数中初始化其中的内置类型成员。 还是先来看看内置类型的成员的”默认初始化”行为：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">};</span><br><span class="line">A g_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    A l_var;</span><br><span class="line">    <span class="type">static</span> A l_static;</span><br><span class="line">    cout&lt;&lt;g_var.v&lt;&lt;<span class="string">' '</span>&lt;&lt;l_var.v&lt;&lt;<span class="string">' '</span>&lt;&lt;l_static.v&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0 2407223 0</span><br></pre></td></tr></tbody></table></figure><p>可见内置类型的成员变量的”默认初始化”行为取决于所在对象的存储类型，而存储类型对应的默认初始化规则是不变的。 所以为了避免不确定的初值，通常会在构造函数中初始化所有内置类型的成员。Effective C++: Item 4一文讨论了如何正确地在构造函数中初始化数据成员。 这里就不展开了，直接给出一个正确的初始化写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">v</span>(<span class="number">0</span>);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="封闭类嵌套成员的初始化"><a href="#封闭类嵌套成员的初始化" class="headerlink" title="封闭类嵌套成员的初始化"></a>封闭类嵌套成员的初始化</h3><p>再来探讨一下当对象聚合发生时成员变量的”默认初始化”行为，同样还是只关注于基本数据类型的成员。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    A a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">B g_var;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    B l_var;</span><br><span class="line">    cout&lt;&lt;g_var.v&lt;&lt;<span class="string">' '</span>&lt;&lt;g_var.a.v&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;l_var.v&lt;&lt;<span class="string">' '</span>&lt;&lt;l_var.a.v&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0 0</span><br><span class="line">43224321 -1610612736</span><br></pre></td></tr></tbody></table></figure><p>规则还是是一样的，默认初始化行为取决于它所属对象的存储类型。 封闭类（Enclosing）中成员对象的内置类型成员变量的”默认初始化”行为取决于当前封闭类对象的存储类型，而存储类型对应的默认初始化规则仍然是不变的。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/142965367/Good-Days&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CPP8/CPP8.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在 C 语言中的全局变量和静态变量都是会自动初始化为 0，堆和栈中的局部变量不会初始化而拥有不可预测的值。 C++ 保证了所有对象与对象成员都会初始化，但其中基本数据类型的初始化还得依赖于构造函数。 下文来详细探讨 C 风格的”默认初始化”行为，以及 C++ 中成员变量的初始化规则。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧 (Coding Skill)" scheme="https://yousazoe.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-Coding-Skill/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>中车大同旧图纸转换定制项目总结</title>
    <link href="https://yousazoe.top/archives/7671ec9e.html"/>
    <id>https://yousazoe.top/archives/7671ec9e.html</id>
    <published>2023-02-02T14:36:22.000Z</published>
    <updated>2023-05-05T12:43:30.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/116635445/Becoming-Someone-New-1-5-by-James-Lipnickas-2021"><img data-src="https://img.yousazoe.top/uPic/img/blog/GSTAR1/GSTAR1.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>中车大同的旧图纸转换功能的定制开发告一段落，这段时间和周工学到了很多有用的知识，特此记录这个项目学到的编程技巧和项目开发经验。</p><span id="more"></span><h3 id="容器越界问题"><a href="#容器越界问题" class="headerlink" title="容器越界问题"></a>容器越界问题</h3><p>在这个项目中我有很多时候对数组越界问题并不敏感，导致在一些情况下程序直接崩溃了，下面举一些具体的例子：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">bool parseDTTitleBar(const CString &amp; filePath)</span><br><span class="line">{</span><br><span class="line">const auto titleBar = parseFile(filePath, titleBarSection[0]);</span><br><span class="line">const auto splitTitleBar = splitProfileString(titleBar);</span><br><span class="line">for (auto&amp; item : splitTitleBar)</span><br><span class="line">{</span><br><span class="line">auto vec = item.second;</span><br><span class="line"><span class="addition">+if (!vec.empty() &amp;&amp; vec.size() == 10)</span></span><br><span class="line">titleBarDefItems_.emplace_back(item.first, vec[0], vec[1], _ttof(vec[5]), _ttof(vec[6]), _ttof(vec[7]), vec[4], _ttof(vec[2]), _ttof(vec[3]), vec[8], vec[9]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">if (titleBarDefItems_.empty())</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本例中我去实例化一个对象，但使用的方式是直接选取 <code>vec</code> 元素没有增加数量判断。倘若 <code>vec</code> 只有 6 个元素但代码中却取到了 <code>vec[9]</code> 就会导致崩溃。</p><h3 id="前向声明"><a href="#前向声明" class="headerlink" title="前向声明"></a>前向声明</h3><p>前向声明是我编程时忽略掉的一个细节，在之前学校里写的代码只要编译能过去就不考虑这些问题了，但工作中需要注意效率。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include "jsoncpp/value.h"</span><br><span class="line">#include "EditableListCtrl.h"</span><br><span class="line"><span class="deletion">-#include "AbstractDetailsCreator.h"</span></span><br><span class="line"></span><br><span class="line">// DlgCvtMain 对话框</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">class DataRow;</span><br><span class="line">class AbstractPaperSelector;</span><br><span class="line">class PaperCreator;</span><br><span class="line">class PaperSizeDefinition;</span><br><span class="line"><span class="addition">+class AbstractDetailsCreator;</span></span><br></pre></td></tr></tbody></table></figure><p><code>#include</code> 所做的就是将整个代码复制过来，而这里我们并不关心 <code>AbstractDetailsCreator</code> 具体如何是什么，只需要知道有这样一个类型存在即可，这时就可以用前置声明而非引入整个头文件。</p><p>从代码编写的优雅程度来讲这样也会让阅读代码更加容易，不会因为引入过多无关头文件而一头雾水。前置声明最大的好处在于避免编译膨胀，一个优秀的 CPP 代码应该只包含它的最小代码集合。</p><h3 id="重写读取-ini-文件函数"><a href="#重写读取-ini-文件函数" class="headerlink" title="重写读取 .ini 文件函数"></a>重写读取 <code>.ini</code> 文件函数</h3><h4 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h4><p>业务场景需要读取下面的 <code>.def</code> 配置文件：</p><figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[Info]</span></span><br><span class="line"><span class="attr">bindingEditable</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">bindingDefault</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">bindingAreaWidth</span>=<span class="number">20</span></span><br><span class="line"><span class="attr">bindingEtcAreaWidth</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">notBindingWidth</span>=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">splitEditable</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">splitDefault</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">splitTextHeight</span>=<span class="number">3.5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">middleEditable</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">middleDefault</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">attachBarEditable</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">attachBarDefault</span>=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mainTitleBarHeight</span>=<span class="number">63</span></span><br><span class="line"><span class="attr">bomHeaderHeight</span>=<span class="number">9.993</span></span><br><span class="line"><span class="attr">bomTextBlockHeight</span>=<span class="number">7</span></span><br><span class="line"><span class="attr">bomTextBlockExtHeight</span>=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DTTitleBar]</span></span><br><span class="line"><span class="attr">main</span>= 主标题栏<span class="comment">;         DTTitleBar; 185; 63;  IRB; 0; 0; 0; bkt-1en_main.dwg;</span></span><br><span class="line"><span class="attr">lb</span>=   副标题栏签字<span class="comment">;     DTTitleBar; 20;  287; ILB; 0; 0; 0; bkt-1en_lb.dwg;   A3:0.75,A4:0.5,A4+:0.75</span></span><br><span class="line"><span class="attr">lt</span>=   副标题栏图样代码<span class="comment">; DTTitleBar; 137; 21;  ILT; 0; 0; 0; bkt-1_lt.dwg;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DTTitleBarText]</span></span><br><span class="line"><span class="attr">IRB001</span> =          图样代码<span class="comment">;  5;   IRB; -60;   47.5;   0; MC; 120; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB002</span> =          中文名称<span class="comment">;  5;   IRB; -85;   33.75;  0; MC; 70;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB003</span> =          中文材料<span class="comment">;  5;   IRB; -85;   11.25;  0; MC; 70;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB004_ZhiLiang</span> = 质量<span class="comment">;      4;   IRB; -26.5; 27.5;   0; MC; 17;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB005_BiLi</span> =     比例<span class="comment">;      4;   IRB; -9;    27.5;   0; MC; 18;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB006</span> =          共张<span class="comment">;      3.5; IRB; -15;   17.5;   0; MC; 30;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB007</span> =          第张<span class="comment">;      3.5; IRB; -40;   17.5;   0; MC; 20;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB008_TuFu</span> =     图幅<span class="comment">;      4;   IRB; -3.5;  -2.5;   0; MC; 7;   STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB009</span> =          俄文名称<span class="comment">;  5;   IRB; -85;   21.25;  0; MC; 70;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB010</span> =          俄文材料<span class="comment">;  5;   IRB; -85;   3.75;   0; MC; 70;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB011</span> =          订货号<span class="comment">;    4;   IRB; -60;   59;     0; MC; 120; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB012</span> =          识别符号<span class="number">1</span><span class="comment">; 4;   IRB; -47.5; 27.5;   0; MC; 5;   STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB013</span> =          识别符号<span class="number">2</span><span class="comment">; 4;   IRB; -42.5; 27.5;   0; MC; 5;   STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB014</span> =          识别符号<span class="number">3</span><span class="comment">; 4;   IRB; -37.5; 27.5;   0; MC; 5;   STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB015</span> =          复印人员<span class="comment">;  3.5; IRB; -70;  -2.5;    0; ML; 30;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ILB001</span> = (左)国家标准登记号<span class="comment">; 4; ILB; 8.5; 12.5;  90; MC; 25; STR; 0; 11; Standard; lb; ;</span></span><br><span class="line"><span class="attr">ILB002</span> = (左)签名和日期<span class="number">1</span><span class="comment">;    4; ILB; 8.5; 42.5;  90; MC; 35; STR; 0; 11; Standard; lb; ;</span></span><br><span class="line"><span class="attr">ILB003</span> = (左)替代正本号<span class="comment">;     4; ILB; 8.5; 72.5;  90; MC; 25; STR; 0; 11; Standard; lb; ;</span></span><br><span class="line"><span class="attr">ILB004</span> = (左)副本登记号<span class="comment">;     4; ILB; 8.5; 97.5;  90; MC; 25; STR; 0; 11; Standard; lb; ;</span></span><br><span class="line"><span class="attr">ILB005</span> = (左)签名和日期<span class="number">2</span><span class="comment">;    4; ILB; 8.5; 127.5; 90; MC; 35; STR; 0; 11; Standard; lb; ;</span></span><br><span class="line"><span class="attr">ILB006</span> = (左)替代文件代号<span class="comment">;   4; ILB; 8.5; 197;   90; MC; 60; STR; 0; 11; Standard; lb; ;</span></span><br><span class="line"><span class="attr">ILB007</span> = (左)相应文件代号<span class="comment">;   4; ILB; 8.5; 257;   90; MC; 60; STR; 0; 11; Standard; lb; ;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ILT001</span> = (上)专利编号<span class="comment">;                   3; ILT; 35;    -17.5; 0; MC; 70; STR; 0; 11; Standard; lt; ;</span></span><br><span class="line"><span class="attr">ILT002</span> = (上)订货号标记<span class="comment">;                 3; ILT; 77;    -7;    0; MC; 14; STR; 0; 11; Standard; lt; ;</span></span><br><span class="line"><span class="attr">ILT003</span> = (上)相应文件决议编号和批准年份<span class="comment">; 3; ILT; 110.5; -3.5;  0; MC; 53; STR; 0; 11; Standard; lt; ;</span></span><br><span class="line"><span class="attr">ILT004</span> = (上)本文件决议编号和批准年份<span class="comment">;   3; ILT; 110.5; -10.5; 0; MC; 53; STR; 0; 11; Standard; lt; ;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">IRB101</span> = 更改区域<span class="number">1____</span><span class="comment">; 3; IRB; -195;   37.5; 0; MC; 20; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB102</span> = 变更序号<span class="number">1</span><span class="comment">;     3; IRB; -181.5; 37.5; 0; MC; 7;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB103</span> = 变更页码<span class="number">1</span><span class="comment">;     3; IRB; -173;   37.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB104</span> = 通知单号<span class="number">1</span><span class="comment">;     3; IRB; -156.5; 37.5; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB105</span> = 签名<span class="number">1</span><span class="comment">;         3; IRB; -137.5; 37.5; 0; MC; 15; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB106</span> = 日期<span class="number">1</span><span class="comment">;         3; IRB; -125;   37.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">IRB107</span> = 更改区域<span class="number">2____</span><span class="comment">; 3; IRB; -195;   42.5; 0; MC; 20; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB108</span> = 变更序号<span class="number">2</span><span class="comment">;     3; IRB; -181.5; 42.5; 0; MC; 7;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB109</span> = 变更页码<span class="number">2</span><span class="comment">;     3; IRB; -173;   42.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB110</span> = 通知单号<span class="number">2</span><span class="comment">;     3; IRB; -156.5; 42.5; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB111</span> = 签名<span class="number">2</span><span class="comment">;         3; IRB; -137.5; 42.5; 0; MC; 15; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB112</span> = 日期<span class="number">2</span><span class="comment">;         3; IRB; -125;   42.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">IRB113</span> = 更改区域<span class="number">3____</span><span class="comment">; 3; IRB; -195;   47.5; 0; MC; 20; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB114</span> = 变更序号<span class="number">3</span><span class="comment">;     3; IRB; -181.5; 47.5; 0; MC; 7;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB115</span> = 变更页码<span class="number">3</span><span class="comment">;     3; IRB; -173;   47.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB116</span> = 通知单号<span class="number">3</span><span class="comment">;     3; IRB; -156.5; 47.5; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB117</span> = 签名<span class="number">3</span><span class="comment">;         3; IRB; -137.5; 47.5; 0; MC; 15; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB118</span> = 日期<span class="number">3</span><span class="comment">;         3; IRB; -125;   47.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">IRB119</span> = 更改区域<span class="number">4____</span><span class="comment">; 3; IRB; -195;   52.5; 0; MC; 20; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB120</span> = 变更序号<span class="number">4</span><span class="comment">;     3; IRB; -181.5; 52.5; 0; MC; 7;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB121</span> = 变更页码<span class="number">4</span><span class="comment">;     3; IRB; -173;   52.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB122</span> = 通知单号<span class="number">4</span><span class="comment">;     3; IRB; -156.5; 52.5; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB123</span> = 签名<span class="number">4</span><span class="comment">;         3; IRB; -137.5; 52.5; 0; MC; 15; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB124</span> = 日期<span class="number">4</span><span class="comment">;         3; IRB; -125;   52.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">IRB125</span>=设计-文件数量<span class="comment">;     3; IRB; -156.5; 27.5 ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB126</span>=审核-文件数量<span class="comment">;     3; IRB; -156.5; 22.5 ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB127</span>=主任设计-文件数量<span class="comment">; 3; IRB; -156.5; 17.5 ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB128</span>=工艺-文件数量<span class="comment">;     3; IRB; -156.5; 12.5 ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB129</span>=标准化-文件数量<span class="comment">;   3; IRB; -156.5; 7.5  ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="attr">IRB130</span>=批准-文件数量<span class="comment">;     3; IRB; -156.5; 2.5  ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DTTitleBarTextReference]</span></span><br><span class="line"><span class="attr">tydmfz</span> = 图样代码<span class="comment">; 3; ILT; 35; -7; 180; MC; 70; STR; 0; 11; Standard; lt; ;IRB001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[DTBOM]</span></span><br><span class="line"><span class="attr">bomHeader</span>=       主明细栏<span class="comment">;       DTBOMHeader;    185; 10; IRB; 0; 0; 0; bkt-1en_bh.dwg;</span></span><br><span class="line"><span class="attr">bomTextBlock</span>=    明细文字框<span class="comment">;     DTBOMTextBlock; 185; 7;  IRB; 0; 0; 0; btb_w185h7.dwg;</span></span><br><span class="line"><span class="attr">bomTextBlockExt</span>= 明细文字框扩展<span class="comment">; DTBOMTextBlock; 185; 10; IRB; 0; 0; 0; btb_w185h10.dwg;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DTBOMText]</span></span><br><span class="line"><span class="attr">BOM001</span> = 序号<span class="comment">; 3.5; IRB; -178.5; 5; 0; MC; 13; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">BOM002</span> = 代码<span class="comment">; 3.5; IRB; -171;   5; 0; ML; 25; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">BOM003</span> = 代号<span class="comment">; 3.5; IRB; -146;   5; 0; ML; 30; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">BOM004</span> = 名称<span class="comment">; 3.5; IRB; -116;   0; 0; ML; 35; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">BOM005</span> = 数量<span class="comment">; 3.5; IRB; -81;    5; 0; ML; 8;  STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">BOM006</span> = 材料<span class="comment">; 3.5; IRB; -73;    5; 0; ML; 35; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">BOM007</span> = 单件<span class="comment">; 3.5; IRB; -38;    5; 0; ML; 12; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">BOM008</span> = 总计<span class="comment">; 3.5; IRB; -26;    5; 0; ML; 12; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">BOM009</span> = 附注<span class="comment">; 3.5; IRB; -14;    5; 0; ML; 15; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">EXT001</span> = 外文名称<span class="comment">; 3.5; IRB; -116; 100; 0; ML; 35; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"><span class="attr">EXT002</span> = 外文材料<span class="comment">; 3.5; IRB; -73;  100; 0; ML; 35; STR; 0; 11; Standard; bomHeader; ;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DTAttachBar]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[DTAttachBarText]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="ini-文件结构"><a href="#ini-文件结构" class="headerlink" title=".ini 文件结构"></a><code>.ini</code> 文件结构</h4><p>我之前遇到的大部分配置文件的类型都是 <code>.xml</code> 或者 <code>.josn</code>（现在网络端也是这两者使用比较多，属于通用的配置文件类型了），面对 <code>.ini</code> 文件还是比较陌生。 这里引用简书一位博主的 <a href="https://www.jianshu.com/p/7f60e3ee905b">ini文件格式和读取</a>：</p><p>ini 就是英文 “initialization” 的头三个字母的缩写，当然 INI file 的后缀名也不一定是 <code>.ini</code>，也可以是 <code>.cfg</code>，<code>.conf</code> 或者是 <code>.txt</code>。</p><p>ini 文件的格式很简单，最基本的三个要素是：<code>parameters</code>，<code>sections</code> 和 <code>comments</code>。</p><h5 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h5><p>ini 所包含的最基本的”元素”就是 <code>parameter</code>，每一个 <code>parameter</code> 都有一个 <code>name</code> 和一个 <code>value</code>，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">name = value</span><br></pre></td></tr></tbody></table></figure><h5 id="sections"><a href="#sections" class="headerlink" title="sections"></a>sections</h5><p>所有的 <code>parameters</code> 都是以 <code>sections</code> 为单位结合在一起的。所有的 <code>section</code> 名称都是独占一行，并且 <code>sections</code> 名字都被方括号包围着（<code>[ section's name ]</code>)。</p><p>在 <code>section</code> 声明后的所有 <code>parameters</code> 都是属于该 <code>section</code>。对于一个 <code>section</code> 没有明显的结束标志符，一个 <code>section</code> 的开始就是上一个 <code>section</code> 的结束，或者是 end of the file。 <code>section</code> 如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[section]</span><br></pre></td></tr></tbody></table></figure><h5 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h5><p>在 ini 文件中注释语句是以分号 <code>;</code> 开始的。所有的所有的注释语句不管多长都是独占一行直到结束的。在分号和行结束符之间的所有内容都是被忽略的。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>项目的工具类中有之前写好的读取 <code>.ini</code> 配置文件函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// 从指定配置文件中读取指定段,指定属性的内容</span></span><br><span class="line"><span class="function">CString IM_PUBLIC_FUNCTION_ <span class="title">IM_GetConfigFileValue</span> <span class="params">( CString szFileName , CString szSegName , CString szKeyName , CString szDefault = _T(<span class="string">""</span>) , <span class="type">int</span> nMaxLength = <span class="number">512</span> )</span> </span>;</span><br><span class="line"><span class="comment">// 向指定配置文件中写入指定段,指定属性的内容</span></span><br><span class="line"><span class="function">BOOL IM_PUBLIC_FUNCTION_ <span class="title">IM_SetConfigFileValue</span> <span class="params">( CString szFileName , CString szSegName , CString szKeyName , CString szValue )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WritePrivateProfileInt IM_WritePrivateProfileInt</span></span><br><span class="line"><span class="function">BOOL IM_PUBLIC_FUNCTION_ <span class="title">IM_WritePrivateProfileInt</span> <span class="params">( LPCTSTR lpAppName , LPCTSTR lpKeyName , <span class="type">int</span> nValue , LPCTSTR lpFileName )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function">CString IM_PUBLIC_FUNCTION_ <span class="title">IM_GetPrivateProfileString</span> <span class="params">( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpDefault, LPCTSTR lpFileName , DWORD lMaxSize = <span class="number">256</span> )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> IM_PUBLIC_FUNCTION_ <span class="title">IM_GetPrivateProfileSectionMap</span><span class="params">( CString szAppName, CString szFilePath, map&lt;CString,CString&gt;&amp; mapValue )</span> </span>;</span><br><span class="line"><span class="comment">// 获取配置文件中所有的段名</span></span><br><span class="line"><span class="function"><span class="type">void</span> IM_PUBLIC_FUNCTION_ <span class="title">IM_GetPrivateProfileAppNames</span><span class="params">(<span class="type">const</span> CString &amp;szFilePath, CStringArray &amp;szAppNames)</span></span>;</span><br><span class="line"><span class="function">CString IM_PUBLIC_FUNCTION_ <span class="title">IM_GetSystemSettingProfile</span> <span class="params">()</span> </span>;</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><p>这些函数的实现则是依赖于底层 Windows 提供的 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilesection">API 接口</a>。</p><p>而在具体实践中，由于业务场景中 <code>.ini</code> 文件的 <code>parameters</code> 的 <code>value</code> 值过长，导致读取的时候出现遗漏的情况（下面以读取 <code>[DTTitleBarText]</code> 为例）：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::map&lt;CString, CString&gt; resultMap;</span><br><span class="line"><span class="built_in">IM_GetPrivateProfileSectionMap</span>(<span class="string">L"DTTitleBarText"</span>, filePath, resultMap);</span><br></pre></td></tr></tbody></table></figure><p>得到的 <code>resultMap</code> 则是缺失了一部分：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">[DTTitleBarText]</span><br><span class="line">IRB001 =          图样代码;  5;   IRB; -60;   47.5;   0; MC; 120; STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB002 =          中文名称;  5;   IRB; -85;   33.75;  0; MC; 70;  STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB003 =          中文材料;  5;   IRB; -85;   11.25;  0; MC; 70;  STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB004_ZhiLiang = 质量;      4;   IRB; -26.5; 27.5;   0; MC; 17;  STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB005_BiLi =     比例;      4;   IRB; -9;    27.5;   0; MC; 18;  STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB006 =          共张;      3.5; IRB; -15;   17.5;   0; MC; 30;  STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB007 =          第张;      3.5; IRB; -40;   17.5;   0; MC; 20;  STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB008_TuFu =     图幅;      4;   IRB; -3.5;  -2.5;   0; MC; 7;   STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB009 =          俄文名称;  5;   IRB; -85;   21.25;  0; MC; 70;  STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB010 =          俄文材料;  5;   IRB; -85;   3.75;   0; MC; 70;  STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB011 =          订货号;    4;   IRB; -60;   59;     0; MC; 120; STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB012 =          识别符号1; 4;   IRB; -47.5; 27.5;   0; MC; 5;   STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB013 =          识别符号2; 4;   IRB; -42.5; 27.5;   0; MC; 5;   STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB014 =          识别符号3; 4;   IRB; -37.5; 27.5;   0; MC; 5;   STR; 0; 11; Standard; main; ;</span><br><span class="line">IRB015 =          复印人员;  3.5; IRB; -70;  -2.5;    0; ML; 30;  STR; 0; 11; Standard; main; ;</span><br><span class="line"></span><br><span class="line">ILB001 = (左)国家标准登记号; 4; ILB; 8.5; 12.5;  90; MC; 25; STR; 0; 11; Standard; lb; ;</span><br><span class="line">ILB002 = (左)签名和日期1;    4; ILB; 8.5; 42.5;  90; MC; 35; STR; 0; 11; Standard; lb; ;</span><br><span class="line">ILB003 = (左)替代正本号;     4; ILB; 8.5; 72.5;  90; MC; 25; STR; 0; 11; Standard; lb; ;</span><br><span class="line">ILB004 = (左)副本登记号;     4; ILB; 8.5; 97.5;  90; MC; 25; STR; 0; 11; Standard; lb; ;</span><br><span class="line">ILB005 = (左)签名和日期2;    4; ILB; 8.5; 127.5; 90; MC; 35; STR; 0; 11; Standard; lb; ;</span><br><span class="line">ILB006 = (左)替代文件代号;   4; ILB; 8.5; 197;   90; MC; 60; STR; 0; 11; Standard; lb; ;</span><br><span class="line">ILB007 = (左)相应文件代号;   4; ILB; 8.5; 257;   90; MC; 60; STR; 0; 11; Standard; lb; ;</span><br><span class="line"></span><br><span class="line">ILT001 = (上)专利编号;                   3; ILT; 35;    -17.5; 0; MC; 70; STR; 0; 11; Standard; lt; ;</span><br><span class="line"><span class="deletion">-ILT002 = (上)订货号标记;                 3; ILT; 77;    -7;    0; MC; 14; STR; 0; 11; Standard; lt; ;</span></span><br><span class="line"><span class="deletion">-ILT003 = (上)相应文件决议编号和批准年份; 3; ILT; 110.5; -3.5;  0; MC; 53; STR; 0; 11; Standard; lt; ;</span></span><br><span class="line"><span class="deletion">-ILT004 = (上)本文件决议编号和批准年份;   3; ILT; 110.5; -10.5; 0; MC; 53; STR; 0; 11; Standard; lt; ;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-IRB101 = 更改区域1____; 3; IRB; -195;   37.5; 0; MC; 20; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB102 = 变更序号1;     3; IRB; -181.5; 37.5; 0; MC; 7;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB103 = 变更页码1;     3; IRB; -173;   37.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB104 = 通知单号1;     3; IRB; -156.5; 37.5; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB105 = 签名1;         3; IRB; -137.5; 37.5; 0; MC; 15; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB106 = 日期1;         3; IRB; -125;   37.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-IRB107 = 更改区域2____; 3; IRB; -195;   42.5; 0; MC; 20; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB108 = 变更序号2;     3; IRB; -181.5; 42.5; 0; MC; 7;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB109 = 变更页码2;     3; IRB; -173;   42.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB110 = 通知单号2;     3; IRB; -156.5; 42.5; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB111 = 签名2;         3; IRB; -137.5; 42.5; 0; MC; 15; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB112 = 日期2;         3; IRB; -125;   42.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-IRB113 = 更改区域3____; 3; IRB; -195;   47.5; 0; MC; 20; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB114 = 变更序号3;     3; IRB; -181.5; 47.5; 0; MC; 7;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB115 = 变更页码3;     3; IRB; -173;   47.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB116 = 通知单号3;     3; IRB; -156.5; 47.5; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB117 = 签名3;         3; IRB; -137.5; 47.5; 0; MC; 15; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB118 = 日期3;         3; IRB; -125;   47.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-IRB119 = 更改区域4____; 3; IRB; -195;   52.5; 0; MC; 20; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB120 = 变更序号4;     3; IRB; -181.5; 52.5; 0; MC; 7;  STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB121 = 变更页码4;     3; IRB; -173;   52.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB122 = 通知单号4;     3; IRB; -156.5; 52.5; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB123 = 签名4;         3; IRB; -137.5; 52.5; 0; MC; 15; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB124 = 日期4;         3; IRB; -125;   52.5; 0; MC; 10; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-IRB125=设计-文件数量;     3; IRB; -156.5; 27.5 ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB126=审核-文件数量;     3; IRB; -156.5; 22.5 ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB127=主任设计-文件数量; 3; IRB; -156.5; 17.5 ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB128=工艺-文件数量;     3; IRB; -156.5; 12.5 ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB129=标准化-文件数量;   3; IRB; -156.5; 7.5  ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br><span class="line"><span class="deletion">-IRB130=批准-文件数量;     3; IRB; -156.5; 2.5  ; 0; MC; 23; STR; 0; 11; Standard; main; ;</span></span><br></pre></td></tr></tbody></table></figure><p>直觉告诉我可能是缓冲区大小的问题，所以还是查一下微软<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilesection">官方文档</a>看一下实现比较好，可能需要自己去重新实现一下读取函数。</p><p><strong>GetPrivateProfileSection function</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetPrivateProfileSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCTSTR lpAppName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPTSTR  lpReturnedString,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCTSTR lpFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>[in] <code>lpAppName</code><br>The name of the section in the initialization file.</p></li><li><p>[out] <code>lpReturnedString</code><br>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</p></li><li><p>[in] <code>nSize</code><br>The size of the buffer pointed to by the lpReturnedString parameter, in characters.<br>The maximum profile section size is 32,767 characters.</p></li><li><p>[in] <code>lpFileName</code><br>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</p></li></ul><p>这里比较关键的地方就是这个 <code>nSize</code>，可以看到它是通过一个缓冲区大小的参数设定读取的缓冲区大小，最大可以设置为 32,767 字节。经过周工排查 <code>IM_GetPrivateProfileSectionMap</code> 的缓冲区为 2k 左右，所以需要我们重新编写函数读取。</p><p>那么首先我们先重新设定最大的缓冲区大小（也就是刚才的 32,767）：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">TCHAR buffer[<span class="number">32767</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">auto</span> profileSize = <span class="built_in">GetPrivateProfileSection</span>(appName, buffer, std::<span class="built_in">size</span>(buffer), filePath);</span><br></pre></td></tr></tbody></table></figure><p>之后则需要用一个我之前几乎没有用过的 <code>string_view</code>。C++17 中我们可以使用 <code>std::string_view</code> 来获取一个字符串的视图，字符串视图并不真正的创建或者拷贝字符串，而只是拥有一个字符串的查看功能。<code>std::string_view</code> 比 <code>std::string</code> 的性能要高很多，因为每个 <code>std::string</code> 都独自拥有一份字符串的拷贝，而 <code>std::string_view</code> 只是记录了自己对应的字符串的指针和偏移位置，当我们在只是查看字符串的函数中可以直接使用 <code>std::string_view</code> 来代替。</p><p>读取出来的 <code>buffer</code> 字符串则是以下面形式排列：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">name1 = value1 \0 name2 = value2 \0 name3 = value3 \0 ... nameN = valueN \0\0</span><br></pre></td></tr></tbody></table></figure><p>这里我的算法是用左右双指针寻找 <code>=</code> 和 <code>\0</code>，以此类推直至读取到 <code>profileSize</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> right = sv.<span class="built_in">find</span>(<span class="string">L'='</span>, left);</span><br><span class="line"><span class="keyword">if</span> (right == std::wstring_view::npos)</span><br><span class="line">    right = profileSize;</span><br><span class="line"></span><br><span class="line">std::wstring_view key = sv.<span class="built_in">substr</span>(left, right - left);</span><br></pre></td></tr></tbody></table></figure><p>左指针归零，右指针先找到 <code>=</code>。此时观察可以发现左右指针已经可以把 <code>name1</code> 读取出来了：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">name1 = value1 \0 name2 = value2 \0 name3 = value3 \0 ...</span><br><span class="line">^     ^</span><br><span class="line">l     r</span><br></pre></td></tr></tbody></table></figure><p>接着左指针移到右指针（也就是 <code>=</code> 所在位置）后面一位，右指针找到 <code>\0</code>。此时观察可以发现左右指针又可以把 <code>value1</code> 读取出来了：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">name1 = value1 \0 name2 = value2 \0 name3 = value3 \0 ...</span><br><span class="line">      ^        ^</span><br><span class="line">      l        r</span><br></pre></td></tr></tbody></table></figure><p>依此类推，最终完整实现如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::map&lt;CString, CString&gt; <span class="title">Utility::readPrivateProfile</span><span class="params">(CString appName, CString filePath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TCHAR buffer[<span class="number">32767</span>] = { <span class="number">0</span> };</span><br><span class="line">    <span class="keyword">auto</span> profileSize = <span class="built_in">GetPrivateProfileSection</span>(appName, buffer, std::<span class="built_in">size</span>(buffer), filePath);</span><br><span class="line">    std::wstring_view sv{ buffer, profileSize };</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> left = <span class="number">0</span>;</span><br><span class="line">    std::map&lt;CString, CString&gt; ret;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; profileSize)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">size_t</span> right = sv.<span class="built_in">find</span>(<span class="string">L'='</span>, left);</span><br><span class="line">        <span class="keyword">if</span> (right == std::wstring_view::npos)</span><br><span class="line">            right = profileSize;</span><br><span class="line">    </span><br><span class="line">        std::wstring_view key = sv.<span class="built_in">substr</span>(left, right - left);</span><br><span class="line">        </span><br><span class="line">        left = right + <span class="number">1</span>;</span><br><span class="line">        right = sv.<span class="built_in">find</span>(<span class="string">L'\0'</span>, left);</span><br><span class="line">        <span class="keyword">if</span> (right == std::wstring_view::npos)</span><br><span class="line">            right = profileSize;</span><br><span class="line">    </span><br><span class="line">        std::wstring_view value = sv.<span class="built_in">substr</span>(left, right - left);</span><br><span class="line">        left = right + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!key.<span class="built_in">empty</span>())</span><br><span class="line">            ret.<span class="built_in">emplace</span>(<span class="built_in">CString</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">length</span>()), <span class="built_in">CString</span>(value.<span class="built_in">data</span>(), value.<span class="built_in">length</span>()));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/116635445/Becoming-Someone-New-1-5-by-James-Lipnickas-2021&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GSTAR1/GSTAR1.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;中车大同的旧图纸转换功能的定制开发告一段落，这段时间和周工学到了很多有用的知识，特此记录这个项目学到的编程技巧和项目开发经验。&lt;/p&gt;</summary>
    
    
    
    <category term="CAD二次开发 (GStarCAD ObjectARX Dev)" scheme="https://yousazoe.top/categories/CAD%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91-GStarCAD-ObjectARX-Dev/"/>
    
    
    <category term="ObjectARX" scheme="https://yousazoe.top/tags/ObjectARX/"/>
    
  </entry>
  
  <entry>
    <title>初次体验 Github Copilot</title>
    <link href="https://yousazoe.top/archives/ff967b76.html"/>
    <id>https://yousazoe.top/archives/ff967b76.html</id>
    <published>2023-01-24T03:21:57.000Z</published>
    <updated>2023-05-05T12:43:30.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/BTZRHX.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近一段时间，AI 技术的进步则让代码补全有了更上一层楼的机会。接下来，我们为大家介绍的 Github Copilot 就是这样一款基于 AI 的代码补全工具。</p><span id="more"></span><p>我们编程时写出的代码，在未编译前通常以纯文本格式存在。因此，实际上我们能使用任何文本编辑器来编写代码，包括系统自带的记事本。但是，好的工具能够让我们事半功倍。面对复杂的工作任务，我们需要 IDE（集成开发环境）这样的生产力工具。IDE 本质上就是更高级的文本编辑器，集成了许多人性化功能来提升效率，比如：自动补全变量，提示可能会用到的函数列表，语法高亮，显示语法错误等等。</p><p>IDE 本身也在不断进化。我的第一门使用 IDE 的编程语言是 Java，使用的是 Eclipse，当时自动补全功能还比较简陋，局限于符号的提示与选单，我也没有对 IDE 究竟有多强大建立起概念。后来，开始学习开发框架后，我慢慢接触到 JetBrains 出品的 IDEA。IDEA 的提示更智能，例如：可以在数组后输入「.for」自动构成 foreach 循环，也可以使用快捷键自动生成 Getter/Setter、构造函数、重载函数等等。毫无疑问，JetBrains 系列产品为编码工作带来了更高的效率，提供了更加全面、智能的补全功能。</p><h3 id="GitHub-Copilot-是什么"><a href="#GitHub-Copilot-是什么" class="headerlink" title="GitHub Copilot 是什么"></a>GitHub Copilot 是什么</h3><p>Github Copilot 是 GitHub 和 OpenAI 合作开发的人工智能工具，可以在编辑代码时帮助你自动生成可能会需要的代码。</p><p>GitHub Copilot 能够提取代码上下文，给出整行代码或整个函数的补全建议。它可以帮助我们完成下列任务：</p><ul><li>将注释转化为代码； </li><li>自动填充重复代码； </li><li>编写测试； </li><li>快速发现解决问题的替代方法； </li><li>无需网络搜索即可快速探索新的 API； </li><li>适应用户编写代码的方式，帮助用户更快地完成工作。</li></ul><h4 id="原理是什么？"><a href="#原理是什么？" class="headerlink" title="原理是什么？"></a>原理是什么？</h4><p>我们先介绍一下 GPT-3。GPT-3（Generative Pre-trained Transformer 3）是一个用于处理自然语言的 AI 模型，由 OpenAI 训练开发。GPT-3 通过阅读几乎一切人类可阅读的内容来进行训练，理论上，它能够完成一切通过语言完成的工作，而且完成效果还非常接近人类。已经有实验证明 GPT-3 可用于撰写文章、回答问题、编写代码生成应用程序、设计表格、开发游戏、将文字描述便携为成型的网页等等。</p><p>而 OpenAI Codex 则是基于 GPT-3 开发的一款针对编程所设计的 AI 模型。Codex 从公共代码仓库学习人类编写的代码，其代码来源包括 Github 上的公共代码仓库。官网原文如下：</p><blockquote><p>OpenAI Codex is a descendant of GPT-3; its training data contains both natural language and billions of lines of source code from publicly available sources, including code in public GitHub repositories. （OpenAI Codex 是 GPT-3 的衍生项目；它的训练数据包括自然语言和数以亿计来自公开可用来源的源代码，其中包括 Github 公开仓库的代码。）</p></blockquote><p>最后，GitHub Copilot 则是使用了 Codex 进行研发的一款商业产品。Github 将算法进行包装，做成了插件和网页，进行应用分发。现在 GitHub Copilot 支持在 Visual Studio Code、Visual Studio、JetBrains Rider 上通过插件形式集成进 IDE，以便我们使用。</p><h3 id="使用-amp-体验"><a href="#使用-amp-体验" class="headerlink" title="使用 &amp; 体验"></a>使用 &amp; 体验</h3><p>要想使用 GitHub Copilot，首先需要注册一个 Github 账号。有了帐号后，按下面的步骤可以找到并启用 GitHub Copilot：</p><ol><li><strong>找到设置页面</strong>：在任何页面的右上角，单击个人资料照片，然后单击“设置”。</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/YeXRqN.jpg"></p><ol start="2"><li><p><strong>找到 GitHub Copilot 设置页面</strong>：在边栏的「代码、规划和自动化」部分，单击「GitHub Copilot」。</p></li><li><p><strong>启用 GitHub Copilot</strong>：在 GitHub Copilot 设置页面上，单击「启用 GitHub Copilot」。</p></li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/vtDoan.jpg"></p><ol start="4"><li><strong>选择付费方式（月付/年付）</strong>：GitHub Copilot 可以免费试用 60 个自然日，随后需要以 $10/月 的价格订阅。如果你是学生的话，可享受教育优惠，免费使用 GitHub Copilot。</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/6CHQ0X.jpg"></p><h4 id="在-Rider-IDE-进行设置"><a href="#在-Rider-IDE-进行设置" class="headerlink" title="在 Rider IDE 进行设置"></a>在 Rider IDE 进行设置</h4><ol><li>在偏好设置里安装 Github Copilot Plugin； </li><li>重启 IDE； </li><li>登陆 Github 完成验证。</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/LIJYV8.jpg"></p><p>设置完成后，IDE 提示可以使用「Tab」来自动补全代码，使用「⌥ + ]」或者「⌥ + [」来选择其他候选的补全选项。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/k8KwOS.jpg"></p><h4 id="体验如何"><a href="#体验如何" class="headerlink" title="体验如何"></a>体验如何</h4><p>在编写代码的过程中，Github Copilot 会自动提示可能的补全方案，此时按下「Tab」即可完成补全。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/exmaple.gif"></p><p>有时，AI 并不会一次给出完整的提示代码，例如，图示的代码就并非一次性生成的，而是逐行自动补全，最终生成了一个可以实际使用的函数（甚至包括注释）。下图的例子在 Unity3D 中绘制了一条射线用于检测前方是否有物品，只有第一行注释是我写下的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/jgOixr.jpg"></p><p>下面的例子很有趣：当我尝试把乐谱的音高编写成数组时，Github Copilot 也给出了他所理解的音乐：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/qICjGP.jpg"></p><p>在这样的例子中，对重复的流行乐片段，Github Copilot 有时可以给出不错的答案。比如预先输入《卡农》的重复性模进片段，Github Copilot 往往可以完全正确地补全乐谱。可见，在面临重复性较高的功能开发，或是使用一些常用的算法时，依靠 AI 补全是一个称得上非常可靠的选择。不过，如果需求非常复杂，大部分情况下，它并不能独立地给出完美的解决方案。GitHub 团队在对一组 Python 函数进行基准性测试后发现尝试十次后，大约 57% 情况下可以给出正确的答案。部分情况下，Github Copilot 也会给出无法通过编译的代码。</p><h3 id="Github-Copilot-的不足之处"><a href="#Github-Copilot-的不足之处" class="headerlink" title="Github Copilot 的不足之处"></a>Github Copilot 的不足之处</h3><p>使用 Github Copilot 很久后，Reddit 大佬 Colin Eberhardt 指出了几点不足：</p><ol><li>Github Copilot 很多时候响应得不够快。虽然它已经快到秒出答案，但这对快速输出状态的程序员来说仍然是不够的。要么它的提示还没出现你就继续输入了，要么你会因为等它而暂时停下思路。 </li><li>Github Copilot 总是会自动提示。这种提示和输入存在冲突：有时，当你需要等等看提示怎么说另一些时，会不断有内容弹出，接着消失。或许，自动模式并不是 Github Copilot 的「最佳打开方式」？ </li><li>Github Copilot 生成代码质量不足。它生成的代码可以满足大部分简单且重复的功能需求，但对于熟练的程序员，可能会额外浪费很多精力来校验它自动生成的代码是否正确。</li></ol><h4 id="Github-Copilot-版权问题"><a href="#Github-Copilot-版权问题" class="headerlink" title="Github Copilot 版权问题"></a>Github Copilot 版权问题</h4><p>许多人指出 Github Copilot 会使用有版权的代码作为提示内容（参见 Jacob Crume 的文章“GitHub Copilot is Now Available for All and Not Everyone Likes It”）。少数派作者 100gle 在《GitHub Copilot：革命未竟，未来可期》中更是举出了很多例子。最为出名的莫过于，如果你在编辑器中输入 <code>Fast inverse square root</code>，便会得到一段代码，它和当年《雷神之锤》使用的算法完全一致。</p><p>现代开源软件多使用 GPL （GNU General Public License）协议，这个协议要求你也将代码开源，且使用 GPL 协议。而通过 Github Copilot 补全时我们并不确定这段代码的作者为它指定的协议。开源许可证的主要作用是对软件的使用、复制、修改和再发布等进行限制。而显然使用 AI 补全显然会破坏这一点。</p><p>可以预见的是，同当今各种 AI 作画工具面对的种种争议一样，Github Copilot 也一定会因为版权问题，难以被大型企业所用，至少短期内如此。</p><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul><li>Github Copilot 能帮助初学者面对不那么熟悉的编程语言或开发框架时，快速学习常用的接口调用方式和简单的实现方案。这意味着我们可以不用为了某些基础问题反复翻找 API 手册，或体验 CSDN 这样的技术博客网站的层层传送门。 </li><li>Github Copilot 可以帮助我们在不熟悉的领域快速上手，只需要一些注释便可快速生成部分业务逻辑，然后进行测试。当然，最终代码的可靠性还是需要开发者人为辨别和控制。 </li><li>Github Copilot 可以在重复性劳动时显著提升效率。比如你需要写一大堆单元测试，它们无法靠复制/粘贴批量生成，同时有一些细微的逻辑变化需要处理。又或是你需要开发一些重复性功能，比如批量声明一些数据类型好几十次。这时 Github Copilot 补全的代码往往很可靠。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Github Copilot 或许并不能承载类似“AI 即将取代程序员”的想象，但在当下，它无疑是程序员的好帮手。作为辅助，它提供的补全并没有智能到让完全不会编程的用户完成开发，但也并不只是简单的提示工具。合理运用 Github Copilot 能够为开发者的学习成长带来很大帮助。</p><p>与此同时，它不可避免地存在一些缺陷，代码的版权问题也限制了它商业化的应用前景。不够熟练的程序员可能也会对它失望——就像它名字中的 Copilot 一样，Github Copilot 更接近优秀的副驾驶角色，但工作总归还是需要一位优秀的主驾驶领导。</p><p>最好的旅行靴已经送到我们手中，走出什么样的路还需要开发者自己去定夺。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CODE5/BTZRHX.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;最近一段时间，AI 技术的进步则让代码补全有了更上一层楼的机会。接下来，我们为大家介绍的 Github Copilot 就是这样一款基于 AI 的代码补全工具。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧 (Coding Skill)" scheme="https://yousazoe.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-Coding-Skill/"/>
    
    
    <category term="Github Copilot" scheme="https://yousazoe.top/tags/Github-Copilot/"/>
    
  </entry>
  
  <entry>
    <title>Jetbrains IDE 开发环境激活方式记录</title>
    <link href="https://yousazoe.top/archives/a906a6fe.html"/>
    <id>https://yousazoe.top/archives/a906a6fe.html</id>
    <published>2023-01-15T04:46:31.000Z</published>
    <updated>2023-05-05T12:43:30.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_jetbrains-banner.png"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Jetbrains 全家桶开发还是比较顺手的，但工作之后学生认证到期了，所以需要重新激活，特此写一篇博文记录自己使用 Jetbrains 产品的各种激活方式。</p><span id="more"></span><blockquote><p>需要提前声明，Jetbrains 也提供了社区版供学生和初学者使用，本文仅作激活操作记录，使用激活的软件请勿用作商业用途，如有条件请务必支持正版购买许可证。 </p></blockquote><h3 id="学生认证"><a href="#学生认证" class="headerlink" title="学生认证"></a>学生认证</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/007S8ZIlly1gf3sypo104j31hc0u0ae8.jpg"></p><p>Github 的学生认证可以通过上传学校信息的方式获取正规免费的许可，在 <a href="https://www.yousazoe.top/archives/e8e3308a.html">Unity Student Plan 申请指南</a> 这篇文章有详细操作。</p><p>如果是在读学生，完全可以用这种方式激活 Jetbrains 相关产品。</p><h3 id="注册机激活"><a href="#注册机激活" class="headerlink" title="注册机激活"></a>注册机激活</h3><p>不推荐这种激活方式。</p><p>之前我使用这种方式激活，因为之前有一些相关文件未删除，会导致整个软件闪退无法使用，在 Mac 上折腾了很长一段时间。</p><h3 id="服务器激活"><a href="#服务器激活" class="headerlink" title="服务器激活"></a>服务器激活</h3><p>先打开这个网站：<a href="https://search.censys.io/">https://search.censys.io/</a></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_censys-website.png"></p><p>然后搜索框输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">services.http.response.headers.location: account.jetbrains.com/fls-auth</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_censys-search.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_censys-search-result.png"></p><p>选择第一个搜索结果，右击进去：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13-censys-server.png"></p><p>将网址到 Jetbrains，选择许可证服务器 <code>/License server</code>，粘贴刚刚复制的网址 <code>http://134.53.225.196</code>，激活。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_licenses%20active.png"></p><p>大功告成，顺带一提，这个好像是迈阿密大学的服务器……</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_jetbrains-banner.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Jetbrains 全家桶开发还是比较顺手的，但工作之后学生认证到期了，所以需要重新激活，特此写一篇博文记录自己使用 Jetbrains 产品的各种激活方式。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建 (Blog Building)" scheme="https://yousazoe.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Blog-Building/"/>
    
    
    <category term="Blog" scheme="https://yousazoe.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>GStarCAD C++笔试&amp;机试&amp;面试总结</title>
    <link href="https://yousazoe.top/archives/2fcb9e48.html"/>
    <id>https://yousazoe.top/archives/2fcb9e48.html</id>
    <published>2023-01-01T05:43:05.000Z</published>
    <updated>2023-05-05T12:43:30.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/117842739/Low-Poly-Game-Assets"><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE4/CODE4.png"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>GStarCAD 笔试和机试总结。笔试题主要考核 C++、代码阅读理解、基本几何运算、英文阅读能力，机试题主要考察 VC++、MFC 的实际编程操作能力。</p><span id="more"></span><h3 id="笔试部分"><a href="#笔试部分" class="headerlink" title="笔试部分"></a>笔试部分</h3><p>笔试题主要考核 C++、代码阅读理解、基本几何运算、英文阅读能力。</p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>下列代码有问题、或有可改进之处吗？如有，请直接修改，并写明原因.</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span></span><br><span class="line">{</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CBase</span>(){m_nVal = <span class="number">100</span>;}</span><br><span class="line">    ~<span class="built_in">CBase</span>(){}</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>{<span class="keyword">return</span> m_nVal;}</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetDouble</span><span class="params">()</span> <span class="type">const</span> </span>{m_nVal *= <span class="number">3</span>; <span class="keyword">return</span> m_nVal;}</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_nVal;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CBase base;</span><br><span class="line">    std::cout &lt;&lt; “val = ”&lt;&lt; base.<span class="built_in">GetDouble</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><p>答：<code>int GetDouble() const {m_nVal *= 3; return m_nVal;}</code> 若需要对成员变量进行赋值需删除 <code>const</code>。</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>请写出 <code>main</code> 函数的输出结果，并写明理由.</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span></span><br><span class="line">{</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">voidSend</span><span class="params">()</span></span>{std::cout &lt;&lt; <span class="string">"\nSend :"</span>&lt;&lt; m_nVal &lt;&lt; std::endl;}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">()</span></span>{<span class="built_in">Send</span>();}</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_nVal;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CUser</span> : <span class="keyword">public</span> CBase</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CUser</span>(){m_nVal = <span class="number">101</span>;}</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">voidSend</span><span class="params">()</span></span>{m_nVal++;std::cout &lt;&lt; “\nSend :”&lt;&lt;m_nVal&lt;&lt; std::endl;}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">()</span></span>{CBase::<span class="built_in">Send</span>();}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CUser user;</span><br><span class="line">    CBase &amp;base=user;</span><br><span class="line">    base.<span class="built_in">Send</span>();<span class="comment">//输出：</span></span><br><span class="line">    CBase *pBase=&amp;base;</span><br><span class="line">    pBase-&gt;<span class="built_in">Output</span>();<span class="comment">//输出：</span></span><br><span class="line">    user.<span class="built_in">Output</span>();<span class="comment">//输出:</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Send：102</span><br><span class="line">Send：103</span><br><span class="line">Send：103</span><br></pre></td></tr></tbody></table></figure><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>阅读理解类声明代码，并使用之实现功能。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AcGePoint2d</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AcGePoint2d</span>();</span><br><span class="line">    <span class="built_in">AcGePoint2d</span>(<span class="type">double</span> x, <span class="type">double</span> y);</span><br><span class="line">    <span class="function">AcGePoint2d&amp; <span class="title">set</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AcGeLinearEnt2d</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">boolintersectWith</span>(<span class="type">const</span> AcGeLinearEnt2d&amp; line, AcGePoint2d&amp; intPnt,<span class="type">const</span> AcGeTol&amp; tol = AcGeContext::gTol) <span class="type">const</span>;<span class="comment">//求直线交点函数</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">AcGeLinearEnt2d</span> ();</span><br><span class="line">    <span class="built_in">AcGeLinearEnt2d</span> (<span class="type">const</span> AcGeLinearEnt2d&amp;);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AcGeLineSeg2d</span>: <span class="keyword">public</span> AcGeLinearEnt2d</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:<span class="built_in">AcGeLineSeg2d</span> ();</span><br><span class="line">  <span class="built_in">AcGeLineSeg2d</span> (<span class="type">const</span> AcGeLineSeg2d &amp; line);</span><br><span class="line">  <span class="built_in">AcGeLineSeg2d</span> (<span class="type">const</span> AcGePoint2d&amp; pnt1, <span class="type">const</span> AcGePoint2d&amp; pnt2);</span><br><span class="line">  <span class="function">AcGeLineSeg2d &amp; <span class="title">set</span> <span class="params">(<span class="type">const</span> AcGePoint2d&amp; pnt1, <span class="type">const</span> AcGePoint2d&amp; pnt2)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//请使用上述类和类成员函数，在本函数中实现两直线段求交点，并输出。</span></span><br><span class="line">    <span class="comment">//这两个直线段分别是从点(0,0) 到(500,500); 从点(600,0) 到(200,900)。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h5><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class AcGePoint2d</span><br><span class="line">{</span><br><span class="line">  public:</span><br><span class="line">    AcGePoint2d();</span><br><span class="line">    AcGePoint2d(double x, double y);</span><br><span class="line">    AcGePoint2d&amp; set(double x, double y);</span><br><span class="line">    </span><br><span class="line">    double x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class AcGeLinearEnt2d</span><br><span class="line">{</span><br><span class="line">  public:</span><br><span class="line">    boolintersectWith(const AcGeLinearEnt2d&amp; line, AcGePoint2d&amp; intPnt,const AcGeTol&amp; tol = AcGeContext::gTol) const;//求直线交点函数</span><br><span class="line">   </span><br><span class="line">  protected:</span><br><span class="line">    AcGeLinearEnt2d ();</span><br><span class="line">    AcGeLinearEnt2d (const AcGeLinearEnt2d&amp;);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class AcGeLineSeg2d: public AcGeLinearEnt2d</span><br><span class="line">{</span><br><span class="line">  public:AcGeLineSeg2d ();</span><br><span class="line">  AcGeLineSeg2d (const AcGeLineSeg2d &amp; line);</span><br><span class="line">  AcGeLineSeg2d (const AcGePoint2d&amp; pnt1, const AcGePoint2d&amp; pnt2);</span><br><span class="line">  AcGeLineSeg2d &amp; set (const AcGePoint2d&amp; pnt1, const AcGePoint2d&amp; pnt2);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">{</span><br><span class="line">    //请使用上述类和类成员函数，在本函数中实现两直线段求交点，并输出。</span><br><span class="line">    //这两个直线段分别是从点(0,0) 到(500,500); 从点(600,0) 到(200,900)。</span><br><span class="line"></span><br><span class="line"><span class="addition">+   AcGeLineSeg2dline1(AcGePoint2d(0,0),AcGePoint2d(500,500));</span></span><br><span class="line"><span class="addition">+   AcGeLineSeg2dline2(AcGePoint2d(600,0),AcGePoint2d(200,900));</span></span><br><span class="line"><span class="addition">+   AcGePoint2d pt;Line1.intersectWith(line2,pt);</span></span><br><span class="line"><span class="addition">+   Printf(“x:%.2f,y:%.2f”,pt.x,pt.y);</span></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>基本几何运算。</p><ol><li>已知两点 <code>pt1</code>,<code>pt2</code>，如何计算从起点 <code>pt1</code> 到终点 <code>pt2</code> 的向量 <code>v</code>？</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">V = pt2 - pt1</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>已知向量 <code>v1{1.0,0.0,0.0}</code>,<code>v2{0.0,1.0,0.0}</code>，<code>v3 = v1 - v2</code> ，则v3 =？</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{1.0,-1.0,0.0}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>已知向量v1{1.0,0.0,0.0},v2{0.0,1.0,0.0}，v3=v1×v2 ，则v3=？</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{0.0,0.0,1.0}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>两向量的点积 <code>v1·v2</code> 等于 0 ，意味着两向量是什么关系？</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">垂直</span><br></pre></td></tr></tbody></table></figure><h4 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h4><p>翻译英文资料。</p><blockquote><p>An ObjectARXapplication  is  a  dynamic  link  library  (DLL)  that  shares  the  address  space  of AutoCAD  and  makes  direct  function  calls  to AutoCAD.  You  can  add  new  classes  to  the ObjectARXprogram environment and export them for use by other programs. </p></blockquote><p>一个 ObjectARX 应用是一个的动态链接库（DLL），它共享 AutoCAD 地址空间，并直接调用函数操作 AutoCAD。你可以在 ObjectARX 程序环境中新增新的类，并将其导出给其他程序使用。</p><blockquote><p><code>CDialog::DoModal()</code> Call  this  member  function  to  invoke  the  modal  dialog  box  and return the dialog-box result when done. This member function handles all interaction with the user while the dialog box is active.</p></blockquote><p><code>CDialog::DoModal()</code>，使用这一成员函数可调出模态对话框，并且当其使用完成后可返回对话框的结果。当对话框激活时，这一成员函数处理所有与用户的交互。</p><blockquote><p>AutoCADstores  the  values  for  its  operating  environment  in  system  variables.  Each  system variable  has  an  associated  type:  integer,  real,  point,  or  text  string.  You  can  examine  any  system variable  and  change  any  writable  system  variable  directly  on  the  command  line  by  entering  the system variable name. Many system variables are also accessible through dialog box options.</p></blockquote><p>AutoCAD 保存与操作环境相关的值于系统变量中。每个系统变量有一个相关类型：整形，实型，点或字符串。你可以检测任何系统变量，并通过在命令行输入系统变量名称直接改变系统变量。许多系统变量也可以通过对话框选项设置。</p><h3 id="机试部分"><a href="#机试部分" class="headerlink" title="机试部分"></a>机试部分</h3><p>机试题主要考察 VC++、MFC 的实际编程操作能力。</p><h4 id="控件窗口操作"><a href="#控件窗口操作" class="headerlink" title="控件窗口操作"></a>控件窗口操作</h4><ul><li>新建基于对话框的 MFC 工程。</li><li>定义 <code>CEdit</code> 的派生类 <code>CMyEdit</code>。在 <code>CMyEdit</code> 类中定义成员函数 <code>void  SetIndex（int index）</code>，调用本函数后，编辑框内显示 <code>index</code> 数值。</li><li>对话框初始创建4个大小不一的控件，分别是：<code>CMyEdit</code>、<code>CButton</code>、<code>CComboBox</code>、<code>CEdit</code>，分别对齐对话框4个角。</li><li>在对话框类内定义一个指针数组成员变量：<code>CArray&lt;CWnd*&gt;  m_arrCtrl</code>，并在对话框初始化时将上述4控件的对象指针按逆时针顺序保存到 <code>m_arrCtrl</code> 数组（第1个为左上角控件）。</li><li>对话框窗口支持调整大小，对话框窗口大小改变后，4个控件大小不变，但位置自动跟随调整（总是对齐4个角）。</li><li>每隔1秒，沿逆时针方向自动旋转切换上述4个控件位置（控件大小不变，只是位置改变，左上角控件跑到左下角，左下角跑到右下角，以此类推），<code>m_arrCtrl</code> 中控件指针也同步切换位置（第1个始终是左上角控件）。每次切换控件位置后，需从指针数组中找到其中唯一的 <code>CMyEdit</code> 控件，并调用它的 <code>SetIndex(index)</code>成员函数，<code>index</code> 为 <code>CMyEdit</code> 对象在 <code>m_arrCtrl</code> 数组中的新索引（0-3）。</li><li><strong>注：对话框内可以定义其它成员变量，但除对话框的构造函数、<code>DoDataExchange</code> 和 <code>OnInitDialog</code> 函数外，对话框其它函数中只能使用 <code>m_arrCtrl</code> 成员变量，不能使用其它成员变量（也不能使用全局变量和静态变量）。</strong></li></ul><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><ul><li>新建基于对话框的 MFC 工程。</li><li>在对话框上绘制一个编辑框和一个排序按钮。</li><li>编辑框内可输入一系列的数，用空格分开。单击排序按钮，则对这些数由小到大排序，并重新显示在编辑框中。</li><li><strong>注：需自写排序算法。</strong></li></ul><h4 id="目录浏览"><a href="#目录浏览" class="headerlink" title="目录浏览"></a>目录浏览</h4><ul><li>新建基于对话框的 MFC 工程。</li><li>对话框左侧显示一个树控件，显示一个两层目录，一级目录为学校，二级为班级。对话框右侧显示一个 <code>LISTBOX</code>。</li><li>当在左侧选中不同的学校或班级，右侧 <code>LISTBOX</code> 刷新显示为本学校或本班级的所有学生姓名。</li></ul><h3 id="面试部分"><a href="#面试部分" class="headerlink" title="面试部分"></a>面试部分</h3><ul><li>简单做一个自我介绍 </li><li>什么时候开始学习 C++ 和开始使用 VC++</li><li>MFC 方面实际使用过哪些类</li><li>描述链表和数组的区别、优缺点，用过链表没，是否用过和了解 STL::map</li><li>英语是否过了4级，阅读过MSDN的英文材料有没有问题</li><li>目前还掌握了什么开发技能，是否自学的</li><li>是否接触过 CAD 软件</li><li>简单描述一个最能体现自身技术能力的典型项目或程序的实现</li><li>感兴趣、爱好、热爱，对于编程，你属于哪一种？为什么？</li><li>是否有哪方面能力特别优秀，在这方面特自信，自认为超过自己周围的人？</li><li>评价一下自己有哪些缺点</li><li>有什么兴趣爱好</li><li>后续有什么职业规划</li><li>转正薪资要求？试用期 3 个月是 80%</li><li>对于我们公司和这份工作有什么需要了解的</li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/117842739/Low-Poly-Game-Assets&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CODE4/CODE4.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;GStarCAD 笔试和机试总结。笔试题主要考核 C++、代码阅读理解、基本几何运算、英文阅读能力，机试题主要考察 VC++、MFC 的实际编程操作能力。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧 (Coding Skill)" scheme="https://yousazoe.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-Coding-Skill/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Google开源项目C++风格指南</title>
    <link href="https://yousazoe.top/archives/bf0a0e19.html"/>
    <id>https://yousazoe.top/archives/bf0a0e19.html</id>
    <published>2022-10-23T14:12:06.000Z</published>
    <updated>2022-11-21T13:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE3/X4uzvL.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码。但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交者造成不小的困扰。Google 因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google 的编程风格。</p><span id="more"></span><p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.</p><p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p><p>风格, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p><p>使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.</p><p>本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.</p><p>Google 主导的开源项目均符合本指南的规定.</p><p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>通常每一个 <code>.cc</code> 文件都有一个对应的 <code>.h</code> 文件. 也有一些常见例外, 如单元测试代码和只包含 <code>main()</code> 函数的 <code>.cc</code> 文件.</p><p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p><p>下面的规则将引导你规避使用头文件时的各种陷阱.</p><h4 id="Self-contained-头文件"><a href="#Self-contained-头文件" class="headerlink" title="Self-contained 头文件"></a>Self-contained 头文件</h4><blockquote><p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code>.h</code> 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code> 头文件的做法.</p></blockquote><p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 <code>#define</code> 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.</p><p>不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 <code>.inc</code> 文件扩展名。</p><p>如果 <code>.h</code> 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 <code>.cc</code> 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 <code>-inl.h</code> 文件里（译者注：过去该规范曾提倡把定义放到 <code>-inl.h</code> 里过）。</p><p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 <code>.cc</code> 文件里。</p><h4 id="define-保护"><a href="#define-保护" class="headerlink" title="#define 保护"></a>#define 保护</h4><blockquote><p>所有头文件都应该有 <code>#define</code> 保护来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code> .</p></blockquote><p>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 <code>foo</code> 中的头文件 <code>foo/src/bar/baz.h</code> 可按如下方式保护:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><blockquote><p>尽可能地避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</p></blockquote><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul><li>前置声明能够节省编译时间，多余的 <code>#include</code> 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 <code>#include</code> 使代码因为头文件中无关的改动而被重新编译多次。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li></ul><ul><li>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li><li>前置声明来自命名空间 <code>std::</code> 的 symbol 时，其行为未定义。</li><li>很难判断什么时候该用前置声明，什么时候该用 <code>#include</code> 。极端情况下，用前置声明代替 <code>#include</code> 甚至都会暗暗地改变代码的含义：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// b.h:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> {};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B {};</span><br><span class="line"></span><br><span class="line"><span class="comment">// good_user.cc:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"b.h"</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>{ <span class="built_in">f</span>(x); }  <span class="comment">// calls f(B*)</span></span><br></pre></td></tr></tbody></table></figure><p>如果 <code>#include</code> 被 <code>B</code> 和 <code>D</code> 的前置声明替代， <code>test()</code> 就会调用 <code>f(void*)</code> .</p><ul><li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 <code>include</code> 冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li></ul><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><blockquote><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p></blockquote><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p><p>另一个实用的经验准则: 内联那些包含循环或 <code>switch</code> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <code>switch</code> 语句从不被执行).</p><p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p><h4 id="include-的路径及顺序"><a href="#include-的路径及顺序" class="headerlink" title="#include 的路径及顺序"></a><code>#include</code> 的路径及顺序</h4><blockquote><p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.</p></blockquote><p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <code>.</code> (当前目录) 或 <code>..</code> (上级目录). 例如, <code>google-awesome-project/src/base/logging.h</code> 应该按如下方式包含:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"base/logging.h"</span></span></span><br></pre></td></tr></tbody></table></figure><p>又如, <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p><blockquote><ol><li><code>dir2/foo2.h</code> (优先位置, 详情如下)</li><li>C 系统文件</li><li>C++ 系统文件</li><li>其他库的 <code>.h</code> 文件</li><li>本项目内 <code>.h</code> 文件</li></ol></blockquote><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p><code>dir/foo.cc</code> 和 <code>dir2/foo2.h</code> 通常位于同一目录下 (如 <code>base/basictypes_unittest.cc</code> 和 <code>base/basictypes.h</code>), 但也可以放在不同目录下.</p><p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p><p>您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，前置声明 (forward declarations) 情况除外。比如您要用到 <code>bar.h</code> 中的某个符号, 哪怕您所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code> 就够了，不用再管后者所包含的其它内容。</p><p>举例来说, <code>google-awesome-project/src/foo/internal/fooserver.cc</code> 的包含次序如下:</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"foo/public/fooserver.h"</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"base/basictypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"base/commandlineflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"foo/public/bar.h"</span></span></span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>例外：</strong></p><p>有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"foo/public/fooserver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"base/port.h"</span>  <span class="comment">// For LANG_CXX11.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LANG_CXX11</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// LANG_CXX11</span></span></span><br></pre></td></tr></tbody></table></figure></blockquote><h5 id="译者-YuleFox-笔记"><a href="#译者-YuleFox-笔记" class="headerlink" title="译者 (YuleFox) 笔记"></a>译者 (YuleFox) 笔记</h5><ol><li>避免多重包含是学编程时最基本的要求;</li><li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li><li>内联函数的合理使用可提高代码执行效率;</li><li><code>-inl.h</code> 可提高代码可读性 (一般用不到吧:D);</li><li>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li><li>包含文件的名称使用 <code>.</code> 和 <code>..</code> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</li></ol><h5 id="译者（acgtyrant）笔记"><a href="#译者（acgtyrant）笔记" class="headerlink" title="译者（acgtyrant）笔记"></a>译者（acgtyrant）笔记</h5><ol><li>原来还真有项目用 <code>#includes</code> 来插入文本，且其文件扩展名 <code>.inc</code> 看上去也很科学。</li><li>Google 已经不再提倡 <code>-inl.h</code> 用法。</li><li>注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li><li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 <code>.cc</code> 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li><li>在 <code>#include</code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code>.h</code> 和本项目内的 <code>.h</code> 是个好习惯。</li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>鼓励在 <code>.cc</code> 文件内使用匿名命名空间或 <code>static</code> 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层.</p><p>举例来说, 两个不同项目的全局作用域都有一个类 <code>Foo</code>, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, <code>project1::Foo</code> 和 <code>project2::Foo</code> 作为不同符号自然不会冲突.</p><p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X {</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y {</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">}  <span class="comment">// namespace Y</span></span><br><span class="line">}  <span class="comment">// namespace X</span></span><br></pre></td></tr></tbody></table></figure><p><code>X::Y::foo()</code> 与 <code>X::foo()</code> 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>命名空间具有迷惑性, 因为它们使得区分两个相同命名所指代的定义更加困难。</p><p>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p><p>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。</p><p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</p><h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>根据下文将要提到的策略合理使用命名空间.</p><ul><li>遵守命名空间命名中的规则。</li><li>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</li><li>用命名空间把文件包含, <a href="https://gflags.github.io/gflags/">gflags</a> 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:<blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace {</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">} <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace {</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">} <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></tbody></table></figure><p>更复杂的 <code>.cc</code> 文件包含更多, 更复杂的细节, 比如 gflags 或 using 声明。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"a.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_FLAG</span>(<span class="type">bool</span>, someflag, <span class="literal">false</span>, <span class="string">"dummy flag"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> a {</span><br><span class="line"></span><br><span class="line">...code <span class="keyword">for</span> a...                <span class="comment">// 左对齐</span></span><br><span class="line"></span><br><span class="line">} <span class="comment">// namespace a</span></span><br></pre></td></tr></tbody></table></figure></blockquote></li><li>不要在命名空间 <code>std</code> 内声明任何东西, 包括标准库的类前置声明. 在 <code>std</code> 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</li><li>不应该使用 <em>using 指示</em> 引入整个命名空间的标识符号。<blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止 —— 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li>不要在头文件中使用 <em>命名空间别名</em> 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。<blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .cc 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .h 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> librarian {</span><br><span class="line"><span class="keyword">namespace</span> impl {  <span class="comment">// 仅限内部使用</span></span><br><span class="line"><span class="keyword">namespace</span> sidetable = ::pipeline_diagnostics::sidetable;</span><br><span class="line">}  <span class="comment">// namespace impl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// 限制在一个函数中的命名空间别名</span></span><br><span class="line">  <span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line">}  <span class="comment">// namespace librarian</span></span><br></pre></td></tr></tbody></table></figure></blockquote></li><li>禁止用内联命名空间</li></ul><h4 id="匿名命名空间和静态变量"><a href="#匿名命名空间和静态变量" class="headerlink" title="匿名命名空间和静态变量"></a>匿名命名空间和静态变量</h4><blockquote><p>在 <code>.cc</code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p></blockquote><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 <code>static</code> 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p><h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h5><p>推荐、鼓励在 <code>.cc</code> 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 <code>.h</code> 中使用。</p><p>匿名命名空间的声明和具名的格式相同，在最后注释上 <code>namespace</code> :</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> {</span><br><span class="line">...</span><br><span class="line">}  <span class="comment">// namespace</span></span><br></pre></td></tr></tbody></table></figure><h4 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h4><blockquote><p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p></blockquote><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点:"></a>优点:</h5><p>某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域.</p><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.</p><h5 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h5><p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 2.1. 命名空间。举例而言，对于头文件 <code>myproject/foo_bar.h</code> , 应当使用</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject {</span><br><span class="line"><span class="keyword">namespace</span> foo_bar {</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">}  <span class="comment">// namespace foo_bar</span></span><br><span class="line">}  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></tbody></table></figure><p>而非</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject {</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line">}  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></tbody></table></figure><p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p><p>如果你必须定义非成员函数, 又只是在 <code>.cc</code> 文件中使用它, 可使用匿名 2.1. 命名空间 或 <code>static</code> 链接关键字 (如 <code>static&nbsp;int&nbsp;Foo()&nbsp;{...}</code>) 限定其作用域.</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><blockquote><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p></blockquote><p>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 坏——初始化和声明分离</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 好——初始化时声明</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>, <span class="number">2</span>}; <span class="comment">// 好——v 一开始就初始化</span></span><br></pre></td></tr></tbody></table></figure></blockquote><p>属于 <code>if</code>, <code>while</code> 和 <code>for</code> 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">'/'</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure></blockquote><p>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) {</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在循环作用域外面声明这类变量要高效的多:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) {</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h4><blockquote><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p></blockquote><p>禁止使用类的静态储存周期变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 <code>constexpr</code> 变量除外，毕竟它们又不涉及动态初始化或析构。</p><p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p><p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 <code>getenv()</code> 或 <code>getpid()</code> ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p><blockquote><p>Xris 译注:</p><p>同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。</p></blockquote><p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 <code>main()</code> 返回还是对 <code>exit()</code> 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p><p>改善以上析构问题的办法之一是用 <code>quick_exit()</code> 来代替 <code>exit()</code> 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 <code>atexit()</code> 所绑定的任何 handlers. 如果您想在执行 <code>quick_exit()</code> 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 <code>_at_quick_exit()</code>. 如果您想在 <code>exit()</code> 和 <code>quick_exit()</code> 都用上该 handler, 都绑定上去。</p><p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 <code>vector</code> (使用 C 数组替代) 和 <code>string</code> (使用 <code>const&nbsp;char[]</code>)。</p><p>如果您确实需要一个 <code>class</code> 类型的静态或全局变量，可以考虑在 <code>main()</code> 函数或 <code>pthread_once()</code> 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p><blockquote><p>Yang.Y 译注:</p><p>上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</p></blockquote><h4 id="译者-YuleFox-笔记-1"><a href="#译者-YuleFox-笔记-1" class="headerlink" title="译者 (YuleFox) 笔记"></a>译者 (YuleFox) 笔记</h4><ol><li><code>cc</code>中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用<code>using</code> 关键字污染命名空间;</li><li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code>public</code>;</li><li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</li><li>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</li><li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</li></ol><h4 id="译者（acgtyrant）笔记-1"><a href="#译者（acgtyrant）笔记-1" class="headerlink" title="译者（acgtyrant）笔记"></a>译者（acgtyrant）笔记</h4><ol><li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li><li>匿名命名空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li><li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li><li>注意别在循环犯大量构造和析构的低级错误。</li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><h5 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h5><p>我们倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空.</p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>C++ 函数由返回值提供天然的输出， 有时也通过输出参数（或输入/输出参数）提供. 我们倾向于使用返回值而不是输出参数： 它们提高了可读性， 并且通常提供相同或更好的性能.</p><p>C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 非可选输入参数通常是值参或 <code>const</code> 引用, 非可选输出参数或输入/输出参数通常应该是引用 （不能为空）. 对于可选的参数， 通常使用 <code>std::optional</code> 来表示可选的按值输入， 使用 <code>const</code> 指针来表示可选的其他输入． 使用非常量指针来表示可选输出和可选输入/输出参数．</p><p>避免定义需要 <code>const</code> 引用参数去超出生命周期的函数， 因为 <code>const</code> 引用参数与临时变量绑定． 相反， 要找到某种方法来消除生命周期要求 （例如， 通过复制参数）， 或者通过 <code>const</code> 指针传递它并记录生命周期和非空要求.</p><p>在排序函数参数时， 将所有输入参数放在所有输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.</p><p>这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.</p><h4 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h4><h5 id="总述-1"><a href="#总述-1" class="headerlink" title="总述"></a>总述</h5><p>我们倾向于编写简短, 凝练的函数.</p><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p><p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.</p><p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p><h4 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h4><h5 id="总述-2"><a href="#总述-2" class="headerlink" title="总述"></a>总述</h5><p>所有按引用传递的参数必须加上 <code>const</code>.</p><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code>int&nbsp;foo(int* pval)</code>. 在 C++ 中, 函数还可以声明为引用参数: <code>int&nbsp;foo(int&nbsp;&amp;val)</code>.</p><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><p>定义引用参数可以防止出现 <code>(*pval)++</code> 这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针.</p><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p><h5 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h5><p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">const</span> string &amp;in, string *out)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code>const</code> 引用, 输出参数为指针. 输入参数可以是 <code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数, 除非特殊要求, 比如 <code>swap()</code>.</p><p>有时候, 在输入形参中用 <code>const&nbsp;T*</code> 指针比 <code>const&nbsp;T&amp;</code> 更明智. 比如:</p><ul><li>可能会传递空指针.</li><li>函数要把指针或对地址的引用赋值给输入形参.</li></ul><p>总而言之, 大多时候输入形参往往是 <code>const&nbsp;T&amp;</code>. 若用 <code>const&nbsp;T*</code> 则说明输入另有处理. 所以若要使用 <code>const&nbsp;T*</code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><h5 id="总述-3"><a href="#总述-3" class="headerlink" title="总述"></a>总述</h5><p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数, 然后用另一个参数类型为 <code>const&nbsp;char*</code> 的函数对其进行重载:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">size_t</span> textlen)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><p>通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.</p><h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><p>如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.</p><h5 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h5><p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等, 而不是一口气重载多个 <code>Append()</code>. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code>std::vector</code> 以便使用者可以用列表初始化指定参数.</p><h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><h5 id="总述-4"><a href="#总述-4" class="headerlink" title="总述"></a>总述</h5><p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与函数重载遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p><h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><p>有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”.</p><h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><p>缺省参数实际上是函数重载语义的另一种实现方式, 因此所有不应当使用函数重载的理由也都适用于缺省参数.</p><p>虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p><p>缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值.</p><p>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题.</p><h5 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h5><p>对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 <code>void&nbsp;f(int&nbsp;n&nbsp;=&nbsp;counter++);</code> 这样的代码.)</p><p>在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p><h4 id="函数返回类型后置语法"><a href="#函数返回类型后置语法" class="headerlink" title="函数返回类型后置语法"></a>函数返回类型后置语法</h4><h5 id="总述-5"><a href="#总述-5" class="headerlink" title="总述"></a>总述</h5><p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p><h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><p>C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>C++11 引入了这一新的形式. 现在可以在函数名前使用 <code>auto</code> 关键字, 在参数列表之后后置返回类型. 例如:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> -&gt; <span class="type">int</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>后置返回类型为函数作用域. 对于像 <code>int</code> 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别.</p><h5 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h5><p>后置返回类型是显式地指定Lambda 表达式的返回值的唯一方式. 某些情况下, 编译器可以自动推导出 Lambda 表达式的返回类型, 但并不是在所有的情况下都能实现. 即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了.</p><p>有时在已经出现了的函数参数列表之后指定返回类型, 能够让书写更简单, 也更易读, 尤其是在返回类型依赖于模板参数时. 例如:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>对比下面的例子:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="keyword">decltype</span>(<span class="built_in">declval</span>&lt;T&amp;&gt;() + <span class="built_in">declval</span>&lt;U&amp;&gt;()) <span class="built_in">add</span>(T t, U u);</span><br></pre></td></tr></tbody></table></figure><h5 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h5><p>后置返回类型相对来说是非常新的语法, 而且在 C 和 Java 中都没有相似的写法, 因此可能对读者来说比较陌生.</p><p>在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍. 因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下, 只使用一种版本是相对来说更规整的形式.</p><h5 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a>结论</h5><p>在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样复杂的模板代码.</p><h3 id="来自Google的奇技"><a href="#来自Google的奇技" class="headerlink" title="来自Google的奇技"></a>来自Google的奇技</h3><p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.</p><h4 id="所有权与智能指针"><a href="#所有权与智能指针" class="headerlink" title="所有权与智能指针"></a>所有权与智能指针</h4><h5 id="总述-6"><a href="#总述-6" class="headerlink" title="总述"></a>总述</h5><p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p><h5 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h5><p>所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.</p><p>智能指针是一个通过重载 <code>*</code> 和 <code>-&gt;</code> 运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位. <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> 是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当 <code>std::unique_ptr</code> 离开作用域时, 对象就会被销毁. <code>std::unique_ptr</code> 不能被复制, 但可以把它移动（move）给新所有主. <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> 同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.</p><h5 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h5><ul><li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li><li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li><li>传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li><li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li><li>可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.</li><li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li></ul><h5 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li><li>其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li><li>如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型.</li><li>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</li><li><code>&lt;span class="pre"&gt;std::unique_ptr&lt;/span&gt;</code> 的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员.</li><li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统.</li><li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li><li>某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁.</li><li>智能指针并不能够完全代替原生指针.</li></ul><h5 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a>结论</h5><p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 <code>std::unique_ptr</code> 来明确所有权传递, 例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">FooFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FooConsumer</span><span class="params">(std::unique_ptr&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 <code>std::shared_ptr&lt;const Foo&gt;</code> ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 <code>std::shared_ptr</code> .</p><p>不要使用 <code>std::auto_ptr</code>, 使用 <code>std::unique_ptr</code> 代替它.</p><h4 id="Cpplint"><a href="#Cpplint" class="headerlink" title="Cpplint"></a>Cpplint</h4><h5 id="总述-7"><a href="#总述-7" class="headerlink" title="总述"></a>总述</h5><p>使用 <code>cpplint.py</code> 检查风格错误.</p><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p><code>cpplint.py</code> 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 <code>// NOLINT</code>, 或在上一行加 <code>//&nbsp;NOLINTNEXTLINE</code>, 可以忽略报错.</p><p>某些项目会指导你如何使用他们的项目工具运行 <code>cpplint.py</code>. 如果你参与的项目没有提供, 你可以单独下载 <a href="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p><h4 id="译者（acgtyrant）笔记-2"><a href="#译者（acgtyrant）笔记-2" class="headerlink" title="译者（acgtyrant）笔记"></a>译者（acgtyrant）笔记</h4><ol><li>把智能指针当成对象来看待的话, 就很好领会它与所指对象之间的关系了.</li><li>原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.</li><li><code>scoped_ptr</code> 和 <code>auto_ptr</code> 已过时. 现在是 <code>shared_ptr</code> 和 <code>uniqued_ptr</code> 的天下了.</li><li>按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.</li><li>Arch Linux 用户注意了, AUR 有对 cpplint 打包.</li></ol><h3 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h3><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.</p><p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.</p><h4 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h4><h5 id="总述-8"><a href="#总述-8" class="headerlink" title="总述"></a>总述</h5><p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p><h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><p>尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> num_errors;            <span class="comment">// "num" 是一个常见的写法</span></span><br><span class="line"><span class="type">int</span> num_dns_connections;   <span class="comment">// 人人都知道 "DNS" 是什么</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="type">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="type">int</span> pc_reader;             <span class="comment">// "pc" 有太多可能的解释了.</span></span><br><span class="line"><span class="type">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></tbody></table></figure><p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code>i</code> 表示迭代变量和用 <code>T</code> 表示模板参数.</p><p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循类型命名的规则, 而非类型模板应当遵循变量命名的规则.</p><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><h5 id="总述-9"><a href="#总述-9" class="headerlink" title="总述"></a>总述</h5><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p><h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p>可接受的文件命名示例:</p><ul><li><code>my_useful_class.cc</code></li><li><code>my-useful-class.cc</code></li><li><code>myusefulclass.cc</code></li><li><code>myusefulclass_test.cc</code> // <code>_unittest</code> 和 <code>_regtest</code> 已弃用.</li></ul><p>C++ 文件要以 <code>.cc</code> 结尾, 头文件以 <code>.h</code> 结尾. 专门插入文本的文件则以 <code>.inc</code> 结尾, 参见头文件自足.</p><p>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 <code>db.h</code>.</p><p>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比 <code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类 <code>FooBar</code>.</p><p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短, 就直接放在 <code>.h</code> 中.</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h3 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h3><p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p><h4 id="现有不合规范的代码"><a href="#现有不合规范的代码" class="headerlink" title="现有不合规范的代码"></a>现有不合规范的代码</h4><h5 id="总述-10"><a href="#总述-10" class="headerlink" title="总述"></a>总述</h5><p>对于现有不符合既定编程风格的代码可以网开一面.</p><h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住, <em>一致性</em> 也包括原有的一致性.</p><h4 id="Windows-代码"><a href="#Windows-代码" class="headerlink" title="Windows 代码"></a>Windows 代码</h4><h5 id="总述-11"><a href="#总述-11" class="headerlink" title="总述"></a>总述</h5><p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p><h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p>如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p><ul><li>不要使用匈牙利命名法 (比如把整型变量命名成 <code>iNum</code>). 使用 Google 命名约定, 包括对源文件使用 <code>.cc</code> 扩展名.</li><li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 <code>DWORD</code>, <code>HANDLE</code> 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 <code>const&nbsp;TCHAR*</code> 而不是 <code>LPCTSTR</code>.</li><li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有警告(warnings)当作错误(errors)处理.</li><li>不要使用 <code>#pragma&nbsp;once</code>; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 <code>#ifndef&nbsp;SRC_DIR_BAR_H_</code>, 参考#define 保护一节).</li><li>除非万不得已, 不要使用任何非标准的扩展, 如 <code>#pragma</code> 和 <code>__declspec</code>. 使用 <code>__declspec(dllimport)</code> 和 <code>__declspec(dllexport)</code> 是允许的, 但必须通过宏来使用, 比如 <code>DLLIMPORT</code> 和 <code>DLLEXPORT</code>, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li></ul><p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p><ul><li>通常我们禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li><li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 <code>_ATL_NO_EXCEPTIONS</code> 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理).</li><li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 <code>StdAfx.h</code> 或 <code>precompile.h</code> 的文件. 为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 <code>precompile.cc</code> 中), 使用 <code>/FI</code> 编译器选项以自动包含该文件.</li><li>资源头文件通常命名为 <code>resource.h</code> 且只包含宏, 这一文件不需要遵守本风格指南.</li></ul><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>运用常识和判断力, 并且保持一致.</p><p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 <code>if</code> 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做.</p><p>风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏, 所以要尽量避免.</p><p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CODE3/X4uzvL.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码。但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交者造成不小的困扰。Google 因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google 的编程风格。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧 (Coding Skill)" scheme="https://yousazoe.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-Coding-Skill/"/>
    
    
  </entry>
  
  <entry>
    <title>向量</title>
    <link href="https://yousazoe.top/archives/8c47f151.html"/>
    <id>https://yousazoe.top/archives/8c47f151.html</id>
    <published>2022-09-29T01:22:20.000Z</published>
    <updated>2023-05-05T12:43:30.691Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://twitter.com/Rcmedy/status/1572658550563807233"><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/GApBvy.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程旨在围绕各类数据结构的设计与实现，揭示其中的规律原理与方法技巧；同时针对算法设计及其性能分析，使学生了解并掌握主要的套路与手段。本文将讲解数据结构向量及查找和排序。</p><span id="more"></span><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><h4 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0001.jpg"></p><p>向量属于最最基本的线性结构，我们笼统称之为线性序列。</p><p>本章我们将围绕这种数据结构展示和讨论两方面问题：</p><ol><li>如何根据统一的接口规范来定制并实现一个数据结构</li><li>围绕这种数据结构展示如何通过更加有效的算法使得我们对外的接口能够更加高效率地工作：查找、排序</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0002.jpg"></p><p>首先我们要辨析抽象数据类型和数据结构：</p><ul><li>抽象数据类型 = 数据模型 + 定义在该模型的一组操作</li><li>数据结构 = 基于某种特定语言，实现 ADT 的一整套算法</li></ul><p>更形象一点，我们可以将数据结构比喻成某种产品比如汽车。作为用户 Application 而言，他只关心这种产品的外在特性能够提供的功能；而实现者 Implementation 则需要对这些功能以及特性具体如何落实负责。</p><h4 id="向量ADT"><a href="#向量ADT" class="headerlink" title="向量ADT"></a>向量ADT</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0004.jpg"></p><p>所谓向量，实际上是 C++ 等高级编程语言中数组这种数据组织形式的一个推广和泛化。</p><h5 id="循秩访问"><a href="#循秩访问" class="headerlink" title="循秩访问"></a>循秩访问</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0005.jpg"></p><p>在这些高级程序设计语言中所谓的数组实际上就是一段连续的内存空间，它被均匀地划分为若干个单元，而每一个单元都会与一个编号彼此回应，并且可以直接访问。</p><p>而向量可以被认为是数组的抽象与泛化，它同样是由一组抽象的元素按照刚才的线性次序封装而成。不同的是原来通过下标 <code>i</code> 的访问方式变成了秩 rank。</p><p>另外向量中元素的类型得到了拓展，不限于是某一种特定的基本类型，它的所有操作、管理维护更加简化，可以通过统一的接口来完成。</p><h5 id="向量ADT接口"><a href="#向量ADT接口" class="headerlink" title="向量ADT接口"></a>向量ADT接口</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0006.jpg"></p><p>可以通过这些操作接口对向量做各种操作，同时也只能通过这些操作接口对向量进行操作。</p><h4 id="接口操作实例"><a href="#接口操作实例" class="headerlink" title="接口操作实例"></a>接口操作实例</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0007.jpg"></p><h4 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0010.jpg"></p><ul><li><a href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/vector/vector.h.htm">SourceCode</a></li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SRC_VECTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRC_VECTOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CAPACITY 3   <span class="comment">// 默认初始容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Vector {</span><br><span class="line">    <span class="keyword">using</span> Rank = <span class="type">int</span>;       <span class="comment">// 秩</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T* _elem;           <span class="comment">// 数据</span></span><br><span class="line">        Rank _size;         <span class="comment">// 规模</span></span><br><span class="line">        Rank _capacity;     <span class="comment">// 容量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span>;                                      <span class="comment">// 空间不足扩容</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">shrink</span><span class="params">()</span></span>;                                      <span class="comment">// 装填过小压缩</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">copyFrom</span><span class="params">(T <span class="type">const</span>* A, Rank lo, Rank hi)</span></span>;        <span class="comment">// 复制数组区间</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Rank <span class="title">maxItem</span><span class="params">(Rank lo, Rank hi)</span></span>;                     <span class="comment">// 选取最大元素</span></span><br><span class="line">        <span class="function">Rank <span class="title">partition</span><span class="params">(Rank lo, Rank hi)</span></span>;                   <span class="comment">// 轴点构造算法</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(Rank lo, Rank hi)</span></span>;               <span class="comment">// 选择排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">bubble</span><span class="params">(Rank lo, Rank hi)</span></span>;                      <span class="comment">// 扫描交换</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                  <span class="comment">// 起泡排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Rank lo, Rank mid, Rank hi)</span></span>;             <span class="comment">// 归并算法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                   <span class="comment">// 归并排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                    <span class="comment">// 堆排序</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                   <span class="comment">// 快速排序</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                   <span class="comment">// 希尔排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/* 构造函数 */</span></span><br><span class="line">        <span class="built_in">Vector</span>(<span class="type">int</span> c = DEFAULT_CAPACITY, Rank s = <span class="number">0</span>, T v = <span class="number">0</span>) {</span><br><span class="line">            _elem = <span class="keyword">new</span> T[_capacity = c];</span><br><span class="line">            <span class="keyword">for</span> (_size = <span class="number">0</span>; _size &lt; s; ++_size)</span><br><span class="line">                _elem[_size] = v;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Vector</span>(T <span class="type">const</span>* A, Rank n) { <span class="built_in">copyFrom</span>(A, <span class="number">0</span>, n); }</span><br><span class="line">        <span class="built_in">Vector</span>(T <span class="type">const</span>* A, Rank lo, Rank hi) { <span class="built_in">copyFrom</span>(A, lo, hi); }</span><br><span class="line">        <span class="built_in">Vector</span>(Vector&lt;T&gt; <span class="type">const</span>&amp; V) { <span class="built_in">copyFrom</span>(V._elem, <span class="number">0</span>, V._size); }</span><br><span class="line">        <span class="built_in">Vector</span>(Vector&lt;T&gt; <span class="type">const</span>&amp; V, Rank lo, Rank hi) { <span class="built_in">copyFrom</span>(V._elem, lo, hi); }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 析构函数 */</span></span><br><span class="line">        ~<span class="built_in">Vector</span>() { <span class="keyword">delete</span>[] _elem; }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 只读接口 */</span></span><br><span class="line">        <span class="function">Rank <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> _size; }                           <span class="comment">// 规模</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> !_size; }                         <span class="comment">// 判空</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Rank <span class="title">find</span><span class="params">(T <span class="type">const</span>&amp; e)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">find</span>(e, <span class="number">0</span>, _size); }       <span class="comment">// 无序向量整体查找</span></span><br><span class="line">        <span class="function">Rank <span class="title">find</span><span class="params">(T <span class="type">const</span>&amp; e, Rank lo, Rank hi)</span></span>;                       <span class="comment">// 无序向量区间查找</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Rank <span class="title">search</span><span class="params">(T <span class="type">const</span>&amp; e)</span> <span class="type">const</span> </span>{                               <span class="comment">// 有序向量整体查找</span></span><br><span class="line">            <span class="keyword">return</span> (_size &lt;= <span class="number">0</span>)? <span class="number">-1</span>: <span class="built_in">search</span>(e, <span class="number">0</span>, _size);</span><br><span class="line">        }</span><br><span class="line">        <span class="function">Rank <span class="title">search</span><span class="params">(T <span class="type">const</span>&amp; e, Rank lo, Rank hi)</span> <span class="type">const</span></span>;              <span class="comment">// 有序向量区间查找 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 可写接口 */</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>[] (Rank r);                                       <span class="comment">// 重载下标操作符</span></span><br><span class="line">        <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (Rank r) <span class="type">const</span>;</span><br><span class="line">        Vector&lt;T&gt;&amp; <span class="keyword">operator</span>= (Vector&lt;T&gt; <span class="type">const</span>&amp;);                      <span class="comment">// 重载赋值操作符</span></span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">remove</span><span class="params">(Rank r)</span></span>;                                             <span class="comment">// 删除单一元素</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(Rank lo, Rank hi)</span></span>;                                 <span class="comment">// 删除区间元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="function">Rank <span class="title">insert</span><span class="params">(Rank r, T <span class="type">const</span>&amp; e)</span></span>;                              <span class="comment">// 插入元素</span></span><br><span class="line">        <span class="function">Rank <span class="title">insert</span><span class="params">(T <span class="type">const</span>&amp; e)</span> </span>{ <span class="keyword">return</span> <span class="built_in">insert</span>(_size, e); }          <span class="comment">// 插入末元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(Rank lo, Rank hi)</span></span>;                                  <span class="comment">// 区间排序</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span> </span>{ <span class="built_in">sort</span>(<span class="number">0</span>, _size); }                               <span class="comment">// 整体排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unsort</span><span class="params">(Rank lo, Rank hi)</span></span>;                                <span class="comment">// 区间置乱</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unsort</span><span class="params">()</span> </span>{ <span class="built_in">unsort</span>(<span class="number">0</span>, _size); }                           <span class="comment">// 整体置乱</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 遍历接口 */</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">void</span>(*) (T&amp;))</span></span>;                                  <span class="comment">// 函数指针遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VST&gt; <span class="type">void</span> <span class="title">traverse</span><span class="params">(VST&amp;)</span></span>;                   <span class="comment">// 函数对象遍历</span></span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SRC_VECTOR_H</span></span></span><br></pre></td></tr></tbody></table></figure><p>整个 Vector 被封装起来，来自各种用户 application 的操作接口 interface 提供在外面，相当于一个 Vector 结构的使用说明书。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0011.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">int</span> c = DEFAULT_CAPACITY, Rank s = <span class="number">0</span>, T v = <span class="number">0</span>) {</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = c];</span><br><span class="line">    <span class="keyword">for</span> (_size = <span class="number">0</span>; _size &lt; s; ++_size)</span><br><span class="line">        _elem[_size] = v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vector</span>(T <span class="type">const</span>* A, Rank n) { <span class="built_in">copyFrom</span>(A, <span class="number">0</span>, n); }</span><br><span class="line"><span class="built_in">Vector</span>(T <span class="type">const</span>* A, Rank lo, Rank hi) { <span class="built_in">copyFrom</span>(A, lo, hi); }</span><br><span class="line"><span class="built_in">Vector</span>(Vector&lt;T&gt; <span class="type">const</span>&amp; V) { <span class="built_in">copyFrom</span>(V._elem, <span class="number">0</span>, V._size); }</span><br><span class="line"><span class="built_in">Vector</span>(Vector&lt;T&gt; <span class="type">const</span>&amp; V, Rank lo, Rank hi) { <span class="built_in">copyFrom</span>(V._elem, lo, hi); }</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line">~<span class="built_in">Vector</span>() { <span class="keyword">delete</span>[] _elem; }</span><br></pre></td></tr></tbody></table></figure><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0012.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">copyFrom</span>(<span class="type">const</span> T *A, Rank lo, Rank hi) {</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span>*(hi - lo)];</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">        _elem[_size++] = A[lo++];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>复制操作将 <code>_elem</code> 空间扩展为原来的二倍，然后将区间元素依次复制。</p><h3 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0013.jpg"></p><h4 id="可扩充向量-1"><a href="#可扩充向量-1" class="headerlink" title="可扩充向量"></a>可扩充向量</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0014.jpg"></p><p>现在我们用 <code>_size</code> 表示实际规模，<code>_capacity</code> 表示总容量。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">T* _elem;           <span class="comment">// 数据</span></span><br><span class="line">Rank _size;         <span class="comment">// 规模</span></span><br><span class="line">Rank _capacity;     <span class="comment">// 容量</span></span><br></pre></td></tr></tbody></table></figure><p>这里的问题是 <code>_capacity</code> 一旦确定按照目前的方案它就将一成不变，而这样一种策略显然存在明显的不足。这种不足体现在两个方面：</p><ul><li>上溢(overflow)：<code>_elem[]</code> 不足以存放所有元素，尽管此时系统仍有足够的空间</li><li>下溢(underflow)：<code>_elem[]</code> 中的元素寥寥无几，装填因子 = _size/_capacity &lt;&lt; 50%</li></ul><h4 id="动态空间管理"><a href="#动态空间管理" class="headerlink" title="动态空间管理"></a>动态空间管理</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0015.jpg"></p><p>我们需要从静态管理策略改编为动态管理策略，模仿蝉的做法在即将发生上溢时适当地扩大内部数组容量。</p><p>向量的生命周期：</p><ul><li>(a) 最开始虽然元素很多但不至于出现上溢的情况</li><li>(b) 但剩余空间有可能会逐步地占用，在某一时刻内部数组饱和</li><li>(c) 模仿蝉退掉外壳，动态申请另一个外壳：另一段存放空间，它的大小应该比原来的有所增长</li><li>(d) 把原先存放好的有效元素逐一按次序复制过来，使得它们对外界而言依旧保持原貌</li><li>(e) 新多出的空间足以存放新需要插入的元素，原来占用的空间在此之后被释放并且归还给系统</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0016.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">expand</span>() {</span><br><span class="line">    <span class="keyword">if</span> (_size &lt; _capacity) <span class="keyword">return</span>;</span><br><span class="line">    _capacity = std::<span class="built_in">max</span>(_capacity, DEFAULT_CAPACITY);</span><br><span class="line"></span><br><span class="line">    T* oldElem = _elem;</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i)</span><br><span class="line">        _elem[i] = oldElem[i];</span><br><span class="line">    <span class="keyword">delete</span>[] oldElem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得益于向量的封装，尽管扩容之后数据区的物理地址有所改变，却不致出现野指针。</p><h4 id="递增式扩容"><a href="#递增式扩容" class="headerlink" title="递增式扩容"></a>递增式扩容</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0017.jpg"></p><p>每当发现当前的内部数组即将发生上溢，我们并不是对它进行容量的加倍而只是在原来的容量的基础上追加一个固定的数额：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0018.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity += INCREMENT];</span><br></pre></td></tr></tbody></table></figure><p>对于这种策略而言，每经过 I 次插入操作它都需要进行一次扩容，每次分摊成本为 O(n)。</p><h4 id="加倍式扩容"><a href="#加倍式扩容" class="headerlink" title="加倍式扩容"></a>加倍式扩容</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0019.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure><p>每次的分摊成本为 O(1) 常数时间。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0020.jpg"></p><p>倍增策略通过在空间的效率上做了一个适当的牺牲换取在时间方面的巨大收益。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0021.jpg"></p><h3 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0022.jpg"></p><h4 id="循秩访问-1"><a href="#循秩访问-1" class="headerlink" title="循秩访问"></a>循秩访问</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0023.jpg"></p><p>首先讨论向量元素的访问。表面上看这并不是什么问题，因为在向量 ADT 中已经定义了两个标准的接口 <code>V.get(r)</code> 和 <code>V.put(r, e)</code>。通过它们我们已经可以自如地来写或者是读向量中特定的元素，但这两种接口在形式上还不是那么简洁直观。</p><p>我们期望数组那种直接地访问方式：<code>A[r]</code>，为此需要重载下标操作符 <code>[]</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="type">const</span> { <span class="keyword">return</span> _elem[r]; }</span><br></pre></td></tr></tbody></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0024.jpg"></p><p>再来考察向量的插入算法，如何讲某一个特定的元素插入到向量的特定位置。</p><p>因为原有向量所有元素都是紧邻排列的，所以为了能够插入新的元素我们需要将对应位置之后的所有元素称作它的后继，进行一个整体的右移操作。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Rank Vector&lt;T&gt;::<span class="built_in">insert</span>(Rank r, T <span class="type">const</span>&amp; e) {</span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = _size; i &gt; r; --i)</span><br><span class="line">        _elem[i] = _elem[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    _elem[r] = e;</span><br><span class="line">    _size++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="区间删除"><a href="#区间删除" class="headerlink" title="区间删除"></a>区间删除</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0025.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank lo, Rank hi) {</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hi &lt; _size)</span><br><span class="line">        _elem[lo++] = _elem[hi++];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shrink</span>();</span><br><span class="line">    <span class="keyword">return</span> hi - lo;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单元素删除"><a href="#单元素删除" class="headerlink" title="单元素删除"></a>单元素删除</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0026.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank r) {</span><br><span class="line">    T e = _elem[r];</span><br><span class="line">    <span class="built_in">remove</span>(r, r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0027.jpg"></p><p>无序向量只支持判等操作，有序向量还需要支持其中的元素相互比较大小。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0028.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0029.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0030.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Rank Vector&lt;T&gt;::<span class="built_in">find</span>(T <span class="type">const</span>&amp; e, Rank lo, Rank hi) {</span><br><span class="line">    <span class="keyword">while</span> ((lo &lt; hi--) &amp;&amp; (_elem[hi] != e));</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从 <code>hi</code> 出发逆向逐一取出向量中的各个元素，与目标元素进行比对。如果不相等，就忽略它并且考察它的前驱，整个工作会遍历向量中的所有元素。</p><h4 id="去重-x2F-唯一化"><a href="#去重-x2F-唯一化" class="headerlink" title="去重/唯一化"></a>去重/唯一化</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0031.jpg"></p><p>向量的唯一化需要把其中重复的元素都剔除掉，只保留一个拷贝。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0032.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">deduplicate</span>() {</span><br><span class="line">    <span class="type">int</span> oldSize = _size;</span><br><span class="line">    Rank i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; _size) {                                      </span><br><span class="line">        (<span class="built_in">find</span>(_elem[i], <span class="number">0</span>, i) &lt; <span class="number">0</span>)?                           </span><br><span class="line">            i++:                                             </span><br><span class="line">            <span class="built_in">remove</span>(i);                                       </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oldSize - _size;                                 </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0033.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0034.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">traverse</span>(<span class="built_in">void</span> (*visit) (T&amp;)) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i)</span><br><span class="line">        <span class="built_in">visit</span>(_elem[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">traverse</span>(VST&amp; visit) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i)</span><br><span class="line">        <span class="built_in">visit</span>(_elem[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>利用函数指针机制，只读或局部性修改</li><li>利用函数对象机制，可全局性修改</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0035.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Increase</span> {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; e)</span> </span>{ e++; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(Vector&lt;T&gt;&amp; V)</span> </span>{</span><br><span class="line">    v.<span class="built_in">traverse</span>(<span class="built_in">Increase</span>&lt;T&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h3><h4 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0036.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0037.jpg"></p><p>与起泡排序算法的理解相同，有序/无序序列中，<strong>任意/总有</strong>一对相邻元素<strong>顺序/逆序</strong>。</p><p>因此，相邻逆序对的数目，可用以度量向量的逆序程度。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0038.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">disordered</span>() <span class="type">const</span> {</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; _size; i++)</span><br><span class="line">        n += (_elem[i - <span class="number">1</span>] &gt; _e);</span><br><span class="line">    <span class="keyword">return</span> n;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0039.jpg"></p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><h4 id="Fib查找"><a href="#Fib查找" class="headerlink" title="Fib查找"></a>Fib查找</h4><h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><h3 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://twitter.com/Rcmedy/status/1572658550563807233&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/DS2/GApBvy.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程旨在围绕各类数据结构的设计与实现，揭示其中的规律原理与方法技巧；同时针对算法设计及其性能分析，使学生了解并掌握主要的套路与手段。本文将讲解数据结构向量及查找和排序。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构 (Data Structure)" scheme="https://yousazoe.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Data-Structure/"/>
    
    
    <category term="Algorithm" scheme="https://yousazoe.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Convex Hull</title>
    <link href="https://yousazoe.top/archives/84b74385.html"/>
    <id>https://yousazoe.top/archives/84b74385.html</id>
    <published>2022-09-21T09:21:29.000Z</published>
    <updated>2023-05-05T12:43:30.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://twitter.com/cyangmou/status/1571176793943457793"><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/qrXkrr.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本节我们将探索计算几何的核心问题：凸包问题。计算几何领域几乎所有的问题都可以“归约”为凸包问题，因此学习凸包问题对整个计算几何体系至关重要。</p><span id="more"></span><h3 id="Convexity"><a href="#Convexity" class="headerlink" title="Convexity"></a>Convexity</h3><h4 id="Why-Convex-Hull"><a href="#Why-Convex-Hull" class="headerlink" title="Why Convex Hull"></a>Why Convex Hull</h4><p>我们计算几何的第一站就是凸包问题，它在计算几何中处于核心位置，这个核心体现在几乎所有的问题从理论上讲都可以归结为凸包问题。</p><h4 id="Nails-In-The-Table"><a href="#Nails-In-The-Table" class="headerlink" title="Nails In The Table"></a>Nails In The Table</h4><p>接下来我们通过一个具体的动手实验领会一下凸包到底是什么。</p><p>为此你需要找到一张桌子或是屏幕，假想在这个桌子上钉上一系列的钉子，然后用皮筋将其撑到足够大以至于它能将桌面上的所有钉子都包含进去。</p><p>接下来的事情非常的轻松，你只要松手就行。那么随着啪的一声，你将会看到这幅图景：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/cvGMfd.png"></p><p>刚才的皮筋就会变成这样一段一段蓝色的线段，它们首尾相连构成了一个紧绷的包围圈。这个蓝色的橡皮筋在在现在这样的一个图景状态就是我们所说的凸包，我们可以看到所谓的凸包是由这上面若干个钉子来决定的，虽然其中有一些钉子并不发挥作用，我们大致可以感觉到因为它们呆在内部。</p><p>那么，这之间的玄机又是什么呢？</p><h4 id="Paint-Blending"><a href="#Paint-Blending" class="headerlink" title="Paint Blending"></a>Paint Blending</h4><p>为了更好地理解什么是凸包，我们再来看一个应用的例子。</p><p>艺术家经常要通过混合得到某种他想要又不是从工厂直接生产出来的颜料。我们知道一般来说每种颜料都可以分成是红绿蓝三个分量的数值指标，每种组合对应的大致都是一种颜料。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/I3MrGz.png"></p><p>我们不妨为了简便起见只考虑红的以及绿的两个分量，所以这样的话每一种颜料也就是它所对应的颜色都可以用红的和绿的这样两个数字，或者说它们在整体的成份中所占的百分比来对应。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C = (R, G)</span><br></pre></td></tr></tbody></table></figure><p>比如说某种颜料 X 它所对应的红的分量可能是 10%，而绿的分量是 35%；另一种颜料比如叫 Y，那么它所对应的这两个分量一个是 16% 一个是 20%。 现在的问题来了，用这两种颜料能否兑出我们所希望的某些颜料呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">X = (10%, 35%)  Y = (16%, 20%)</span><br></pre></td></tr></tbody></table></figure><p>我们来看一下，当颜料混合在一块的时候它们的变化是多端的，有很多很多种组合，每几种颜料它们按照不同的分量、按照不同的比重勾兑在一块所得到的颜色其实都会不同。当然，艺术家有他的勾兑的方法，包括他的灵感，那么如果从数学的角度，从算法的角度来考虑，这其中应该用什么样的指导的方法呢？</p><p>那么从数学上来看我们一般来说都可以认为有一个目标的颜色，比如说这里的 U，这种颜色比如说特定的来说他希望红的占的比重是 12%，而绿的比重是 30%。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">U = (12%, 30%)</span><br></pre></td></tr></tbody></table></figure><p>对于这样的一种目标的颜料我们应该用刚才的 X、Y，这两种来自于工厂的原始颜料用什么样的比例来对它们进行混合和勾兑呢？</p><p>好，我想你已经知道这个答案了。没错 我们应该用两份的 X 和一份的 Y 勾兑起来，就可以得到 U 了。</p><p>你不妨去做个简单的验算，两份的 10% 再加上一份*的 16% 合在一块再除以 3，正好是 12%；而两份的 35%，再加上一份的 20% 也同样的除以 3 恰好也是 30%，所以用 2 比 1 的比例是这个问题的一个解。</p><p>好，如果说我们为此花费这些时间还是值得的话，我们还是希望得到一个方法，否则的话我们会很困惑，因为如果你没有掌握这背后的、统一的方法的话，那么如果下一次换一种颜色比如说这里的 V 它要求的是 13% 和 22%，那你可能又要花费一些时间了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">V = (13%, 22%)</span><br></pre></td></tr></tbody></table></figure><p>那么首先一个问题是这种颜料能不能勾兑出来。并不是像我们这里所说的那样，每两种颜色给定了以后你都能勾兑出所有的颜色。其实在这个时候我们或许需要第三种颜色，比如这里我们也许从厂房里可以拿到第三种颜色 Z，它的对应的比重是 7% 和 15%。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Z = (07%, 15%)</span><br></pre></td></tr></tbody></table></figure><p>好了，这个时候用这三种颜色是否能把它勾兑出来呢？</p><p>好，现在我来揭晓答案。正确的比例应该是一份的 X，三份的 Y 再加上刚才我们新添的第三种颜色 Z 一份 1 比 3 比 1。你可以按照刚才同样的方法去推算一下 验算一下，我想答案应该是它。</p><p>那么所有这里讨论的事情其实都是颜色，或者准确地讲是颜料之间的那种勾兑混合。这个东西和我们这里讨论的计算几何有什么关系呢？其实它们之间有着非常深刻的联系。</p><h4 id="Color-Space"><a href="#Color-Space" class="headerlink" title="Color Space"></a>Color Space</h4><p>既然谈到几何，那么少不了就要谈到它最最基础的一个概念叫做空间，欧氏空间。</p><p>在这里我们将欧氏空间对应于颜色，我们称之为颜色空间，具体来讲我们要将每一种颜色都对应成是这个空间中的一个点。无论这种颜色或者颜料是来自于生产厂家直接供应的那种基础性的颜料，还是艺术家为了创作的需要必须重新勾兑出来的新的颜色。总而言之每一种颜色都对应这个空间中的一个点。</p><p>当然这里因为我们讨论的都是正数，那可以认为它基本上都限于第一个象限，这不是主要的问题。那么现在的问题是在于我们固然可以按照这种方法将我们刚才的三种颜料也就是 X、Y、Z 按照横轴也就是刚才比如红色的分量数值以及纵轴，也就是刚才说的绿色的分量的数值对应地画出一个一个的点，三种颜料，分别是三种点。</p><p>我们刚才看到过，在我们只有 X 和 Y 两种颜料的时候如果我们要勾兑出 U，那个比重是 2 比 1。其实这件事情倒过来，我们在给出了固定的 X 和 Y 之后我可以将我们目标的那个 U 也在这个屏幕上画出来，如果你画出来的话你就会发现其实非常地巧，我们可以验证一下它们三者是所谓共线的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/7XidsU.png"></p><p>如果是这种情况，那么我们认为 U 肯定是能被勾兑出来的，而且它的勾兑比例可以从几何上一目了然的能解释。</p><p>你可以再去计算一下，我会告诉你其实 U 到 X 的距离相对更短，U 到 Y 的距离相对更长，而二者的距离之比其实是 1 比 2，而我们刚才勾兑的比例是反过来的 2 比 1。</p><p>其实这就是一个规律，也就是说如果我要勾兑的一种颜色恰好是位于这两个顶点的那条连接的线段上，而且它们的距离存在一个比的话，那么这种颜色就必然能够被勾兑出来。而且勾兑的方法就蕴含在刚才的那个比例中，只要把刚才那个距离比 1 比 2 颠倒过来变成 2 比 1，它就必然能得到这种颜色。</p><p>你可以作为一个极端的例子去想一下，整个的是如果要勾兑 Y 和勾兑 X 本身的时候另一个分量是 0 是同样的道理。</p><p>好，那么刚才我们也可以解释为什么 V 这种颜色必须要借助第三种颜色才能够勾兑出来。因为你大致可以看出来因为 V 并没有位于 X 和 Y 所确定的这条线段上跑偏了，在这种情况下我们说必然要借助 Z，而之所以要借助 Z 或者说准确地讲按照我们刚才那个比例必须是 1 比 3 比 1 也蕴含在这个图中，原理是一样的。</p><p>如果在这种情况下我们要做的事情就是要首先确认 V 这个颜料所对应的那个点是不是落在 X、Y、Z 所定义的这个三角形的内部，如果是它就一定能勾兑出来；如果不是，至少它是不能勾兑出来的。</p><p>好，如果它能勾兑出来，具体的勾兑的比例是多少呢？在这个图中也给出来了，为此我们只需要去量一下 V 到这三个点的距离，然后找一下它们的比。我们在这里会发现它们的比恰好是 3 比 3 比 1，所以倒过来在这里我们勾兑的比例自然也就是这个最短的最近的这个点对应的那个颜色要取的更多，反其道而行之它要取三份；而到更远的那两个点所对应的颜色所取的比例要更少，完全可以用这个来度量</p><p>当然以上的这些结论你还需要在课后再做仔细的推导和严格的验证，在这里你不妨把这个结论记下来：也就是说如果有一种颜料能够被两种已知的颜料勾兑出来，它必然位于二者之间的那条连线上；如果是对于三种颜料的情况，那么某种目标的颜色能够被勾兑出来当且仅当在颜色空间中它位于这三个点所对应的那个三角形的内部，而勾兑的比例是与他们的距离成反比的。</p><h4 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h4><p>我们虽然不是很喜欢数学，但是不得不还要用一些简单的数学把刚才我们所看到的那个结论严格地表述出来。</p><p>也就是说我们如果给定的是平面二维空间中的一系列的点的话，那么这些点所对应的颜料能构造出哪些新的颜料出来呢？我们会发现其实每一种新的颜料从几何来讲，对应于原来那些颜料的某一个调和方案。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/zuOrJ9.png"></p><p>那么在这里有一些勾兑方案专门地称之为凸的勾兑方案，或者叫作凸组合 Convex Combination。具体而言，如果是一个凸组合需要有哪些条件呢？</p><p>我们说大致有两个主要的条件：</p><ol><li>所有分量的总和必须是 100%</li><li>所有分量必须是非负的</li></ol><h3 id="Extreme-Points"><a href="#Extreme-Points" class="headerlink" title="Extreme Points"></a>Extreme Points</h3><h4 id="Extremity"><a href="#Extremity" class="headerlink" title="Extremity"></a>Extremity</h4><p>在我们最开始给定的这些点中，哪些是最终对凸包有贡献的被皮筋绷住的，哪些是没有实质作用的，这种性质可以归纳为所谓的极性。</p><p>沿着刚才的那个思路，我们观察结论可以表述为这样的一幅图。我们看到在刚才的所有那些钉子中凡事被最终的皮筋绷住的钉子，暂时没有实质作用的这些钉子我们都用青色来表示，有什么本质不同呢？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/KWQXLc.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> there exists a line L through p</span><br><span class="line">    such that</span><br><span class="line">        all points of S lie on the same side of L</span><br></pre></td></tr></tbody></table></figure><p>数学上的观察告诉我们，所谓有用的点都有一个共同的特点：经过它们我们总能找到一条直线使得所有的点都落在这条直线的同一侧。</p><h4 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h4><p>在排序算法中有一个非常有意思的算法：起泡排序 Bubblesort。我们这里的算法设计和它是非常类似的：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/nTOTYN.png"></p><p>如何甄别极点和非极点呢？</p><p>我们需要回忆颜料勾兑的例子，一种颜料能够被其他几种颜料勾兑出来当且仅当它落在某一个三角形的内部。反过来像极点这样不能被其他颜料勾兑出来的颜色它就不可能被包含于任何三角形的内部，这样的话我们又往前转化了一步，将我们的甄别任务转化为某一个点是否会被包含于另外的三个点所确定的三角形内部。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/6fTUE0.png"></p><h4 id="In-Triangle-Test"><a href="#In-Triangle-Test" class="headerlink" title="In-Triangle Test"></a>In-Triangle Test</h4><p>根据刚才的分析，所谓凸包问题可以归结为一系列的判断：任何的一个点是否会落在其他的三个点所对应的三角形内部被它们包围，我们称这个为 In-Triangle Test。</p><p>基于 In-Triangle Test，我们就可以将非极点们一个一个地找出来并且将它们排除在我们的视野之外。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/oos30d.png"></p><p>首先做初始化，要像无罪推论一样将所有的点都设定为极点。接着枚举出所有可能的三角形，对于每个三角形我们还要去考察除它们之外的每一个点 s；一旦我们发现 s 的确是落在当前这个三角形内部，我们就可以立即断定它不是一个极点，从而将它排除在外。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Make all points of S as EXTREME</span><br><span class="line">For each triangle Δ(p, q, r)</span><br><span class="line">    For each s in S\{p, q, r}</span><br><span class="line">        If s in Δ(p, q, r)</span><br><span class="line">            mark s as NON_EXTREME</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/nZts0C.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">extremePoint</span><span class="params">(Point S[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; n; s++)</span><br><span class="line">        S[s].extreme = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each triangle</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; n; p++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q = p + <span class="number">1</span>; q &lt; n; q++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = q + <span class="number">1</span>; r &lt; n; r++) {</span><br><span class="line">                <span class="comment">// For each point</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; n; s++) {</span><br><span class="line">                    <span class="keyword">if</span> (s == p || s == q || s == r || !S[s].extreme)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">InTriangle</span>(S[p], S[q], S[r], S[s]))</span><br><span class="line">                        S[s].extreme = FALSE;    </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h4><p>我们给出的第一个基于极点的凸包算法虽然效率低下，但是它的意义还是很重要的，它会引出 To-Left Test，后面这个测试几乎是贯穿于我们计算几何这个课程的始终。</p><p>每当我们给定了一个点以及一个三角形后，如何来判定这个点是否落在这个三角形的内部？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/r06PyL.png"></p><p>依然是大事化小小事化了，我们将刚才这个 In-Triangle Test 转化为三次 To-Left Test。也就是说一个点如果确实落在某一个三角形的内部的话，那么相对于这个三角形的三条边所做的 To-Left Test 都会统一的返回 true。 </p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/XvoAfS.png"></p><p>所谓 To-Left Test，就是说这个点相对于有向线段而言位于左侧还是右侧。这里的敏锐观察可以归结为一个点如果落在三角形内部，它的充要条件当且仅当它相对于这三条直线的 To-Left Test 都是 true，它同时位于这三条直线的左侧。</p><p>那么现在问题转变为如何判断一个点在线段的左侧/右侧？</p><h4 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/CbRPDq.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ToLeft</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">Area</span><span class="params">(p, q, s)</span> &gt; 0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Area2</span><span class="params">(Point p, Point q, Point s)</span>    </span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> p.x * q.y - p.y * q.x</span></span><br><span class="line"><span class="function">         + q.x * s.y - q.y * s.x</span></span><br><span class="line"><span class="function">         + s.x * p.y - s.y * p.x</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="Extreme-Edges"><a href="#Extreme-Edges" class="headerlink" title="Extreme Edges"></a>Extreme Edges</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>延续极点的思路推广到边，引入所谓的极边。</p><p>极边的候选者其实就是来自于任何两个相邻极点的连边，凡是对最终的凸包有贡献的那些边都称之为极边；凡是那些对凸包没有贡献的就不是极边，或者叫作非极边，non-extreme Edge。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/ea2Xl7.png"></p><p>就像我们定义极点一样，如果有一条这样的连边确实是极边的话，那么所有的点都会同时落在它的同侧，相应的另一侧就必然是空的。更具体来讲，以逆时针次序凸包边界每一条边都有这样一个特性：所有的点都恰好落在它的左侧，它们的右侧都是空的。</p><p>这样我们算法中的实质问题就自然地转化和具体化为如何来甄别任何两个点之间的那条连边是否为极边的问题。</p><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/fmhhQx.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Let EE = null</span><br><span class="line">    For each directed segment pq</span><br><span class="line">        If points in S\{p, q} lie to the same side of pq</span><br><span class="line">            Let {pq} = EE</span><br></pre></td></tr></tbody></table></figure><p>按照极边的思路，我们可以将伪代码细化为这样一段真实的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">markEE</span><span class="params">(Point S[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) </span><br><span class="line">        S[k].extreme = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; n; p++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q = p + <span class="number">1</span>; q &lt; n; q++) </span><br><span class="line">            <span class="built_in">checkEdge</span>(S, n, p, q);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkEdge</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">bool</span> LEmpty = TRUE, REmpty = TRUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n &amp;&amp; (LEmpty || REmpty); k++) {</span><br><span class="line">        <span class="keyword">if</span> (k != p &amp;&amp; k != q) {</span><br><span class="line">            <span class="built_in">ToLeft</span>(S[p], S[q], S[k])? LEmpty = FALSE: REmpty = FALSE;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LEmpty || REmpty)</span><br><span class="line">        S[p].extreme = S[q].extreme = TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Incremental-Construction"><a href="#Incremental-Construction" class="headerlink" title="Incremental Construction"></a>Incremental Construction</h3><h4 id="Decrease-and-Conquer"><a href="#Decrease-and-Conquer" class="headerlink" title="Decrease and Conquer"></a>Decrease and Conquer</h4><p>接下来我们将从一个典型的算法思想减而治之 Decrease and Conquer 进一步改进。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/mzXh86.png"></p><p>一个经典的应该能回忆起来的算法就是插入排序 Insertionsort。插入排序整个思路可以归纳为将整个待排序序列存成线性结构，接下来在任何时候都将它分为排序和未排序两部分，在未排序部分随机找出一个（一般是两者分界的那个元素），通过一次查找在 sorted 子序列中找到这个元素对应的恰当插入位置。</p><p>同理，我们也可以应用于极边算法。</p><h4 id="In-Convex-Polygon-Test"><a href="#In-Convex-Polygon-Test" class="headerlink" title="In-Convex-Polygon Test"></a>In-Convex-Polygon Test</h4><p>递进式的核心技术是 In-Convex-Polygon Test，也就是判别多边形内部或者外部的问题。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/i6u0B3.png"></p><p>我们要判断一个新引入的点是否是当前的极点，其实本质上就是判断当前这个点是否落在此前的凸包的外面或者是里面的位置关系。</p><p>要将刚才那种直觉转化成数学上的判断：每次我们递增式新引入的这个点如果是当前的 extreme point 的话，那么充要条件其实就是看它是否落在当前这个凸包的外面：如果落在外面那它就是下一个 extreme point；否则不是。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/jScreb.png"></p><p>如果凸多边形确实是给定的，而且在此后要反复多次地做这类的查询的话，你是可以对这个多边形做一个预处理（本质上是排序）。</p><p>我们可以大致以一个点作为基础，在其余的 n - 1 个点中可以找到一个居中的连接起来确定一条有向线段。接下来又是我们刚才的惯用的 To-Left Test，经过这样一次常数成本的操作，我们确实可以判断出来这个未知的点到底是落在左边或者是右边，无论是哪边我们都可以将搜索的范围有效地收缩为原先的一半。</p><p>如此往复，我们每一次经过常数时间的成本都可以将这个问题的范围有效地降解为此前的一半，如此下去最终总会到达平凡的情况–trivial case：In-Triangle Test。</p><p>但是这个算法却不可行，最重要的是凸包并不是一成不变的，这种情况下我们的预处理是没有效力的。</p><h4 id="Why-Not-Binary-Search"><a href="#Why-Not-Binary-Search" class="headerlink" title="Why Not Binary Search"></a>Why Not Binary Search</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/vdGYz8.png"></p><p>与插入排序类似，sorted 部分本身就是动态的，即便可以使用二分查找，线性存储所带来的插入成本在最坏情况也会将这种优化无效化。</p><p>回到凸包，对于这种情况朴素的方法反而是最好的。我们可以沿着给定的凸多边形边界做习惯性的 CCW 逆时针旋转遍历，可以发现内部的点一定是在左手一侧的；反之如果我们在任何一段发现某一个点在右侧，那么可以立即断定它并非落在内部。</p><h4 id="Support-Lines"><a href="#Support-Lines" class="headerlink" title="Support-Lines"></a>Support-Lines</h4><p>其实我们还有一个任务要完成，解决如何将新引入的这个点附着或者是增加到原先的凸包上去，要使之成为一个完整的可以继续使用的结构。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/SM3vZw.png"></p><p>凸包切线又被称为 Support Line。</p><h4 id="Pattern-Of-Turns"><a href="#Pattern-Of-Turns" class="headerlink" title="Pattern Of Turns"></a>Pattern Of Turns</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/ibqaRy.png"></p><p>只需要花费两次 To-Left Test，就可以明确确定一个顶点到底是来自 ts(L + R) 还是 st(R + L)。</p><h4 id="Exterior-x2F-Interior"><a href="#Exterior-x2F-Interior" class="headerlink" title="Exterior/Interior"></a>Exterior/Interior</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/X3dd3R.png"></p><h3 id="Jarvis-March"><a href="#Jarvis-March" class="headerlink" title="Jarvis March"></a>Jarvis March</h3><h4 id="Selectionsort"><a href="#Selectionsort" class="headerlink" title="Selectionsort"></a>Selectionsort</h4><p>在介绍 GW 算法之前为了更好地理解它的算法思路，不妨温习一下之前我们很熟悉的选择排序。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/hFprPa.png"></p><p>与刚才的插入排序非常对称，在这里我们的 sorted 和 unsorted 部分是前后颠倒了，这个颠倒实际上是有本质区别的。</p><p>我们需要从 unsorted 部分中去找出一个最大的元素，接着将它进行一次交换挪到刚才 sorted 那个部分的首部。悄然之间，sorted 部分就向前迈进了一步。</p><p>那么这样一个算法思路从宏观的策略来讲我们可以概括为：每次我们都是维护一个局部的解，然后在尚未处理的部分中要去找到一个与当前的这个局部解紧密相关联的一个元素。没错，凸包就可以这么来做。</p><h4 id="Strategy-1"><a href="#Strategy-1" class="headerlink" title="Strategy"></a>Strategy</h4><p>我们如果反思一下在 Extreme Edge 那个算法中为什么会需要多达 n^3 的时间，就会发现根本的原因在于我们实际上考察的对象是遍布所有可能的那些边，这些边的总数会多达 n^2，每个又需要 n 时间鉴别。那么有什么改进的诀窍呢？</p><p>刚才的 selectionsort 就给了我们提示，也就是说我们或许能够将下一个的查找范围缩小到一个足够小的范围。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/xzIg9d.png"></p><p>Jarvis 观察注意到一些结论：</p><ol><li>所有构成凸包的那些边其实在拓扑上讲都是首尾相连构成一个环状结构的</li><li>如果构造过程确实是一条一条边构造，那么如果我在某一个时刻构造出一条边，那么接下来我必然可以沿着它的某一个端点向后继续去找到下一条 extreme edge</li></ol><h4 id="Coherence"><a href="#Coherence" class="headerlink" title="Coherence"></a>Coherence</h4><p>该图可以说明如何在当前已有的这些极边基础上沿着下一个端点拓展出新的极边：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/pPWwjn.png"></p><p>当前节点称作 <code>k</code>，它的前驱我们称之为 <code>i</code>，下一个极边则是 <code>s</code>。根据刚才 Jarvis 的判断，这个 <code>s</code> 必然来自于其他尚未处理的那些点中的一员。</p><p>而 <code>s</code> 之所以可以脱颖而出，其资本在于它是所有这些拐角中的最小者。也许有同学已经跃跃欲试准备用三角函数和反三角函数操作了，但其实有一种基本的技术就可以解决我们的问题。</p><h4 id="To-Left-Test-1"><a href="#To-Left-Test-1" class="headerlink" title="To-Left Test"></a>To-Left Test</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/Qyx4n5.png"></p><h4 id="Lowest-Then-Leftmost"><a href="#Lowest-Then-Leftmost" class="headerlink" title="Lowest-Then-Leftmost"></a>Lowest-Then-Leftmost</h4><p>一个技术细节问题，也就是我们刚才说到的起点和第一条极边应该如何来找呢？</p><p>作为第一个点，它至少是极点。在这里针对于我们目前的算法需求，可以对问题进一步简化，也就是找到沿着 y 轴负方向最低的位置。这个点也就是所谓的 Lowest Point，在没有退化的情况下必然是 extreme point，所以我们可以以它为起点。</p><p>如果出现多个最低点的退化情况，则优先选择最左侧的点，也称为 Lowest-Then-Leftmost point。</p><h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/x8V0zb.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Jarvis</span><span class="params">(Point S[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        S[k].extreme = FALSE</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ltl = <span class="built_in">LTL</span>(S, n);</span><br><span class="line">    <span class="type">int</span> k = ltl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start with LTL</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        P[k].extreme = TRUE;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++)</span><br><span class="line">            <span class="keyword">if</span> (t != k &amp;&amp; t != s &amp;&amp; (s == <span class="number">-1</span> || !<span class="built_in">ToLeft</span>(P[k], P[s], P[t])))</span><br><span class="line">                s = t;</span><br><span class="line">        P[k].succ = s;</span><br><span class="line">        k = s;</span><br><span class="line">    } <span class="keyword">while</span>(ltl != k)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>初始化所有点都被视为非极点，接下来找到刚才所说的 Lowest-Then-Leftmost point 并且把它作为我们的第一个点 <code>k</code> 进入下面一个迭代循环。</p><p>每一个点当它进入这个循环的时候必为极点，第一个点如此，后面的点也一样。接下来我们则要找 <code>s</code> 是逐渐优化最终找到的极点，任何时候我们都未必知道它就是，需要遍历所有候选 <code>t</code>。 </p><p>当 <code>t</code> 通过 To-Left 测试时什么都不处理，<code>s</code> 依然为候选者；反过来 To-Left 测试失败意味着出现在右侧，需要更迭 <code>s</code> 为 <code>t</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/zpOE73.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LTL</span><span class="params">(Point S[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="type">int</span> ltl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">if</span> (P[k].y &lt; P[ltl].y || (P[k].y == P[ltl].y &amp;&amp; P[k].x &lt; P[ltl].x))</span><br><span class="line">            ltl = k;</span><br><span class="line">    <span class="keyword">return</span> ltl;        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Output-Sensitivity"><a href="#Output-Sensitivity" class="headerlink" title="Output Sensitivity"></a>Output Sensitivity</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/spDhK8.png"></p><h3 id="Lower-Bound"><a href="#Lower-Bound" class="headerlink" title="Lower Bound"></a>Lower Bound</h3><h4 id="Reduction"><a href="#Reduction" class="headerlink" title="Reduction"></a>Reduction</h4><p>在前面几节里我们围绕凸包的计算问题给了一系列的算法，从最开始的 n^4 极点算法一直到后面 n^3 极边的算法，再到 Jarvis march 以及 Incremental n^2，我们在沿着一条不断递减的路线在降低这个算法的复杂度。</p><p>但是如果计算模型是固定的话，必然有一个我们所说的 Low Bound 的概念：下界，也就是复杂度再低也不会低于某一个极限。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/dcT0rw.png"></p><h4 id="CAO-Chong’s-Methodology"><a href="#CAO-Chong’s-Methodology" class="headerlink" title="CAO Chong’s Methodology"></a>CAO Chong’s Methodology</h4><p>三国中曹操的儿子曹冲有个很著名的故事：曹冲称象。</p><p>我们需要度量一个东西的难度，曹冲是要称出一头象的重量，他去找中间参照物石头，通过石头的重量估算出象的重量，而 Reduction 关系就是曹冲的船和水。</p><h4 id="Transitivity"><a href="#Transitivity" class="headerlink" title="Transitivity"></a>Transitivity</h4><p>那么为什么这个问题可以像曹冲称象一样能够间接通过 A 问题的难度就得到 B 问题的难度呢？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/AZka7O.png"></p><p>对于 A 问题的任何一个输入，我们都可以曲径通幽式的先把它转化为 B 问题的输入，接下来调用 B 问题的任意算法得到输出，再转化为 A 的输出。</p><p>如果 A 问题确实存在某一个下界，而且这个下界是严格大于 n 的，那么我们说 B 问题的所有算法都不可能低于这个复杂度下界。</p><h4 id="Reduction-Input"><a href="#Reduction-Input" class="headerlink" title="Reduction: Input"></a>Reduction: Input</h4><p>首先要把我们未知的那个问题（也就是那头象）摆在右边，这里我们考虑二维的凸包 2-dimensional convex hull 这个问题。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/RHvnFP.png"></p><p>而石头则是 Sorting。也许初看这个问题可能会很迷茫，排序这个问题和凸包这个问题一个是纯粹的抽象计算问题，一个是具体的几何计算问题，二者之间怎么会有联系呢？</p><ol><li>证明可以在线性时间内将排序问题的任何一个输入转化为凸包问题的输入</li><li>证明凸包问题的结果线性时间内转换回到排序问题</li></ol><p>排序问题的输入可以理解为在数轴或者平面上 x 轴一系列的点，在图中我们只取了四个点。为了转换为凸包问题我们需要辅助线，以抛物线作为标尺将每一个点做提升变换，将 n 个数字转化为平面上的 n 个点。</p><h4 id="Reduction-Output"><a href="#Reduction-Output" class="headerlink" title="Reduction: Output"></a>Reduction: Output</h4><p>来自抛物线上有线个点的凸包都具有这样的一个特性：最左侧的那个点和最右侧的那个点会在上面连上一条纵跨的一条单调直线。</p><p>这样我们就完成了 Reduction 的第二步：将凸包问题转化为排序问题。输入是无序的，输出是有序的，这正是排序算法的要求。</p><p>(注：这里有一个疑惑就是如果是正五边形，那么这个左右边界又该如何去界定呢？边界的连线并不单调。)</p><h4 id="Sorting-lt-x3D-N-2d-CH"><a href="#Sorting-lt-x3D-N-2d-CH" class="headerlink" title="Sorting <=N 2d-CH"></a>Sorting &lt;=N 2d-CH</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/s350xy.png"></p><p>所以排序算法的下界是 nlogn，那么凸包问题也是如此，成为 Convex Hull 的下界。</p><h3 id="Graham-Scan-Algorithm"><a href="#Graham-Scan-Algorithm" class="headerlink" title="Graham Scan: Algorithm"></a>Graham Scan: Algorithm</h3><h4 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>那么我们来看一个下界意义上讲最优的算法：Graham Scan。</p><p>Graham Scan 首先要做的一件事情是一个预处理，一个排序。这个 presorting 其实就是要找到某一个特定的点，并且将其余所有的点按照这个点所对应的极坐标按极角来做一个排序。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/M8f8bt.png"></p><p>那么具体的这样第一个点应该找谁呢？</p><p>其实任何一个极点理论上都是可以的，同样为了简化算法的解释和实现，我们不妨依然采用前面所讲过的 Lowest-then-Leftmost point 为 1 号点。</p><p>接下来会有与 1 号成角度最小的 2 号点，这里不妨假设 1、2 号点为同一高度，并且没有三点共线的情况，接着按照 (1, 2) 极轴的夹角从小到大命名其他点。</p><p>Graham Scan 算法的数据结构也很简单，只需要两个栈 T 和 S。初始化时依次将 1、2 入栈 S 中，其他 n-2 个点自顶到底存入 T 栈。</p><p>而排序可以选用任意排序，只是对象变成了点，而比较器变为 To-Left Test。</p><h4 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h4><p>这个扫描过程中要关注三个东西：S 栈栈顶以及次栈顶、T 栈栈顶，我们可以用 <code>S[0]</code>、<code>S[1]</code>、<code>T[0]</code> 表示。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/YCf577.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!T.<span class="built_in">empty</span>()) {</span><br><span class="line">    <span class="comment">// test type of current turn</span></span><br><span class="line">    <span class="built_in">toLeft</span>(S[<span class="number">0</span>], S[<span class="number">1</span>], T[<span class="number">0</span>])?</span><br><span class="line">        <span class="comment">// step forward at a left turn</span></span><br><span class="line">        S.<span class="built_in">push</span>(T.<span class="built_in">pop</span>()):</span><br><span class="line">        <span class="comment">// or, backtrack</span></span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Graham-Scan-Correctness"><a href="#Graham-Scan-Correctness" class="headerlink" title="Graham Scan: Correctness"></a>Graham Scan: Correctness</h3><h4 id="Left-Turn"><a href="#Left-Turn" class="headerlink" title="Left Turn"></a>Left Turn</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/3oGYec.png"></p><h4 id="Right-Turn"><a href="#Right-Turn" class="headerlink" title="Right Turn"></a>Right Turn</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/Zw9WOM.png"></p><p>9 号点被包含在了某一个三角形(1-8-10)的内部，它应该被排除掉。</p><h3 id="Graham-Scan-Analysis"><a href="#Graham-Scan-Analysis" class="headerlink" title="Graham Scan: Analysis"></a>Graham Scan: Analysis</h3><h4 id="Backtracks"><a href="#Backtracks" class="headerlink" title="Backtracks"></a>Backtracks</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/fTPnpm.png"></p><h4 id="Planarity"><a href="#Planarity" class="headerlink" title="Planarity"></a>Planarity</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/i2ooE2.png"></p><p>根据欧拉公式，平面图中所有边的数量包括面数加在一起依然和顶点数目保持同阶，边数不会超过顶点数的三倍。</p><h4 id="Amortization"><a href="#Amortization" class="headerlink" title="Amortization"></a>Amortization</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/mAH8dL.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>: S.<span class="built_in">size</span>()++; T.<span class="built_in">size</span>()--;   <span class="comment">//  1 - 2</span></span><br><span class="line"><span class="keyword">else</span>: S.<span class="built_in">size</span>()++;               <span class="comment">// -1 + 0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Divide-And-Conquer-1"><a href="#Divide-And-Conquer-1" class="headerlink" title="Divide-And-Conquer (1)"></a>Divide-And-Conquer (1)</h3><h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/fbtL5x.png"></p><p>归并排序作为引子引出我们的算法。</p><p>Divide-And-Conquer 要求我们接近均匀切分 divide，接着我们把这些结果合并起来成为有序序列，变成最终结果。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/3p8soR.png"></p><p>凸包问题也是如此，把输入的点集分成大小规模接近的子集分别求出它们的凸包。问题实质就变成了我有两个凸包子集之后如何将它们合并得到更大的凸包。</p><h4 id="Common-Kernel"><a href="#Common-Kernel" class="headerlink" title="Common Kernel"></a>Common Kernel</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/tuDj5v.png"></p><p>找到一个公共核使得这两个待合并的子凸包能够同时关于这个点是角度有序的。</p><h4 id="Interior"><a href="#Interior" class="headerlink" title="Interior"></a>Interior</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/5IBdvu.png"></p><p>二路归并采用环形次序，然后 Graham Scan 即可。</p><h4 id="Exterior"><a href="#Exterior" class="headerlink" title="Exterior"></a>Exterior</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/ReaP65.png"></p><p>我们预选的那个来自第一个子凸包的 centroid point 不幸落在第二个子凸包的外面，在这种情况下我们应当如何完成二者的归并呢？</p><h3 id="Divide-And-Conquer-2"><a href="#Divide-And-Conquer-2" class="headerlink" title="Divide-And-Conquer (2)"></a>Divide-And-Conquer (2)</h3><h4 id="Preprocessing-1"><a href="#Preprocessing-1" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/jzuwYn.png"></p><p>不妨做一个假设，待合并的两个子凸包或者说它们对应的点集是沿着某个方向是可分割的，彼此独立。如果这样我们的合并任务就会变得更加简明、简单。</p><p>为了保证这一点，我们引入一个预处理：按 x 轴排序。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/HybE5r.png"></p><h4 id="Common-Tangents"><a href="#Common-Tangents" class="headerlink" title="Common Tangents"></a>Common Tangents</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/FGE9PW.png"></p><h4 id="Topmost-Bottommost"><a href="#Topmost-Bottommost" class="headerlink" title="Topmost + Bottommost?"></a>Topmost + Bottommost?</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/mhMYrp.png"></p><h4 id="Stitch"><a href="#Stitch" class="headerlink" title="Stitch"></a>Stitch</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/4F6fi4.png"></p><p>我们可以在最初构造一个子凸包的时候记下 leftmost 和 rightmost 各是哪两个顶点，剩下几乎不用花时间：把此前计算结果延续下来即可，而分摊到每一次合并常数时间就够了。</p><h4 id="Zig-Zag"><a href="#Zig-Zag" class="headerlink" title="Zig-Zag"></a>Zig-Zag</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/mTWeCG.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/a3j4Rj.png"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://twitter.com/cyangmou/status/1571176793943457793&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CG1/qrXkrr.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本节我们将探索计算几何的核心问题：凸包问题。计算几何领域几乎所有的问题都可以“归约”为凸包问题，因此学习凸包问题对整个计算几何体系至关重要。&lt;/p&gt;</summary>
    
    
    
    <category term="计算几何 (Computational Geometry)" scheme="https://yousazoe.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-Computational-Geometry/"/>
    
    
    <category term="Computational Geometry" scheme="https://yousazoe.top/tags/Computational-Geometry/"/>
    
  </entry>
  
  <entry>
    <title>Introduction</title>
    <link href="https://yousazoe.top/archives/ed328fdc.html"/>
    <id>https://yousazoe.top/archives/ed328fdc.html</id>
    <published>2022-09-21T02:18:51.000Z</published>
    <updated>2023-05-05T12:43:30.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://twitter.com/m4ndrill/status/1570094225261301760"><img data-src="https://img.yousazoe.top/uPic/img/blog/CG0/Ofd9RT.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算几何的重要之处在于它是多门技术与学科的基础，例如图形学、CAD、GIS、路径规划等。这些技术的背后原理往往是基于计算几何的本质上。所以该门课程的学习对养成计算几何理论的总体认识很有帮助，这种认识将为学习者日后的研究工作提供几何的视角。</p><span id="more"></span><h4 id="What-can-we-learn-from-this-course"><a href="#What-can-we-learn-from-this-course" class="headerlink" title="What can we learn from this course?"></a>What can we learn from this course?</h4><blockquote><ul><li>Awareness of Computational Geometry theory that will help students incorporate Computational Geometry into their future research </li><li>Comprehensive understanding on fundamental paradigms/strategies for solving geometric problems, incremental construction, plane sweeping </li><li>Essential geometric structures and algorithms such as polygon decompositions, Voronoi diagrams, Delaunay triangulations</li></ul></blockquote><p>本课程的教学目标有三：</p><ul><li>对计算几何理论的总体认识，在日后的研究工作中，这种认识为你提供几何的视角</li><li>对几何问题求解范式及策略的全面领会，包括递增式构造、平面扫描、分而治之、分层化、近似以及随机化等</li><li>对基本几何结构及其算法的透彻掌握，包括凸包、多边形细分、Voronoi图、Delaunay三角剖分，以及几何求交、点定位、范围查找、截窗查询等</li></ul><h4 id="Are-you-qualified-for-learning-Computational-Geometry"><a href="#Are-you-qualified-for-learning-Computational-Geometry" class="headerlink" title="Are you qualified for learning Computational Geometry?"></a>Are you qualified for learning Computational Geometry?</h4><blockquote><p>Computational Geometry requires some skills of algorithm design and analysis as well as programming, but you don’t need to be an expert before learning this course. Actually, C/C++ programming experience and some basic knowledge of common data structures will be enough. To make sure whether you are qualified for learning this course, check the list below:</p><ul><li>C/C++ programming: variable, function, struct, class;</li><li>Algorithm design and analysis: complexity, amortized analysis, recursion, divide and conquer, linked list, binary search tree, priority queue.</li></ul></blockquote><p>计算几何这门课对数据结构和算法基础和编程基础有一定的要求，但这并不意味着你需要精通所有相关课程。实际上，你只需掌握一些常见数据结构，拥有一定的算法分析能力，以及C/C++语言编程的基本技巧。为确认自己是否适宜选修这门课程，不妨对照以下清单做一清点：</p><ul><li>C/C++语言程序设计基础：变量，函数，结构体，类</li><li>数据结构与算法分析：复杂度、摊还分析、递归、分治法、链表、栈、二叉搜索树、优先队列</li></ul><h3 id="History-of-This-Course"><a href="#History-of-This-Course" class="headerlink" title="History of This Course"></a>History of This Course</h3><p>这门课已经开设 18 年之久，虽然国外诸多著名高校都开设了这门课程，但国内做计算几何方面的学校和机构屈指可数。</p><h3 id="What’s-Computational-Geometry"><a href="#What’s-Computational-Geometry" class="headerlink" title="What’s Computational Geometry"></a>What’s Computational Geometry</h3><p>说到计算几何，我们要做一个名词辨析。</p><p>如果你第一次听到 Computational Geometry，首先注意到的肯定是几何，脑海中浮现的是曲线、曲面诸如此类。事实上我国数学家苏步青八十年代就曾出版过一本《计算几何》的书。 此计算几何非彼计算几何，这门课更加强调的是计算。现代计算几何人们公认诞生于 1978 年 Shamos 那篇著名的博士论文，所以这门学科到现在也不过区区四十年的发展历史。</p><p>当然计算几何之所以很重要，就是因为它是很多学科尤其是技术学科的基础，包括典型的图形学、CAD、GIS、路径规划等等……最后都会回到计算几何这些基本的问题。</p><p>在学习之前如果一言以蔽之概括一下的话，计算几何就是就是”算法设计与分析”的几何版，它所讨论的对象、问题的表面形式都是几何的，它求解这些问题的方法、策略高到上面的方法论其实也都是几何的。尽管从这个方面讲计算几何只是算法设计与分析的一个分支，但是正因为它融入了很多古典的一些离散几何学、组合几何学等等精华的结论和方法，所以它不仅仅是一个几何和计算两个问题的物理反应，而是很深入的化学反应。</p><h3 id="How-to-Learn-CG-Better"><a href="#How-to-Learn-CG-Better" class="headerlink" title="How to Learn CG Better"></a>How to Learn CG Better</h3><p>计算几何强调本质的东西就是要形象。</p><p>没有人喜欢复杂深奥的东西，所以这门课如果在学习过程中没办法很好理解推导和公式，不必拘泥于复杂深奥的泥潭，暂时放下它，将注意力放在图形和具体表现上。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://twitter.com/m4ndrill/status/1570094225261301760&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CG0/Ofd9RT.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;计算几何的重要之处在于它是多门技术与学科的基础，例如图形学、CAD、GIS、路径规划等。这些技术的背后原理往往是基于计算几何的本质上。所以该门课程的学习对养成计算几何理论的总体认识很有帮助，这种认识将为学习者日后的研究工作提供几何的视角。&lt;/p&gt;</summary>
    
    
    
    <category term="计算几何 (Computational Geometry)" scheme="https://yousazoe.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-Computational-Geometry/"/>
    
    
    <category term="Computational Geometry" scheme="https://yousazoe.top/tags/Computational-Geometry/"/>
    
  </entry>
  
  <entry>
    <title>基础算法</title>
    <link href="https://yousazoe.top/archives/ce5da845.html"/>
    <id>https://yousazoe.top/archives/ce5da845.html</id>
    <published>2022-09-20T13:04:37.000Z</published>
    <updated>2023-05-05T12:43:30.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/89559779/The-spirit"><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/DiUjjX.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>简单介绍一些基本算法，包括：搜索、贪心、二分查找与三分查找、序列分治以及排序。</p><span id="more"></span><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(3).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(4).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(5).PNG"></p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(6).PNG"></p><h4 id="什么是搜索"><a href="#什么是搜索" class="headerlink" title="什么是搜索"></a>什么是搜索</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(7).PNG"></p><h4 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(8).PNG"></p><ul><li>以起始状态为根，每个状态向其后继状态连有向边，可以得到一棵有根树<ul><li>终止状态对应这棵树的叶子</li></ul></li><li>搜索过程可以被抽象成遍历这棵搜索树的过程</li><li>如果需要遍历整棵搜索树，则复杂度至少正比于搜索树的结点数量</li><li>如果除叶结点外的结点都有至少两个叶结点，则可以用叶结点的数量估计有根树的大小<ul><li>为什么?</li></ul></li><li>如果除终止状态之外的状态都至少有两个后继状态，则可以用终止状态的数量估计搜索的复杂度</li><li>如果除终止状态之外的状态的后继状态数量是有下限的，则可以用层数估计终止状态的数量</li></ul><h4 id="搜索复杂度"><a href="#搜索复杂度" class="headerlink" title="搜索复杂度"></a>搜索复杂度</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(9).PNG"></p><h4 id="深度优先与广度优先"><a href="#深度优先与广度优先" class="headerlink" title="深度优先与广度优先"></a>深度优先与广度优先</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(10).PNG"></p><p>深度优先搜索(<strong>Depth-First Search</strong>)优先遍历一个后继结点的子树内所有结点</p><ul><li>先一条路走到黑，再返回上一个分岔点</li></ul><p>广度优先搜索(<strong>Breadth-First Search</strong>)先遍历所有后继结点，再遍历后继结点的后继</p><ul><li>在分岔点分身，最终每个终止结点都有一个分身</li></ul><h4 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 Depth-First Search"></a>深度优先搜索 Depth-First Search</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(11).PNG"></p><h4 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 Breadth-First Search"></a>广度优先搜索 Breadth-First Search</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(12).PNG"></p><h4 id="搜索策略的选择"><a href="#搜索策略的选择" class="headerlink" title="搜索策略的选择"></a>搜索策略的选择</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(13).PNG"></p><p><strong>深度优先搜索 DFS</strong></p><ul><li>只需储存从初始状态到当前状态的一条路径</li><li>当递归层数较深时可能会爆栈</li><li>需要考虑回溯撤销的问题，细节可能比较麻烦<ul><li>搜索层数不确定时可能会带来问题:无限拓展</li></ul></li><li>移动棋子，绕了一大圈返回起点</li><li>子树中结点编号是连续的</li></ul><p><strong>广度优先搜索 BFS</strong></p><ul><li>需要储存所有尚待拓展的状态，空间开销大</li><li>可以动态使用堆内存</li><li>状态单向拓展，实现较为简单</li><li>可以知道从初始状态到每个状态的最少步数<ul><li>适用于边权都为 1 的最短路</li></ul></li><li>同一层的结点编号是连续的</li></ul><h4 id="扩展阅读-迭代加深搜索"><a href="#扩展阅读-迭代加深搜索" class="headerlink" title="扩展阅读:迭代加深搜索"></a>扩展阅读:迭代加深搜索</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(14).PNG"></p><h4 id="搜索剪枝-Pruning"><a href="#搜索剪枝-Pruning" class="headerlink" title="搜索剪枝 Pruning"></a>搜索剪枝 Pruning</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(15).PNG"></p><p>果树剪枝是为了让树长得更好看，结出的水果质量更高</p><p>搜索树也可以剪枝，让搜索效率更高;注意不要把最优解给剪枝掉了</p><p>可行性剪枝</p><ul><li>如果当前状态已经不满足题目的要求，则不继续拓展</li><li>可以用于最优化问题，也可以用于统计解</li></ul><p>最优性剪枝</p><ul><li>只能用于最优化问题</li><li>如果从当前状态出发，可以得到的最优解一定不比已经得到的最优解优，则不继续拓展</li></ul><p>此外还有其它剪枝思路，例如在双人游戏中有 Alpha-beta 剪枝等，在这里不详细展开</p><h4 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h4><h5 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(16).PNG"></p><h5 id="埃及分数"><a href="#埃及分数" class="headerlink" title="埃及分数"></a>埃及分数</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(18).PNG"></p><h5 id="剪枝思路"><a href="#剪枝思路" class="headerlink" title="剪枝思路"></a>剪枝思路</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(19).PNG"></p><ul><li>放缩!</li><li>如果怎么救都救不回来，那就应该放弃<ul><li>如果后续状态一定不合法，则不继续深入搜索</li></ul></li><li>以最小化问题为例<ul><li>为当前状态的所有后继估计解的下界，如果下界大于(或大等于，取决于具体题目)当前最小值则剪枝</li></ul></li><li>扩展阅读:分支定界法求解</li></ul><h4 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(20).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(21).PNG"></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(26).PNG"></p><h4 id="贪心-Greedy-Algorithm"><a href="#贪心-Greedy-Algorithm" class="headerlink" title="贪心 Greedy Algorithm"></a>贪心 Greedy Algorithm</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(27).PNG"></p><h4 id="贪心与动态规划的区别"><a href="#贪心与动态规划的区别" class="headerlink" title="贪心与动态规划的区别"></a>贪心与动态规划的区别</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(28).PNG"></p><h4 id="找零钱问题"><a href="#找零钱问题" class="headerlink" title="找零钱问题"></a>找零钱问题</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(29).PNG"></p><ul><li>假设你有面值为 1 元，5 元，10 元，20 元，50 元和 100 元的纸币各若干张</li><li>用这些纸币表示出给定的正整数金额，使得用的纸币数量最少</li><li>贪心做法:每次选取不超过尚未被表示的金额的面值最大的纸币<ul><li>127 → 100 + 20 + 5 + 1 + 1</li><li>正确性?</li></ul></li><li>假设纸币的面值是 1 元，2 元，4 元，8 元，16 元，……，贪心做法还是正确的吗?</li><li>假设纸币的面值是 1 元，5 元，10 元，20 元和 25 元，贪心做法还是正确的吗?<ul><li>反例:40 → 25 + 10 + 5，但是 20 + 20 更优</li></ul></li></ul><h4 id="证明贪心正确性的常见思路"><a href="#证明贪心正确性的常见思路" class="headerlink" title="证明贪心正确性的常见思路"></a>证明贪心正确性的常见思路</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(30).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(31).PNG"></p><h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(32).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(33).PNG"></p><h3 id="二分与三分"><a href="#二分与三分" class="headerlink" title="二分与三分"></a>二分与三分</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(34).PNG"></p><h4 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 Binary Search"></a>二分查找 Binary Search</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(35).PNG"></p><h4 id="一个小故事"><a href="#一个小故事" class="headerlink" title="一个小故事"></a>一个小故事</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(36).PNG"></p><h4 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(48).PNG"></p><h3 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(50).PNG"></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(51).PNG"></p><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(52).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(53).PNG"></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(54).PNG"></p><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(55).PNG"></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(56).PNG"></p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(57).PNG"></p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(58).PNG"></p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(59).PNG"></p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(60).PNG"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/89559779/The-spirit&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/THUAA3/DiUjjX.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;简单介绍一些基本算法，包括：搜索、贪心、二分查找与三分查找、序列分治以及排序。&lt;/p&gt;</summary>
    
    
    
    <category term="清华大学算法协会 (Tsinghua University Algorithm Association)" scheme="https://yousazoe.top/categories/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E5%8D%8F%E4%BC%9A-Tsinghua-University-Algorithm-Association/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>《赛博朋克：边缘行者》与人文主义的反思</title>
    <link href="https://yousazoe.top/archives/dff9eab3.html"/>
    <id>https://yousazoe.top/archives/dff9eab3.html</id>
    <published>2022-09-19T02:03:09.000Z</published>
    <updated>2023-05-05T12:43:30.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/FQe8VN.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在贪墨成风的反乌托邦世界中，四处都是生化改造植入体。动画剧聚焦一个在街头长大的鲁莽天才少年努力想成为边缘行者：拿钱办事的法外之徒。</p><span id="more"></span><p>近些年里，游戏改编的影视作品越来越多，每一部都会宣称自己制作如何精良，但它们要么如《龙之血》《双城之战》那样摒弃了游戏玩法、着重于挖掘背景故事，要么如《神秘海域》或者《光环》，大幅改造甚至看不起原作剧情直接另起炉灶，没有任何一个能像《边缘行者》这样忠实地遵从原作的框架、同时还能讲好一个故事。它甚至还弥补了《2077》至今未能实现的缺憾：我们终于看到了单分子线在大杀四方的同时也能实现骇入，也终于看到了 NCART，其实是能坐人的。</p><p>《边缘行者》播出以来在各个评分网站上都收获了不错的口碑，这不仅证明了《2077》确实有着优秀的基础框架，可惜潜力没有被充分发挥出来；同时也是打了那些自大的好莱坞编剧们的脸：老老实实照着游戏内容拍，远比你们一拍脑门搞出来的那套东西更能讨好观众。</p><p>当然，出色的作画、讨喜的人设，还有以上说的种种，固然能够大幅提升玩家们的观感；但真正能够打动观众的，还是赛博朋克的内核。</p><h3 id="剧情梳理"><a href="#剧情梳理" class="headerlink" title="剧情梳理"></a>剧情梳理</h3><h4 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h4><p>本剧的主角，大卫·马丁内斯，在故事刚开始的时候，还是一个不谙世事的学生。他的母亲葛洛丽亚在市政部门工作，薪水微薄，日常工作是清理横死街头的赛博疯子和帮派分子。借着职务之便，能够接触到这些死人身上拆下来的义体，她便通过把义体倒卖给边缘行者们来赚取外快。而她这样辛辛苦苦、不惜违法地赚钱，目的就是供养自己的儿子在荒坂学院念书。</p><p>荒坂学院是荒坂公司附属的精英学术机构，费用高昂，但学员能够成功毕业，就有机会进入荒坂公司工作，再之后，就有机会一步一步爬到高层——这在葛洛丽亚看来，是普通人唯一能够改变命运的手段。</p><p>而对大卫来说，自己和学院里其他那些少爷终究不是一路人。尽管成绩优异，但连备用制服都买不起的贫寒家境让他处处遭到排挤。平时，他只能在黑超梦带来的感官刺激里麻醉自己，同时靠帮黑市的义体医生推销这些超梦来赚些零花钱。</p><p>本来，日子像这样平平常常地过去，也许大卫最终会成为荒坂公司的一颗螺丝钉，在无止境的工作和加班中被消磨殆尽；又或许时运眷顾，他真的会在企业里步步高升，最后出人头地呢。</p><p>但按部就班的生活因为一场车祸戛然而止。赶来救援的创伤小队把没有保险的母子二人留在原地等死，超级摩天楼里简陋医院的廉价急救套餐终于还是没能救回葛洛丽亚。</p><p>大卫把母亲火化——这是最便宜的丧葬方案——抱着母亲的骨灰回到了因为租金逾期未交而把他拒之门外的家。</p><p>他甚至没有哭泣。</p><p>在夜之城，死亡会让人麻木。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/UPABD8.jpg"></p><p>可他在母亲的遗物中发现了一件义体，他在黑超梦中见过它。斯安威斯坦，军用级义体，能够触发缓时。发动时，周围的一切仿佛静止，只有使用者能够移动自如。</p><p>到了2077年，斯安威斯坦已经发展到可以人手一件的程度，但在剧中故事发生时，装备这件义体还是一个禁忌。不只是因为它专供军用科技内部使用，外部难以获取；更是因为，普通人使用它，十有八九会发疯。</p><p>大卫没管这么多，他甚至在不知道什么是免疫抑制剂的情况下，去找那个相熟的义体大夫安装了斯安威斯坦。随后他直奔学院，在全班同学面前，把之前羞辱了自己和自己的母亲的田中痛打了一番。</p><p>在这之后又是无尽的空虚。他漫无目的地行走在那些曾经走过无数遍的道路上，不知道该做些什么。</p><p>而在这时他遇到了生命中的光。</p><h4 id="PART2"><a href="#PART2" class="headerlink" title="PART2"></a>PART2</h4><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Lucy，我偶尔，只是很偶尔的时候，会问自己，如果我没有见过你，我到现在的人生会不会不一样？没有成为边缘行者的我，没有遇到爱情的我，没有结实这么多同伴的我。我也许会给田中道歉、回到荒坂学院、成为义体实验对象，也许，有那么一丝的可能性，我能够进入公司的高层，能够实现妈妈的愿望。那样的什么都不知道的我，会不会也很快乐呢？ </p><p>但是再给我一次机会，我仍然不可能做出其他的选择。在那趟列车之前，在妈妈遇到车祸之前，在田中把我揍得体无完肤之前，我就见过你了。也许没有真的见过你，也许只是在梦里见过你。但那一头银发，是我黑暗中的光，我早已见过一次又一次，就算是在梦里我也不会认错。 </p><p>我的人生早已注定了。我注定会认识你。</p><p>而这是我遇到过的，最最最幸运的事。</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>他之前就遇到过好几次，一头璀璨耀眼的银发，但总是转瞬即逝，以至于他会以为是幻觉。不过，这次是在轻轨上，她无法再那么轻易地消失了。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/KbQWK1.jpg"></p><p>女孩名叫露西。他看到她在偷取别人的芯片，她发现了他窥伺的目光，冲突、解释、握手言和。他提出帮忙，三七分成。之后是一番奇遇，她把他邀请到家中，分享了自己隐秘的梦想——离开夜之城的牢笼，去月球生活。他们在超梦里登月，在虚拟的低重力下跳跃、欢笑。然后美梦醒来，一伙壮汉把大卫拉回现实。他们是赛博朋克，即是边缘行者。斯安威斯坦本是那伙人中的头领曼恩向葛洛丽亚订购的，如今后者杳无音信，露西按图索骥找到了大卫，现在他们要拿回自己的东西。大卫坚定地要为他们工作来偿还债务，思忖良久，曼恩答应了下来。</p><p>就这样大卫加入了这个小团体，认识了浑身装满义体的大块头曼恩 Maine、曼恩强壮的女友多利欧 Dorio、有着一双灵活手臂的技术狂皮拉 Pilar、皮拉的萝莉妹妹瑞贝卡 Rebecca、沉默寡言的黑客专家琦薇 Kiwi、以及老练可靠的司机法尔科 Falco。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/FQe8VN.jpg"></p><p>大卫在这里找到了家的感觉、和同伴们打成一片，也在一次次任务中逐渐成长为了优秀的边缘行者。他向 Lucy 吐露了自己的感情，答应要带着她去月球。Lucy 吻了过去，两颗心贴在了一起。</p><p>如果到此为止，不过是一系列热血番中常见的展开。主角团中有人死去、有人离开，但主角总是借着光环无法倒下。可赛博朋克的世界不是童话故事。一次任务中，大哥曼恩终于无法控制住自己日渐被义体所侵蚀的神经系统，失手攻击 Kiwi，打乱了行动计划，Lucy 作为备用黑客迫不得已加入任务；后面又因为失神造成了 Dorio 的死去。面对着 NCPD 和创伤小队的双重围堵，曼恩知道自己大限已至。面对前来试图营救自己的大卫，他只是淡然地说了一句：“这就是我的终点了。”</p><p>随后，便用烈火将自己和爱人焚尽。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/yNCjfh.jpg"></p><h4 id="PART3"><a href="#PART3" class="headerlink" title="PART3"></a>PART3</h4><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>他们都说，夜之城的传奇都在坟墓里。</p><p>这大概是真的吧。那么，曼恩大哥也算是一个传奇了吧。</p><p>但如果有选择的话，我宁愿不做那个传奇。毕竟，以前你们好多人和我说，说我老是为别人的梦想而活；而现在我也有自己的梦想了呢。我的梦想，就是我之前承诺过的，帮你实现你的梦想。你那时说你的梦想是去月球，我从来没有忘记过。月球的单程票是25万欧，当然，如果想要在那里生活，应该还需要更多的钱吧。如果完成了这最后一份差事，大概就足够了。如果能拿到赏金，如果能和你一起去月球，是不是也挺不错的呢？</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>此去经年，大卫成了小团体的新领袖，在圈子里的声望也越来越显赫。Rebecca 在和大卫搭档的过程中对他暗生情愫，可这份心思又怎么能够挑明呢？露西和他一起住进了漂亮的大公寓里，但不再参与组织的工作。当时，她在任务目标的大脑中发现，对方想要拿大卫作为荒坂的新产品“义体金刚”的实验对象。为了保护大卫，她删除了相关信息，没告诉任何人；在这几年中，她名义上拒绝参与团队工作，实际上却是在追杀任何了解实验计划的荒坂员工。</p><p>Lucy 的讳莫如深在大卫眼中看来是逐渐的疏远，可他自己又何尝没有改变呢？</p><p>当初，为了跑步时能够追上 Lucy，他给自己装上了斯安威斯坦外的第一个义体——一对人工肺。后来，曼恩嘱托他，为自己多装几个义体，变强，活下来。于是几年下来，大卫也变成了一个钢铁大块头，一个机械部分多于肉体的义体改造狂。他用的免疫抑制剂，药效也越来越猛、剂量也越来越多。他会时不时地抑制不住自己手臂的抖动，一如曼恩最后的那些日子。</p><p>明眼人都看得出来，大卫离赛博精神病不远了。</p><p>在《2077》里，也许是因为 Relix 芯片的特殊性，又或许仅仅是因为 CDPR 偷懒没有做出来，V 就算把自己浑身上下改装个遍，也感觉不到义体的副作用。可对普通人来说，你的身上不属于自己的部件越多，你的神经系统和肉体对它们的排异反应就会越大，最终，你的大脑会成为机械的奴隶，这就是赛博精神病。成为赛博疯子就是每个没在这之前就挂掉的义体改造狂最终的结局，而在终点等待着他们的，就是疯控小队。</p><p>大卫相信自己有某种天赋。这天赋从他还是十几岁的孩子、刚刚装上斯安威斯坦就能熟练掌控、随心所欲地运用就能看出端倪。要知道，就算是V，发动斯安威斯坦的效果都需要60秒游戏内时间的冷却。这天赋让他能装上一个又一个的义体，而不良反应比起其他人来说又是少之又少。这天赋让他觉得自己是“独特“的，让他觉得他能在夜之城里混出个名堂，让他觉得，带着露西去月球生活，也是有可能的。</p><p>所以说就算 Lucy 和 Rebecca 都劝说他，不要再改装自己了，拆卸下一些义体吧，他还是固执地为自己安装更多的功能模块。</p><p>在他看来，这是能让他赚到足够去月球的钱的，唯一的道路。</p><p>机会来了。一个大单子。拦截荒坂的一辆运输车，取到货，数百万欧，足够团队里每个人过上逍遥日子。当然，这自始至终都是诱饵，目的是让大卫穿上“义体金刚“、与军用科技斗个两败俱伤、最后由荒坂公司自己回收其中的实战数据。另一边，Lucy之前的行迹败露，又遭到Kiwi的出卖，被已成为荒坂哈巴狗的中间人法拉第扭送往荒坂。</p><p>计划如公司所料般进行，大卫一伙被军用科技包围，法拉第用合成的 Lucy 声音哄骗大卫穿上义体金刚，Kiwi跳反，偷袭法尔科后扬长而去。此后，按计划，大卫会发疯、与军用科技同归于尽——可 Lucy 在最后关头挣脱，向大卫发出了警告。这义体是把你赛博精神病的最后一根稻草，就算你没有疯，超量的免疫抑制剂也会让你的理智滑向边缘之外。求求你，千万别装。</p><p>可大卫有什么选择呢？穿了这义体，就不能陪你去月球；但不穿这义体，就不能救下你。这看似是两种选择，但对大卫来说，可能性只有一个。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/SkWYWR.jpg"></p><p>义体安装完成，Rebecca 帮他注入了一大瓶抑制剂。他启动机体，反重力装置和磁场发生装置风卷残云般摧毁了军用科技的包围圈。和荒坂料想中的不同，大卫还保持着清醒。下一步，他们向荒坂塔开去。</p><h4 id="PART4"><a href="#PART4" class="headerlink" title="PART4"></a>PART4</h4><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>可是我也许一开始就知道这是不可能的吧。大概从我安装上斯安威斯坦那天起，我就从它前主人的超梦中预见到了自己的结局。曼恩大哥那时对我说，那就是他的终点了。我当时不甘心，我当时觉得也许我再努力一点就能救下他了。但现在我知道了，当一个边缘行者的终点到来时，他会明白的。正如这就是我的终点了。</p><p>我没能救下妈妈，没能救下曼恩大哥，没能救下瑞贝卡，但我终于救下了你。</p><p>在月球好好生活吧。去感受地球六分之一的重力。去感受太阳的温度。</p><p>只是对不起，我们不能一起去了。</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>穿过荒坂和军用科技的重重围堵，一行人终于来到了最后的目的地。在荒坂塔前，大卫注射了最后一管免疫抑制剂，这其实就是他的死亡宣告：就算他最后战胜了重锤，也无法活着离开。更何况我们都心知肚明，他不可能打赢。</p><p>相比于 V 的轰轰烈烈，大卫的荒坂塔之旅，结束得既迅速又潦草。早在突围时大卫就开始在疯狂和清醒的边缘游走，越接近公司广场时更是越发难以稳定智识。恍惚中他登上了荒坂塔的顶端，在某种意义上完成了母亲的梦想。随后他冲进大楼，在这里遇到了亚当·重锤，一个他以为并非真实的人物。一个几乎只有大脑是原装的机械怪物。一个全无人性的梦魇。斯安威斯坦对重锤来说不过是初级的植入物，面对他，大卫毫无胜算。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/xrSssQ.jpg"></p><p>在此时的大卫身上我仿佛看到了自己。曾经自命不凡地以为自己是独特的那个，在现实日复一日的捶打下逐渐动摇了信心，开始怀疑自己，最后终于在某一刻发现，自己的“独特”在别人眼里可能只是个笑话。看到重锤，正是让大卫明白，自己的“独特”、“对于义体的天生钝感”，在这种公司培育出来的怪物面前，根本不值一提。</p><p>于是他释然了。就像当初的曼恩那样，大卫也明白了自己的结局。他选择了他能做到的最好的事：给法尔科和露西争取时间，让他们带着钱离开。让露西能够实现去月球的梦想。至于他自己呢？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/3qxDOb.jpg"></p><h3 id="绝望与无力"><a href="#绝望与无力" class="headerlink" title="绝望与无力"></a>绝望与无力</h3><p>从第一集开始大卫因为没有钱所以只能眼睁睁地看着本来有救的母亲去世，到最后站在荒坂大厦的顶端往下纵身一跃，他确实给垄断这个世界的大企业造成了一点小小的麻烦，但是归根结底，他都始终无法像传统的 TRIGGER 主角们那样用自己的意志去决定自己的命运。</p><p>恰巧相反，男主大卫从一开始接受移植手术到最后组装金刚机甲其实都是在接受一种看似自由选择的命运操弄，这种无论如何努力却依旧还是在既有框架体系之中的绝望和无力感，个人认为是对于 TRIGGER 传统的【钻破体系障碍】的逆反，但同时也是对于赛博朋克这一题材的绝佳诠释。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/OlIlVF.jpg"></p><p>在赛博朋克的世界里，一切的传统价值都被解构掉了，就连【相信】这个词也不能够被相信了，只有赤裸裸的能够被量化的金钱、身体机能改造或者成瘾品才能作为生存的意义，以至于大卫实际上只能够为了别人而活，为别人的梦想而活，他自己根本找不到自己为什么要活着的原因。</p><p>赛博朋克这个概念本来也就是作为一种现代化狂飙突进到极点之后的反乌托邦，因此大卫的迷茫其实也有其一定的现实意义。</p><h3 id="梦想与现实"><a href="#梦想与现实" class="headerlink" title="梦想与现实"></a>梦想与现实</h3><p>有批评者认为本作剧情不佳，觉得情节转折推进生硬、大卫行事动机薄弱，觉得露西明明可以和大卫解释清楚，觉得大卫明明可以拆下义体，觉得两个人明明可以靠着攒来的钱远走高飞，又何必走到最后那一步呢？</p><p>可我们别忘了，这里是夜之城，在这里，公司就是不坏的王权。</p><p>哪怕是当年强尼·银手和摩根·黑手把两颗战术核弹塞进了荒坂塔，把它夷为了平地，荒坂也能够在原地重新建造一座更气派的大楼。哪怕是后来无所不能的、最后成了城市之王的V，也不过是杀了几个西海岸的董事会成员、暂时阻止了荒坂三郎借尸还魂，荒坂在日本的根基并没有动摇、何况三郎的意识在别的分部可能也有备份。哪怕是荒坂就此一蹶不振，军用科技、康陶、夜氏集团也会立刻把它的份额瓜分殆尽。一切都不会有任何改变。</p><p>而大卫呢？大卫后来租住的公寓看上去相当豪华，但如果不接任务，他可能会连抑制剂都供养不起，更别提攒钱了；他的团队已经算是圈子里的顶尖队伍，在中间人法拉第眼中也不过是一批耗材；后者还幻想着一步登天进入公司，但在真正的公司人眼中也只是个逐利的小丑。在夜之城，哪怕你混成了来生的传奇，在公司眼里也是随时可以碾碎的蛆虫。大名鼎鼎、天赋异禀的大卫·马丁内斯，甚至都打不过亚当·重锤这条荒坂豢养的看门狗，更遑论撼动公司的一根汗毛。</p><p>在边缘行者们眼中，大卫最终迎来了一个壮烈的牺牲，一个传奇式的结局。</p><p>而在公司眼中，整个事件自始至终也没有惊动任何一个荒坂家族的成员，甚至可能董事会都对此漠不关心。</p><p>只是疯控小队又在公司广场上处决了一个赛博疯子，夜之城普普通通的一天而已。</p><p>对于在这样一个世界里的底层民众来说，只有梦想，只有那一点点对于未来的希望，才能支撑着人活下去。</p><p>人们总是对大卫说，你不要为了别人的梦想而活，但大卫根本不知道该梦想什么。在城市的边缘徘徊了那么久，他早已丧失里梦想的能力，哪怕最后对女主说出，“我的梦想就是完成你的梦想”，也依然没有跳出为别人梦想而活的桎梏。这其实也揭示了他注定的悲剧结局，因为直到最后，他也没有学会该怎样为自己而活。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/k6rWhY.jpg"></p><p>就算是那些有梦想的人，又能梦想到多远的地方呢？母亲的梦想是迎合，是儿子有朝一日能出人头地；曼恩的梦想是苟且，是靠不断变强的身体和同伴的支持走下去；露西的梦想是逃避，是逃往一个能够远离荒坂的触手的地方。而就连这些卑微的梦想，也会被公司一个接一个地毁灭。就算没有遇到车祸，葛洛丽亚的身体也会被不断累积的账单、债务和日夜的操劳压垮；就算任务没有出现差错，曼恩也会因为义体对神经系统的侵蚀而一步一步滑向彻底疯狂的深渊；而如果没有大卫，就算露西特意租了一间可以看到发射场的公寓，那一艘又一艘腾空而起的飞船里，也永远不会有她的身影；就算是现在，露西成功地来到了月球上，她又能躲得过荒坂的清算吗？</p><p>潘多拉因为好奇打开了众神留下的盒子，所有丑恶的东西一齐向人间四散飞去。在最后一刻她终于关上了盒子，留下了希望。有人说这是众神最后的怜悯，就算周围一片黑暗，希望仍存。</p><p>也有人说这是众神最大的恶意，因为每一个希望背后，总有绝望随行。</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>L’enfer est pavé de bonnes intentions. </p>            <i class="fa fa-quote-right"></i>          </blockquote><p>哦，还有爱情，这最后一点慰藉，最后一点美好的东西。</p><p>可夜之城的爱情，也不过是风中的烛火，轻轻一吹，就熄灭了。</p><h3 id="人文主义反思"><a href="#人文主义反思" class="headerlink" title="人文主义反思"></a>人文主义反思</h3><p>对未来的担忧往往会被人们以鲜明而极端的方式所表达出来。比如阿道司·赫胥黎的《美丽新世界》和乔治·奥威尔的《1984》等经典反乌托邦的末日预言，或者赫伯特·乔治·威尔斯的电影《先河》呈现出的未来世界完美或近乎完美的愿景。</p><p>而兴起于20世纪80年代由“控制论”和“朋克”两个概念组合而成的“赛博朋克”，正诞生于社会大变革下人们对未来的担忧的时代。于是，一场基于赛博朋克概念的文学运动逐渐蔓延，其所传达的精神文化通过各种形式的媒体传播，一种包罗万象、不断增长的亚文化随之流行。</p><p>赛博朋克展现了一种信息高度发达的未来人类社会图景，这种社会表面充满和平，内在却充斥着难以控制的阶级矛盾、资源紧缺等弊病。物质文明泛滥并高于精神文明，致使人类精神在高度发达的技术社会难以实现真正自由，从而具有明显的反乌托邦特性和悲观主义色彩。</p><p>从1984至今，科技迅速发展，新技术层出不穷，就在我们的世界随着现实时间的推进而更新的同时，赛博朋克下构建近未来世界的元素也大大增加。</p><p>尽管赛博朋克不是现实生活的完全映射，其狂想的架构更是塑造了许多个陌生的世界，以至于需要一定的接受度和反应时间。但赛博朋克作为一种基于时代环境的自我反思，揭示出了其中反映的数字时代的认知、认知局限与认知方式的转变，也持续地发人深省，供给科技伦理更多善意。</p><h4 id="赛博朋克的诞生"><a href="#赛博朋克的诞生" class="headerlink" title="赛博朋克的诞生"></a>赛博朋克的诞生</h4><p>二十世纪60年代，是一个社会大变革的年代。二战的滚滚硝烟与第三次科技革命的爆发，导致了这个黑暗压抑又有一丝光明前景的时代，未来近在眼前，历史还未走远。</p><p>一方面，曾经自由民主的国家无法抑制失业率上升或通货膨胀，国家干预也无法解决诸如种族主义或个人对意义和秩序的渴望等社会问题。超级大国利用游击队和傀儡政权作为他们争夺世界霸权的筹码。越来越多的经济学家和未来学家开始怀疑，冷战最终不过是日渐式微的西方世界的杂耍表演。</p><p>第三世界的主要国家正在崛起。日本比欧洲和美国更娴熟地玩着资本主义的游戏，中国和东南亚“七虎”在不受西方自由主义影响的情况下开始了自己的致富之路。而西方则无法与他们日益提高的生产效率和越来越多的劳动力相抗衡。</p><p>世界环境也在走向地狱，生物学家雷切尔·卡森早就在《寂静的春天》一书中对使用DDT和其他杀虫剂存在的危害发出了第一次警告，而这仅仅是个开始。事实证明，有毒废物造成的危害比任何人想象的都要多，公众的担忧似乎也无法阻止农药进入空气、土地和水中。</p><p>工厂和城市的有毒排放物不断地进入环境之中，持续的气候变化也迫在眉睫。1979年，世界气象协会（WMA）警告称，全球变冷已经持续了几十年，冰川期很可能即将来临。</p><p>另一方面，20世纪后期，控制论、信息论、计算机/网络、生物遗传工程等飞速地发展。尤其是80年代中期后，虚拟现实技术、人工智能技术，计算机图形学、仿真技术、多媒体技术、人工智能技术、计算机网络技术、并行处理技术和多传感技术的发展，人类生活水平前所未有地提高了。</p><p>现代性许诺了美好的前景和理想，诸如平等、自由和理性。人们在希望和绝望之间摇摆不定。终于，这种矛盾产生了科幻艺术创作的参考设定——赛博朋克。</p><p>事实上，赛博朋克所具备的元素在20世纪初的科幻小说中就可见端倪。在视觉文本出现以前，科幻小说是科幻领域的主要的表现形式。在整个十九世纪中，科幻创作经历了草创期以及从古典到现代的转型，工业革命引发了人类文明史上科技前所未有的大发展，这为作家们提供了用之不竭的创作激情。</p><p>进入二十世纪后，科幻领域开始出现变化，科幻电影、绘画、连环漫画、广播剧以及电视作品先后出现。梅里埃的《月球旅行记》成为了科幻电影的发端，也揭开了小说改编成电影的序幕。</p><p>1982年，世界上第一部赛博朋克电影《电子世界争霸战》在美国上映，《漫长的明天》将科幻小说和黑色电影相融合，《银翼杀手》则展现了一个雨后华丽的未来都市。</p><p>而真正开启了赛博朋克流派的发展则是1984年布鲁斯·贝斯克的《赛博朋克》和威廉·吉布森的《神经漫游者》问世。事实上，无论从哪方面来评价，《赛博朋克》和《神经漫游者》都是赛博朋克流派的权威之作。</p><p>《神经漫游者》的展望中，未来的两部分泾渭分明。一边是肮脏、充满犯罪的物质世界，一边是明亮的网络空间；一边是大街上为了生存抗争的人们，一边是绕地球环行的贵族努力找办法填补他们人为延长的寿命；一边是来自我们世界的老旧残迹——在故事早期，凯斯买了“一把50年前南美版瓦尔特PPK手枪的越南仿制品”——另一边则是能够让人们用新的肢体、眼睛和皮肤来强化身体的尖端科技，只要他们买得起。</p><p>于是，借助流行文化、科幻小说、戏剧和电影，这些基于既定事实又承载着超越想象力的故事，以《神经漫游者》为代表的赛博朋克作品从多个侧面描绘了一个关于未来的模糊信仰。</p><p>它既包含着对技术的依赖和恐惧、对未来浪漫而悲观的想象，又掺杂了身处技术爆炸时期的后人类对世界与自我的颠覆性认知。而这些杂陈的情绪以一种哲学化的方式被植入赛博空间的意象中，使它本身作为一个通信科学发展的产物，承载了更加值得深思的文化隐喻。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/KBIXfd.jpg"></p><h4 id="从浪潮到退潮"><a href="#从浪潮到退潮" class="headerlink" title="从浪潮到退潮"></a>从浪潮到退潮</h4><p>20世纪80年代明确了赛博朋克作为一种风格的界限，一并开启了赛博朋克流派作品的创作。</p><p>同时，在计算机领域突飞猛进的发展下，到了赛博朋克出现的八十年代，信息技术、生物工程、基因技术、网络、黑客等名词逐渐进入公众领域。人机联网，人工智能，虚拟空间等开始在现实生活中逐步实现。而在赛博朋克文学和电影诞生之初，赛博朋克就将这些先进技术与很多现实问题联系在一起。</p><p>其中，帕特·卡蒂甘的《合成人（1991）》构筑了一个由复杂的人机合作所掌控的世界，关注大脑改造技术的心理暗示；鲁迪·鲁克的Ware系列则延续了《神经漫游者》里有自我意识的人工智能这一思路，并得出了逻辑上的结论，即在此基础上产生的机械生命体是如何在其后代中进化的。</p><p>K.W.基特曾以《极度恐怖》而闻名，他推出的《玻璃锤》，则是一部结合了《硬线》风格的寓言故事——诺斯替主义邪教的超速者和走私者以及他们救赎世界的理念误入歧途的图景。</p><p>格雷格·贝尔则在《血音乐》一书中创造了一个复杂的未来，人类会被因基因改而拥有自我意识的细菌所破坏和改造。赛博朋克主题出现在他后来的一些作品中，尤其是以1990年的《天使女王》为开端的系列，书中的故事发生在洛杉矶，在那里纳米技术带来了根本性的变化。</p><p>布鲁斯·斯特林的作品，比如《网络岛》，对黑客这种亚文化开始特别关注。同时，斯特林是赛博朋克舞台上的一个标志，他编辑的《镜影：赛博朋克选集》是一本重要的短故事合集，包括吉布森、卡蒂甘和鲁克的作品。在这本书的前言中，斯特林写道：</p><p>“有些中心主题在赛博朋克中反复出现，比如身体入侵，包括假肢、植入电路、整容手术和基因突变。更重要的主题是心灵入侵：人脑-电脑交互，人工智能，神经化学——这都是从根本上重新定义了人性本质和自我本质的技术。”</p><p>于是，第一波浪潮中的赛博朋客作家继续他们的多元化发展，赛博朋克的思想和意象向四面八方扩散。赛博朋克的成功展示了一种思想在实现实体表达之前所具有的力量。正如乔治·奥威尔在《1984》中的构思已经成为了政治话语的一部分。因此，赛博朋克的存在也同时影响着现实世界中计算机和其他领域的发展。</p><p>然而，这并不意味着赛博朋克的发展就是一帆风顺的。事实上，在赛博朋克小说上发生的事情，同样发生在流行文化任何一个分支里的成功新事物上。布鲁斯·贝斯克说，“它从一个意料之外的、崭新的原创事物变成一股短暂的新潮，一个可重复的商业公式和一种老套的修辞。”</p><p>《神经漫游者》的主题变成了某种清单。疏离的独行者在镜影中做着毒品生意或飞快地入侵电脑，这样的故事很快成为标准内容。然而类似故事太多了，一些90年代最重要的赛博朋克故事，将这种公式推至具有讽刺意味的极端，使得赛博朋克终于在90年代走向了退潮。</p><h4 id="赛博朋克的重新出发"><a href="#赛博朋克的重新出发" class="headerlink" title="赛博朋克的重新出发"></a>赛博朋克的重新出发</h4><p>尽管看起来赛博朋克走向了消逝，但奇异的是，随着千禧年的结束，赛博朋克迎来了它最重要的时刻。它的影响力向外扩展，朝着许多不同方向突变，最终进入了主流文化。</p><p>究其根本，是因为赛博朋克本身的吸引力远不止于表面的皮革、铬合金和霓虹灯。风格显然很重要，但是赛博朋克更为重要的内核是：人们可以通过自我的表达充分说明所处的文化。</p><p>早期的赛博朋克作家们和他们的同龄人担心的很多事情都没有发生。冷战确实结束了，但不是通过核战争的形式。苏联解体了，即时它会因错位的怀旧情绪而复苏，但苏联式的共产主义对任何极端狂热分子来说都不再是未来的潮流。日本十年前陷入的经济困境依然深重，看不到真正复苏的希望。</p><p>上世纪70年代的许多大型企业要么倒闭，要么被其他企业吞并。冰川纪似乎不太可能在短时间内再次降临，人口这颗滴答作响的巨大炸弹正在缓慢而稳步地解除武装。</p><p>当然，新的恐惧总会取代旧的恐惧，全球变暖在许多人的脑海萦绕不去。曾经被认为已经解决的传染病问题又回来了，抗生素的滥用与自然进化相结合，制造出了越来越危险的微生物。</p><p>人们所担心的不再是苏联霸权，而是宗教狂热和恐怖主义。计算机化无时无刻不在给工作和娱乐的新领域带来革命，但也有代价，包括失业、数字鸿沟的扩大。精通技术的人和不具备使用高科技工具进行工作的能力的人之间的鸿沟，以及传统社区形成和维护方式的崩溃，网络互动无法(现在，也许永远)完全取代传统的社区。</p><p>社会构架偏向全球化，各个地域文化通过各种形式交融。人工智能发达，有强大的系统通过各种手段统治着所有人的生活。</p><p>在这样的背景下，赛博朋克再一次迸发出了新生的力量。当下大多数赛博朋克作品，都在二元对立下重新定义了“人”：机器人也可以为自己赋予人格，并成为新本体。《攻壳机动队》中，反抗政府过度化发展科技的群体被政府视为可弃之物，他们游走于城市边缘游行示威，最后却被政府抓走做义体人实验。生物组织通过无数次实验后，第一个真正意义上的义体人素子出现。素子竭力寻找自己的真实身份，自我觉醒让她重获新生。</p><p>《银翼杀手2049》中，复制人K的工作任务是追杀老式型号复制人。影片中，人类作为复制人的创造者，主宰复制人的生与死。</p><p>在游戏方面，《杀出重围》为CDPR创作《赛博朋克2077》奠定了基础。小岛秀夫在十年之前创作了《掠夺者》，也吸取了神经控制论和人工智能等元素，并将之运用在《合金装备》，获得了极大的成功。、</p><p>人类对世界的关注具有周期性。思想和风格会重新流行起来，故事也会不断重复。如果处理得当，旧的观念可以被打磨成新的、引人注目的东西，使人们对最原始的恐惧和希望产生强烈的共鸣。我们生活在赛博空间的临界点上，科学与人文问题和以往一样重要。</p><p>赛博朋克是我们这一代的流派。它是在计算机的体积和成本都非常巨大的时候被构想出来的，并预示了一个由微型处理器和超导体组成的世界。它赋予了黑色主题新的风格和复杂性，预示着对克隆和人类灭绝的恐惧，而这些正是今天社会关注的热点问题。</p><p>或许，这也是赛博朋克经久不衰的原因。赛博朋克作为一种具有思辨精神的基于美学的哲学，带有强烈的悲观主义色彩，却为浸淫在华丽的网络空间中逐渐模糊现实与虚幻的人类提供了一个自我审视的机会，以创造一个反乌托邦的未来世界的方式来警醒人们：任何一种进步都存在弊端，赛博朋克提出的问题都是人类在未来即将遇到且无法回避的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/xziLKI.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MV14/FQe8VN.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在贪墨成风的反乌托邦世界中，四处都是生化改造植入体。动画剧聚焦一个在街头长大的鲁莽天才少年努力想成为边缘行者：拿钱办事的法外之徒。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>Bézier Curves</title>
    <link href="https://yousazoe.top/archives/ca6f86db.html"/>
    <id>https://yousazoe.top/archives/ca6f86db.html</id>
    <published>2022-09-17T08:41:32.000Z</published>
    <updated>2023-05-05T12:43:30.695Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/119998367/Little-voxel-restaurant"><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-pa4/4tCecw.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>GAMES101现代图形学入门是由闫令琪老师教授。本次作业我们会通过 <strong>de Casteljau</strong> 算法来绘制由 4 个控制点表示的 Bézier 曲线。</p><span id="more"></span><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>Bézier 曲线是一种用于计算机图形学的参数曲线。在本次作业中，你需要实现 <strong>de Casteljau</strong> 算法来绘制由 4 个控制点表示的 Bézier 曲线 (当你正确实现该算法时，你可以支持绘制由更多点来控制的 Bézier 曲线)。</p><p>你需要修改的函数在提供的 main.cpp 文件中。</p><ul><li>bezier: 该函数实现绘制 Bézier 曲线的功能。它使用一个控制点序列和一个 <code>OpenCV::Mat</code> 对象作为输入，没有返回值。它会使 <code>t</code> 在 0 到 1 的范围内进行迭代，并在每次迭代中使 <code>t</code> 增加一个微小值。对于每个需要计算的 <code>t</code>，将调用另一个函数 <code>recursive_bezier</code>，然后该函数将返回在 Bézier 曲线上 <code>t</code> 处的点。最后，将返回的点绘制在 <code>OpenCV::Mat</code> 对象上。</li><li>recursive_bezier: 该函数使用一个控制点序列和一个浮点数 <code>t</code> 作为输入， 实现 <strong>de Casteljau</strong> 算法来返回 Bézier 曲线上对应点的坐标。</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>De Casteljau</strong> 算法说明如下:</p><ol><li>考虑一个 p0, p1, … pn 为控制点序列的 Bézier 曲线。首先，将相邻的点连接起来以形成线段。</li><li>用 t : (1 − t) 的比例细分每个线段，并找到该分割点。</li><li>得到的分割点作为新的控制点序列，新序列的长度会减少一。</li><li>如果序列只包含一个点，则返回该点并终止。否则，使用新的控制点序列并转到步骤 1。</li></ol><p>使用 [0,1] 中的多个不同的 t 来执行上述算法，你就能得到相应的 Bézier 曲线。</p><h3 id="开始编写"><a href="#开始编写" class="headerlink" title="开始编写"></a>开始编写</h3><p>在本次作业中，你会在一个新的代码框架上编写，它比以前的代码框架小很多。和之前作业相似的是，你可以选择在自己电脑的系统或者虚拟机上完成作业。 请下载项目的框架代码，并使用以下命令像以前一样构建项目:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></tbody></table></figure><p>之后，你可以通过使用以下命令运行给定代码 <code>./BezierCurve</code>。运行时，程序将打开一个黑色窗口。现在，你可以点击屏幕选择点来控制 Bézier 曲线。程 序将等待你在窗口中选择 4 个控制点，然后它将根据你选择的控制点来自动绘制 Bézier 曲线。代码框架中提供的实现通过使用多项式方程来计算 Bézier 曲线并绘制为红色。两张控制点对应的 Bézier 曲线如下所示:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-pa4/Vkv71b.png"></p><p>在确保代码框架一切正常后，就可以开始完成你自己的实现了。注释掉 <code>main</code> 函数中 <code>while</code> 循环内调用 <code>naive_bezier</code> 函数的行，并取消对 <code>bezier</code> 函数的注释。要求你的实现将 Bézier 曲线绘制为<strong>绿色</strong>。</p><p>如果要确保实现正确，请同时调用 <code>naive_bezier</code> 和 <code>bezier</code> 函数，如果实现正确，则两者均应写入大致相同的像素，因此该曲线将表现为<strong>黄色</strong>。如果是这样，你可以确保实现正确。</p><p>你也可以尝试修改代码并使用不同数量的控制点，来查看不同的 Bézier 曲线。</p><h3 id="评分与提交"><a href="#评分与提交" class="headerlink" title="评分与提交"></a>评分与提交</h3><p>评分:</p><ul><li>[5 分] 提交的格式正确，包含所有必须的文件。代码可以编译和运行。</li><li>[20 分] De Casteljau 算法:<br>对于给定的控制点，你的代码能够产生正确的 Bézier 曲线。</li><li>[5 分] 奖励分数:<br>实现对 Bézier 曲线的反走样。(对于一个曲线上的点，不只把它对应于一个像素，你需要根据到像素中心的距离来考虑与它相邻的像素的颜色。)</li><li>[-2 分] 惩罚分数:<br>未删除 /build, /.vscode 和 assignment4.pdf。<br>未按格式建立 /images，缺少结果图片。<br>未提交或未按要求完成 README.md。<br>代码相关文件和 README 文件不在你提交的文件夹下的第一层。</li></ul><p>提交:</p><ul><li>当你完成作业后，<strong>请清理你的项目</strong>，记得在你的文件夹中包含 CMakeLists.txt 和所有的程序文件 (无论是否修改);</li><li>同时，请新建一个 /images 目录，将所有实验结果图片保存在该目录下;</li><li>再添加一个 README.md 文件写清楚自己完成了上述得分点中的哪几点 (如果完成了，也请同时在 images 目录下提交一份结果图片并注明)，并简要描述你在各个函数中实现的功能;</li><li>最后，将上述内容打包，并用“姓名 Homework4.zip”的命名方式提交到 SmartChair 平台。<br>平台链接:<a href="http://www.smartchair.org/GAMES101-Spring2021/">http://www.smartchair.org/GAMES101-Spring2021/</a> 。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;cv::Point2f&gt; control_points;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_handler</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span> *userdata)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (event == cv::EVENT_LBUTTONDOWN &amp;&amp; control_points.<span class="built_in">size</span>() &lt; <span class="number">4</span>) </span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Left button of the mouse is clicked - position ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span></span><br><span class="line">        &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        control_points.<span class="built_in">emplace_back</span>(x, y);</span><br><span class="line">    }     </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">naive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_0 = points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_1 = points[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_2 = points[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_3 = points[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> point = std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">3</span>) * p_0 + <span class="number">3</span> * t * std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">2</span>) * p_1 +</span><br><span class="line">                 <span class="number">3</span> * std::<span class="built_in">pow</span>(t, <span class="number">2</span>) * (<span class="number">1</span> - t) * p_2 + std::<span class="built_in">pow</span>(t, <span class="number">3</span>) * p_3;</span><br><span class="line"></span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau's algorithm</span></span><br><span class="line">    <span class="keyword">return</span> cv::<span class="built_in">Point2f</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cv::Mat window = cv::<span class="built_in">Mat</span>(<span class="number">700</span>, <span class="number">700</span>, CV_8UC3, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(window, window, cv::COLOR_BGR2RGB);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">"Bezier Curve"</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">setMouseCallback</span>(<span class="string">"Bezier Curve"</span>, mouse_handler, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (key != <span class="number">27</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;point : control_points) </span><br><span class="line">        {</span><br><span class="line">            cv::<span class="built_in">circle</span>(window, point, <span class="number">3</span>, {<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>}, <span class="number">3</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (control_points.<span class="built_in">size</span>() == <span class="number">4</span>) </span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">naive_bezier</span>(control_points, window);</span><br><span class="line">            <span class="comment">//   bezier(control_points, window);</span></span><br><span class="line"></span><br><span class="line">            cv::<span class="built_in">imshow</span>(<span class="string">"Bezier Curve"</span>, window);</span><br><span class="line">            cv::<span class="built_in">imwrite</span>(<span class="string">"my_bezier_curve.png"</span>, window);</span><br><span class="line">            key = cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">"Bezier Curve"</span>, window);</span><br><span class="line">        key = cv::<span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="De-Casteljau算法"><a href="#De-Casteljau算法" class="headerlink" title="De Casteljau算法"></a>De Casteljau算法</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/GAMES101_Lecture_11_page-0026.jpg"></p><p>$$<br>b^2_0(t) = (1 - t)^2b_0 + 2t(1 - t)b_1 + t^2b_2<br>$$</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/GAMES101_Lecture_11_page-0027.jpg"></p><p><code>bezier()</code> 函数则调用 <code>recursive_bezier()</code> 算法并将线段颜色设置为绿：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t += <span class="number">0.001f</span>) {</span><br><span class="line">        <span class="keyword">auto</span> point = <span class="built_in">recursive_bezier</span>(control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h5><p>由于给定的框架代码有四个控制点，所以我们可以向课程中那样依次推演：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau's algorithm</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> p_0 = control_points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> p_1 = control_points[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> p_2 = control_points[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> p_3 = control_points[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p_01 = (<span class="number">1</span> - t) * p_0 + t * p_1;</span><br><span class="line">    <span class="keyword">auto</span> p_12 = (<span class="number">1</span> - t) * p_1 + t * p_2;</span><br><span class="line">    <span class="keyword">auto</span> p_23 = (<span class="number">1</span> - t) * p_2 + t * p_3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p_012 = (<span class="number">1</span> - t) * p_01 + t * p_12;</span><br><span class="line">    <span class="keyword">auto</span> p_123 = (<span class="number">1</span> - t) * p_12 + t * p_23;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cv::<span class="built_in">Point2f</span>((<span class="number">1</span> - t) * p_012 + t * p_123);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h5><p>另一种递归方式则采用分而治之的策略，将问题不断分化：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau's algorithm</span></span><br><span class="line">    <span class="keyword">if</span> (control_points.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> control_points[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::Point2f&gt; lines;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; control_points.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        lines.<span class="built_in">emplace_back</span>((<span class="number">1</span> - t) * control_points[i] + t * control_points[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recursive_bezier</span>(lines, t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://games-cn.org/forums/topic/%E4%BD%9C%E4%B8%9A%E5%9B%9B%E5%BE%97%E5%88%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E8%A6%81%E6%B1%82%EF%BC%9F/">作业四得到这样的结果是否满足要求？</a></li><li><a href="https://zhuanlan.zhihu.com/p/344934774">从零开始学图形学：10分钟看懂贝塞尔曲线</a></li><li><a href="https://blog.csdn.net/qq_41835314/article/details/124882791">GAMES101作业4-贝塞尔曲线&amp;OpenCV图像处理</a></li><li><a href="https://blog.csdn.net/ycrsw/article/details/124117190">【GAMES101】作业4（提高）含Bazier曲线的反走样处理</a></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/119998367/Little-voxel-restaurant&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GAMES101-pa4/4tCecw.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;GAMES101现代图形学入门是由闫令琪老师教授。本次作业我们会通过 &lt;strong&gt;de Casteljau&lt;/strong&gt; 算法来绘制由 4 个控制点表示的 Bézier 曲线。&lt;/p&gt;</summary>
    
    
    
    <category term="现代图形学入门 (GAMES101-Introduction to Computer Graphics)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-GAMES101-Introduction-to-Computer-Graphics/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>STL&amp;基础数据结构</title>
    <link href="https://yousazoe.top/archives/558bb9a.html"/>
    <id>https://yousazoe.top/archives/558bb9a.html</id>
    <published>2022-09-15T12:31:48.000Z</published>
    <updated>2023-05-05T12:43:30.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/122046889/The-Traveler?tracking_source=project_owner_other_projects"><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/Hk2SRw.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>简单介绍 Vector 向量、List 链表、Queue 队列、Stack 栈、Priority_Queue 优先队列的原 理，以及 C++ STL 中这些数据结构的使用，以及笔试和面试的一些应用场景。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=514053762&amp;bvid=BV1Rg41117YB&amp;cid=791539408&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h3><h4 id="STL容器简介"><a href="#STL容器简介" class="headerlink" title="STL容器简介"></a>STL容器简介</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(5).PNG"></p><ul><li><p>容器(Containers)是用于保存一系列对象的对象。</p></li><li><p>例如，std::vector<int>, std::list<a href="std::string">std::string</a>, std::queue&lt;std::vector<double>&gt;;*</double></int></p></li><li><p>分类:</p><ul><li>Sequence container</li><li>Associative container</li><li>另外还有 Container adaptor 和 Almost container<br></li></ul></li><li><p>你也可以设计自己的容器，只要它满足通用的标准和接又</p></li></ul><blockquote><p>*注:在使用 C++98 标准编译时，需要在两个 &gt; 中间添加空格。</p></blockquote><h4 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(6).PNG"></p><ul><li>对指针的抽象。</li><li>因此需要重载 * 运算符。</li><li>指针的运算是基于使用连续的内存空间，但是对于一些容器来说并非如此。</li><li>基于能够进行的运算类型，迭代器可以分为下列几类:<ul><li>所有的迭代器都支持解引用运算符(*)和自增运算符(++)</li><li>Input iterator 在此基础上支持 ==, !=, 单次读取，-&gt;; Output Iterator 仅支持单次写入(课后:查阅 I/O 库相关内容，了解它们的使用场景)</li><li>Forward iterator 在 Input iterator 基础上支持重复访问及读写</li><li>Bidirectional iterator 在 Forward iterator 基础上支持自减运算符(–)</li><li>Random-access iterator 在 Bidirectional iterator 基础上支持 [], +, +=, −, −=, &lt;, &lt;=, &gt;, &gt;= 运算符(和普通指针功能相同)<br></li></ul></li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(7).PNG"></p><p>为了保证通用性，标准库中还提供了一些库函数</p><ul><li>#include <iterator></iterator></li><li>std::advance(iter, n) 迭代器 iter 自增 n 次</li><li>std::distance(iter1, iter2) 返回迭代器 iter1 和 iter2 间的距离</li><li>std::next(iter, n=1), std::prev(iter, n=1) 返回 “iter + n” 或 “iter – n” 对应的迭代器(c++11)</li><li>注意如果不是 Random-access iterator ，这些方法的复杂度可能是线性的，或者行为未定义，或者无法通过编 译。<br></li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(8).PNG"></p><p>容器的 begin() 和 end() 方法可以获得首尾迭代器</p><ul><li>for (auto it = c.begin(); it != c.end(); ++it)</li><li>for (auto &amp; x: c)</li><li>迭代器的类型为 ContainerType::iterator</li></ul><p>另外 cbegin() 和 cend() 方法可以返回首尾的常量迭代器(类似于常量指针)</p><ul><li>for (auto it = c.cbegin(); it != c.cend(); ++it)</li><li>for (const auto &amp;x: c)</li><li>迭代器的类型为 ContainerType::const_iterator</li></ul><p>课后:查询反向迭代器的相关资料，解释 rbegin(), rend(); crbegin(), crend() 的用法。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(9).PNG"></p><p>C++ 标准在设计的过程中，就有意地让这些标准容器共享接又，从而发挥模板多态的特性。</p><p>例如，常见的构造函数:</p><ul><li>ContainerType c(num)</li><li>ContainerType c(num, x)</li><li>ContainerType c(beg, end)</li></ul><p>容量相关的方法:</p><ul><li>int s = c.size(); bool b = c.empty();</li><li>c.resize(num); c.resize(num, x);</li><li>c.clear();</li></ul><blockquote><p>Reference: Bjarne Stroustrup. The C++ Programming Language, 4th edition. §31.3</p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(11).PNG"></p><h4 id="std-stack-lt-T-Container-gt"><a href="#std-stack-lt-T-Container-gt" class="headerlink" title="std::stack<T, Container>"></a>std::stack&lt;T, Container&gt;</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(12).PNG"></p><ul><li>属于 Container Adapter，需要基于某个 Sequence container</li><li>不能使用迭代器访问</li><li>push(x)</li><li>pop()</li><li>top()</li><li>课后:了解 initializer_list，理解 emplace() 方法的使用。</li></ul><h4 id="如何实现一个栈"><a href="#如何实现一个栈" class="headerlink" title="如何实现一个栈?"></a>如何实现一个栈?</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(13).PNG"></p><ul><li>方便起见，假设数据的总量为 N，数据类型为 int.</li><li>int stack[N], top; 数据存放在 [0, top) 区间内。</li></ul><p>一些基本操作:</p><ul><li>push: stack[top++] = x;</li><li>pop: int y = stack[–top];</li><li>size: return top;</li><li>empty: return top == 0;</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(14).PNG"></p><h4 id="Catalan数"><a href="#Catalan数" class="headerlink" title="Catalan数"></a>Catalan数</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(15).PNG"></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(17).PNG"></p><h4 id="如何实现一个队列"><a href="#如何实现一个队列" class="headerlink" title="如何实现一个队列"></a>如何实现一个队列</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(18).PNG"></p><p>int queue[N], head, tail; 其中元素存放在 [head, tail) 区间。</p><p>基本操作</p><ul><li>push: queue[tail++] = x;</li><li>pop: int y = queue[head++];</li><li>size: return tail – head;</li><li>empty: return head == tail;</li></ul><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(19).PNG"></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(20).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) { </span><br><span class="line">    <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())</span><br><span class="line">        stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>()), stack1.<span class="built_in">pop</span>(); }</span><br><span class="line">    <span class="keyword">return</span> stack2.<span class="built_in">top</span>();</span><br></pre></td></tr></tbody></table></figure><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(22).PNG"></p><ul><li>之前我们假设了数据量是已知的，那么当我们的数据量未知时?</li><li>不定长数组<ul><li>#include <vector> std::vector<t></t></vector></li><li>Sequence Container</li><li>Random-access iterator</li><li>随机访问: operator [], at(x), front(), back()</li><li>insert(iter, x), push_back(x)</li><li>erase(iter), pop_back()</li></ul></li></ul><h4 id="如何实现一个向量？"><a href="#如何实现一个向量？" class="headerlink" title="如何实现一个向量？"></a>如何实现一个向量？</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(23).PNG"></p><h4 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(24).PNG"></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(25).PNG"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(26).PNG"></p><h4 id="列表与链表"><a href="#列表与链表" class="headerlink" title="列表与链表"></a>列表与链表</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(27).PNG"></p><ul><li>另外一种实现动态性的方式是不采用数组，而是每增加一个元素，新开辟一块空间</li><li>但是我们依然需要保存一些额外信息来保存它们之间的顺序关系——指针!</li><li>这种链状的数据结构称为链表(linked list)。</li><li>例子:火车车厢</li><li>#include <list> std::list<t><ul><li>Sequence container, Bidirectional iterator</li><li>front(), back()</li><li>insert(iter, x), push_back(x), push_front(x),</li><li>erase(iter), pop_back(), pop_front()</li></ul></t></list></li></ul><h4 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a>链表的结构</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(28).PNG"></p><h4 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="哨兵节点"></a>哨兵节点</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(29).PNG"></p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(30).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node* pos, <span class="type">int</span> value)</span> </span>{</span><br><span class="line">    Node* n = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">    n-&gt;next = pos-&gt;next;</span><br><span class="line">    pos-&gt;next = n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(31).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node *pos, <span class="type">int</span> value)</span> </span>{ </span><br><span class="line">    Node *n = <span class="keyword">new</span> <span class="built_in">Node</span>(value); </span><br><span class="line">    n-&gt;next = pos-&gt;next;</span><br><span class="line">    n-&gt;prev = pos;</span><br><span class="line">    pos-&gt;next-&gt;prev = n; </span><br><span class="line">    pos-&gt;next = n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(32).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(Node *pos)</span> </span>{ </span><br><span class="line">    pos-&gt;prev-&gt;next = pos-&gt;next;</span><br><span class="line">    pos-&gt;next-&gt;prev = pos-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> pos;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(33).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase2</span><span class="params">(Node *pos)</span> </span>{</span><br><span class="line">    Node *tmp = pos-&gt;next;</span><br><span class="line">    pos-&gt;next = pos-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(34).PNG"></p><ul><li>for (Node* x = head-&gt;next; x != tail; x = x-&gt;next);</li><li>对比迭代器的 begin() 和 end()</li><li>“下标”访问?</li><li>单向链表查询上一个元素?</li><li>size()?</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(35).PNG"></p><h5 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(36).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(37).PNG"></p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(39).PNG"></p><h4 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a>std::priority_queue</h4><ul><li>Container Adaptor, 无迭代器</li><li>push(x), pop(), top()</li><li>std:priority_queue&lt;T, Container=std::vector<t>, Compare=std::less<t>&gt;<ul><li>the Compare parameter is defined such that it returns true if its first argument comes before its second argument in a weak ordering. But because the priority queue outputs largest elements first, the elements that “come before” are actually output last</li><li>需要定义小于号</li><li>std::greater<t> (需要定义大于号)</t></li></ul></t></t></li></ul><blockquote><p>Reference: std::priority_queue - cppreference.com</p></blockquote><h4 id="如何实现优先级队列-选讲"><a href="#如何实现优先级队列-选讲" class="headerlink" title="如何实现优先级队列?(选讲)"></a>如何实现优先级队列?(选讲)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(41).PNG"></p><ul><li>多种实现方式，最简单的一种——二叉堆</li><li>堆:满足父亲结点优先级不小于孩子结点的二叉树</li><li>为了方便实现，可以采用完全二叉树</li><li>向上调整过程 up, push()</li><li>向下调整过程 down, pop()</li></ul><h3 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h3><h4 id="单调栈-单调队列"><a href="#单调栈-单调队列" class="headerlink" title="单调栈 单调队列"></a>单调栈 单调队列</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(44).PNG"></p><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(45).PNG"></p><ul><li>为了简化问题，假设我们只有 + - * / () 这几种运算</li><li>观察:1+2<em>3 和 1</em>2+3。我们什么时候可以确定计算顺序?</li><li>第一个等式需要到最末尾，第二个等式在扫描到 + 的时候就发现可以计算前面的内容</li><li>无法判断的式子优先级大小递增</li><li>类似单调队列的单调栈。同时需要维护没有计算的数</li><li>括号?将括号也纳入优先级比较的范围，或者每遇到一层括号，括号内优先级增加一档</li></ul><h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(46).PNG"></p><ul><li>(问题的最后一步)有一个长度为 n 的序列，进行 n – 1 次操作，每次将值最小的两个元素取出，再将它们的和放回序列。求每步操作取出的两个数是多少</li><li>对比优先队列的定义和接口</li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/122046889/The-Traveler?tracking_source=project_owner_other_projects&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/THUAA2/Hk2SRw.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;简单介绍 Vector 向量、List 链表、Queue 队列、Stack 栈、Priority_Queue 优先队列的原 理，以及 C++ STL 中这些数据结构的使用，以及笔试和面试的一些应用场景。&lt;/p&gt;</summary>
    
    
    
    <category term="清华大学算法协会 (Tsinghua University Algorithm Association)" scheme="https://yousazoe.top/categories/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E5%8D%8F%E4%BC%9A-Tsinghua-University-Algorithm-Association/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++梳理</title>
    <link href="https://yousazoe.top/archives/74ba873d.html"/>
    <id>https://yousazoe.top/archives/74ba873d.html</id>
    <published>2022-09-12T12:09:10.000Z</published>
    <updated>2023-05-05T12:43:30.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/132894291/The-Lovers?tracking_source=search_projects%7Clow%20poly"><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/AhZ5WD.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这一节课面向已经有一些 C++ 基础的同学(一个快速判断标准:是否知道构造函数和析构函数是什么，并自己写过构造函数和析构函数)， 复习串讲一些 OOP 中的知识点，以及介绍一些有趣的在面试中或者在写程序时用得到的 C++ 知识。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=386482748&amp;bvid=BV15d4y1U7HH&amp;cid=787484737&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="关于算协"><a href="#关于算协" class="headerlink" title="关于算协"></a>关于算协</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(3).PNG"></p><ul><li><p>2016年：清华大学计算机系学生算法与竞赛协会 </p><ul><li>举办过的活动：清华校赛（THUPC）</li></ul></li><li><p>2022年：清华大学学生算法协会</p><ul><li>成为校级社团 希望开展更广泛的活动</li></ul></li></ul><p>暑期培训：拓展业务的尝试，希望你在奋斗的路上少一些孤单。</p><ul><li>初衷：帮助大三升大四的同学复习编程和算法知识 </li><li>形式：多次相对独立的授课，提供回放 </li><li>建议：分析自身需求，有选择性地听课和完成作业</li></ul><h3 id="授课定位"><a href="#授课定位" class="headerlink" title="授课定位"></a>授课定位</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(7).PNG"></p><ul><li>C++ 相当庞大 不仅语言名字的字符数是 C 语言的三倍 标准的长度也相当于C语言的三倍多。</li><li>C++20 标准页数 1853 页 </li><li><a href="https://www.iso.org/standard/79358.html">ISO - ISO/IEC 14882:2020 - Programming languages — C++</a> </li><li>C11 标准页数 520 页 </li><li><a href="https://www.iso.org/standard/74528.html">ISO - ISO/IEC 9899:2018 - Information technology — Programming languages — C</a> </li><li>段子：21 天才能精通 C++ </li><li>本次课理想受众：至少上过一门 C++ 的课程/读过一本 C++ 的入门书籍</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(8).PNG"></p><ul><li>尝试带大家梳理一些语言特性，帮助大家“融会贯通” </li><li>最终希望大家能够尝试自己梳理更多的 C++ 语言特性、或用同样的思路学习其他语言。 </li><li>第一次做这种尝试，请大家在课后问卷中多多反馈</li><li>You can’t just look at C++ as a collection of features; some features make no sense in isolation. You can only use the sum of the parts if you are thinking about design, not simply coding. And to understand C++ this way, you must understand the problems with C and with programming in general.</li><li>– Bruce Eckel，Thinking in C++ </li><li>The C++ Programming Language 里，大量的交叉引用反映了语言特性之间的互动和联系</li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(10).PNG"></p><h4 id="内存是什么？"><a href="#内存是什么？" class="headerlink" title="内存是什么？"></a>内存是什么？</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(11).PNG"></p><ul><li>我们可以认为，程序处理的数据存储在内存（RAM）（忽略缓存和硬盘的使用）</li><li>现在常用的内存条，包含若干内存颗粒(半导体集成电路)</li><li>物理上，通过一些微小的元器件来表示 “0” “1” 状态</li><li>能存储的比特数取决于集成电路里的元器件数目</li><li>可以想象成一条非常非常长的纸带 每个格子可以填写 0-255 的一个状态（8 个 0/1 比特，一个字节）</li><li>例如 16G 的内存，一共能填写 16x1024x1024x1024 个字节</li><li>然后这根纸带卷啊卷，卷到了一根内存条这么大</li><li>这就是操作系统所拥有的内存资源，操作系统会将内存分配给正在执行的程序</li></ul><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(12).PNG"></p><ul><li>（分配内存的细节，和编译器、操作系统、运行时环境等等有关，具体细节需具体学习）</li><li>计算机上有多个程序同时运行，操作系统也预留了一部分内存，而内存是有限的</li><li>因此程序只能在操作系统分配给它的范围内使用内存</li><li>操作系统一开始就分配给程序一些内存，用来存储全局变量、局部变量、函数参数返回值、程序代码等数据。其中，全局变量、程序代码分配在static内存区域（从程序开始执行到结束，这些内存都被占用）。局部变量、函数参数返回值等，被分配在栈内存区域（函数调用栈）</li><li>函数每一次被调用时，在函数调用栈中分配一个大小合适的栈帧，存储这一次的局部变量、参数和返回值。从函数中返回时，释放栈帧的内存。（操作系统角度，整个函数调用栈还是在程序那里）</li><li>递归过深程序崩溃，是因为大量的栈帧未释放，占满了函数调用栈的内存。(stack overflow)</li><li>另外，程序在运行时，可以向操作系统动态地申请和释放一些内存（堆内存）</li></ul><h4 id="变量-x2F-指针-x2F-引用"><a href="#变量-x2F-指针-x2F-引用" class="headerlink" title="变量/指针/引用"></a>变量/指针/引用</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(13).PNG"></p><ul><li>变量：一块具有类型的内存（类型：数据的存储表示方式以及你可以对它进行的操作）</li><li>指针：一块内存的地址，指针的类型可能说明这个指针指向特定类型的变量。（void*）</li><li>引用：可以理解为指针的一种“语法糖”（左值引用/右值引用）</li><li>数组：内存中连续排列的多个同类型变量。数组名称可以用作指向第一个元素的指针</li><li>自定义的类型 (class/struct):一组成员变量在内存里的排列方式以及可以对它进行的操作</li><li>一个对象：按照特定排列方式存储在内存里的一组成员变量<br>+（课后练习：查阅资料，复习/学习 struct 中各个成员变量的 layout 规则）</li></ul><h4 id="一些类的示例"><a href="#一些类的示例" class="headerlink" title="一些类的示例"></a>一些类的示例</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(14).PNG"></p><p><code>Model2</code> 中一目了然的设计缺陷：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Triangle</span> {</span><br><span class="line">    Point A;</span><br><span class="line">    Point B;</span><br><span class="line">    Point C;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Model</span> {</span><br><span class="line">    Triangle many_triangles[<span class="number">100</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Model2</span> {</span><br><span class="line">    Triangle* triangles;</span><br><span class="line">    <span class="built_in">Model2</span>(<span class="type">int</span> n) {</span><br><span class="line">        triangles = <span class="keyword">new</span> Triangle[n];</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Model2</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] triangles;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Model3</span> {</span><br><span class="line">    std::vector&lt;Triangle&gt; triangles;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>Model2</code> 需要加一个成员变量表示拥有多少个三角形面片。</p><h4 id="构造函数-x2F-析构函数，new-x2F-delete"><a href="#构造函数-x2F-析构函数，new-x2F-delete" class="headerlink" title="构造函数/析构函数，new/delete"></a>构造函数/析构函数，new/delete</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(15).PNG"></p><ul><li>C++ 中两个运算符替代了C语言的 malloc/dealloc 库函数</li><li>通过 new/delete 动态分配或释放一个对象时会发生:</li><li>new：分配内存，然后调用对应的构造函数(递归调用各个成员变量的构造函数)</li><li>delete：调用对应的析构函数，然后释放内存</li></ul><p>动态内存管理的两种风格(不代表只有这两种风格）</p><ol><li>RAII （C++ 语言中可通过恰当实现构造/析构函数、恰当调用 new/delete 实现）</li><li>垃圾回收（C++ 语言中可通过智能指针实现）</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(16).PNG"></p><ul><li>将动态分配的资源的生命周期绑定到某个局部变量上，随着作用域的创建和消失完成分配和释放。</li><li>当希望创建一个动态数组时，不是在主函数里直接 new/delete</li><li>而是使用一个“包含动态数组的类”，作为局部变量定义，构造函数里 new，析构函数里 delete。</li><li>阅读 The C++ programming language 13.3 Resource Managerment，RAII 和异常处理。</li></ul><h4 id="智能指针-amp-垃圾回收"><a href="#智能指针-amp-垃圾回收" class="headerlink" title="智能指针&amp;垃圾回收"></a>智能指针&amp;垃圾回收</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(17).PNG"></p><p>如果计算机能够更加智能，意识到某块动态分配的内存目前没有任何一个活跃的指针会用到，就自动回收这一块内存，会怎么样？</p><p>这里介绍两种垃圾回收思路（并不止两种）：</p><ol><li>引用计数（C++ 中可以用智能指针实现，weak_ptr, shared_ptr, unique_ptr)<br>记录一下当前有多少个活跃的指针指向一块动态分配的内存 当这个计数变为 0 时，释放这块内存。</li><li>Mark &amp; sweep （最早的垃圾回收方法，在Lisp中被使用）<br>每隔一段时间 标记所有从当前程序执行到的位置出发，能够访问到的变量<br>然后将所有未标记的变量释放</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(18).PNG"></p><p>时间所限，这里不细讲智能指针的具体语法。</p><p>有空可以看一下 “leak freedom in C++… by default by Herb Sutter”，CppCon的演讲</p><p>思考：</p><ul><li>引用计数和 Mark&amp;Sweep 带来的额外开销有什么区别？注重实时性的系统能否用垃圾回收？</li><li>C++ 中的智能指针常常会重载哪个运算符？(-&gt; 和 *)</li><li>尝试用智能指针实现一个双向链表，要求做到首尾节点释放后，中间的所有节点自动释放</li><li>使用 STL 的容器可以大大方便 C++ 中的一些内存管理，非必要不造轮子</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(19).PNG"></p><h4 id="减少函数调用：内联函数-vs-预处理宏"><a href="#减少函数调用：内联函数-vs-预处理宏" class="headerlink" title="减少函数调用：内联函数 vs 预处理宏"></a>减少函数调用：内联函数 vs 预处理宏</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(20).PNG"></p><ul><li><p>调用函数时，处理传参/返回值/栈帧的产生和销毁，会带来一定的开销。</p></li><li><p>对于简单的函数，将调用函数改为直接嵌入一段代码，可以节约一些计算开销。</p></li><li><p>C 语言：采用宏定义， #define min(a, b) ((a&lt;b)?a:b)</p></li><li><p>C++：使用 inline 关键字建议编译器进行内联（但并不代表编译器一定会这么做）</p></li><li><p>C++ 中，建议非必要不使用宏，如果一定要用，起一堆大写字母的丑陋名字</p><br></li><li><p>课后：查询如何用 C++11 中引入的 constexpr 关键字标识函数</p></li></ul><h4 id="传值-x2F-传引用"><a href="#传值-x2F-传引用" class="headerlink" title="传值/传引用"></a>传值/传引用</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(21).PNG"></p><p>定义函数</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(Type x){</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>函数 g 内有 Type 类型的局部变量 b，并调用了 f(b)</li><li>在函数 f 内修改 x，会不会导致 f 返回后，函数 g 中 b 的数值发生对应的改变？（传值/传引用）</li><li>f(int x), f(int &amp;x), f(int *x), f(int x[]), f(int &amp;&amp;x)</li></ul><p>思考题：举出一种实际应用情况，我们选择让函数返回一个引用（提示：从The C++ programming language 7.7.1 page 192中查找答案）</p><h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(22).PNG"></p><p>拷贝有两种情况可能发生：</p><ul><li>拷贝构造函数</li><li>重载赋值符号(A = B）<br></li><li>当一个类中包含动态分配的资源时，浅拷贝将不会分配第二份资源，使得拷贝后的对象和之前的对象指向相同的一份资源（如数组）。这很多时候是一个 bug，或者可以用 CoW/Move 来替代</li><li>默认的拷贝行为对所有成员函数逐个拷贝</li><li>合理的拷贝行为应当满足：等价性，独立性</li></ul><h4 id="拷贝-x2F-移动"><a href="#拷贝-x2F-移动" class="headerlink" title="拷贝/移动"></a>拷贝/移动</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(23).PNG"></p><p>有时并不需要进行拷贝，因为完成拷贝之后，旧的元素失去了使用的价值。</p><p>例如常见的交换函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type a, Type b)</span></span>{</span><br><span class="line">    Type tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以通过 move 来避免不必要的拷贝。（右值引用表示一个可以被销毁的临时值）</p><h4 id="swap函数"><a href="#swap函数" class="headerlink" title="swap函数"></a>swap函数</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(24).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type&amp; A, Type&amp; B)</span> </span>{</span><br><span class="line">    T tmp = std::<span class="built_in">move</span>(a);</span><br><span class="line">    a = std::<span class="built_in">move</span>(b);</span><br><span class="line">    b = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(25).PNG"></p><ul><li>通过函数指针，实现“以函数为参数”的函数, 或者说，传入一个“谓词”(predicate)</li><li>实质上是函数的代码所在的地址<br></li><li>例如可以定义遍历函数 iterate(数组A，函数B)，对数组中每个元素执行函数B (如都翻倍)</li><li>另一个常见例子：给排序函数传入一个比较函数的函数指针作为参数</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>{ <span class="keyword">return</span> <span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b); }</span><br><span class="line">std::<span class="built_in">sort</span>(array_A, array_A+n, cmp_func);</span><br></pre></td></tr></tbody></table></figure><ul><li>另一个用途: 设置回调函数, “发生某事件时调用该函数”</li></ul><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(26).PNG"></p><ul><li>函数对象是重载了函数调用运算符()的对象</li><li>在 C++ 中，应当倾向于使用函数对象 /lambda 表达式而非函数指针</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> a &lt; b; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(27).PNG"></p><ul><li>C++11 标准中引入的匿名函数，用于方便地定义一个匿名的函数对象</li><li>可以在 lambda 中“捕获”当前作用域的变量，定义参数列表，也可以有返回值</li><li>也可以将 lambda 表达式赋值给一个变量</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = (<span class="type">const</span> <span class="type">int</span> &amp;x, <span class="type">const</span> <span class="type">int</span> &amp;y){<span class="keyword">return</span> x&lt;y;}; <span class="comment">//这里没有捕获列表。</span></span><br></pre></td></tr></tbody></table></figure><br>+ 尝试分别用函数指针/函数对象/lambda表达式结合 std::sort( ) 写一个“按照绝对值排序整数的程序”+ 查阅文档：如何表示“捕获”一个变量时，捕获它的值/引用？<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(28).PNG"></p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(29).PNG"></p><ul><li>两类典型的继承：“实现继承”/ “接口继承”</li><li>如果没有继承语法，我们如何表示继承关系？</li><li>可以将基类作为子类的一个成员</li><li>如果一开始理解继承机制的时候有困难，可以认为基类就是子类的一种特殊成员变量</li><li>public/private 控制外部对成员变量的访问权限</li><li>通过 protected，特殊控制子类对基类的访问权限</li></ul><p>列个表：</p><ul><li>public/private/protected 继承，子类分别能否访问基类的public/private/protected成员变量？</li></ul><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(30).PNG"></p><ul><li>在成员函数前标注 virtual，允许子类重新实现这个函数，编译器和运行时环境通过虚表，保证调用正确版本的函数</li><li>纯虚函数要求子类必须重新实现这个函数</li><li>虚表可以认为是子类隐藏的一个成员数组，数组中标注每个虚函数具体指向哪一个实现版本（通常是继承关系上，“最近”的一个类所实现的版本，例如如果这个子类自身有实现，就调用自身实现的版本）（虚表中可能会保存指向一些函数实现的函数指针）</li><li>查阅文档: 用 final 或 override 关键字标注一个虚函数，分别会对子类提出什么样的要求？</li></ul><h4 id="运行时多态-runtime-polymorphism"><a href="#运行时多态-runtime-polymorphism" class="headerlink" title="运行时多态(runtime polymorphism)"></a>运行时多态(runtime polymorphism)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(31).PNG"></p><ul><li>多态: 通过继承和虚函数，可以实现这样的行为: 某个变量的类型为基类的指针，它可以指向某个子类的对象，并正确调用子类对虚函数的具体实现。</li><li>（也可以通过引用来实现多态行为）</li><li>如果不用指针/引用而直接使用一个对象，可能会导致意外的切片(slicing), 从子类转换为基类，丢失了子类的数据。<br></li><li>尝试写一个会导致切片行为的简单程序</li><li>不同语言会用不同的方式来实现多态。查询文档：Java 中如何用 interface 实现多态？(rust 如何用 trait 实现多态？）</li></ul><h4 id="多态的应用：Visitor-pattern"><a href="#多态的应用：Visitor-pattern" class="headerlink" title="多态的应用：Visitor pattern"></a>多态的应用：Visitor pattern</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(32).PNG"></p><ul><li>这是一种在编译器中应用广泛的设计模式</li><li>在编译器中，常常需要多次遍历一个语法树的所有结点，第一轮遍历的时候进行符号收集，第二轮遍历的时候进行代码生成……</li><li>不同类型的节点有着不同的内部结构，但都对外提供构造函数、visit() 等接口</li><li>Visit() 可以接收一个函数对象作为参数，表示对节点进行的操作</li><li>这个函数对象我们称为 visitor，语法树节点的 visit() 接口接收一个基类 visitor 的函数对象作为参数</li><li>实际调用时，传入一个具体的继承 visitor（的指针/引用），对语法树中的节点进行遍历</li><li>如果大家去做一些编译原理课程的作业，看一下实验框架(通常是 toy compiler），或者看一些用 C++ 实现的开源编译器，常常会找到类似的结构。</li></ul><h4 id="模板的简介"><a href="#模板的简介" class="headerlink" title="模板的简介"></a>模板的简介</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(33).PNG"></p><ul><li>函数：对于两段只有参数数值不同的代码，不用重复编写</li><li>模板：对于两个只有参数类型不同的函数，不用重复编写，编译器自动生成程序中用到的不同类型的函数。模板较多的代码往往编译起来非常慢<br></li><li>C++ 的 STL 容器中大量使用了模板，如我们可以定义保存任意类型的 std::vector，定义任意两个类型组成的 std::pair</li><li>可以通过模板来实现一些编译期计算(有个名词叫做“模板元编程”）</li></ul><h4 id="为什么模板类的函数声明和定义要放在一起？"><a href="#为什么模板类的函数声明和定义要放在一起？" class="headerlink" title="为什么模板类的函数声明和定义要放在一起？"></a>为什么模板类的函数声明和定义要放在一起？</h4><p>考虑模板代码生成的过程：</p><ul><li>从编译器的角度，模板函数本身并不是一个能直接拿来链接的函数，而是需要用它来生成一些其他的函数</li><li>将函数声明和定义拆开编写，其实是在链接阶段再去处理函数名称和函数实现的绑定</li><li>链接器通常没有办法在链接阶段再去处理模板参数的替换</li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/132894291/The-Lovers?tracking_source=search_projects%7Clow%20poly&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/THUAA1/AhZ5WD.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这一节课面向已经有一些 C++ 基础的同学(一个快速判断标准:是否知道构造函数和析构函数是什么，并自己写过构造函数和析构函数)， 复习串讲一些 OOP 中的知识点，以及介绍一些有趣的在面试中或者在写程序时用得到的 C++ 知识。&lt;/p&gt;</summary>
    
    
    
    <category term="清华大学算法协会 (Tsinghua University Algorithm Association)" scheme="https://yousazoe.top/categories/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E5%8D%8F%E4%BC%9A-Tsinghua-University-Algorithm-Association/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA Special Address at SIGGRAPH 2022</title>
    <link href="https://yousazoe.top/archives/5bc35f45.html"/>
    <id>https://yousazoe.top/archives/5bc35f45.html</id>
    <published>2022-09-07T08:27:19.000Z</published>
    <updated>2023-05-05T12:43:30.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><iframe src="//player.bilibili.com/player.html?aid=942855653&amp;bvid=BV1JW4y1B7iG&amp;cid=825831229&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机图像学 (Foundations of Computer Graphics)" scheme="https://yousazoe.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%83%8F%E5%AD%A6-Foundations-of-Computer-Graphics/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
    <category term="SIGGRAPH" scheme="https://yousazoe.top/tags/SIGGRAPH/"/>
    
  </entry>
  
  <entry>
    <title>把命运交还给时间和土地--电影《隐入尘烟》观后感</title>
    <link href="https://yousazoe.top/archives/7d09866f.html"/>
    <id>https://yousazoe.top/archives/7d09866f.html</id>
    <published>2022-09-01T11:45:59.000Z</published>
    <updated>2023-05-05T12:43:30.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/0eQBU8.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>影片讲述西北农村，两个被各自家庭抛弃的孤独个体，在日复一日的耕耘中相濡以沫的故事，武仁林与海清展现了一对底层农民夫妇从陌生到熟悉，从相知到相守的心路历程。</p><span id="more"></span><h3 id="作者自述"><a href="#作者自述" class="headerlink" title="作者自述"></a>作者自述</h3><p>我一直认为我做的工作就是在日常中提炼电影，然后在电影中去还原日常的工作。写作剧本、拍摄电影的过程就是发现生活，呈现生活和总结生活的过程，如何感知和捕捉日常中微妙诗意瞬间使之变成永恒的过程。2020年2月份，我陪海清老师随着电影的男主演去地里干活体验生活，我在田埂边的树桩修改剧本，看到眼前躺在田埂上休息的海清老师和在远处播撒种子的农人，瞬间让我对电影和种子有了新的认识和理解。农民在把种子撒进地里，在日复一日的全情陪伴中收获粮食，而电影剧本中的每一个字就像农民撒进地里的种子，它们最终在镜头中结出果来。以下是我和大家分享的在不同阶段感知到的一些诗意瞬间。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/kzoppi.jpg"></p><p>流云踩着墙头，躲进门窗的褶皱里，探听风的消息。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/2UUAhy.jpg"></p><h3 id="马有铁的个人魅力"><a href="#马有铁的个人魅力" class="headerlink" title="马有铁的个人魅力"></a>马有铁的个人魅力</h3><p>马有铁和大多数边远地区农村人一样，老实、木讷、敦厚，被无视，被边缘化，但却有着极强的生命力。只要给他的生活以希望，他就能在贫瘠的土地上开出花来。</p><p>电影中，一年的时间，他凭自己的双手，借蛋养了一窝属于自己的鸡，还养了一口小猪，收获了属于自己的粮食，盖起了属于自己的房子。他的脸上有了笑容，甚至憧憬着，明年为妻子买一台电视。</p><p>这一切，都是因为贵英。</p><p>这个被别人当累赘丢掉的女人，使他看到了希望，为他沉重、灰暗的生活掀开了一条缝，透进了一点微光，让他粗糙的大手有了力气，让他布满皱纹的脸变得柔和。</p><p>他高贵的灵魂，也得以在这粗粝的黄土地中绽放。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/u2tGZE.jpg"></p><p>他看到了希望，得到了希望，蓬勃的生命力，便从身体的每一道褶皱中迸发出来。借几个鸡蛋抚育新生命，在女人的手上印一朵花，说出最美最质朴的情话，一天做几百个土坯而不觉得辛苦……</p><p>他依然被抽血、被驱赶、被嘲讽、被压榨，但他不在乎，心中有希望，生活的小苦难就变得不值一提，脸上的皱纹都会不自觉地舒展开。</p><p>可是，最后，贵英死了，他的希望破灭了。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/XDwBJI.jpg"></p><p>他的生活，看似是一个新的开始，其实却回不去了。他吃了一个鸡蛋，因为贵英去找他的时候，拿着一个鸡蛋，贵英生病的时候，他也给她煮了一个鸡蛋，那是他们一起养的鸡娃子下的蛋，是他们自己辛劳所得。</p><p>他还了所有的欠债，想一了百了，让生命如尘般来，如烟般去。</p><p>干净、纯洁、高贵、厚重，却沉默无言，来去无影，隐入世间，什么都留不下。</p><h3 id="苍凉而残酷的底色"><a href="#苍凉而残酷的底色" class="headerlink" title="苍凉而残酷的底色"></a>苍凉而残酷的底色</h3><p>本片仅从抒情的角度看，它是精明且有效的。全片事无巨细地展现农村生活，却能牢牢锚定“土”（耕种的地和建筑的泥）的核心意象，将情感增厚，为羁绊赋形，做到形散神不散：穷人的命运就是扎根土地，风吹雨打，仍在默默隐忍中开出自己的麦花。但从一个了解电影语境的中国观众角度出发，这种将逆来顺受浪漫化的温吞做法背后，又有多少结构性的顽疾被草草略过？这片土地有太多值得且亟需被讲述的故事，它们绝不该隐入尘烟。</p><p>马有铁和曹贵英一辈子卑微、沉默，如蝼蚁般在泥土的缝隙里挣扎求生，面对命运，他们没有选择权，没有话语权，甚至连和别人平等对话的机会都没有。那么浅的一条灌溉水渠，那么多人看着，贵英掉下去，却没有人愿意伸出援手。</p><p><strong>资本家靠吸穷人的血活下来，勤劳能干的边缘人，失声、丢命，拼尽全力，却连一点希望都抓不住、一点痕迹都留不下，两条生命，还不如世间的一粒微尘。</strong></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MV13/0eQBU8.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;影片讲述西北农村，两个被各自家庭抛弃的孤独个体，在日复一日的耕耘中相濡以沫的故事，武仁林与海清展现了一对底层农民夫妇从陌生到熟悉，从相知到相守的心路历程。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>极圈以南，承诺埋葬冰川之下--South of the Circle</title>
    <link href="https://yousazoe.top/archives/6c20c24c.html"/>
    <id>https://yousazoe.top/archives/6c20c24c.html</id>
    <published>2022-08-29T12:39:55.000Z</published>
    <updated>2023-05-05T12:43:30.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/WI2ABK.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>《极圈以南》是一款动人心弦的叙事游戏，探索两位被卷入政治冲突的剑桥学者披得与克拉拉之间的情感关系。当过去被迫做出的选择已成幻影，我们又该如何坚守职业生涯与真爱的承诺。</p><span id="more"></span><p><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.akamai.steamstatic.com/steam/apps/1811040/ss_1b0d785bc5288a160d458252861a093463427b61.600x338.jpg?t=1661510536">       <source id="mp4" src="https://cdn.akamai.steamstatic.com/steam/apps/256899096/movie480_vp9.webm?t=1659529552" type="video/mp4">       </video></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p>《极圈以南》将以多层次的电影化叙事手段来讲述一段动人心弦的故事。游戏的主要故事将向人生选择之重抛出疑问，并从过去与未来的双重视角探讨对职业生涯与真爱的影响。玩家将扮演在冷战时期的南极遭遇飞机失事事件的剑桥学者披得。在寻求帮助的道路上，他将回忆起自己的过去，并思考权利的威压与个人的野心是怎么将自己一步步带入这个必须逃脱的困境。随着披得与自己的同事克拉拉之间爱意萌生，他渐渐意识到了当初许下诺言的承重。就像是儿时的回忆，不经意间的承诺也将陪伴我们一生。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/1811040/extras/SotC_TRAIN_D.gif?t=1661510536"></p><p><strong>匠心打造，电影味十足</strong></p><p>由揽获英国电影和电视艺术学院（BAFTA）大奖的工作室 State of Play 创作，《极圈以南》中唯美的画面与细致入微的文笔将在电影化的镜头语言中娓娓道来，除此以外还有来自多位知名演员的倾情演出：Gwilym Lee（波西米亚狂想曲），Olivia Vinall（白衣女人），Richard Goulding（王冠），Anton Lesser（权利的游戏），Adrian Rawlins（切尔诺贝利）以及Michael Fox（唐顿庄园）。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/1811040/extras/SotC_CAR_D.gif?t=1661510536"></p><p><strong>特色</strong></p><ul><li>在独特时代与地点背景下引人入胜的沉浸式叙事体验</li><li>细致入微而且深入肺腑的选择</li><li>完美演绎情绪波动的真人动作捕捉演出</li><li>设定在真实冷战年代的细腻背景</li><li>与故事本身交织融合的环境叙事手法</li><li>出类拔萃的美术风格</li><li>由制作出荣获BAFTA大奖的 Lumino City、BAFTA提名KAMI 2以及荣获苹果设计大奖（Apple Design Award）的INKS等多款游戏的State of Play Games倾情打造，玩家们将在游戏中见证诸多感人肺腑的动情时刻</li></ul><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/1811040/extras/SotC_footer_karta_steam_616x136__copy.png?t=1661510536"></p><h3 id="游戏实况"><a href="#游戏实况" class="headerlink" title="游戏实况"></a>游戏实况</h3><iframe src="//player.bilibili.com/player.html?aid=259995007&amp;bvid=BV1aa411R71s&amp;cid=816529436&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="极具特色的画面张力"><a href="#极具特色的画面张力" class="headerlink" title="极具特色的画面张力"></a>极具特色的画面张力</h4><p><strong>简约化</strong></p><p>与漫漫长夜极为相似的印象派画风让本作的美术风格给人一种独树一帜的感觉，非常的简约，并没有着重勾勒面部、建筑、场景的细节，而是着重于色彩对比、阴影处理等烘托氛围的表现方式，把简约化模型作为画面的主要表现形式，让玩家专注于剧情发展。</p><p><strong>噪点</strong></p><p>将游戏画面做旧，这种复古的画面设计把冷战时期那种不清晰的质感拔高，呈现出一种“时过境迁”的年代感。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/2xjQDV.jpg"></p><p><strong>色彩</strong></p><p>本作画面张力的另一处体现。本作的色彩较为鲜艳，虽然在噪点的影响下看上去饱和度不算太高，但产生的色彩对比让本作极具直观的视觉冲击力。</p><p><strong>阴影</strong></p><p>本作处理阴影的手法也非常巧妙，大量的特殊镜头与光线关系，将玩家包裹在了有限的回旋空间里，特别是在房间里，聚光灯式的打光方式，圆形画面外的阴影令人恐惧，而在狭隘的空间中聚焦到一处的视觉表现，非常地压抑。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/1t7qoI.jpg"></p><h4 id="电影叙事与蒙太奇手法"><a href="#电影叙事与蒙太奇手法" class="headerlink" title="电影叙事与蒙太奇手法"></a>电影叙事与蒙太奇手法</h4><p>State of Play 把游戏做成了一部冗长的电影，在电影里运用蒙太奇式的插叙叙事手法将 “过去/剑桥” 和 “现在/南极” 两条不同时间线的故事糅合到一起，风雪与细雨，雪原与街道，铀矿场与游乐园、南极站与办公室……过往的故事仿佛梦境一般插在南极冒险的中间，时空的错位感构筑出截然不同的两种氛围环境，同时产生一些只可意会的暗喻内涵，拔高了整个作品的层次感和节奏感。</p><p>与之相对的，游戏电影化非常考验制作人的手法：在叙事性与游戏性间平衡。显然本作并没有达到完美的平衡，游戏中要求文章联名只存在于 Peter 的自我幻想，无论前面做出什么决定玩家都不会改变结果，这会给人非常强的负反馈与挫败感，单线式剧情和存在感弱的选项使游戏缺乏交互感，也是许多玩家给予差评的原因之一。</p><h4 id="富有争议的讨论与思考"><a href="#富有争议的讨论与思考" class="headerlink" title="富有争议的讨论与思考"></a>富有争议的讨论与思考</h4><p>虽然游戏只有短短的三个小时流程，但其包含了两个饱受争议的对立议题：女性独立与平权、意识形态与冷战思维。</p><h5 id="冷战思维与意识形态"><a href="#冷战思维与意识形态" class="headerlink" title="冷战思维与意识形态"></a>冷战思维与意识形态</h5><p>在游戏中的 “现在/南极” 时间线是关于冷战思维的部分。</p><p><strong>学校政治运动</strong></p><p>游戏涉及了大量史实，比如剑桥的教授曾对 Peter 提及剑桥四人组，并暗示军方对所有剑桥的研究学者都有所怀疑；以及政府对同性恋、女权主义近乎宗教审判式的迫害。</p><p>历史上真实存在的是剑桥五杰，他们是上世纪30年代就读于剑桥大学的五位高材生，认为资本主义无法拯救欧洲大陆的命运，对苏联新起的社会主义充满兴趣，后来都成为了坚定的共产主义信徒。毕业之后的五人分别在英国的外交、情报甚至间谍机构工作，而苏联的间谍组织克格勃也开始秘密与他们接触。五人后来相继成为了苏联的间谍，为苏联不断提供英方政府的情报。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/nEntlP.jpg"></p><p><strong>南极条约</strong></p><p>尽管历史上1959年包括美苏在内的许多国家已经签署并加入确保各国在南极和平发展的《南极条约》，但美苏冷战的范围早已不可避免地波及这片地球的处女地，甚至相继在南极洲附近展开核武器实验，时至今日南极洲的冰层上仍可检测出大量残存的放射性氯元素。</p><p><strong>苏联工程师</strong></p><p>在 Peter 与飞行员交流的过程中，玩家可以明显感受到西方世界对于苏联的偏见，事实上在玩游戏前我以为制作方可能会与大部分欧美人一样以抹黑苏联作为一种政治正确。</p><p>但是制作组还是打了我的脸。最后飞行员放下了心中的偏见，也把问题抛给了玩家：对于大多数人而言，时代就像一股莫之能御的洪流。整个冷战期间各个国家的人都彼此满怀恶意，而在极地圈中三人相依为命，机长给工程师递烟，敬威士忌，而工程师也与他敞开心扉，聊的酣畅淋漓，不由得让玩家们在极地的寒冷中感受到了一丝暖意。这也是在生命的最后时期中，体现出的一丝人性的良知面，这种感情，并不是国与国之前能限制的，而是人与人一辈子的生死至交。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/wessdX.jpg"></p><h5 id="妇女运动与女性独立"><a href="#妇女运动与女性独立" class="headerlink" title="妇女运动与女性独立"></a>妇女运动与女性独立</h5><p>在游戏中的 “过去/剑桥” 时间线是关于女性独立的部分。</p><p>其实关于女性独立的话题我一直不想涉及，因为这个话题涉及到太多的争议，而我之前也被朋友以”女权”之名中伤过，现在想想那位可能怎么也想不到我会为这样的游戏宣传。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/Q4QMEi.jpg"></p><p>但本作的精妙之处在于，即使玩家选择了所有支持克拉拉的选项，结果依然是背叛。其实许多暗线都指向了背叛，首先本作开头 Peter 出现在南极，就说明他最终选择了向名利妥协没有在论文中联名；其次当 Peter 多次选择联名论文选项时，给出的说辞是模棱两可的，也就侧面印证了”幻想说”：许多场景都是 Peter 自己的臆想，其实他选择的是背叛和食言，只是负罪感迫使他去逃避这段现实，捏造了虚构的情景（也就是玩家选择的场景）。</p><p>换句话说，其实玩家是站在一种比较虚伪的角度去协助克拉拉，以强者的怜悯姿态而非平等的尊重，也是很多人会犯的本质错误。当最后真相大白时，玩家的选择被一个个的否定，其实也就是制作组告诉你之前的一切只是幻想罢了，这段是给我非常大震撼的一段剧情。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/FAxZn0.jpg"></p><p>不仅如此，除了故事的主线，大量支线也在隐喻妇女运动，例如 Peter 小时候父母吵架暗示了父权社会的主导地位、Peter 在剑桥路上闲聊中发现克拉拉对于自己教授资格非常敏感暗示了职场中女性的不平等地位…… </p><p>《极圈以南》提供了一个从男性的视角去体验变化的过程，看着父权如何运作，主角是如何从童年开始被建构成“男人”的，通过画面明暗的隐喻，“男人群体”间的玩笑，“以父之名”的规训，男主被压抑的想法，以及厌女的社会氛围如何形成，并且在这样一个环境中男主角有何感受，经过了怎样的事情被迫妥协，甚至是合作反抗的故事，这是让我觉得最难能可贵的地方；并且这种与个人命运相关的叙事反复穿插在极难环境的求生过程中，并与求生的主题相互呼应，随着事态的变化高低起伏，铺满悬念，以至于被剥夺一切之后，那种极端环境下的绝望和最后觉醒的冲击力不言而喻，而游戏的配乐、画面运镜在不遗余力渲染这种情绪高潮的到来。结局里男主角从克拉拉的女性他者的幻象中走了出来，看清了何为真实，伸手与过去作别，最终向着深邃幽蓝的天空远去。这个意味深长的结局或许是象征着男主角从男性建构中挣扎并最终挣脱的过程，不只是与现实的他一起离开了南极圈的险境，更是代表着离开了思想的“险境”，完成了对于他自身的蜕变。</p><p>作为一款从男性视角看待女性主义的作品，我是非常推荐去尝试的。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><p>从南极冻土挟着冰霜而来的凛冽狂风在世人心中呼啸，自冷战至今，从未止息。</p></blockquote><p>《极圈以南》的结局可以看作是开放性的，彼得和同伴们在最后一刻成功是否脱险，并没有明确交待给玩家，留下了想象和回味的空间。游戏通过在现在与过去之间闪回式的插叙展现了男主角彼得的人生，表达出冷战大背景下个人命运的些许无奈，但同时也歌颂了热爱和平的反战精神。游戏的艺术性很强，思想性也可圈可点，如果你不是很在意游戏性，而是想体验一个沉浸式的故事，那么本作非常值得推荐。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/KQwQkE.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GT16/WI2ABK.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;《极圈以南》是一款动人心弦的叙事游戏，探索两位被卷入政治冲突的剑桥学者披得与克拉拉之间的情感关系。当过去被迫做出的选择已成幻影，我们又该如何坚守职业生涯与真爱的承诺。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>一花一叶，毕其一生--Gorogoa</title>
    <link href="https://yousazoe.top/archives/9a8c63ec.html"/>
    <id>https://yousazoe.top/archives/9a8c63ec.html</id>
    <published>2022-08-23T02:15:46.000Z</published>
    <updated>2023-05-05T12:43:30.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/rvrEea.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Gorogoa 是一款独具特色的解谜游戏，其故事情节采用由 Jason Roberts 设计和作画的精美手绘插画展开。</p><span id="more"></span><p><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.akamai.steamstatic.com/steam/apps/557600/ss_aa212d776cb3cd25316b3932c218c08f4843f4dd.600x338.jpg?t=1660851691">       <source id="mp4" src="https://cdn.akamai.steamstatic.com/steam/apps/256717596/movie480.webm?t=1527026591" type="video/mp4">       </video></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/557600/extras/Gorogoa_1S.png?t=1660851691"></p><p><strong>充满独特想象力的谜团</strong></p><p>Gorogoa 的情节设计均为原创，游戏中有多个细节丰富的插画格子，玩家可按照自己的想法通过移动和组合插画格子来解谜。操作极为简单，内容却复杂有趣。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/557600/extras/Gorogoa_2S.png?t=1660851691"></p><p><strong>精美的手绘游戏情节</strong></p><p>Jason Roberts 精心制作了数千张极为精细的插画，构成极为丰富的 Gorogoa 特色游戏情节。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/557600/extras/Gorogoa_3S.png?t=1660851691"></p><p><strong>全新的叙述方式</strong></p><p>Gorogoa 不仅是一款游戏，还是一件艺术品，它用充满情感、极富魅力的插画和构思奇妙的解谜机制诉说着自己的故事。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/557600/extras/Gorogoa_4S.png?t=1660851691"></p><h3 id="游戏实况"><a href="#游戏实况" class="headerlink" title="游戏实况"></a>游戏实况</h3><iframe src="//player.bilibili.com/player.html?aid=344859158&amp;bvid=BV1Hd4y1A7e6&amp;cid=811487520&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="近乎绚烂的美术风格"><a href="#近乎绚烂的美术风格" class="headerlink" title="近乎绚烂的美术风格"></a>近乎绚烂的美术风格</h4><iframe src="//player.bilibili.com/player.html?aid=32718176&amp;bvid=BV1qW411S7X2&amp;cid=57247688&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="突破思维定势的交互体验"><a href="#突破思维定势的交互体验" class="headerlink" title="突破思维定势的交互体验"></a>突破思维定势的交互体验</h4><p>笔者从来都没玩过像 Gorogoa 这样的解谜游戏。它安静而引人深思：四个可拖动的方块就像是一扇扇窗户，通向美丽梦幻的手绘世界。当你滚动、覆盖、拼接或放大缩小每一块画面时，你会发现每一个小方块中都蕴藏着一个神秘庞大的世界。静态的场景会随着画面的移动焕发生机，你可以通过改变方框的位置来激活场景的互动，探索隐藏在其中的双重世界（神秘、悲伤还有一点吓人）。一旦你找到了正确的拼接方法，你就会感到无比兴奋和满足。游戏的故事只需要短短两个小时就可以通关，但游戏独具的魅力和充满神秘感的故事会在你的脑海里停留很长一段时间。</p><p>见到这款游戏的第一眼，你可能会以为这些图片只是从儿童故事书上撕下来的插画，毫无联系可言。游戏的奥秘往往隐藏在一个平凡的小物件上：枝头的一个苹果、书架上的一盏灯、一个指南针、一张地图和一幅照片。还有一些场景需要将两幅图片拼到一起，形成一个更大的场景，然后你可以点击进入场景或将场景放大，以揭示隐藏在原来的图像中的新世界：一座废弃的城市、瓦砾堆里坏掉的玩具和寺庙上的滚动陨石。它们之间的联系是分散而神秘的，每个谜题的场景都像是梦境，讲述了一个深奥的故事。这是一种难以抗拒的魅力。</p><p>你在这几幅画框之间探索、排列和堆叠，有时甚至从一张画框中分离出两个图层，这些四散在画框中的杂乱线索会以一种不可思议的方式组合在一起。在一幅场景里，笔者从天上偷了一颗星星来点亮台灯。在另一幅场景里，笔者通过重叠门的图案、旋转古代遗迹并将转动的瓷盘当成齿轮，来指引主角在几张老照片中穿梭。在这些谜题中，时间和空间不受物理定律约束，可以自由的组合切换，同时出现在一幅场景中。笔者发现自己回到了过去或是到了遥远的土地上，在那片土地上的一举一动竟然会影响现在。这是一种非常巧妙的机制，它能激励玩家去发掘每个场景背后新颖神奇的联系，在这个过程中跟随故事一起回想过去与得失。</p><h4 id="记忆碎片背后的叙事艺术"><a href="#记忆碎片背后的叙事艺术" class="headerlink" title="记忆碎片背后的叙事艺术"></a>记忆碎片背后的叙事艺术</h4><blockquote><p>该部分主要参考了以下两个游戏资料</p><ul><li><a href="https://www.gcores.com/radios/95810/timelines?pi=1">机核</a></li><li><a href="https://www.bilibili.com/video/BV1tC4y1a7bG">制作人演讲</a></li></ul></blockquote><h5 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h5><p>游戏制作人 Jason Roberts 原本是个软件工程师，37 岁那年他辞去工作，开始独立制作这款游戏。不断推翻重来的制作过程花光了他所有的钱，但也让他想象中的游戏成为了现实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/j7DIbP.jpg"></p><p>游戏本名 Gorogoa，是他在小时候给自己想象中的生物起的名字，它听起来像是雷声或是从地下传来的轰隆声，古老而强大。而它的出现也成了游戏的序章，巨龙游过街头如同神迹降临，心怀好奇的男孩从此开始冒险。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/iuZytz.jpg"></p><p>当他集齐五色果实想召唤神龙时，神龙却闭上了眼，他也从云端坠落…</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/j2VVwe.jpg"></p><p>从此，破解神龙的秘密成为了他一生的追求。通过拼图，玩家跟着游戏中的男孩一步步展开冒险。</p><p>男孩在寻找神龙的旅程中度过了一生，这个游戏就像他所有的回忆。它们并不遵照时间顺序重演，而是不断折叠、编织，构成了一个时空交错的寓言。大部分玩家在游玩过程中专注于解谜的过程，其蕴含的剧情故事却被忽略，而这恰恰是开发者最想要传达的故事，只不过以一种比较隐晦的方式表达出来。</p><h5 id="剧情梳理"><a href="#剧情梳理" class="headerlink" title="剧情梳理"></a>剧情梳理</h5><p>童年时期男孩看见巨龙从街头经过，他查阅书籍发现了一个古老的仪式，集齐五色果实就可以召唤神龙，于是男孩踏上了寻找果实的冒险之旅。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/DCfBug.jpg"></p><p>旅程的开端十分顺利，一只乌鸦振翅而飞，他就获得了从枝头掉落的红色果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/SD1BYa.jpg"></p><p>随后他通过一扇画中之门进入花园，从女神像手中得到绿色果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/tRyWdx.jpg"></p><p>在另外几尊塑像的指引下，他来到一片墓地，时间由黄昏进入深夜，一颗星辰成为了黄色果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/xNDt5W.jpg"></p><p>此后昼夜流转，在经历了一些神秘的建筑遗迹后他来到一处祭坛，取走了蓝色果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/D7Cmmp.jpg"></p><p>最后他搭乘列车来到紫色塔楼，登上高塔，摘下了紫色果实。可当他为神龙献上五色果实后，神龙却闭上了眼，他也因此从云端坠落。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/XcVoWo.jpg"></p><p>受了重伤的男孩缠上了绷带，需要借助轮椅移动。养伤期间，他回到了自己曾获得果实的地方，想起自己过去的经历，心中充满了困惑。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/bcpQjx.jpg"></p><p>这场伤病持续了很久，男孩已长成少年，但仍需要拄着双拐行动。此时城市因为某种原因成为废墟，有关神龙的资料也被烧毁了一部分。在一幅寓言画中，失明的人在沙漠中进入一片绿洲，得到女神赐予他的眼睛，从此得到了光明。</p><p>与之对应的，现实中的男孩身处断壁残垣之间，就像失明者看不清方向。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/RIHBr9.jpg"></p><p>得到神龙之眼意为他得到了启示，开始真正认识这个世界。</p><p>在家中翻阅古籍后，男孩了解了”神的起源”，人们对神的想象经历了漫长的演变，并由此创造了神的象征图案以及它所对应的马鱼星座。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/bU32pn.jpg"></p><p>研究古籍的日子一直持续到青年时期，男孩在书中看到了”神的惩戒”，人对神的召唤并未得到应允，反会引来陨石的坠落，是他让这座城市遭受了天灾。</p><p>愧疚之下他更渴望破解神龙的奥秘，开始学习占星术。房间里的书架和书桌边都散落着大量书籍，他每天研读资料至深夜。确认了马鱼星会在何时出现后，他来到野外进行观测。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/wtI2LH.jpg"></p><p>当它如预想中的一样出现在夜空时，他的求知之树已然结出了果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/ioPN83.jpg"></p><p>读完万卷书后，进入中年时期的他开始行万里路。地图上标注了他参与不同教派进行三次修行的路径。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/fqAv8N.jpg"></p><p>第一次修行，他在沙漠中徒步摇铃，齿轮中的图案呈现了这一教派的四种仪式：</p><ul><li>日出时献祭孔雀</li><li>白天在沙漠摇铃</li><li>日落时放走飞蛾</li><li>夜晚握着蓝色念珠对着马首鱼身神像做礼拜</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/mLujm5.jpg"></p><p>第二次修行，他在森林中供奉烛火。</p><p>花窗中的图案表明火焰是这一教派信仰的象征，他们高举火焰以示崇拜，并在教徒间传递火焰留存火种。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/TC36HF.jpg"></p><p>第三次修行，他攀登雪山为自己洗礼。 瓷盘中的图案也呈现了四种仪式：</p><ul><li>为自己洗礼</li><li>在蛋上绘画</li><li>供奉烛火</li><li>马鱼祭祀</li></ul><p>这三次苦修磨砺了他的身心，但他始终没有追寻到神龙的踪迹。看着自己曾用过的法器，他又回想起了当初的梦魇，不由地感到失望而沮丧，但他始终没有放弃。</p><p>当他年近花甲时，开始回顾自己一生的研究，希望能从中找到有用的线索。当他理清思绪后，他再次搭乘火车来到紫色塔楼。</p><p>曾被摧毁的高塔在重建后已恢复了原貌，他登上高塔开始回溯过去的经历。</p><h5 id="果实隐喻"><a href="#果实隐喻" class="headerlink" title="果实隐喻"></a>果实隐喻</h5><p>童年时期，那本记录了神龙的书其实早已揭示了后果：献祭果实失败后，他将从云端跌落。血一般的红色果实，象征的是他渴望追寻理想的热血和甘愿为之牺牲的勇气。</p><p>少年时期，在现实和内心都是一片荒芜的时刻，绿色果实象征者神的启示降临。他怀揣希望，开始寻找前行的路。</p><p>青年时期，在钻研知识的道路上，他经历了漫长而孤独的黑夜，黄色果实象征着他从未熄灭的求知欲。通过研究与实践，他正一步步解开神龙的秘密。</p><p>中年时期，他云游四海，在沙漠、森林与雪山中完成了艰苦的修行，蓝色果实象征着他的决心与毅力。肉体与精神上的锤炼让他变得更加坚韧。</p><p>老年时期，他在精神世界重走了一遍人生路，从事物的表象到达了意识的深处，则色果实意味着他实现了顿悟。</p><p>当他参透了所有果实的含义后，他的灵魂也就此升华。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/Ptilrl.jpg"></p><h4 id="开发者的朝圣修行之旅"><a href="#开发者的朝圣修行之旅" class="headerlink" title="开发者的朝圣修行之旅"></a>开发者的朝圣修行之旅</h4><iframe src="//player.bilibili.com/player.html?aid=795979987&amp;bvid=BV1tC4y1a7bG&amp;cid=198333711&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>玩家在游戏中用了90分钟追梦，作者在创作中用了七年追梦，而男孩在画中用了一生追梦。</p><p><strong>追寻并不一定有结果，即使达到了终点也不一定是你想要的，但这追寻的过程，便是那可以令人生而无憾的宝物。</strong></p><blockquote><p>有生之年，得偿所愿。</p><p>画中世界，怪龙隐现。</p><p>小小男孩，四处追寻。</p><p>众人身影，仿佛曾见。</p><p>乌鸦振翅，眼珠游动。</p><p>飞蛾扑火，青花旋转。</p><p>列车出站，楼高危险。</p><p>瓷碗破碎，眼前一黑。</p><p>鲜血红艳，枝桠绿翠。</p><p>挂毯紫绣，鳞羽燃星。</p><p>痴人前行，不舍昼夜。</p><p>摇铃叩门，天光重开。</p><p>兽尾深潜，层层叠叠。</p><p>黄粱一梦，已历半生。</p><p>轮椅仍在，男孩又见。</p><p>不知谁人，泪流满面。</p></blockquote><p>如果你和游戏中的他一样，也在为了一个遥不可及的梦忍受失败和孤独，那么祝愿你终有一天也能触碰到那个奇异而美丽的龙。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GT15/rvrEea.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Gorogoa 是一款独具特色的解谜游戏，其故事情节采用由 Jason Roberts 设计和作画的精美手绘插画展开。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fl0w3r</title>
  
  <subtitle>carpe diem</subtitle>
  <link href="https://yousazoe.top/atom.xml" rel="self"/>
  
  <link href="https://yousazoe.top/"/>
  <updated>2022-07-01T09:23:45.771Z</updated>
  <id>https://yousazoe.top/</id>
  
  <author>
    <name>Yousazoe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你赢了？--First Strike</title>
    <link href="https://yousazoe.top/archives/4e597f2f.html"/>
    <id>https://yousazoe.top/archives/4e597f2f.html</id>
    <published>2022-07-01T00:53:10.000Z</published>
    <updated>2022-07-01T09:23:45.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/qCNH4s.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>《先发制人》是一款快节奏实时策略游戏，在此游戏中，您可以从全世界最大的十二个核超级大国中选择一个扮演，然后努力成为整个世界毁灭时的最后一个幸存者。</p><span id="more"></span><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.cloudflare.steamstatic.com/steam/apps/587000/ss_6d95b6190af9e255c00dcb7d9be39979dfbddc02.600x338.jpg?t=1615819400"><source id="mp4" src="https://cdn.cloudflare.steamstatic.com/steam/apps/256685072/movie480_vp9.webm?t=1615365572" type="video/mp4"></video><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/zHgUfb.jpg"></p><h4 id="即时战略类核战游戏"><a href="#即时战略类核战游戏" class="headerlink" title="即时战略类核战游戏"></a>即时战略类核战游戏</h4><p>全世界已有数以百万计的指挥官玩《先发制人》。如今，该游戏以《先发制人：经典之战》重新回归。我们将这款标志性核战策略游戏重新打造。重建后，游戏机制更稳定，敌人狡猾并难以对付；呈现给各位玩家最好的《先发制人》。</p><p>《先发制人》是一款快节奏实时策略游戏，在该游戏中，投射导弹就像学习 ABC 一样简单。但一定要采取正确措施保证人民的安全。</p><p>从美国等知名超级大国和朝鲜等新兴核国家中选择一个扮演，然后明智地规划策略：扩张到其他国家，建造或拆除核武器，重建核武器库。或通过研究获得新型核技术、更好的侦察情报、自动化自卫序列等。</p><p>不管您是嗜血好战者，还是环保主义嬉皮士，现在都该亮牌了。《先发制人》将向您展示让事件升温究竟有多简单。您掌控着浮动在太空中这个宝贵但脆弱星球的命运，我们称它为地球。当整个世界毁灭时，您能存活下来吗？</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/YQkZRZ.jpg"></p><h4 id="游戏特点"><a href="#游戏特点" class="headerlink" title="游戏特点"></a>游戏特点</h4><ul><li><p>全世界已有数以百万计的指挥官玩《先发制人》。现在，随着《先发制人：末日终结》的推出，这款备受赞誉的策略型游戏最终登陆PC，您将体验到全新功能和精美的高清场景！</p></li><li><p>可扮演十二个核超级大国 - 选择自己要扮演的实际超级大国，包括美国、俄罗斯、中国或朝鲜等</p></li><li><p>毁灭性超级武器 - 建造十二个先进的火箭，如三叉戟和沙皇火箭，每个联盟都独一无二</p></li><li><p>建造火箭和导弹，征服新领地，研究新的毁灭性核技术。</p></li><li><p>控制世界 - 在三维地球上发射和防御核火箭。</p></li><li><p>全新的专属互不侵犯条约系统 - 寻找条约伙伴，联合对抗敌人</p></li><li><p>高清结构场景 - 全新场景，包括夜间照明、凹凸贴图、高清选项和仅适于PC的星群画面</p></li><li><p>快节奏策略游戏玩法 - 完成先发制人的每个回合需要半小时至一个小时。</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/P55W1j.jpg"></p><h4 id="奖励和选择"><a href="#奖励和选择" class="headerlink" title="奖励和选择"></a>奖励和选择</h4><p>《先发制人》是全世界许多游戏大奖的入围者和获胜者，包括</p><ul><li><p>获胜者 “Most Innovative Game” - BAE Awards*</p></li><li><p>获胜者 “Game of the Year” - BOSA Awards*</p></li><li><p>获胜者 “Newcomer of the Year” - SwissICT Awards*</p></li><li><p>获胜者 “Best Mobile Game” - Indie Prize Amsterdam*</p></li><li><p>入围者 “Best Strategy Game” - BAE Awards*</p></li><li><p>入围者 “Best Hardcore Game” - Game Connection USA Awards*</p></li><li><p>入围者 “Most Innovative Game” - Game Connection USA Awards*</p></li><li><p>入围者 “Best Upcoming Game” - IMGA Awards*</p></li><li><p>入围者 “Most Meaningful Play” - IMGA Awards*</p></li><li><p>入围者 “Best International Game” - Ludicious Game Festival*</p></li><li><p>入围者 “Best Swiss Game” - SGDA Awards*</p></li><li><p>入围者 “Master of the Year” - BOSA Awards*</p></li></ul><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="高度简化的策略系统"><a href="#高度简化的策略系统" class="headerlink" title="高度简化的策略系统"></a>高度简化的策略系统</h4><p>高度简化的策略系统中玩家无需考虑资源问题，所要做的就是在自己的领地内适当管理建造导弹的数量与种类，以便及时对敌方的核武攻击做出有效防御并予以回击，同时积蓄力量主动出击一举摧毁敌方核武力量与领地。</p><p>游戏中导弹种类也被简化为仅有三种：用于导弹拦截防御的「短程巡航导弹」(Cruise)、射程可覆盖半个地球的「中程弹道导弹」 (IRBM) 以及在取得科技点升级后可以攻击全球的「洲际弹道导弹」 (ICBM) 。当某块领地正在执行或执行过某个动作后（如建造导弹、反导反击、进行技术研究）会有一段冷却时间，这段时间内该领地将不能对外产生任何反馈，合理分配动作的时机与先后是避免领地遭受打击的要诀。</p><p>扩张则是对领地附近的区域执行吞并的指令，国家的疆域越广阔拥有的核武库基数也就越大，能够取得更多的先机；同时，假若本土不幸遭受到一轮饱和打击，拥有广阔疆域也使得我方全军覆没的危险性大大降低。因此，及时进行扩张行动是每个玩家都需要尽快考虑的事。</p><p>除此之外，每局游戏中玩家还可为自己的国家选择两种超级武器的研发方向，通过研发解锁所有科技点来获得他们的使用权。这其中包括有最高技术先进性、可同时发动多处真假核打击的「全面攻击型三叉戟导弹」；能够使被攻击区域承受严重核污染、再也无法重新利用的「恐怖型镭炸弹」；一击便可摧毁整个大洲、威力无比强大的「沙皇氢弹」等众多强力武器，合理地使用它们将会是取得这场大战最终胜利的制胜秘诀。当玩家核武库中拥有超过9枚以上的导弹时，便可使用「全面核打击」的决战技能，将库存中的核导弹倾数发射集中攻击目标国，甚至可于一轮攻击中夷平目标，决定战争的胜负。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/VjixXl.jpg"></p><p>稍稍一提游戏的画面。游戏画面采用比较夸张的卡通渲染，没有过多的细节，不容易让人感到战争的凝重感和恐怖感；但核武攻击的画面依然很有气势，尤其是执行全面核攻击的时刻：漫天核弹划破天际，密密麻麻的轨迹线引向目标。最终导弹群在落地后引发大地剧烈震颤的场面，依然让人感到十分的爽快与震撼。</p><h4 id="战争游戏下的反战内核"><a href="#战争游戏下的反战内核" class="headerlink" title="战争游戏下的反战内核"></a>战争游戏下的反战内核</h4><p><strong>游戏中有两处细节我觉得值得一提：</strong></p><p>其一是《先发制人》中每次打击城市时升起的那一排几百万几千万死亡人数的数字。</p><p>很多玩家也许根本不会在意这个细节，然而只要细思就会感到不寒而栗：几个人的死亡令人感到恐惧、悲伤或是惋惜，成千上万人的死亡则令人感到麻木，而当达到百万千万数量级的死亡时，感官上便已失去实感，个人生命的价值已经被无限地淡化与忽视，众生皆如蝼蚁，那些逝去的灵魂不过只是计数器上一个个枯燥的数字罢了。人的生命，有时真的很不值钱。</p><p>其二是暂停时游戏界面上出现的时钟。那并非是普通的时钟，而是被称作「末日时钟」的概念形象。</p><blockquote><p>「末日时钟」(Doomsday Clock) 是一虚构钟面，由芝加哥大学的《原子科学家公报》杂志于1947年设立，标示出世界受核武威胁的程度：12时正象征核战爆发，杂志社因应世界局势将分针拨前或拨后，以此提醒各界正视问题。最近的两次调整—— 在2012年，指针被拨到11时55分；2015年1月22日，「末日时钟」被拨快了2分钟，距离「象征世界灾难末日的」午夜时分仅剩3分钟；2018年1月25日，提醒世人人类全体毁灭的象征性「末日时钟」被再度拨快30秒，距离象征人类末日的「午夜12时」仅剩2分钟，这是冷战以来最危险的情况。</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/STsmm7.jpg"></p><p>核武平衡乃是维系当今世界大国和平的根本，然而，这些恐怖的毁灭性武器一如高悬于全人类头顶的达摩克利斯之剑，它们既是能够缔结和平的「卫士」，也是随时能让人类迈向毁灭深渊的「恶魔」。</p><p>空灵的声音配合漆黑的宇宙背景，这一下就让人仿佛置身其境，加上转动摄像头时不经意可以看见真实的太阳射线，这些画面真的是很让我非常爱不释手。每次释放全面核打击的时候，背景音乐的风格陡然改变，变得紧迫和悲壮，这意味着核打击给人们带来的，只有生灵涂炭，核战争结束后，没有任何赢家，在地球的角度，我们只是一个践踏生命的暴徒。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/LeDBIn.jpg"></p><p>游戏制作组为本作加入的隐藏结局所反映的便是对这个问题的一种思考。为什么一定要疯狂地扩张军备？为什么一定要与其他国家无休止地勾心斗角？如果自一开始就做出牺牲与让步，主动销毁所有的核武库存，其他国家也会在您无私行为的感召下放弃对核武的执念，逐步削减自身的核武库，并带来「实现世界无核化」、取得真正和平的「真结局」。</p><p>这是一款表面鼓励玩家推进毁灭性的核子战争，实则拥有深刻反战内核的作品。（值得一提的是，制作组将自身收入的四分之一捐献于控核组织，是实打实地为实现和平理想做出了小小献力。）</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/owysWG.jpg"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><p>当你拆下自己的核弹的那一刻，你才真正的赢了</p><p>You win when you disarm your nuke</p></blockquote><p>“您赢了”，后面是一个大大的问号。</p><p>核战争没有赢家。</p><p>是一个小游戏，但其反战的精神内核却引人深思。当人们的死亡变成一个数字的时候，战争的意义在哪里呢？</p><p>「向您致敬！在局势极其紧张的时候，您冒着极大的风险，销毁所有的核武器，向全世界表达了您的诚意。您的这一举措为全世界带来了和平！您是这场战斗的最终胜利者！」</p><p>也许这都不过是一厢情愿，也许这都只是美好的憧憬。但我愿意相信：</p><blockquote><p>进步的文明终会带来更高层次的道德与理性。</p><p>人性的真善美终会克服破坏与毁灭的天性。</p><p>愿世界永远和平！</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/qCNH4s.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;《先发制人》是一款快节奏实时策略游戏，在此游戏中，您可以从全世界最大的十二个核超级大国中选择一个扮演，然后努力成为整个世界毁灭时的最后一个幸存者。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Rendering Course by Wangningbei</title>
    <link href="https://yousazoe.top/archives/971404c0.html"/>
    <id>https://yousazoe.top/archives/971404c0.html</id>
    <published>2022-06-29T23:09:54.000Z</published>
    <updated>2022-07-01T09:23:45.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://twitter.com/UeVoxel/status/1541408464203042816"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/uCRUgR.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>偶然间发现了王贝贝老师的渲染课程录播，虽然只更新了五篇但还是特开一篇文章用以复习回顾。</p><span id="more"></span><h3 id="渲染入门"><a href="#渲染入门" class="headerlink" title="渲染入门"></a>渲染入门</h3><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=411172353&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=411225590&amp;page=2&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=415024791&amp;page=3&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br><h3 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h3><h4 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h4><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=423088298&amp;page=4&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br><h4 id="双向路径追踪与光子映射"><a href="#双向路径追踪与光子映射" class="headerlink" title="双向路径追踪与光子映射"></a>双向路径追踪与光子映射</h4><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=426761029&amp;page=5&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://twitter.com/UeVoxel/status/1541408464203042816&quot;&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/uCRUgR.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;偶然间发现了王贝贝老师的渲染课程录播，虽然只更新了五篇但还是特开一篇文章用以复习回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="光线追踪 (Ray Tracing)" scheme="https://yousazoe.top/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
    <category term="Ray Tracing" scheme="https://yousazoe.top/tags/Ray-Tracing/"/>
    
  </entry>
  
  <entry>
    <title>日本独立游戏开发的概况及面向跨文化市场的挑战</title>
    <link href="https://yousazoe.top/archives/9523ea4f.html"/>
    <id>https://yousazoe.top/archives/9523ea4f.html</id>
    <published>2022-06-27T03:14:59.000Z</published>
    <updated>2022-07-01T09:23:45.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/nSRNGT.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>日本是电玩游戏产业代表性的大国，但日本的独立游戏，相较于全球，能见度与影响力就没那么强烈。在日本经营着独立游戏开发者社群的 Anne Ferrero，于 2022 年的 GDC，以《Big in Japan, Not in the West: The Difficults of Cross-Cultural Appeal》为题，分享了她收集与整理的日本独立游戏开发者概况，以及面向跨文化的全球市场时，所该注意的事项。</p><span id="more"></span><blockquote><p>授权转载自 <a href="https://igdshare.org/content/big_in_japan_not_in_west">IGDShare.org</a>，进行了简繁转换，并对一些词汇的不同用法做了修改。</p></blockquote><p>Anne 来自法国，曾在当地的电视台工作，自 2011 年起常驻于日本，与“<a href="https://www.archipel.jp/toco-toco">Archipel</a>”频道合作制作了一系列日本创作者的短篇纪录片。2019 年开始，担任日本独立开发者交流实体空间“<a href="https://asobu.dev/">asobu</a>”的社群经理。她在独立游戏界的代表作，是 2016 年推出的纪录片《<a href="https://branchingpaths.jp/">Branching Paths</a>》，Anne 花了两三年的时间，采访拍摄了多位日本独立游戏开发者，以及以日本为基地的海外独立游戏开发者，影片内容颇受好评，IGDSHARE 曾协助本片的翻译、并在台湾举办放映会。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/5PH2Fv.jpg"></p><p>在谈论日本独立游戏的现况前，先简单介绍一下日本独立游戏的历史。就跟欧美早期有许多“卧室开发者”一样，日本在 1980 年代也有类似的开发者，将自己开发的游戏投稿到电脑杂志、相关竞赛，赚取稿费或奖金，并一步步迈向商业化。像是以《门门冒险（Door Door）》赚到成立 Chunsoft 公司的中村光一，或是从自制游戏攻略本转向独立游戏开发的 Gamefreak 公司等。</p><p>另一个分支，则是“同人”游戏，同样在 1980 年代开始发展，直到现在这样的社群文化都还持续着。同人游戏通常是业余、基于兴趣开发，在 Comiket 等贩售会或者专卖店进行贩售，发展出了像《东方 Project》系列、《寒蝉鸣泣之时》系列、《Fate》系列等等热门到变成商业化大作的系列。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/vjbmLe.jpg"></p><p>时间进到 1990-2000 年代，这时期的主流独立游戏是各种小型的免费游戏，在个人网页提供下载，还有可以线上直接游玩的 Flash 游戏，代表作有《洞窟物语》、《La-Mulana》、《梦日记》等。</p><p>2000 年代之后，新兴的名词是“自制游戏”，性质跟上述的免费游戏其实没有太多差别，主要是因为影音分享网站“NicoNico 动画”使用了这个词汇而被广泛认知。“自制游戏”时期的特性是，通常是使用简易开发工具制作出来的 RPG/文字冒险类游戏，并在 NicoNico 影音网站上，借由游戏实况影片及弹幕(即时字幕留言)讨论创造话题，在年轻一代的玩家之间形成风潮。代表作《青鬼》红到改编成电影、动画、小说等跨媒体作品。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/wL4opl.jpg"></p><p>到了 2010 年起的近代，许多独立游戏也登上了智能手机平台，但因为功能型手机在日本没有快速被取代，所以在平台转移到智能手机这点，日本开发者们的速度比国外开发者慢了一些。代表作品有《妈妈藏走我的游戏机》、《猫咪收藏集》等。</p><p>最后，是“独立游戏”。当然，上述游戏都属于独立游戏的范畴，这里所指的，是采取欧美观点里的“Indie Game”。在这之前，日本开发者要制作游戏的话，通常只有两条路走，一是进到游戏公司作游戏，另一则是业余创作游戏。到了 2010 年代，欧美式的“独立游戏”观念传入日本后，才开始有较多的开发者尝试自己成立小型团队全职制作自己的游戏。成功案例包含《Downwell》、《Gnosia》、《天穗之咲稻姬》等游戏。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/g8Q4Wh.jpg"></p><p>简单区分的话，同人游戏、自制游戏偏向业余同好基于兴趣的创作，独立游戏则是在兴趣同时，作为赖以维生的方式。这些不同的开发者与玩家族群虽然有一定程度的重叠，但彼此的社群与文化之间还是存在着一些隔阂。即使现在已经有不少日本独立游戏的成功典范，还是会有很多日本人认为独立游戏跟业余开发游戏没有太多差别。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/FVV59T.jpg"></p><p>目前在日本有不少定期举辨的独立游戏相关活动，包含东京电玩展里面的独立游戏专区，或是专为独立游戏举办的 BitSummit，以及同时具备同人游戏贩售会与独立游戏展览的 Digital Game Expo 等等，在全球疫情之后，也有一些线上版的展会。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/OxNiGf.jpg"></p><p>接下来，是关于日本独立游戏界的从业概况。根据《<a href="https://head-high.com/survivalguide">独立游戏生存指南</a>》（一条贵彰著作）一书的调查，日本的独立游戏开发者大约有一万人，最主要的分布地则是有许多大公司的东京/横滨，和有着任天堂、CAPCOM 等公司的京都/大坂。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/fMuwbu.jpg"></p><p>Anne 透过 twitter 募集了 65 位开发者，参与独立游戏开发者概况的问卷调查。样本数不算多，无法完全呈现真实的产业概况，但仍然可以在一定程度上提供参考价值。受访者大多是单人开发，或是 5 人以下的小团队。年龄分布上，有 13 % 是 20 多岁，对于海外游戏与独立游戏有较多的接触，另外 85% 的开发者介于 30~49 岁之间，是受日本家用主机影响很深的世代，大多是在有着额外的工作或积蓄的情况下进行独立游戏开发。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/Pwlv0u.jpg"></p><p>在时间与财务上，全职独立开发与兼职独立开发占的比例差不多，分别是 37、35%，有 25% 的开发者则是纯兴趣式的在制作游戏。财务方面，有 58% 的开发者需要额外工作来赚取开发与生活所需费用，有 40 % 开发者是靠上一款游戏赚的钱作为下一款游戏的开发资金。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/r91sBb.jpg"></p><p>在外部资源的支持上，日本独立开发者能获得的十分有限。发行商愿意给予的 MG (Minimum Guarantee，最低保证销售量) 通常很低，也几乎得不到来自政府与产业的协助；就算有公司愿意投资独立游戏，也都是投资给大公司出身的知名开发者，或者已经有成功实绩的手机游戏公司。不过在近期值得关注的是，漫画出版社“集英社”展现了对独立游戏的兴趣，成立独立游戏开发者的网络交流社群“Game Creators Camp”，并且主办或协办了游戏创作竞赛，有点类似他们举办漫画新人奖的方式，优胜者不但会有奖金，还可以获得商品化的全额或部分开发资金出资。</p><p>至于欧美兴盛一时的 Kickstarter 平台，要到 2017 年才接受日本人提案，在那之前只能透过欧美国家的代理人提案，大多数的独立开发者无力参与。实际上，也只有本来就已经很有名的日本游戏制作人，才有机会在 Kickstrter 上成功，而且这“有名”还必须要是在海外有名才行，只在日本有名是不够的，也因为主要的目标是海外玩家，很需要有懂英语的团队协助沟通。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/dn3BE6.jpg"></p><p>日本当地当然也有集资平台，代表性的是 Campfire，有不少游戏在这个平台上成功集资，但可以创下的金额纪录就远不及 Kickstarter 了。会在上面集资的游戏，多半是群体比较小众但又死忠的类型，例如 VR 游戏、日式动画风游戏、卷轴式射击游戏等。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/TmZOPx.jpg"></p><p>对日本独立游戏开发者来说，要他们进军海外市场，普遍会遇到的最大问题，就是语言隔阂。有 80% 的受访者认为他们无法顺利进行外语沟通，必须仰赖翻译工具协助理解。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/yYXr5d.jpg"></p><p>这对于资讯获取上，造成了很大的阻碍。在网络上，有许多免费提供的游戏开发、行销的教学文章或影片，但大多是以英文撰写，英文不好的话就难以阅读；然后，国际展会或竞赛的说明，多半仅提供英文版的说明，这也造成了日本独立游戏比较少参与国际竞赛；还有，游戏的开发工具本身的界面、以及使用文件，基本上也都是英文的。更糟的是，不佳的英语能力还可能造成资讯上的误解。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/qeJBxV.jpg"></p><p>语言隔阂也会造成成本上的增加，当日文游戏想要卖到海外时，必然需要外语化的翻译。只需要少量翻译的游戏或许还好，但文字数量很高的 RPG 或文字冒险类游戏类型游戏，又是日本独立游戏的主流大宗，翻译上会增加不少开发成本，资金比较不足的团队可能就选择不做翻译，这也导致游戏失去了被海外发行商青睐的机会。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/7neZPg.jpg"></p><p>在 Anne 所做的问券统计里，有 50% 的开发者会自行设法将游戏翻译成外国语言，19% 开发者的游戏翻译是由发行商负责，31% 的开发者选择不做翻译。而在翻译的语言选择上，比例最高的是英语，其次则是文化相近、翻译难度较低、市场规模也很大的中文。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/DZR75Y.jpg"></p><p>语言隔阂造成的另一个阻碍，是游戏的行销。即使游戏有办法做好翻译，但要向海外的玩家介绍游戏，需要的是更加灵活、即时的文字运用。像是怎么样正确的描述游戏、怎么样联系媒体、怎么样经营社区、怎么样跟粉丝互动等等。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/x1OuL3.jpg"></p><p>在 Anne 所做的问券统计里，有 50% 的开发者会自行设法将游戏翻译成外国语言，19% 开发者的游戏翻译是由发行商负责，31% 的开发者选择不做翻译。而在翻译的语言选择上，比例最高的是英语，其次则是文化相近、翻译难度较低、市场规模也很大的中文。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/LH0EBE.jpg"></p><p>语言隔阂造成的另一个阻碍，是游戏的行销。即使游戏有办法做好翻译，但要向海外的玩家介绍游戏，需要的是更加灵活、即时的文字运用。像是怎么样正确的描述游戏、怎么样联系媒体、怎么样经营社区、怎么样跟粉丝互动等等。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/NXMdvS.jpg"></p><p>特别是在日文里，有许多只有日本人在用的“和制英语”，又或者日本玩家习惯使用的英文简称，国外玩家不见得看得懂。例如像《街头快打（Final Fight）》这种边走路边打人的游戏，在日本习惯称为“Belt Action / 带状卷轴动作游戏”，但英语圈并不会用这个词，而是用“Beat them up / 打爆他们”来称呼。又或者像“战略 RPG ”游戏，日本是用“SRPG”(Strategy RPG)，在英文圈则习惯用“Tacital RPG”来称呼。不只游戏类型的表述与缩写方式有歧异，像游戏预告片的英文，日本会习惯用“PV”(Promotion Video)，欧美则是会用 Trailer 这个字，跟海外玩家说“请看看我们游戏的最新 PV”时，他们可能会看不懂这是什么意思。</p><p>接着是受访者们选择的游戏主机平台。比例最高的是 PC/MAC，因为这是上架门槛最低的平台，但同时，日本的电脑游戏市场规模却很小，而且是远小于欧美国家的程度。要上主机的话，Switch 平台是首选，即使近年的 Xbox Game Pass 服务让独立游戏界受益不少，Xbox 系列主机在日本的市占率依然是低到不行，也因此影响了开发者们制作 Xbox 版游戏的意愿。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/w9VJfc.jpg"></p><p>在 PC 上，日本独立游戏最主要的销售平台是 Steam，其次是同人游戏的贩卖会、Itch.io 网站或免费下载。日本当地的数位贩售平台如 DLsite、DMM Games、Booth，也都有一定的使用量，但这些平台是包含影片、漫画、插画等作品的综合平台，主要内容也比较偏向成人游戏或同人游戏，不会有主流游戏大作在这边销售，国外消费者的比例也不高，因此吸引一般玩家的效果有限，只适合锁定特定群体的游戏。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/5pie54.jpg"></p><p>选择上架 GOG、Humble Store、Epic 等海外平台的比例又低了一阶，这跟这些平台并没有做好日文化、本身在日本就很少人用有关。</p><p>在发行与宣传上，高达 75% 的受访者在日本是自己发行游戏，而到了海外发行这边，交给发行商负责的比例提升了一些，但有 35% 的开发者选择不在海外发行。宣传方面，66% 的开发者自己负责游戏的宣传，但有 21% 的开发者并不特别宣传游戏；海外部分，不宣传的比例更高到过半，即使游戏有在海外平台上架了，因为不懂得怎么宣传或者不会用英语宣传，就只是单纯将游戏上架后，放着等愿者上钩。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/oXPHMj.jpg"></p><p>媒体联系方面，65% 左右的作品都会发新闻稿等相关资讯给日本国内媒体，但会联系海外媒体的比例则是反过来，主要原则还是不知道有哪些媒体、无法提供英文版新闻稿等语言隔阂因素。另外，大约 80 % 的开发者不会联系主动任何网红(不论国内外)，只被动的希望网红们可以去玩他们的游戏。有 86% 开发者不曾将游戏带到海外参展，即使有，也是以邻近的中国台湾地区、韩国为主。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/6im0il.jpg"></p><p>游戏宣传的管道，几乎全部的受访者都会透过 twitter 宣传，有七成以上会有网站页面，半数有做 Youtube 宣传影片，但剩余平台的使用比例就都不高，海外流行的 twitch 在日本的使用率是低到不行。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/m1RjA3.jpg"></p><p>日本有许多游戏媒体，如法米通、4gamer、Gamespark、电击、IGN Japan、Automaton、Gamecast 等等，这些媒体大多接受新闻稿投稿，有机会可以获得一至两篇的文章刊登曝光。一部分的日本游戏媒体会为游戏评论并且打分数，但只有 IGN Japan 的游戏评分会被列入 Metacritic 分数统计里。Automaton 则是较常报导海外独立游戏，也会将日文报导翻译成英文的媒体。然后，有不少欧美游戏媒体会录制影片或 podcast 型节目，日本游戏媒体这么做的很少，都还是维持在静态文字与图片报导的形式。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/KGCt85.jpg"></p><p>海外人士可能不知道，日本媒体经常会做“逆向输入”型的报导。就好像欧美媒体在介绍日本知名事物时，会形容“Big In Japan”那样，如果日本的游戏在海外有所回响，就会用“在海外受到瞩目”为主题来做报导，这是从音乐、影视、流行文化产业就很盛行的作法。</p><p>例如《ElecHead》这款日本独立游戏，被美国知名游戏开发者 Derek Yu 转推介绍后，就有日本媒体为此写了一篇“国产游戏被海外著名开发者夸赞”的报导。这也是一种向海外行销游戏所能带来的好处，毕竟独立游戏通常缺乏知名度或特殊的新闻点，较难吸引记者撰写报导，但要是在海外引起回响、被知名人士推荐，就构成了足以被写成新闻的题材。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/OrapWS.jpg"></p><p>可惜的是，并不是所有游戏都能够在全世界获得回响，即使游戏品质良好，还是会因为文化隔阂等因素，无法获得海外玩家的喜爱。像是《Unreal Life》，这是一款气氛渲染得很棒的像素画风冒险游戏，在日本获得不错的评价，也针对海外市场做了多国语言的翻译，但在 Steam 上，有 78% 的销售量是日本玩家购买，在 Switch 上更加极端，97% 的销售量来自日本。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/MgFvlu.jpg"></p><p>另一个例子是《Nkodice》，本作设计了一种特殊的骰子，骰子各面上标记的不是点数而是日文假名(字母)，玩法就是投掷骰子拼凑出单字，因为骰面上的假名经过刻意挑选，容易让玩家想要挑战骰出下流或搞笑的单字组合，在日本网络上成为一时爆红的话题。但这样的游戏，难以被直接翻译，就算要重新设计骰面、为不同语言进行在地化也不容易，是注定出不了日本的游戏。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/s2lhVi.jpg"></p><p>接下来要谈论的，是日本的学校与公司、产业间，对于独立游戏其实所知甚少。日本有不少大学有游戏相关科系，也有以游戏开发为主要授课内容的专门学校，但这些学校对于学生的期许或承诺，就是让他们毕业后可以进到游戏公司工作，并将就职率视为学校可以用来宣传的绩效。因此学生们在学的最后一年里，几乎都是在实习、面试，设法取得公司内定的流程中度过。当整个教育体系都这样引导学生时，自然很少有学生会有成为独立开发者的打算。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/X6PBxq.jpg"></p><p>而当开发者们进了游戏公司之后呢，大多数的公司并不鼓励甚至会禁止员工私下开发自己的游戏，即使有些开发者还是会私下制作游戏，也只能够用化名的方式发表。任天堂或 SONY 这种主机硬体商，为了充实自家平台的软件数，会对独立游戏提供一些协助，但其他游戏公司就比较少对独立开发者伸出援手，在日本最大的游戏开发者研讨会 CEDEC，也很少会有独立游戏开发的议题分享。</p><p>在整个产业面向，日本虽然有“Cool Japan”这种以“文化软实力”为主轴的推广计划，但多半只有大公司能从中获得助益，独立游戏能获得的官方支援相当少，就算是出国展览，也缺乏“国家馆”之类的集体出展单位，只能够单打独斗。</p><p>讲者对日本独立游戏开发者与社群提出了一些建议。首先是要有更多的翻译资源，像是国外教学文章的翻译或者影片的字幕，让不谙外语的人们，也能获取海外的相关知识，反过来也是，日本的游戏与相关宣传内容，都应该尽可能制作翻译版本，才能有效在海外扩散。然后是要有更多的区域或国家性的展览、发表会或者联合特卖，这可以让玩家们意识到这个国家也存在着独立开发的群体、有着哪些游戏。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/b6gLIo.jpg"></p><p>另外，也要设法促成更多海外交换学生或者海外移居工作的机会，特别是像日本这样社会相对封闭的国家，能够有人实际到国外生活与工作、再带着相关经验回来分享是很重要的。然后，也希望能有更多当地原生的孵化器或加速器单位出现，现在的孵化器或加速器单位有许多都是来自英语圈，日本当地的开发者比较不敢参与，也可能因为文化隔阂而合作困难。不过在 2021 年，日本终于有了第一个专为独立游戏团队服务的孵化器“<a href="https://igi.dev/">iGi</a>”（indie Game incubator），这是很好的现象。</p><p>最后的结论，还是要尽可能透过展览、宣传等方式，让大众有认识各式各样独立游戏与创作者的机会，当有更多的成功典范出现，就能够启发更多人投入创作、相互精进。跨文化的游戏多样性，也能够建立起全新的粉丝群，例如日系的 RPG 或是视觉小说，在二十年前可能只有日本当地市场，但现在，全世界都有这类游戏的粉丝，也有海外的开发者会去做类似风格的游戏。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/ZVVgbD.jpg"></p><p>然后，创作者与作品都要试着跨出独立游戏圈与同温层，吸引一般玩家、主流媒体的关注，证明独立游戏创作也是一种堂堂正正的职业，就像是独立电影或独立音乐那样，是值得被社会重视、被政府与企业投资的文化产业。</p><p>而如果你是一名玩家，那就不要吝于谈论你喜爱的游戏或开发者，留下评论、推荐、分享转贴，不仅能带来宣传与扩散的效果，还能够为开发者带来很大的鼓舞！</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/At04qw.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/nSRNGT.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;日本是电玩游戏产业代表性的大国，但日本的独立游戏，相较于全球，能见度与影响力就没那么强烈。在日本经营着独立游戏开发者社群的 Anne Ferrero，于 2022 年的 GDC，以《Big in Japan, Not in the West: The Difficults of Cross-Cultural Appeal》为题，分享了她收集与整理的日本独立游戏开发者概况，以及面向跨文化的全球市场时，所该注意的事项。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏分析与测评 (Game Analysis and Evaluation)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%B5%8B%E8%AF%84-Game-Analysis-and-Evaluation/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
    <category term="Japan" scheme="https://yousazoe.top/tags/Japan/"/>
    
  </entry>
  
  <entry>
    <title>记忆消散，思念永存--7 Years From Now</title>
    <link href="https://yousazoe.top/archives/5b6e89b1.html"/>
    <id>https://yousazoe.top/archives/5b6e89b1.html</id>
    <published>2022-06-17T13:22:44.000Z</published>
    <updated>2022-07-01T09:23:45.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/YMop7p.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>生活片段故事风格的冒险游戏，包含独特的体素画面与时间跳跃元素。陪伴高中生春人踏上旅程，寻找他有可能在七年前的一次事故中失去的记忆。</p><span id="more"></span><p><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.akamai.steamstatic.com/steam/apps/1562920/ss_3d51edd32f1c232e2d34f6dbd7d6777290db781f.600x338.jpg?t=1644419909">       <source id="mp4" src="https://cdn.akamai.steamstatic.com/steam/apps/256838864/movie480_vp9.webm?t=1623927587" type="video/mp4">       </video></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p>扮演高中生 Haruto Soraki 踏上旅程，寻找他有可能在七年前的一次事故中失去的记忆。从故乡开启旅程，与遗忘的朋友碰面，揭开小镇的黑暗秘密，倒流时光以赶超那些试图阻止你的人，想办法拼凑出七年前的真相。</p><p><strong>主要特色</strong></p><ul><li><p>独特像素风格的生活片段故事</p></li><li><p>探索城镇，并与镇民互动以推进故事的发展</p></li><li><p>调查神秘事件</p></li><li><p>揭开小镇的秘密</p></li><li><p>倒流时光，赶超你的敌人</p></li><li><p>破解失忆谜团，找出真相</p></li></ul><p><img data-src="https://p.qpic.cn/wegame/0/727dab91fd9fda00520bd50cd91902d0.jpg/1000"></p><h3 id="游戏实况"><a href="#游戏实况" class="headerlink" title="游戏实况"></a>游戏实况</h3><iframe src="//player.bilibili.com/player.html?aid=512535395&amp;bvid=BV1Cg411Q7qZ&amp;cid=749979228&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="近乎完美的节奏把控"><a href="#近乎完美的节奏把控" class="headerlink" title="近乎完美的节奏把控"></a>近乎完美的节奏把控</h4><p>本作的节奏把控非常完美，正作每个小节衔接完整，并且常常在小节最后给出关键线索，让人欲罢不能想立刻开启下一章节的故事。笔者影响很深刻，第一次玩的时候打算从下午花两天打完，结果越玩越上头通宵通关（那时候还没出 DLC 只有正作）。</p><p>值得一提的还有游戏的BGM。音效的变化，是一个剧情类方向的特别之处。随着不同的音效，剧情往往也会走向一个不同的发展阶段，这也是对于剧情类走向的一个情感变化关键，在音效的交叉变化之中，就会有更多的代入感，能够吸引玩家们去深入剧情之中。玩家们在音效的变化中，而体会到剧情的斗转变化，从而更深的沉浸并感受出游戏情节的意义，这是音效在剧情游戏中起到的关键作用，能够加情感变化带到极致，以增添玩家们的代入感和沉浸感。下面放了游戏的 OST 以供鉴赏：</p>    <div id="aplayer-CbzCbezr" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2942950496" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"></div><h4 id="关于穿越的台本剧情"><a href="#关于穿越的台本剧情" class="headerlink" title="关于穿越的台本剧情"></a>关于穿越的台本剧情</h4><p>故事主体还是比较清晰的，在7年前由于某件事而失去了记忆，他拼命拜托父母，终于在春假期间回到了故乡，在与医生和旧友们的相处时间里，他一点点找回属于自己的记忆，不断地经历了一系列变故，朋友的牺牲，医院的阴谋，医生的实验……这些又在一次次的时空回溯中归于零点，当最后一丝记忆被他寻回时，关于医院的一切事实都浮出水面，而他却要面临一次抉择：留存回忆，还是改变过去。好在最后的结局是美好的，春人和葵还是完成了那个约定。</p><p>我也看了网上一些朋友对游戏台本的批评，认为其过于啰嗦和稚嫩，底层的逻辑撑不起整个故事。作为一个 AVG 的轻度玩家个人认为有些言重了，且不谈作者 fumi 是作为独立开发者全栈开发没有相对专业的文案台本，就”稚嫩”来说整个故事大部分都是围绕医院的孩子们，要求过于严谨的台本反而会给玩家一种疏远感，掐掉了没有玩法游戏的生命线：玩家对故事的代入感。</p><p>日式对话也许确实造成了本地化翻译比较难做，但不至于到无法接受的程度。至于故事的底层逻辑，我承认确实后面的设定有些跑远了，但没有明显的逻辑错误。正如科幻作品要落脚于人文主义的关怀，时光跳跃终究只是表面，内核依然是作者对友情和爱情羁绊能够跨越时空的赞扬和歌颂，当葵为了实现七年之后的诺言穿越成千上万次时，谁还会在意为什么一木的时光机不能像机器猫的抽屉一样随意穿越，又有哪位朋友在两人赴约于井时还会较真故事过于牵强而不是为最后的 HE 他们的爱情动容呢。</p><p><img data-src="https://p.qpic.cn/wegame/0/b01ace413057c9a72019a89029ad6fad.png/1000"></p><h4 id="线性流程与开放想象"><a href="#线性流程与开放想象" class="headerlink" title="线性流程与开放想象"></a>线性流程与开放想象</h4><p>严格来讲本作不能算一款游戏，它没有玩法，只有故事。</p><p>在线性的故事流程中，玩家所做的就是操作人物到指定地点交互。但除了前面说到的台本和音乐，玩家之所以拥有很强的代入感我觉得一部分要归功于体素的艺术风格。这里的体素风格只是作者身为独立开发者的无奈之举，但恰恰成为了类似于留白的点睛之笔，让玩家专注于剧情本身而非其他因素喧宾夺主，体素极具抽象的风格留给玩家更多的思考和想象空间，效果甚至要优于一些拥有优秀立绘的 AVG 作品。</p><p>简单的画面并不会影响剧情的跌宕起伏，单一的分支并不会减少玩家对于剧情的理解，反而更能体现其深刻。游戏一层一层的铺垫完美地让玩家跟角色的情感体验在同一个水平面上，或悲或喜，或惊或惧，像是没有屏幕的隔阂，我仿佛也能看到他们的笑容与眼泪，被他们的情感直直击中内心。</p><h3 id="插画鉴赏"><a href="#插画鉴赏" class="headerlink" title="插画鉴赏"></a>插画鉴赏</h3><p>因为游戏本身比较冷门所以同人不是很多，我尽可能的收集了一些自己比较喜欢的作品。</p><p><a href="https://twitter.com/arutarisa/status/1535547996829458432"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/ebyQUH.jpg"></a></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/c8cc3Q.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/35O8fh.jpg"></div></div></div></div><p><a href="https://twitter.com/hinata_ngm/status/926123260772720640"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/HZiD89.jpg"></a></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/6VI2Jt.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/gEE4mR.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/z2HK7C.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/3CUED7.jpg"></div></div></div></div><p><a href="https://twitter.com/imozabu/status/1006743473599287296"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/8YSDNI.jpg"></a></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/bUKzCS.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/LB73eM.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/4Gy313.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/hFeFTj.jpg"></div></div></div></div><p><a href="https://twitter.com/ccccccch1/status/1419655974780952577"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/NDq20J.jpg"></a></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/zR885n.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/0dKNTv.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/WWmnwf.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/amJR7p.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/IWnHaq.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/q1PmBC.jpg"></div></div></div></div><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><p>“为了儿子的初恋而死，一定很帅吧！！！”</p><p>春人与葵梦幻般的初恋，是两个人不离不弃、无条件的相信对方一定会来拯救自己，以及用生命守护儿子初恋的立石，穿越时间也要让手术成功的一木父亲、义无反顾的相信并且帮助朋友的陆、门真、一木，在绝对理想的条件下共同创造出来的究极浪漫。</p><p>无私奉献的亲情、两小无猜的爱情、两肋插刀的友情，无不是让每一个人憧憬不已的感情，这种种感情交汇在一起不是层层叠加而是不断升华，让人越看下去越是陶醉，也越发心碎。</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/YMop7p.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;生活片段故事风格的冒险游戏，包含独特的体素画面与时间跳跃元素。陪伴高中生春人踏上旅程，寻找他有可能在七年前的一次事故中失去的记忆。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Qexo博客后端搭建</title>
    <link href="https://yousazoe.top/archives/e8ba704.html"/>
    <id>https://yousazoe.top/archives/e8ba704.html</id>
    <published>2022-06-12T12:56:16.000Z</published>
    <updated>2022-07-01T09:23:45.747Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/0QiSYR.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在博客自动化的基础上加入 Qexo：一个快速、强大、漂亮的在线 Hexo 编辑器。</p><span id="more"></span><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/wZqdfM.jpg"></p><h3 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h3><ul><li><p>自定义图床上传图片 </p></li><li><p>在线配置编辑</p></li><li><p>在线页面管理 </p></li><li><p>开放 API</p></li><li><p>自动检查更新</p></li><li><p>实验性的在线更新</p></li><li><p>自动填充 date 模板</p></li><li><p>基于时间戳的 abbrlink</p></li></ul><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><h4 id="Vercel-部署"><a href="#Vercel-部署" class="headerlink" title="Vercel 部署"></a>Vercel 部署</h4><h5 id="申请-MongoDB"><a href="#申请-MongoDB" class="headerlink" title="申请 MongoDB"></a>申请 MongoDB</h5><p>注册 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDB</a> 账号并创建免费 MongoDB 数据库，区域一定要选择 AWS / N. Virginia (us-east-1)。</p><p>在 Clusters 页面点击 CONNECT，按步骤设置允许所有 IP 地址的连接，创建数据库用户，并记录数据库连接信息，密码即为你所设置的值。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/XgbEx6.jpg"></p><h5 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h5><p>点击<a href="https://vercel.com/new/clone?repository-url=https://github.com/am-abudu/Qexo">开始部署</a>，部署到 Vercel</p><p>第一次部署会出现报错，原因在于没有设置环境变量（记得多看文档！）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[15:50:22.190] Cloning github.com/Yousazoe/Qexo (Branch: main, Commit: e9f1dc4)</span><br><span class="line">[15:50:22.766] Cloning completed: 575.787ms</span><br><span class="line">[15:50:24.432] Looking up build cache...</span><br><span class="line">[15:50:24.715] Build Cache not found</span><br><span class="line">[15:50:25.105] Running "vercel build"</span><br><span class="line">[15:50:25.540] Vercel CLI 24.2.5-canary.2 build (beta) — https://vercel.com/feedback</span><br><span class="line">[15:50:25.635] ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">[15:50:25.635] │ WARN! Due to `builds` existing in your configuration file, the Build and Development Settings defined in your Project Settings will not apply. Learn More: https://vercel.link/unused-build-settings │</span><br><span class="line">[15:50:25.636] └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">[15:50:26.204] Collecting asgiref==3.4.1</span><br><span class="line">[15:50:26.259]   Downloading asgiref-3.4.1-py3-none-any.whl (25 kB)</span><br><span class="line">[15:50:26.298] Collecting autopep8==1.5.7</span><br><span class="line">[15:50:26.311]   Downloading autopep8-1.5.7-py2.py3-none-any.whl (45 kB)</span><br><span class="line">[15:50:26.323]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 45.0/45.0 kB 4.3 MB/s eta 0:00:00</span><br><span class="line">[15:50:26.363] Collecting beautifulsoup4==4.10.0</span><br><span class="line">[15:50:26.376]   Downloading beautifulsoup4-4.10.0-py3-none-any.whl (97 kB)</span><br><span class="line">[15:50:26.392]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 97.4/97.4 kB 6.2 MB/s eta 0:00:00</span><br><span class="line">[15:50:26.444] Collecting boto==2.49.0</span><br><span class="line">[15:50:26.457]   Downloading boto-2.49.0-py2.py3-none-any.whl (1.4 MB)</span><br><span class="line">[15:50:26.497]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1.4/1.4 MB 36.1 MB/s eta 0:00:00</span><br><span class="line">[15:50:26.965] Collecting boto3==1.20.23</span><br><span class="line">[15:50:26.980]   Downloading boto3-1.20.23-py3-none-any.whl (131 kB)</span><br><span class="line">[15:50:26.988]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 131.8/131.8 kB 26.6 MB/s eta 0:00:00</span><br><span class="line">[15:50:27.537] Collecting botocore==1.23.23</span><br><span class="line">[15:50:27.552]   Downloading botocore-1.23.23-py3-none-any.whl (8.4 MB)</span><br><span class="line">[15:50:27.647]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 8.4/8.4 MB 91.5 MB/s eta 0:00:00</span><br><span class="line">[15:50:27.717] Collecting certifi==2021.5.30</span><br><span class="line">[15:50:27.732]   Downloading certifi-2021.5.30-py2.py3-none-any.whl (145 kB)</span><br><span class="line">[15:50:27.739]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 145.5/145.5 kB 31.7 MB/s eta 0:00:00</span><br><span class="line">[15:50:27.954] Collecting cffi==1.15.0</span><br><span class="line">[15:50:27.968]   Downloading cffi-1.15.0-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.whl (444 kB)</span><br><span class="line">[15:50:27.978]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 444.3/444.3 kB 59.5 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.015] Collecting charset-normalizer==2.0.4</span><br><span class="line">[15:50:28.028]   Downloading charset_normalizer-2.0.4-py3-none-any.whl (36 kB)</span><br><span class="line">[15:50:28.096] Collecting click==8.0.1</span><br><span class="line">[15:50:28.110]   Downloading click-8.0.1-py3-none-any.whl (97 kB)</span><br><span class="line">[15:50:28.116]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 97.4/97.4 kB 22.1 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.150] Collecting colorama==0.4.4</span><br><span class="line">[15:50:28.164]   Downloading colorama-0.4.4-py2.py3-none-any.whl (16 kB)</span><br><span class="line">[15:50:28.201] Collecting Deprecated==1.2.13</span><br><span class="line">[15:50:28.215]   Downloading Deprecated-1.2.13-py2.py3-none-any.whl (9.6 kB)</span><br><span class="line">[15:50:28.242] Collecting dj-database-url==0.5.0</span><br><span class="line">[15:50:28.256]   Downloading dj_database_url-0.5.0-py2.py3-none-any.whl (5.5 kB)</span><br><span class="line">[15:50:28.377] Collecting Django==3.0.5</span><br><span class="line">[15:50:28.391]   Downloading Django-3.0.5-py3-none-any.whl (7.5 MB)</span><br><span class="line">[15:50:28.476]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 7.5/7.5 MB 91.8 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.554] Collecting djongo==1.3.6</span><br><span class="line">[15:50:28.571]   Downloading djongo-1.3.6.tar.gz (331 kB)</span><br><span class="line">[15:50:28.580]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 331.6/331.6 kB 47.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.605]   Preparing metadata (setup.py): started</span><br><span class="line">[15:50:28.777]   Preparing metadata (setup.py): finished with status 'done'</span><br><span class="line">[15:50:28.820] Collecting django-cors-headers==3.10.1</span><br><span class="line">[15:50:28.834]   Downloading django_cors_headers-3.10.1-py3-none-any.whl (12 kB)</span><br><span class="line">[15:50:28.866] Collecting dnspython==1.16.0</span><br><span class="line">[15:50:28.889]   Downloading dnspython-1.16.0-py2.py3-none-any.whl (188 kB)</span><br><span class="line">[15:50:28.897]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 188.4/188.4 kB 37.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.939] Collecting gunicorn==20.1.0</span><br><span class="line">[15:50:28.956]   Downloading gunicorn-20.1.0-py3-none-any.whl (79 kB)</span><br><span class="line">[15:50:28.962]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 79.5/79.5 kB 19.5 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.992] Collecting idna==3.2</span><br><span class="line">[15:50:29.008]   Downloading idna-3.2-py3-none-any.whl (59 kB)</span><br><span class="line">[15:50:29.014]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 59.6/59.6 kB 14.2 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.048] Collecting jmespath==0.10.0</span><br><span class="line">[15:50:29.062]   Downloading jmespath-0.10.0-py2.py3-none-any.whl (24 kB)</span><br><span class="line">[15:50:29.099] Collecting prettytable==2.2.0</span><br><span class="line">[15:50:29.114]   Downloading prettytable-2.2.0-py3-none-any.whl (23 kB)</span><br><span class="line">[15:50:29.177] Collecting pyasn1==0.4.8</span><br><span class="line">[15:50:29.192]   Downloading pyasn1-0.4.8-py2.py3-none-any.whl (77 kB)</span><br><span class="line">[15:50:29.198]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 77.1/77.1 kB 17.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.232] Collecting pycodestyle==2.7.0</span><br><span class="line">[15:50:29.245]   Downloading pycodestyle-2.7.0-py2.py3-none-any.whl (41 kB)</span><br><span class="line">[15:50:29.250]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 41.7/41.7 kB 10.0 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.276] Collecting pycparser==2.21</span><br><span class="line">[15:50:29.292]   Downloading pycparser-2.21-py2.py3-none-any.whl (118 kB)</span><br><span class="line">[15:50:29.298]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 118.7/118.7 kB 25.1 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.342] Collecting PyGithub==1.55</span><br><span class="line">[15:50:29.359]   Downloading PyGithub-1.55-py3-none-any.whl (291 kB)</span><br><span class="line">[15:50:29.369]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 291.7/291.7 kB 41.7 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.414] Collecting PyJWT==2.3.0</span><br><span class="line">[15:50:29.428]   Downloading PyJWT-2.3.0-py3-none-any.whl (16 kB)</span><br><span class="line">[15:50:29.883] Collecting pymongo==3.12.0</span><br><span class="line">[15:50:29.902]   Downloading pymongo-3.12.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (531 kB)</span><br><span class="line">[15:50:29.913]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 531.9/531.9 kB 61.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.970] Collecting PyNaCl==1.4.0</span><br><span class="line">[15:50:29.988]   Downloading PyNaCl-1.4.0-cp35-abi3-manylinux1_x86_64.whl (961 kB)</span><br><span class="line">[15:50:30.003]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 961.1/961.1 kB 77.6 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.065] Collecting python-dateutil==2.8.2</span><br><span class="line">[15:50:30.079]   Downloading python_dateutil-2.8.2-py2.py3-none-any.whl (247 kB)</span><br><span class="line">[15:50:30.087]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 247.7/247.7 kB 48.6 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.111] Collecting python-decouple==3.4</span><br><span class="line">[15:50:30.126]   Downloading python_decouple-3.4-py3-none-any.whl (9.5 kB)</span><br><span class="line">[15:50:30.212] Collecting pytz==2021.1</span><br><span class="line">[15:50:30.233]   Downloading pytz-2021.1-py2.py3-none-any.whl (510 kB)</span><br><span class="line">[15:50:30.244]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 510.8/510.8 kB 58.8 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.307] Collecting requests==2.26.0</span><br><span class="line">[15:50:30.321]   Downloading requests-2.26.0-py2.py3-none-any.whl (62 kB)</span><br><span class="line">[15:50:30.327]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 62.3/62.3 kB 13.6 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.361] Collecting rsa==4.7.2</span><br><span class="line">[15:50:30.376]   Downloading rsa-4.7.2-py3-none-any.whl (34 kB)</span><br><span class="line">[15:50:30.413] Collecting s3transfer==0.5.0</span><br><span class="line">[15:50:30.427]   Downloading s3transfer-0.5.0-py3-none-any.whl (79 kB)</span><br><span class="line">[15:50:30.433]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 79.2/79.2 kB 15.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.464] Collecting six==1.16.0</span><br><span class="line">[15:50:30.480]   Downloading six-1.16.0-py2.py3-none-any.whl (11 kB)</span><br><span class="line">[15:50:30.521] Collecting soupsieve==2.2.1</span><br><span class="line">[15:50:30.534]   Downloading soupsieve-2.2.1-py3-none-any.whl (33 kB)</span><br><span class="line">[15:50:30.567] Collecting sqlparse==0.2.4</span><br><span class="line">[15:50:30.583]   Downloading sqlparse-0.2.4-py2.py3-none-any.whl (38 kB)</span><br><span class="line">[15:50:30.612] Collecting tcping==0.1.1rc1</span><br><span class="line">[15:50:30.626]   Downloading tcping-0.1.1rc1.tar.gz (4.1 kB)</span><br><span class="line">[15:50:30.631]   Preparing metadata (setup.py): started</span><br><span class="line">[15:50:30.800]   Preparing metadata (setup.py): finished with status 'done'</span><br><span class="line">[15:50:30.832] Collecting toml==0.10.2</span><br><span class="line">[15:50:30.845]   Downloading toml-0.10.2-py2.py3-none-any.whl (16 kB)</span><br><span class="line">[15:50:30.964] Collecting ujson==4.1.0</span><br><span class="line">[15:50:30.979]   Downloading ujson-4.1.0-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.whl (179 kB)</span><br><span class="line">[15:50:30.987]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 179.5/179.5 kB 31.3 MB/s eta 0:00:00</span><br><span class="line">[15:50:31.011] Collecting Unipath==1.1</span><br><span class="line">[15:50:31.025]   Downloading Unipath-1.1.tar.gz (30 kB)</span><br><span class="line">[15:50:31.034]   Preparing metadata (setup.py): started</span><br><span class="line">[15:50:31.200]   Preparing metadata (setup.py): finished with status 'done'</span><br><span class="line">[15:50:31.259] Collecting urllib3==1.26.7</span><br><span class="line">[15:50:31.272]   Downloading urllib3-1.26.7-py2.py3-none-any.whl (138 kB)</span><br><span class="line">[15:50:31.280]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 138.8/138.8 kB 27.9 MB/s eta 0:00:00</span><br><span class="line">[15:50:31.313] Collecting wcwidth==0.2.5</span><br><span class="line">[15:50:31.326]   Downloading wcwidth-0.2.5-py2.py3-none-any.whl (30 kB)</span><br><span class="line">[15:50:31.367] Collecting whitenoise==5.3.0</span><br><span class="line">[15:50:31.382]   Downloading whitenoise-5.3.0-py2.py3-none-any.whl (19 kB)</span><br><span class="line">[15:50:31.520] Collecting wrapt==1.13.3</span><br><span class="line">[15:50:31.533]   Downloading wrapt-1.13.3-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (81 kB)</span><br><span class="line">[15:50:31.539]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 81.3/81.3 kB 21.7 MB/s eta 0:00:00</span><br><span class="line">[15:50:31.576] Collecting Markdown==3.3.6</span><br><span class="line">[15:50:31.591]   Downloading Markdown-3.3.6-py3-none-any.whl (97 kB)</span><br><span class="line">[15:50:31.597]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 97.8/97.8 kB 22.1 MB/s eta 0:00:00</span><br><span class="line">[15:50:31.626] Collecting html2text==2020.1.16</span><br><span class="line">[15:50:31.640]   Downloading html2text-2020.1.16-py3-none-any.whl (32 kB)</span><br><span class="line">[15:50:31.987] Requirement already satisfied: setuptools&gt;=3.0 in /usr/local/lib/python3.9/site-packages (from gunicorn==20.1.0-&gt;-r requirements.txt (line 18)) (58.1.0)</span><br><span class="line">[15:50:32.524] Collecting importlib-metadata&gt;=4.4</span><br><span class="line">[15:50:32.538]   Downloading importlib_metadata-4.11.4-py3-none-any.whl (18 kB)</span><br><span class="line">[15:50:32.616] Collecting zipp&gt;=0.5</span><br><span class="line">[15:50:32.633]   Downloading zipp-3.8.0-py3-none-any.whl (5.4 kB)</span><br><span class="line">[15:50:32.691] Using legacy 'setup.py install' for djongo, since package 'wheel' is not installed.</span><br><span class="line">[15:50:32.691] Using legacy 'setup.py install' for tcping, since package 'wheel' is not installed.</span><br><span class="line">[15:50:32.692] Using legacy 'setup.py install' for Unipath, since package 'wheel' is not installed.</span><br><span class="line">[15:50:32.914] Installing collected packages: wcwidth, Unipath, sqlparse, pytz, python-decouple, pyasn1, dj-database-url, certifi, boto, zipp, wrapt, whitenoise, urllib3, ujson, toml, soupsieve, six, rsa, pymongo, PyJWT, pycparser, pycodestyle, prettytable, jmespath, idna, html2text, gunicorn, dnspython, colorama, click, charset-normalizer, asgiref, tcping, requests, python-dateutil, importlib-metadata, Django, Deprecated, cffi, beautifulsoup4, autopep8, PyNaCl, Markdown, djongo, django-cors-headers, botocore, s3transfer, PyGithub, boto3</span><br><span class="line">[15:50:32.961]   Running setup.py install for Unipath: started</span><br><span class="line">[15:50:33.168]   Running setup.py install for Unipath: finished with status 'done'</span><br><span class="line">[15:50:35.005]   Running setup.py install for tcping: started</span><br><span class="line">[15:50:35.215]   Running setup.py install for tcping: finished with status 'done'</span><br><span class="line">[15:50:37.169]   Running setup.py install for djongo: started</span><br><span class="line">[15:50:37.439]   Running setup.py install for djongo: finished with status 'done'</span><br><span class="line">[15:50:38.307] Successfully installed Deprecated-1.2.13 Django-3.0.5 Markdown-3.3.6 PyGithub-1.55 PyJWT-2.3.0 PyNaCl-1.4.0 Unipath-1.1 asgiref-3.4.1 autopep8-1.5.7 beautifulsoup4-4.10.0 boto-2.49.0 boto3-1.20.23 botocore-1.23.23 certifi-2021.5.30 cffi-1.15.0 charset-normalizer-2.0.4 click-8.0.1 colorama-0.4.4 dj-database-url-0.5.0 django-cors-headers-3.10.1 djongo-1.3.6 dnspython-1.16.0 gunicorn-20.1.0 html2text-2020.1.16 idna-3.2 importlib-metadata-4.11.4 jmespath-0.10.0 prettytable-2.2.0 pyasn1-0.4.8 pycodestyle-2.7.0 pycparser-2.21 pymongo-3.12.0 python-dateutil-2.8.2 python-decouple-3.4 pytz-2021.1 requests-2.26.0 rsa-4.7.2 s3transfer-0.5.0 six-1.16.0 soupsieve-2.2.1 sqlparse-0.2.4 tcping-0.1.1rc1 toml-0.10.2 ujson-4.1.0 urllib3-1.26.7 wcwidth-0.2.5 whitenoise-5.3.0 wrapt-1.13.3 zipp-3.8.0</span><br><span class="line">[15:50:38.307] WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv</span><br><span class="line">[15:51:09.211] Traceback (most recent call last):</span><br><span class="line">[15:51:09.211]   File "/vercel/path0/manage.py", line 22, in &lt;module&gt;</span><br><span class="line">[15:51:09.211]     main()</span><br><span class="line">[15:51:09.212]   File "/vercel/path0/manage.py", line 18, in main</span><br><span class="line">[15:51:09.212]     execute_from_command_line(sys.argv)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py", line 401, in execute_from_command_line</span><br><span class="line">[15:51:09.212]     utility.execute()</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py", line 395, in execute</span><br><span class="line">[15:51:09.212]     self.fetch_command(subcommand).run_from_argv(self.argv)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 328, in run_from_argv</span><br><span class="line">[15:51:09.212]     self.execute(*args, **cmd_options)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 369, in execute</span><br><span class="line">[15:51:09.212]     output = self.handle(*args, **options)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 83, in wrapped</span><br><span class="line">[15:51:09.212]     res = handle_func(*args, **kwargs)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/commands/makemigrations.py", line 101, in handle</span><br><span class="line">[15:51:09.212]     loader.check_consistent_history(connection)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/loader.py", line 283, in check_consistent_history</span><br><span class="line">[15:51:09.212]     applied = recorder.applied_migrations()</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/recorder.py", line 76, in applied_migrations</span><br><span class="line">[15:51:09.213]     if self.has_table():</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/recorder.py", line 56, in has_table</span><br><span class="line">[15:51:09.213]     return self.Migration._meta.db_table in self.connection.introspection.table_names(self.connection.cursor())</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/django/db/backends/base/introspection.py", line 48, in table_names</span><br><span class="line">[15:51:09.213]     return get_names(cursor)</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/django/db/backends/base/introspection.py", line 43, in get_names</span><br><span class="line">[15:51:09.213]     return sorted(ti.name for ti in self.get_table_list(cursor)</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/djongo/introspection.py", line 47, in get_table_list</span><br><span class="line">[15:51:09.213]     for c in cursor.db_conn.list_collection_names()</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/pymongo/database.py", line 880, in list_collection_names</span><br><span class="line">[15:51:09.213]     for result in self.list_collections(session=session, **kwargs)]</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/pymongo/database.py", line 842, in list_collections</span><br><span class="line">[15:51:09.213]     return self.__client._retryable_read(</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/pymongo/mongo_client.py", line 1514, in _retryable_read</span><br><span class="line">[15:51:09.214]     server = self._select_server(</span><br><span class="line">[15:51:09.214]   File "/usr/local/lib/python3.9/site-packages/pymongo/mongo_client.py", line 1346, in _select_server</span><br><span class="line">[15:51:09.214]     server = topology.select_server(server_selector)</span><br><span class="line">[15:51:09.214]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 244, in select_server</span><br><span class="line">[15:51:09.214]     return random.choice(self.select_servers(selector,</span><br><span class="line">[15:51:09.214]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 202, in select_servers</span><br><span class="line">[15:51:09.214]     server_descriptions = self._select_servers_loop(</span><br><span class="line">[15:51:09.214]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 218, in _select_servers_loop</span><br><span class="line">[15:51:09.214]     raise ServerSelectionTimeoutError(</span><br><span class="line">[15:51:09.214] pymongo.errors.ServerSelectionTimeoutError: connection closed,connection closed,connection closed, Timeout: 30s, Topology Description: &lt;TopologyDescription id: 62971a4e82b1c0159350eafa, topology_type: ReplicaSetNoPrimary, servers: [&lt;ServerDescription ('cluster0-shard-00-00.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;, &lt;ServerDescription ('cluster0-shard-00-01.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;, &lt;ServerDescription ('cluster0-shard-00-02.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;]&gt;</span><br><span class="line">[15:51:40.368] Traceback (most recent call last):</span><br><span class="line">[15:51:40.368]   File "/vercel/path0/manage.py", line 22, in &lt;module&gt;</span><br><span class="line">[15:51:40.368]     main()</span><br><span class="line">[15:51:40.368]   File "/vercel/path0/manage.py", line 18, in main</span><br><span class="line">[15:51:40.368]     execute_from_command_line(sys.argv)</span><br><span class="line">[15:51:40.368]   File "/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py", line 401, in execute_from_command_line</span><br><span class="line">[15:51:40.368]     utility.execute()</span><br><span class="line">[15:51:40.368]   File "/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py", line 395, in execute</span><br><span class="line">[15:51:40.369]     self.fetch_command(subcommand).run_from_argv(self.argv)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 328, in run_from_argv</span><br><span class="line">[15:51:40.369]     self.execute(*args, **cmd_options)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 369, in execute</span><br><span class="line">[15:51:40.369]     output = self.handle(*args, **options)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 83, in wrapped</span><br><span class="line">[15:51:40.369]     res = handle_func(*args, **kwargs)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/core/management/commands/migrate.py", line 86, in handle</span><br><span class="line">[15:51:40.369]     executor = MigrationExecutor(connection, self.migration_progress_callback)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/executor.py", line 18, in __init__</span><br><span class="line">[15:51:40.369]     self.loader = MigrationLoader(self.connection)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/loader.py", line 49, in __init__</span><br><span class="line">[15:51:40.369]     self.build_graph()</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/loader.py", line 212, in build_graph</span><br><span class="line">[15:51:40.370]     self.applied_migrations = recorder.applied_migrations()</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/recorder.py", line 76, in applied_migrations</span><br><span class="line">[15:51:40.370]     if self.has_table():</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/recorder.py", line 56, in has_table</span><br><span class="line">[15:51:40.370]     return self.Migration._meta.db_table in self.connection.introspection.table_names(self.connection.cursor())</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/backends/base/introspection.py", line 48, in table_names</span><br><span class="line">[15:51:40.370]     return get_names(cursor)</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/backends/base/introspection.py", line 43, in get_names</span><br><span class="line">[15:51:40.370]     return sorted(ti.name for ti in self.get_table_list(cursor)</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/djongo/introspection.py", line 47, in get_table_list</span><br><span class="line">[15:51:40.370]     for c in cursor.db_conn.list_collection_names()</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/pymongo/database.py", line 880, in list_collection_names</span><br><span class="line">[15:51:40.370]     for result in self.list_collections(session=session, **kwargs)]</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/pymongo/database.py", line 842, in list_collections</span><br><span class="line">[15:51:40.371]     return self.__client._retryable_read(</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/mongo_client.py", line 1514, in _retryable_read</span><br><span class="line">[15:51:40.371]     server = self._select_server(</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/mongo_client.py", line 1346, in _select_server</span><br><span class="line">[15:51:40.371]     server = topology.select_server(server_selector)</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 244, in select_server</span><br><span class="line">[15:51:40.371]     return random.choice(self.select_servers(selector,</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 202, in select_servers</span><br><span class="line">[15:51:40.371]     server_descriptions = self._select_servers_loop(</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 218, in _select_servers_loop</span><br><span class="line">[15:51:40.371]     raise ServerSelectionTimeoutError(</span><br><span class="line">[15:51:40.372] pymongo.errors.ServerSelectionTimeoutError: connection closed,connection closed,connection closed, Timeout: 30s, Topology Description: &lt;TopologyDescription id: 62971a6e87ecd8382d3ed4fa, topology_type: ReplicaSetNoPrimary, servers: [&lt;ServerDescription ('cluster0-shard-00-00.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;, &lt;ServerDescription ('cluster0-shard-00-01.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;, &lt;ServerDescription ('cluster0-shard-00-02.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;]&gt;</span><br><span class="line">[15:51:40.836] Error! Command "./migrate.sh" exited with 1</span><br><span class="line">[15:51:40.936] Error: Command "vercel build" exited with 1</span><br></pre></td></tr></tbody></table></figure><p>重新进入项目，在项目设置界面添加环境变量 Environment Variables：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/VUdwLM.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/QDBMOe.png"></p><p>在 Deployments 点击 Redeploy 开始部署，若没有 Error 信息即可打开域名进入初始化引导。</p><h4 id="友链管理"><a href="#友链管理" class="headerlink" title="友链管理"></a>友链管理</h4><p>这个教程将帮助你在几分钟内利用 Qexo 为博客接入友链系统。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/uQ7bP9.jpg"></p><h5 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h5><p>友链功能要求 Qexo &gt;= 1.5.0 且用户浏览器必须支持文件上传。</p><h5 id="添加友链"><a href="#添加友链" class="headerlink" title="添加友链"></a>添加友链</h5><ol><li><p>在 Qexo 侧边栏找到 <strong>友链</strong> 点击进入</p></li><li><p>点击右上角 <strong>新增友链</strong> 输入站点名称、链接等数据，其中链接及图片链接<strong>必须包含http协议头</strong>。</p></li><li><p>点击 <strong>确定</strong> 按键保存友链数据</p></li></ol><h5 id="接入博客"><a href="#接入博客" class="headerlink" title="接入博客"></a>接入博客</h5><ol><li>在根目录打开命令行，输入命令创建页面：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page links</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><p>打开 source/links/index.md 修改页面配置</p></li><li><p>在页面内引入 Qexo-Friends 将其中的 <code>${SITE}</code> 改为你的 Qexo 链接，例如 <a href="https://admin.mysite.com/">https://admin.mysite.com</a></p></li></ol><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"qexo-friends"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/qexo-static@1.1.3/hexo/friends/friends.css"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/qexo-static@1.1.3/hexo/friends/friends.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">loadQexoFriends</span>(<span class="string">"qexo-friends"</span>, <span class="string">"${SITE}"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>将博客推送至你的 Github 仓库</li></ol><h5 id="友链申请"><a href="#友链申请" class="headerlink" title="友链申请"></a>友链申请</h5><p>由 @Fgaoxing 适配的友链申请 API：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"friends-api"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/gh/Fgaoxing/blog-cdn@main/source/js/friends-api.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">qexo_friend_api</span>(<span class="string">"friends-api"</span>,<span class="string">"Qexo域名"</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="Github-配置"><a href="#Github-配置" class="headerlink" title="Github 配置"></a>Github 配置</h4><p>如果部署中遇到问题，可以访问 <a href="https://hexoplusplus.cronfly.workers.dev/?step=start">HPP校验助手</a> 自检配置，若确认无误，可检查仓库内是否有已经发布的文章</p><h5 id="Github-仓库"><a href="#Github-仓库" class="headerlink" title="Github 仓库"></a>Github 仓库</h5><p>您 Hexo 自动化部署所在的仓库：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">username/repo</span><br></pre></td></tr></tbody></table></figure><h5 id="项目分支"><a href="#项目分支" class="headerlink" title="项目分支"></a>项目分支</h5><p>您 Hexo 自动化部署所在仓库的分支：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">master</span><br></pre></td></tr></tbody></table></figure><h5 id="Github-密钥"><a href="#Github-密钥" class="headerlink" title="Github 密钥"></a>Github 密钥</h5><p>于 <a href="">Github 设置</a> 生成的 Token 需要 Repo 下的至少读取和写入权限，不建议给出所有权限：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">wrq_P8sYPlYA9fjMlOPEYSKA84xxxxxxxxxxxxxx</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/OBqvrl.png"></p><h5 id="仓库路径"><a href="#仓库路径" class="headerlink" title="仓库路径"></a>仓库路径</h5><p>您 Hexo 自动化部署所在仓库的路径 若为根目录请留空：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">path/</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义图床配置"><a href="#自定义图床配置" class="headerlink" title="自定义图床配置"></a>自定义图床配置</h4><p>Qexo 提供了强大的自定义图床功能，在配置完成图床设置后即可在文章/页面编辑界面上传图片。</p><h5 id="API-地址"><a href="#API-地址" class="headerlink" title="API 地址"></a>API 地址</h5><p>图床图片上传的 API：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://7bu.top/api/upload</span><br></pre></td></tr></tbody></table></figure><h5 id="POST-参数名"><a href="#POST-参数名" class="headerlink" title="POST 参数名"></a>POST 参数名</h5><p>图床图片上传 API 参数中图片文件的参数名：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">image</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/iRuSc1.jpg"></p><h5 id="JSON-路径"><a href="#JSON-路径" class="headerlink" title="JSON 路径"></a>JSON 路径</h5><p>图床 API 返回数据中图片 URL 所在的路径，若为整个返回值请留空。示例：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/bpYkLI.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">data.url</span><br></pre></td></tr></tbody></table></figure><h5 id="自定义请求头"><a href="#自定义请求头" class="headerlink" title="自定义请求头"></a>自定义请求头</h5><p>POST 请求时附带的请求头，需要标准 JSON 格式，若不需要请留空。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{"key":"value"}</span><br></pre></td></tr></tbody></table></figure><h5 id="自定义-BODY"><a href="#自定义-BODY" class="headerlink" title="自定义 BODY"></a>自定义 BODY</h5><p>POST 请求时额外的请求主体，需要标准 JSON 格式，若不需要请留空。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{"key":"value"}</span><br></pre></td></tr></tbody></table></figure><h5 id="自定义前缀"><a href="#自定义前缀" class="headerlink" title="自定义前缀"></a>自定义前缀</h5><p>返回 URL 所需要添加的前缀，若不需要请留空。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">some_text_or_url</span><br></pre></td></tr></tbody></table></figure><h4 id="Vercel-相关配置"><a href="#Vercel-相关配置" class="headerlink" title="Vercel 相关配置"></a>Vercel 相关配置</h4><h5 id="VERCEL-TOKEN"><a href="#VERCEL-TOKEN" class="headerlink" title="VERCEL_TOKEN"></a>VERCEL_TOKEN</h5><p>您的 Vercel 账户密钥 在 <a href="https://vercel.com/account/tokens">此处</a> 生成：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/MsSR1F.png"></p><h5 id="PROJECT-ID"><a href="#PROJECT-ID" class="headerlink" title="PROJECT_ID"></a>PROJECT_ID</h5><p>您 Qexo 部署所在项目的 ID 位于 <code>Project Settings -&gt; General -&gt; Project ID</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">prj_xxxxxxx</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/Fxj1Vw.png"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="什么是-API-密钥"><a href="#什么是-API-密钥" class="headerlink" title="什么是 API 密钥"></a>什么是 API 密钥</h4><p>在您完成初始化之后可在设置界面修改/创建 API 密钥，用于 Webhook 中的身份验证。若留空系统会随机生成一个 API 密钥。</p><h4 id="Webhook-是什么"><a href="#Webhook-是什么" class="headerlink" title="Webhook 是什么"></a>Webhook 是什么</h4><p>Qexo 中的 Webhook 指 /api/webhook 用于自动化操作，目前可用于自动清除缓存。</p><h4 id="安装后出现-504-Time-out"><a href="#安装后出现-504-Time-out" class="headerlink" title="安装后出现 504 Time out"></a>安装后出现 504 Time out</h4><ol><li><p>您的数据库没有正确配置或没有允许所有 IP 白名单访问，可在 MongoDB 控制台进行修改，修改完成后一定要重新部署。</p></li><li><p>删除并重建数据库，注意区域一定要选择 AWS / N. Virginia (us-east-1)。</p></li></ol><h4 id="安装-x2F-更新后出现-5xx-错误"><a href="#安装-x2F-更新后出现-5xx-错误" class="headerlink" title="安装/更新后出现 5xx 错误"></a>安装/更新后出现 5xx 错误</h4><p>Qexo 每个 Release 都经过 Dev 分支的测试，一般情况下不会出现较大问题，如果你遇到了500等错误，请尝试以下步骤：</p><ol><li><p>检查数据库配置</p></li><li><p>清除浏览器缓存</p></li><li><p>在高级设置中点击“修复”按钮</p></li><li><p>若无法登录请使用API: yoursite.com/pub/fix?token={$APIKEY}</p></li><li><p>保留数据库配置的环境变量并重新 Fork 仓库部署</p></li><li><p>重新部署整个程序</p></li><li><p>尝试 Dev 分支</p></li></ol><h4 id="AssertionError-“xxx-object-…-its-id-attribute-is-set-to-None-”"><a href="#AssertionError-“xxx-object-…-its-id-attribute-is-set-to-None-”" class="headerlink" title="AssertionError(“xxx object … its id attribute is set to None.”)"></a>AssertionError(“xxx object … its id attribute is set to None.”)</h4><p>请检查你是否曾使用过 0.01 或 0.1 版本，这两个版本有严重问题，请重新创建数据库并部署。</p><h4 id="Github-配置校验错误"><a href="#Github-配置校验错误" class="headerlink" title="Github 配置校验错误"></a>Github 配置校验错误</h4><p>如果配置中遇到问题，可以访问 HPP校验助手 自检配置，若确认无误，可检查仓库内是否有已经发布的文章。</p><p>注意：Github 仓库一定为您 Hexo <strong>自动化部署</strong> 所在的仓库。</p><h4 id="Vercel-用量问题"><a href="#Vercel-用量问题" class="headerlink" title="Vercel 用量问题"></a>Vercel 用量问题</h4><p>Vercel 的无服务器函数用量对于 Qexo 来说是充裕的，但这依然抵挡不住有心之人的攻击行为，所以要保护好自己后台地址，不过好在 Vercel 不会随意扣费，所以在资源用完之后并不会产生费用，若依然不放心可以考虑部署在自己的服务器上。</p><h4 id="在线更新失败了"><a href="#在线更新失败了" class="headerlink" title="在线更新失败了"></a>在线更新失败了</h4><p>检查高级设置中的 <code>VERCEL_TOKEN</code> 和 <code>PROJECT_ID</code> 是否正确为 Qexo 的部署项目。</p><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>如果还有问题，可以发 <a href="https://github.com/Qexo/Qexo/issues">issue</a> 或加入 <a href="https://jq.qq.com/?_wv=1027&amp;k=rAcnhzqK">HexoPlusPlus交流群</a> 询问。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/rgtSe5.png"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/0QiSYR.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在博客自动化的基础上加入 Qexo：一个快速、强大、漂亮的在线 Hexo 编辑器。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建 (Blog Building)" scheme="https://yousazoe.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Blog-Building/"/>
    
    
    <category term="Blog" scheme="https://yousazoe.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Github Action自动化部署Hexo</title>
    <link href="https://yousazoe.top/archives/ae288086.html"/>
    <id>https://yousazoe.top/archives/ae288086.html</id>
    <published>2022-06-02T10:23:01.000Z</published>
    <updated>2022-07-01T09:23:45.747Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/hrLdxQ.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>为了方便可以使用 GitHub Actions 实现博客自动发布，将静态博客页面部署到多个服务器上，比如 GitHub Pages，Gitee pages 以及云服务器上。本文介绍使用 GitHub Actions 实现将 Hexo 博客自动编译并发布到 GitHub Pages 上。</p><span id="more"></span><h3 id="SSH-秘钥"><a href="#SSH-秘钥" class="headerlink" title="SSH 秘钥"></a>SSH 秘钥</h3><p>生成秘钥用于仓库间的推送：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -f hexo-deploy-key -t rsa -C "youremail@something.com"</span><br></pre></td></tr></tbody></table></figure><p>以上命令会在当前路径下生成：秘钥 <code>hexo-deploy-key</code> 和公钥 <code>hexo-deploy-key.pub</code>，然后分别添加到对应的文件中。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/uyWREQ.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/lWgKmq.png"></p><ul><li><p>页面文件仓库（即 <a href="https://yousazoe.top/">yousazoe.github.io</a>）: 在 <code>Settings &gt; Deploy keys</code> 中添加 <code>Deploy key</code>，内容为 <code>hexo-deploy-key.pub</code> 文件内容，同时勾选 <code>Allow write access</code> 选项</p></li><li><p>博客源文件库：在 <code>Settings &gt; Secrets</code> 中添加一个 Secret，名称为 <code>DEPLOY_KEY</code>，内容为 <code>hexo-deploy-key</code> 文件内容。后续在 Workflow 中通过名称 <code>DEPLOY_KEY</code> 使用这个密钥</p></li></ul><h3 id="Workflow-配置"><a href="#Workflow-配置" class="headerlink" title="Workflow 配置"></a>Workflow 配置</h3><p>在博客源文件库中新建文件 <code>.github/workflows/deploy.yml</code>，配置内容如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># This is a basic workflow to help you get started with Actions</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Blog</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Controls when the workflow will run</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># Triggers the workflow on push or pull request events but only for the main branch</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Allows you to run this workflow manually from the Actions tab</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># This workflow contains a single job called "build"</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="comment"># The type of runner that the job will run on</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Steps represent a sequence of tasks that will be executed as part of the job</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Runs a set of commands using the runners shell</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">'14'</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Npm</span> <span class="string">Install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Key</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_KEY:</span> <span class="string">${{</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">}}</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh</span></span><br><span class="line"><span class="string">          echo "$DEPLOY_KEY" &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.email "yourname@mail.com"</span></span><br><span class="line"><span class="string">          git config --global user.name "yourname"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate</span></span><br><span class="line"><span class="string">          gulp</span></span><br><span class="line"><span class="string">          hexo deploy</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Webhook-部署"><a href="#Webhook-部署" class="headerlink" title="Webhook 部署"></a>Webhook 部署</h3><ol><li><strong>Copy the Deploy Webhook URL.</strong></li></ol><p>You can find your site’s deploy Webhook under the “Settings” tab.</p><p><img data-src="https://www.21cloudbox.com/assets/deploy-webhook.png"></p><ol start="2"><li><strong>Paste the Deploy Webhook URL on “Payload URL” in your Github</strong></li></ol><p>Github &gt; Settings &gt; Webhooks &gt; “Payload URL”</p><p><img data-src="https://www.21cloudbox.com/assets/automatic-github-deployment-21yunbox.png"></p><ol start="3"><li><strong>Click “Add webhook”</strong></li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p><a href="https://printempw.github.io/use-github-actions-to-deploy-hexo-blog">使用GitHub Actions自动部署Hexo博客</a></p></li><li><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions">利用Github Actions自动部署Hexo博客</a></p></li><li><p><a href="https://frostming.com/2020/04-26/github-actions-deploy">使用GitHub Actions实现博客自动化部署</a></p></li><li><p><a href="https://blog.yrpang.com/posts/43978">使用shell脚本判断git状态</a></p></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/hrLdxQ.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;为了方便可以使用 GitHub Actions 实现博客自动发布，将静态博客页面部署到多个服务器上，比如 GitHub Pages，Gitee pages 以及云服务器上。本文介绍使用 GitHub Actions 实现将 Hexo 博客自动编译并发布到 GitHub Pages 上。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建 (Blog Building)" scheme="https://yousazoe.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Blog-Building/"/>
    
    
    <category term="Blog" scheme="https://yousazoe.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101-SUM</title>
    <link href="https://yousazoe.top/archives/692c2b09.html"/>
    <id>https://yousazoe.top/archives/692c2b09.html</id>
    <published>2022-05-30T03:55:26.000Z</published>
    <updated>2022-07-01T09:23:45.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/FT8rVmPVsAM_EJI.jpeg"></p><div align="center">  <font size="3">    <i>      <a href="https://twitter.com/GhostDiegog/status/1530990215912796161">Twitter@GhostDiegog</a>    </i>  </font></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近打算重新温习一下 GAMES101 现代计算机图形学入门的课程内容，做一个总结与梳理比较重要的内容以便快速复习。</p><span id="more"></span><h3 id="Review-of-Linear-Algebra"><a href="#Review-of-Linear-Algebra" class="headerlink" title="Review of Linear Algebra"></a>Review of Linear Algebra</h3><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0008.jpg"></p><h5 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0009.jpg"></p><h5 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0010.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0011.jpg"></p><h5 id="Multiplication"><a href="#Multiplication" class="headerlink" title="Multiplication"></a>Multiplication</h5><h6 id="Dot-Product"><a href="#Dot-Product" class="headerlink" title="Dot Product"></a>Dot Product</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0013.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0014.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0015.jpg"></p><br><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lec02_page-0019.jpg"></p><p>通过判断点乘的正负判断两个方向向量有多么接近：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">dotProduct &gt; <span class="number">0</span> ? forward: backward;</span><br></pre></td></tr></tbody></table></figure><h6 id="Cross-Product"><a href="#Cross-Product" class="headerlink" title="Cross Product"></a>Cross Product</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0021.jpg"></p><p>叉乘向量的方向用右手螺旋定则判断，类似于大拇指点赞。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0022.jpg"></p><p>叉乘没有交换律，但分配律和结合律依然存在。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0023.jpg"></p><br><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0024.jpg"></p><p>叉积有两个作用：</p><ul><li><p>判定左右（不经过逆/顺时针旋转保持方向一致）</p></li><li><p>判定内外（叉乘符号保持一致）</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0025.jpg"></p><h4 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h4><h5 id="Matrix-Matrix-Multiplication"><a href="#Matrix-Matrix-Multiplication" class="headerlink" title="Matrix-Matrix Multiplication"></a>Matrix-Matrix Multiplication</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0033.jpg"></p><p>矩阵间的乘法规则为”前行乘后列”，算第几行第几列就去找左矩阵第几行和右矩阵第几列。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0034.jpg"></p><p>矩阵间的乘法不满足交换律，但满足结合律和分配律。</p><h5 id="Transpose"><a href="#Transpose" class="headerlink" title="Transpose"></a>Transpose</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0036.jpg"></p><p>矩阵转置就是把行列互换。</p><h5 id="Identity-Matrix"><a href="#Identity-Matrix" class="headerlink" title="Identity Matrix"></a>Identity Matrix</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_02_page-0037.jpg"></p><p>只有对角线上有非零元素的矩阵被称为对角阵，单位矩阵则都为 1。矩阵与矩阵的逆相乘得到单位矩阵。</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><h4 id="2D-Transformation"><a href="#2D-Transformation" class="headerlink" title="2D Transformation"></a>2D Transformation</h4><h5 id="Scale-Matrix"><a href="#Scale-Matrix" class="headerlink" title="Scale Matrix"></a>Scale Matrix</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0014.jpg"></p><h5 id="Reflection-Matrix"><a href="#Reflection-Matrix" class="headerlink" title="Reflection Matrix"></a>Reflection Matrix</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0015.jpg"></p><h5 id="Shear-Matrix"><a href="#Shear-Matrix" class="headerlink" title="Shear Matrix"></a>Shear Matrix</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0016.jpg"></p><p>水平方向的切变。</p><h5 id="Rotate-Matrix"><a href="#Rotate-Matrix" class="headerlink" title="Rotate Matrix"></a>Rotate Matrix</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0018.jpg"></p><p>旋转默认原点为中心逆时针方向，推导过程如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210329121348717.png"></p><h5 id="Homogenous-Coordinates"><a href="#Homogenous-Coordinates" class="headerlink" title="Homogenous Coordinates"></a>Homogenous Coordinates</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0025.jpg"></p><p>齐次坐标服务于平移变换，把二维的点增加一个纬度变成齐次坐标，所有变换形式上简化为一个矩阵乘以一个向量。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0026.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0027.jpg"></p><h5 id="2D-Transformation-1"><a href="#2D-Transformation-1" class="headerlink" title="2D Transformation"></a>2D Transformation</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0028.jpg"></p><h5 id="Inverse-Transformation"><a href="#Inverse-Transformation" class="headerlink" title="Inverse Transformation"></a>Inverse Transformation</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0029.jpg"></p><h5 id="Composing-Transforms"><a href="#Composing-Transforms" class="headerlink" title="Composing Transforms"></a>Composing Transforms</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0034.jpg"></p><p>变换顺序从右到左非常重要，可以视作交换律的不可用。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_03_page-0037.jpg"></p><p>旋转时的中心点始终为原点，所以保证旋转时物体在原点，之后再做其他的变换操作。</p><h4 id="3D-Transform"><a href="#3D-Transform" class="headerlink" title="3D Transform"></a>3D Transform</h4><h5 id="Scale-amp-Translation"><a href="#Scale-amp-Translation" class="headerlink" title="Scale &amp; Translation"></a>Scale &amp; Translation</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0007.jpg"></p><h5 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0008.jpg"></p><p>$Z x X = Y$</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0009.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0010.jpg"></p><p>推导过程如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210330074955431.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210330075031617.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20210330075055898.png"></p><iframe src="//player.bilibili.com/player.html?aid=511277281&amp;bvid=BV1Eu411r7GC&amp;cid=711633371&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="Viewing-Transform"><a href="#Viewing-Transform" class="headerlink" title="Viewing Transform"></a>Viewing Transform</h4><h5 id="View-x2F-Camera-Transform"><a href="#View-x2F-Camera-Transform" class="headerlink" title="View/Camera Transform"></a>View/Camera Transform</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0012.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0014.jpg"></p><p>相机身处原点，法向为 Y，朝向为 -Z 的标准位置。</p><h6 id="Model-Transform"><a href="#Model-Transform" class="headerlink" title="Model Transform"></a>Model Transform</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0015.jpg"></p><p>视图矩阵需要先平移至原点，然后一次旋转到标准轴。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0016.jpg"></p><p>齐次坐标先做平移后做旋转。</p><p>虽然任意轴旋转到标准轴很难推导，但是这个逆过程标准轴旋转到任意方向还算简单，又因为旋转矩阵的逆矩阵与转置矩阵相等最后可以推导出来。</p><h5 id="Projection-Transform"><a href="#Projection-Transform" class="headerlink" title="Projection Transform"></a>Projection Transform</h5><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0020.jpg"></p><p>透视投影(P)会有近大远小的现象，而正交投影(O)没有。</p><h6 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection"></a>Orthographic Projection</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0021.jpg"></p><ul><li>相机从原点看向 -Z 方向，头顶朝向 Y 方向</li><li>扔掉 Z 轴</li><li>缩放变换 X、Y 至 [-1, 1]</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0022.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0024.jpg"></p><p>首先把立方体中心从负方向移到原点，然后再做一个缩放把长度变为 2。</p><h6 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0029.jpg"></p><p>透视投影可以拆分为两步：首先将 Frustum 挤成 Cuboid；然后直接用正交投影。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0030.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0031.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0032.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_04_page-0035.jpg"></p><p>至此我们终于推导出投影-正交矩阵。</p><h4 id="Viewport-Transform"><a href="#Viewport-Transform" class="headerlink" title="Viewport Transform"></a>Viewport Transform</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/GAMES101_Lecture_05_page-0005.jpg"></p><h3 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h3><h3 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h3><h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><h3 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h3></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/FT8rVmPVsAM_EJI.jpeg&quot;&gt;&lt;/p&gt;
&lt;div align=center&gt;
  &lt;font size=&quot;3&quot;&gt;
    &lt;i&gt;
      &lt;a href=&quot;https://twitter.com/GhostDiegog/status/1530990215912796161&quot;&gt;Twitter@GhostDiegog&lt;/a&gt;
    &lt;/i&gt;
  &lt;/font&gt;
&lt;/div&gt;

&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;最近打算重新温习一下 GAMES101 现代计算机图形学入门的课程内容，做一个总结与梳理比较重要的内容以便快速复习。&lt;/p&gt;</summary>
    
    
    
    <category term="现代图形学入门 (GAMES101-Introduction to Computer Graphics)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-GAMES101-Introduction-to-Computer-Graphics/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>悲惨歌喉下的隐喻--Love, Death &amp; Robots Season 3</title>
    <link href="https://yousazoe.top/archives/3a2065a8.html"/>
    <id>https://yousazoe.top/archives/3a2065a8.html</id>
    <published>2022-05-23T12:27:55.000Z</published>
    <updated>2022-07-01T09:23:45.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10.webp"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>艾美奖获奖动画选集《爱、死亡 &amp; 机器人》第三部回归，恐怖、想象力和美在新剧集中完美融合，从揭示古老的邪恶力量到喜剧般的末日，剧集以标志性的巧思和创造性的视觉效果，为观众带来令人震惊的奇幻、恐怖和科幻短篇故事。</p><span id="more"></span><h3 id="三个机器人：退场策略"><a href="#三个机器人：退场策略" class="headerlink" title="三个机器人：退场策略"></a>三个机器人：退场策略</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-1.jpeg"></p><h4 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h4><p>延续第一季《三个机器人》，三个机器人来到地球，深入调查末日后人类的情形，以洞悉初生机器人文化了解生存之道，可以确认的是他们眼前的地方人类都死亡，但透过满是枪枝的迹象，推理很多人类以为摆脱政府补助的医疗服务，有足够的子弹和鹿肉干就能建立乌托邦社会，人类将鹿灭杀殆尽，比猫大的动物无一幸免，然后突袭彼此此营地，他们瞄准窗外，不是因为鹿来寻仇，而是彼此杀戮。但利用这种野蛮方式而建立起的乌托邦只有穷人，因为缺乏经济和社会优势的人选择比较少，有钱人则是有复杂的生存策略，但尽管创造有主权的国度，还是免不了死亡，当中最主要是因为这里住的科技富豪被机器人给起义。</p><p>至于领袖们则是躲在深山堡垒等待外面混乱过去，虽然有系统维持农业食物，但因为被一种霉菌破坏，所以没食物后开始实施所谓的「极端主义」然后投票下个要被吃的人。例外还有 0.01% 的有钱人，他们有钱到可以直奔火星，宁愿花钱去火星也不要离在地球拯救家园，当中三个机器人他们发现一个发射的火星，很疑惑到底是谁移民火星，事实上人类没有抵达火星，反倒是一批猫殖民了火星。</p><h4 id="影评"><a href="#影评" class="headerlink" title="影评"></a>影评</h4><p>人类的灭绝是自己而来？从机器人的分析可以知道人类想要逃离政府束缚而建立的乌托邦，最主要是分成有钱人和穷人不同社会阶级的生存策略，但是我们从剧情中也能知道，穷人和有钱人的策略差异，<strong>带来的事实上都是相同的结果</strong>。我觉得地球会有文明末日是人类自己造成的，食物总有一天会殆尽，不管是鹿肉还是海上的海鲜，都会阻碍他们生存（就例如海洋过度捕捞和食物链塑胶微粒，都是在讽刺人类自食其果和人口过剩）。</p><p>这回归到地球文明灭绝而来？我想就是人类从开始在地球上生存而渐渐累积来的，直到最后一刻渴望求生的过程中，仍然没有改变，然后就被科技给起义灭绝，因而让机器人文化崛起，这其实就是象征着人类对机器人的「奴隶」，如果人类对他们的机器人奴隶表现出善意和同情，那么机器人也许可以在帮助人类度过世界末日的过程中发挥作用。</p><p>本集中利用四种四种不一样社会阶级的人在末日时还是只能以钱和地位来决定谁最有资格留下来的差异让观众知道，不管是哪一种阶级的人，下场都一样，因为在逃命的过程争中，人类不会互助，「菁英并不同情他们的烦恼」，如果这群超级有钱的人可以直奔火星，为什么不要把手上资源留下来拯救地球？<strong>这就是象征着贪婪和自私，不将手上资源去帮助别人</strong>。然而，在最后我们看到移民火星的是穿着太空衣的猫，根本不是人类，这也证实人类为了生存而付出的努力，结果都是徒劳的。</p><p>从第一季的《三个机器人》到第三季之间，因为在第一集中向机器人展示自己的同一只说话的猫现在正在火星上喝冰牛奶，这些猫仍在使用人形太空服，这意味着它们希望对自己的真实影响保密（毕竟它都可以先开头罩喝牛奶了，绝不是为了氧气）。因此，看起来猫透过伪装成人类多年来控制了地球上的一些重要资源，猫科动物很有可能利用世界末日的混乱来巩固自己的力量，并最终成为唯一在其他文明消亡时离开地球的生物，也意味着人类太傲慢把自己当成最优势的物种。</p><h3 id="差劲旅行"><a href="#差劲旅行" class="headerlink" title="差劲旅行"></a>差劲旅行</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-2.jpeg"></p><h4 id="剧情-1"><a href="#剧情-1" class="headerlink" title="剧情"></a>剧情</h4><p>从前，在远方的异域海洋，水手会猎捕大杰布鲨，危险航程中船只经常消失，有人说这样的船只是遇上「差劲旅行」，一艘船只在海上被「巨型甲壳类（萨纳帕德）」攻击过后，托林被要求这艘船带它去「费登岛」，托林偷偷和萨纳帕德达成协议不能吃他，并且要求把一把钥匙吐出来，原来这是一把可以拿到枪枝的钥匙，好让他可以和船上船员交涉，让他成为这船上的掌权者，首先他先用自己的势力把这艘船上的领袖丢去喂食萨纳帕德，随后托林选择要带萨纳帕德去无人岛而不是费登岛，因为至少不会让费登岛的人民被无辜吃掉，但去无人岛也会有风险。</p><p>不过大家似乎没有共识，在不记名的投票后，托林向大家宣布自己刚刚在纸张上做了只有自己认的出来的记号，并找出投票去费登岛的懦夫，然后一枪杀掉他们，丢去喂食萨纳帕德，但他这样做只为了争取更多时间，只是托林发现萨纳帕德已经开始产卵，需要更多食物，晚上，其他船员想要偷袭拖林将他打死，却也没想到拖林早算到这一招是先躲起来，最后一一将这些人枪杀。不过唯独落下一个躲起来的船员，最后托林向他坦承自己根本没在票上做过记号，因为所有人都选择去费登岛，于是托林将最后一个船员推下萨纳帕德的食物坑。而托林欺骗萨纳帕德说费登岛已经抵达时，放火烧掉整艘船和萨纳帕德，自己则是顺利逃脱。</p><h4 id="影评-1"><a href="#影评-1" class="headerlink" title="影评"></a>影评</h4><p>这一集是由大卫芬奇执导的一集，这是我全季最喜欢的一集之一，这一集结尾以全新的视角描绘了托林的行为，给观众的内心留下双方面的思辨。最初，托林似乎在抛弃道德线，只是为了确保自己的生存而努力。然而，最后，观众得知托林知道船上的船员已经注定没有生还的机会。然而，他们的死亡可以用来避免萨纳帕德攻击费登岛的无辜居民。而且，托林是船上唯一一个无情地采取必要行动阻止怪物前往费登岛的人。最终，托林成功地带领萨纳帕德离开了费登岛并让萨纳帕德灭亡，然而，托林也是该事件的唯一幸存者，<strong>这凸显了他行为的道德模棱两可</strong>。</p><p>某种程度，托林是用他的道德行为来掩盖自己的邪恶和自私，他是真的邪恶与自私吗？我觉得也不是，他牺牲自己必须承担的罪恶感来拯救岛上的人，因此在这过程中托林必须要用尽方法来神不知鬼不觉地一一将船员杀掉好喂食萨纳帕德，这是托林的一个策略，<strong>我觉得这种策略是托林让自己少点杀掉船员罪恶感的手段</strong>，因为如果是依照刚开始抽签的方式，其他人都会陷入怜悯和不自愿，这是托林自己感受过的，所以如果用了一些自己可以自我防卫的方式杀掉这些船员，那托林也就不会有深深的罪恶感去承担这些人的性命。</p><h3 id="机器的脉动"><a href="#机器的脉动" class="headerlink" title="机器的脉动"></a>机器的脉动</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-3.jpeg"></p><h4 id="剧情-2"><a href="#剧情-2" class="headerlink" title="剧情"></a>剧情</h4><p>当星球表面的探索以灾难告终时，玛莎发现自己刚刚的执着让自己陷入困境，并且波顿还因此死亡，她不仅没有设备可以回去安全基地，甚至还与基地失联，距离最近的登陆艇也还要41公里，最惨的是她的氧气设备受损，大量氧气外泄，最后她选择利用波顿的样气设备，并拖着波顿的尸体跋涉到安全地带。玛莎因为做手受伤，于是必须使用药物让自己不痛，尽管会有会扭曲思维的副作用，或许宁愿亢奋致死也是不错的选择。</p><p>路途中，玛莎听到有人在说话，声音似乎来自于波顿，她马上直觉是自己用药的幻觉，波顿声音一路上不停地说话，眼前浮出许多人物形象，甚至是已经死去的波顿，原来这又是幻觉让她把石头看成波顿。清醒过来后感受到手臂的疼痛，再次加强药物注射，透过波顿的一连串话语，让玛莎理解到这个艾欧卫星会有大量二氧化硫是因为这是个机器，没错，是机器在透过波顿跟她说话，随之因为氧气量过低而昏迷，这昏迷中她感受到波顿抱着她走了一段路，再醒来后，她发现脚下有一处热湖的地方，这是艾欧鼓励玛莎也跳进去加入她，实体组织将被摧毁，神经组织会得以保留，结果可能是生是死，玛莎也只能赌一把，可能永生不死或这只是一场梦，最后玛莎的意识也对地球求救。</p><h4 id="影评-2"><a href="#影评-2" class="headerlink" title="影评"></a>影评</h4><p>当涉及到视觉媒体时，「音诗」（交响诗）一词被广泛使用，但诗歌是这一集的全部基础，观众会发现这一集的对话几乎都是有点难懂的内容，有时有哲学、有时有科学、有时有一般对话，最主要这一集的台词都是「艾欧」喔直讲话而来的，这一集故事非常简短，虽然叙事并不多，但视觉效果很强，情感宣泄值得一游，虽然内容不太好嗑，但的确是蛮特别的科幻故事。</p><p>剧情中玛莎有幻觉吗？玛莎是否产生幻觉可能对观众来说是主观的，<strong>先来谈谈如果这一切是玛莎自己的幻想</strong>。然而，有迹象表明玛莎与艾欧一起经历的一切都是她想像中的虚构，可能是玛莎作为临终时的一种应对机制，例如她的氧气罐在残骸中受损，虽然她能够将她的管子连接到波顿，但不能保证缺氧可能会导致幻觉。再加上波顿为了减少手臂疼痛而注射过量吗啡，被警告可能导致行动功能丧失、幻觉和兴奋，到最后玛莎跳入热湖，相信她的意识会像波顿一样通过艾欧继续存在，这可能是要季兴奋下的症状，让她在没有痛苦的情况下死去。</p><p>再来就换个角度想，<strong>如果艾欧的存在不是幻觉</strong>，艾欧有没有骗玛莎自杀？如果艾欧是真的而不是幻觉，那么艾欧就有可能诱骗玛莎加入机器。在夜间，当波顿的尸体被艾欧升起时，玛莎则是也被不知觉的状况下来到热湖的悬崖边。醒来后，玛莎迅速耗尽氧气，这导致艾欧诱骗她加入艾欧不断扩大的意识。这一则故事看起来很像是外星科技的概念，因为是在一个艾欧卫星中，他们会来探索是因为要了解这个地方，因此艾欧说自己是一个机器，这让人直觉想到艾欧的存在是外星科技的存在。</p><p>由于我们在本集结尾听到了玛莎与她的卫星通讯的声音，我们知道她至少有一部分还活着，但这看起来比较像是玛莎的意识已经被艾欧吸收了，并且听那呼叫的声音语调也已经不像是玛莎，反倒是艾欧用玛莎的意识去对外交流，因此，最终，玛莎的肉身被摧毁，但她的意识仍然存在于艾欧中，所以艾欧用玛莎的声音对地球求救，似乎也意味着想要透过玛莎声音对地球更多人吸引去这个地方，让艾欧又可以吸收更多人的意识。</p><h3 id="迷你亡灵之夜"><a href="#迷你亡灵之夜" class="headerlink" title="迷你亡灵之夜"></a>迷你亡灵之夜</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-4.jpeg"></p><h4 id="剧情-3"><a href="#剧情-3" class="headerlink" title="剧情"></a>剧情</h4><p>在一对年轻夫妇的热情交流后意外释放诅咒在墓地中的僵尸。这种情况导致墓地的尸体变成僵尸并袭击了这对夫妇，很快，这对夫妻也变成了丧尸，半死不活的生物开始迅速扩散开来。第二天早上，僵尸袭击了两名正在慢跑的妇女，这些女性还以僵尸的身份复活，并加入了越来越多的僵尸群。没过多久，丧尸的势力越来越大，开始入侵医院、社区热点、火车站、体育赛事等多个地方，丧尸几乎遍及人类文明的每一个主要和偏远地区，甚至延伸到各国。</p><p>政治领导人利用广泛的军事力量来应对僵尸的威胁，然而，所有的武器和弹药都被证明对数百万在全球的僵尸无效，僵尸袭击了一家化工厂，一群警察试图用枪挡住他们，然而，情况升级为气体泄漏，僵尸在接触化学物质后肢解，随着世界末日的临近，一种新型的喷火巨型僵尸加剧了人类的困境，然而，美国总统最后一次尝试结束僵尸大灾难，与俄罗斯一起发动所有的核武毁掉僵尸，但也毁掉自己与地球。</p><h4 id="影评-3"><a href="#影评-3" class="headerlink" title="影评"></a>影评</h4><p>这一集还蛮有趣的，从少数僵尸到成群结队，再到巨大的变异变异体，不死族军队将人类推向了毁灭的边缘，迫使俄罗斯和美国将其所有核武库释放到地球上，<strong>人类在地球上的灭亡方式终究是宇宙风中的一个屁，显示地球在整个宇宙中渺小到毫不起眼</strong>。美国和俄罗斯为什么要使用核武？白宫是地球上被丧尸攻击的最后地点之一，但最终被占领，在恐慌的状态下，总统决定使用美国的核武对付丧尸，然而，发射核武器会迫使俄罗斯在这个迷你世界中发射核武器进行报复（这是政治的嘲讽），人类没有希望，核武器将摧毁几乎所有的东西，包括僵尸，但也包含地球与人类自己。</p><p>整集强调了对抗僵尸末日的徒劳，这一集叙事本身的直截了当嘲弄了僵尸类型的非原创性，毕竟丧尸末日这种题材很常见，这一集叙事手法并没有费心去充实人物，反倒是用迷你世界来呈现，在镜头的带动下观众会发现我们都是从上帝视角去观看，因此镜头被拉得远呈现视觉效果，仿佛巧妙地让观众在看事情更为宏观一些。</p><p>这一集的结局是毁灭性的核爆炸，然而，这一场景是从外太空呈现的，这减少了看似破坏性事件的影响，就如前面所提到的，<strong>人类在地球上的灭亡方式终究是宇宙风中的一个屁</strong>，僵尸不是带来末日的主要族群，反倒是人类发射了无数的核弹让地球与人类毁灭，这一集的形式呈现了最可爱，虽是本季最短的电影，但考虑到其轻快、画面般的结构和呈现方式，非常适合它，也很容易让观众记得。</p><h3 id="杀戮小队开杀"><a href="#杀戮小队开杀" class="headerlink" title="杀戮小队开杀"></a>杀戮小队开杀</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-5.jpeg"></p><h4 id="剧情-4"><a href="#剧情-4" class="headerlink" title="剧情"></a>剧情</h4><p>一群美国精英特种部队来到指定地点出任务，当中一个小队全军覆没，大家争论这是什么样的恐怖攻击时，突然凶手马上出现，竟然是一只基金改造过的熊，这只熊不仅刀枪不入，动作还很敏捷，在失去两名弟兄之时，一阵电频响起音频让它逃之夭夭，原来是莫里斯上士，并且还知道这只熊的来历是被地下研究出来的，代号叫「犬魔计画」，是昨天和他的小队出来巡逻时失控。莫里斯带着大家来到基地时，发现这里的人全被杀死，于是他们打算准备武器去跟「犬魔」对战，而当中出现了一个小小助手机器人朋友也来助阵。</p><p>只是一遇到犬魔出现，人类还是招架不住，反倒是机器人朋友勇敢奋战，眼看无处可去，他们只好用手上的武器疯狂射击犬魔，最终一颗大火箭射向犬魔的心脏，终于让犬魔分尸，但在佛伦交代完搞笑的遗言时，犬魔的身体掉出一颗炸弹，将这基地炸毁，因此最后无人幸存。</p><h4 id="影评-4"><a href="#影评-4" class="headerlink" title="影评"></a>影评</h4><p>这是我觉得看完比较无感的一集，有趣的是，由于基因改造灰熊是中央情报局的产物，是用来想要歼灭圣战士的产物，但士兵们基本上是被一个旨在「帮助他们」的实体杀死的，这也讽刺地诉说着，制造出来的怪物也不一定会帮助自己，反倒会害了自己，就像是现世报一样，想要害人之心本来就不可有，创造出来的暴力总有一天都会反噬到自己身上。</p><h3 id="虫群"><a href="#虫群" class="headerlink" title="虫群"></a>虫群</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-6.jpeg"></p><h4 id="剧情-5"><a href="#剧情-5" class="headerlink" title="剧情"></a>剧情</h4><p>艾佛亚博士在外星中与外星生物做交流，最主要他是在这里研究「虫群」，这是外星生物无法理解他的目的，只觉得虫群不过是组织良好的动物而已，艾佛亚博士声称人类就是该找机会学习更多事物，艾佛亚博士进入了奇怪的生态系统。在里面，他遇到了另一个人，嘉琳娜，她多年来一直在研究虫群及其生物，虽然居住在虫群中的生物是无意识的寄生虫，但它们对被称为「女王」的巢穴思维做出了回应。</p><p>随着时间的推移，艾佛亚博士将他的目标定为研究嘉琳娜所知道的虫群。他解释说，透过利用虫群，人类可以培育出一个奴隶种族，可以用来增加人类在太空中的扩张。此外，从虫群中的外星人进化而来的新外星物种将成为人类追求的熟练士兵，并为混乱的人类时期带来稳定。尽管嘉琳娜对艾佛亚博士的计划持怀疑态度，但她同意帮助他，条件是不伤害虫群。嘉琳娜教艾佛亚博士如何用合成的费洛蒙控制类似机器体的外星虫，两人还试图取回一个女王的蛋。然而，虫群向人类释放了它的真实本性，导致两个有情物种之间发生了一场史诗般的对抗。</p><p>最后时刻，艾佛亚博士遭到武士虫种族的袭击，他为自己的生命而战，但许多虫给淹没，外星虫打败了艾佛亚博士并将他带到了巢穴中心，在那里他遇到了虫群的一个有知觉的分支。智能生命形式使用嘉林娜作为傀儡并与艾佛亚博士交谈。智能生物解释说，艾佛亚博士和嘉琳娜的行为触发了群体中的特定基因程序，从而导致了群体的产生，虫群感知到了人类构成的威胁，并创造了智能生物来应对外来威胁。智能虫群侮辱人类作为低等生物，并评论他们的智慧将导致他们的死亡，甚至说通过繁殖厉害的物种对付外来侵入，现在智能虫群打算要利用艾佛亚来繁殖人类成为寄生虫，但艾佛亚愿意跟她打赌，坚持认为人类绝对不会成为寄生虫。</p><h4 id="影评-5"><a href="#影评-5" class="headerlink" title="影评"></a>影评</h4><p>这一集是以布鲁斯斯特林1982 年广受好评的短篇小说《蜂群》为故事，这一集拥有本季所有短片中最逼真的人类动画。首先，艾佛亚博士来研究虫群的目的是为了要将这个有秩序的系统带回到人类的系统重新建立（需要虫卵带回去培育一个新虫群生态，让人类再次拥有权力的控制），因为人类扩张形成混乱，所以有妳股利量驾驭。嘉琳娜有说「那是剥削」，虫群之所以会和谐，我想是因为食物充足，没有斗争、没有不公平。因此看到艾佛亚博士与嘉琳娜在谈论要把这套系统给带回去人类世界时，嘉琳娜用了两种形容词「剥削」「傲慢」，这象征着刚来到这里的艾佛亚博士身上带着人类的气息，与这里的虫群生态相比，问题不在于系统，而是出自于人类自己，而艾佛亚博士来这里取虫卵为的是繁衍一个重生态，繁殖奴隶。</p><p>艾佛亚这样的举动<strong>是想要让人类可以优越化</strong>，当艾佛亚博士说「等你们毁灭人类之前，说不定….」，智能虫群反驳说到「你们很有可能会自我毁灭，智慧不是有利生存的特质」，这有点是在讽刺人类因为太过聪明所以会有很多小动作想要去掠夺其他资源或是占有，而且这种行为还会在人类之间存在，呼应到艾佛亚来这里说到人类扩张处于困乱的状态， 相较之下，虫群的存在就很单纯，也很好控制。</p><p>这一集的最后以探讨生物族群的「智慧」，虫群为艾佛亚博士提供了一个选择，艾佛亚即自愿让智能虫群繁殖人类，并且观看悲剧事件发生，但将其视为一项挑战，<strong>因为他内心其实还是认为人类是优越的种族</strong>。然而，这一集的结尾很有趣，因为智慧虫群说「我很高兴不需要吸收你，否则会想念彼此的谈话」，这智慧重群的言论与本集一开始时外星人和艾佛亚博士的情绪相呼应。因此，结局意味着艾佛亚博士其实是被外星人给设局进来这里的，因此看到这里，人类还是觉得自己是优越的智慧种族吗？我想虫群好像更胜一筹。</p><h3 id="梅森的老鼠"><a href="#梅森的老鼠" class="headerlink" title="梅森的老鼠"></a>梅森的老鼠</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-7.jpeg"></p><h4 id="剧情-6"><a href="#剧情-6" class="headerlink" title="剧情"></a>剧情</h4><p>农夫梅森实在受不了鼠患，于是拿着猎枪准备去跟老鼠大开杀戒，却没想到老鼠会拿武器反击，吓得梅森农夫找来陷阱科技公司来解决老鼠问题，他才不管这是不是人类造成的动物进化论，他只想要灭鼠器，于是推销员介绍一款TT6脉冲雷射灭鼠器，农夫不情愿地付了钱。再一次，看起来相当先进和足智多谋的老鼠们迅速战胜了灭鼠科技。于是，梅森购买了更先进防御系统（TT15机种），至此，农夫的谷仓已经变成了名副其实的战区，最后，梅森决定走进他的谷仓看看发生了什么事，他对里面发生的史诗般的残酷战斗感到震惊，老鼠们使用许多武器进行英勇的反攻，甚至还有简陋的坦克。最后，他们成功地破坏了TT15，但被斩首的机器继续试图杀死老鼠，梅森走到损坏的灭鼠机器前，用他的猎枪结束了这灭鼠器。为了表示感谢，老鼠们向农民提供了一杯饮料，这一集以和解的方式结束，梅森和老鼠们敬酒。</p><h4 id="影评-6"><a href="#影评-6" class="headerlink" title="影评"></a>影评</h4><p>「人类正在改造换整个环境，迫使动物们为了适应而做出改变等等之类的行为」隐喻这格世界中人类破坏了许多的生态，让有些物种为了生存只好和人类抢夺地盘和生存资源， 因而引发物种会和人类对战的情形，<strong>我想这是象征着大自然会反扑的概念</strong>，会有物种间的暴力对抗就在于人类破坏了之间的平衡。</p><p>另外，这个故事很细腻，也是我最喜欢的故事之一，梅森农夫最后出人意料地杀死了自己的机器TT15，<strong>即便农夫是很想要摆脱老鼠的威胁，但梅森似乎对TT15 所采取的野蛮暴力行为感到厌烦</strong>。在多个情况下，机器在杀死老鼠的同时很残忍，这让梅森非常反感，我想最终获胜的是「同理心」。机器对它的受害者毫无感觉并继续它的横冲直撞，但农夫，看到老鼠在不利的情况下激烈地战斗，开始为他们感到怜悯。梅森意识到TT15 造成的伤害比老鼠要大得多，在看到老鼠在「战场」上的英勇壮举后，<strong>他也获得了一些尊重</strong>。最后，梅森和老鼠，彼此之间的共同点比与机器的共同点要多。</p><p>这个故事其实也透露出<strong>这个世界间的暴力不停存在，因为彼此没有同理心和停下脚步去看</strong>，所以在梅森农夫跑去谷仓看到老鼠和机器人大战的时候，说到「这里就像第四次世界大战」，为什么不是说「第三次世界大战」？这是有用意的，因为这在很大程度上暗示现实生活中的人类可能会再次开战一次，或者可能两次，进一步暗示的世界大战的发生将是有道理的，为什么一家简单的害虫防治公司可以使用这种高科技武器，人类许多最伟大的技术进步都来自战争时期，再加上老鼠和其他动物变得越来越聪明，<strong>因此除虫公司需要变得更具创造性和破坏性，就因为彼此越来越暴力，武器越来越冲击，伤害到的就只有彼此，杀戮最终也会无止尽</strong>，因此农夫的举动也在暗示这个世界不需要战争，只需要彼此的同理心。</p><h3 id="隧道墓穴"><a href="#隧道墓穴" class="headerlink" title="隧道墓穴"></a>隧道墓穴</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-8.jpeg"></p><h4 id="剧情-7"><a href="#剧情-7" class="headerlink" title="剧情"></a>剧情</h4><p>一群特种部队去到一个隧道要营救人质，在暗不见天日的隧道里，他们发现奇怪的发光体类苔藓东西，也发现人质的尸体，但脸整个不见，身上的肉也被被啃食光剩下骨头，他们不解释是什么武器把人弄成这样，此时远方传来声响，使他们往前一探究竟，突然一个东西从上面掉下来，他们一看之下像是一种有人脸的蜘蛛蟑螂，随后满坑满谷的蜘蛛袭击而来，他们被迫一直开枪，好不容易先逃到一个空旷地方，蜘蛛也没有再跟上来，代表这些蜘蛛是看守隧道。</p><p>至于是看守什么？就是他们身后的这座古庙，哈波认为古庙那里一条隧道应该可以通到地面，不过在半路上，人脸蜘蛛已经追上来，哈波只能眼睁睁看着史宾斯死去，他们也只剩一点点弹药，此时古庙传来声音，巨大的铁链也在拖动，定睛一看才发现这里有着被禁锢的古恶灵，当祂发出一阵电波时，让他们两个脑中浮现这千年长老神（克苏鲁）的回忆，并被洗脑要释放祂，哈波想要阻止长官，于是不得不对长官开枪。哈波看着长老神的眼睛也被洗脑，最终哈波挖掉自己双眼，走回地面。</p><h4 id="影评-7"><a href="#影评-7" class="headerlink" title="影评"></a>影评</h4><p>「上帝已死，接受眼前的困境吧」看起来这个被困住的古恶灵是一种邪神长老神，以祂的形象来看似乎是克苏鲁邪神，克苏鲁神话中的众神之所以被定位为「邪神」，是源自于洛夫克拉夫特的这段记述：「<strong>人类跟宇宙比起来毫无意义，如果真的有神的话，根本不可能帮助如此渺小的人类，除非…他们怀有恶意。</strong>」，这对照到哈波对史宾斯说的那句「上帝已死，接受眼前的困境吧」，也就隐喻出「没有会拯救人的神」这件事。</p><p>所以最后他们遇到这个克苏鲁，虽然他是神，但也应验着即便是神，根本不会帮人类，在这一集的最后，士官和哈波面对这个克苏鲁都是透过祂的眼睛被洗脑，盯着这个可怕的神祗是变成疯狂的起始，尤其是当你遇到克苏鲁的时候，虽然我们不能肯定地说士官和哈波遇到的世不是可怕的恐怖是克苏鲁，然而，被困在神庙中的神看起来很像克苏鲁，主要是因为背上巨大翅膀、和克苏鲁一样的触手和多只眼睛。</p><p>盯着克苏鲁的眼睛会让任何正常的凡人发疯，然而，也有人对克苏鲁的描绘是「<strong>克苏鲁的苦恐怖是无法言喻的，但或许真正的恐怖，其实源自于人类对未知的恐惧</strong>。」就如同士官会被洗脑一样，前面经过一连串的未知堆叠起来的恐惧，来到直接面对克苏鲁，还被克苏鲁强迫看完这牵连来的作恶，恐惧在士官内心中爆发，所以也被洗脑释放祂。至于哈波最后是不是还活着出来？是的，在最后一幕中我们可以看到哈波走在外面的世界，但眼睛挖掉，这不是被克苏鲁搞的，<strong>而是哈波选择挖掉自己的眼睛不被克苏鲁影响和洗脑，也不被搞疯，这是唯一不被影响且可以活命的机会</strong>。我想，透过挖掉眼睛这个举动来看，<strong>我们能知道我们面对外面的世界都是「看得太多、感受得太多」，所以会被洗脑和支配思想</strong>。 </p><h3 id="吉巴罗"><a href="#吉巴罗" class="headerlink" title="吉巴罗"></a>吉巴罗</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-9.jpeg"></p><h4 id="剧情-8"><a href="#剧情-8" class="headerlink" title="剧情"></a>剧情</h4><p>一群骑士护送着重要人士在树林里稍作休息，在湖边，吉巴罗偷捡了一块小金块，触动了湖中的水妖，全身黄金闪亮水妖以声音蛊惑人心并开始自相残杀，全部往湖里奔去，血染这座湖，本身是耳聋的吉巴罗不懂发生什么事，水妖对于吉巴罗完全不为所动有点疑惑但也瞬间对他迷恋，吉巴罗最后驾着马逃离，却因为太着急而撞到一棵树。吉巴罗停留在树林里，睡着之际，水妖也来到他身边，甚至搂着他睡觉。醒来，吉巴罗发现水妖身上有着许多黄金麟片，兴奋地追上去，不管多危险的地方都能想尽办法追上去。在女妖对吉巴罗摩蹭之际，吉巴罗突袭女妖，并且将她身上的金饰一一掏空，把女妖推下水，女妖随着瀑布回流到湖中血染湖水，让吉巴罗喝下后突然耳聋被治愈了，但对声音不知所措的吉巴罗反倒是师空地在树林里狂奔、自残。水中康复醒来后的女妖发现身上的黄金鳞片全被拔光，于是难过地大喊着，听得到声音的吉巴罗变得被女妖声音蛊惑，最终也最终也沉没于湖底。</p><h4 id="影评-8"><a href="#影评-8" class="headerlink" title="影评"></a>影评</h4><p>吉巴罗战友的死让他可以自由地拿走他认为合适的任何战利品，多亏了他的耳聋，这才阻止了他被女妖的声音给蛊惑，但也正因为如此，他们才对彼此产生了迷恋。然而，吉巴罗被蛊惑的契机不是因为声音，却也被眼前的金银财宝蛊惑，<strong>搭配上他所有战友都死去，没人跟他抢，因此面对眼前满是金饰的女妖来说，这会放大吉巴罗的贪欲</strong>。</p><p>女妖本身也是有欲望的，她的欲望来自于有人不会被她的声音所伤害到，所以她是不是真的有爱上吉巴罗，我想是的，这就是为什么她会主动去亲吻吉巴罗，尽管她伤害了吉巴罗，让他满嘴是血，但还是有着非常强烈的渴望，我在想这也是为什么湖底会有成千上万的男人尸体，这些或许都是女妖本身想要得到的到的爱情，想要找到那个可以不会被她声音伤害的人，只是可悲的是，吉巴罗对她的迷恋是多亏了她美丽华丽的鳞片。之后吉巴罗的下场也是很神转折，因为喝了水妖的血，所以治愈了吉巴罗的耳聋。水妖这举动是想要帮吉巴罗治愈他嘴上的伤？还是想要故意治好他的耳聋？我选择后者，因为水妖最后还是因为自己身上的黄金鳞片的消失而生气想要报复，迫使他越来越深入湖中死掉，直到他成为众多成为她猎物男人中的一员。</p><p>这一集无疑是所有故事中最具视觉创意的，介于其极其逼真的动画和画面色彩渲染，尤其是热带环境（还有爱心型的湖，象征着水妖渴望有男人可以陪伴她），以及非传统的电影风格之间，这一集采用快速快门速度、疯狂编辑和大量相机抖动来看吉巴罗在树林中的视角，有效地传达了场景的感官迷失和纯粹的陌生感。金色的女人，一个奇特但不可否认的诱人妖精，是本季迄今为止最令人印象深刻和令人难忘的CGI 表现。</p><p>原本以为《吉巴罗》会是一段爱情故事，但最终其实是一部讲述性别关系，以及殖民者的掠夺与文化入侵的作品。身上穿戴各种金银财宝的湖妖就是原住民的代表，原本她以为聋骑士是个好人、主动接近他，但没想到过没多久就显露出本性。而最终湖妖在被血色染红的湖水中所产开的反击，则是原生居民在家园遭到蹂躏后，忍无可忍地对侵略者做出的反扑。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10.webp&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;艾美奖获奖动画选集《爱、死亡 &amp;amp; 机器人》第三部回归，恐怖、想象力和美在新剧集中完美融合，从揭示古老的邪恶力量到喜剧般的末日，剧集以标志性的巧思和创造性的视觉效果，为观众带来令人震惊的奇幻、恐怖和科幻短篇故事。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>Cherno OpenGL教程</title>
    <link href="https://yousazoe.top/archives/cbd8aac2.html"/>
    <id>https://yousazoe.top/archives/cbd8aac2.html</id>
    <published>2022-05-11T15:39:16.000Z</published>
    <updated>2022-07-01T09:23:45.751Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/geexlab-opengl-21-demopack-20190921.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。</p><span id="more"></span><h3 id="欢迎来到OpenGL"><a href="#欢迎来到OpenGL" class="headerlink" title="欢迎来到OpenGL"></a>欢迎来到OpenGL</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=465609139&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>在这个视频中，主要包括 OpenGL 实际是什么、怎么使用它以及它能为我们做什么和它不是什么等等，这个系列也是如此。</p><h4 id="什么是OpenGL"><a href="#什么是OpenGL" class="headerlink" title="什么是OpenGL"></a>什么是OpenGL</h4><p>首先如果你听过 OpenGL 但不确定它是什么，你可能想到与图形有关的，那就是 OpenGL。OpenGL 是一种图形接口，现在 API 代表应用程序接口，基本上就是一大堆我们能够调用的函数去做一些事情。在这种情况下，由于 OpenGL 是一种图形 API，它允许我们做一些与图形相关的事情，特别的是它允许我们访问 GPU 也就是显卡，图形处理单元（Graphics Processing Unit）。</p><p>调用显卡也更好地绘制图形，所以实际上为了利用电脑或其他设备（比如手机）中强大的图形处理器，需要调用一些 API 访问固件。OpenGL 正好是允许访问和操作 GPU 的许多接口中的一种，当然我们也有一些其他的接口，比如 Direct3D、Vulcan 和 Metal 等等，所以某种角度来说 OpenGL 允许我们控制显卡。</p><h4 id="关于OpenGL误解"><a href="#关于OpenGL误解" class="headerlink" title="关于OpenGL误解"></a>关于OpenGL误解</h4><p>让我们来澄清一些人关于 OpenGL 的误解。</p><p>首先，许多人称它为一个类库或一种引擎或一些其他的框架，但这些都不是。OpenGL 核心本身只是一种规范，和 CPP 规范差不多。实际上它没有确定任何代码和类似的事情本身就是规范，比如“嘿，这个函数应该存在，需要这些参数并且返回这个值”，它只是一种你能利用这种 API 做什么规范，没有任何具体的实现，这意味它绝不是一个类库，因为 OpenGL 本身没有代码，它只是一种规范。</p><br><p>去哪儿下载 OpenGL 是另一个常见的问题。</p><p>然而，答案是你不需要真的去下载 OpenGL，它本身只是一种规范。那么，谁去实现它呢，谁去为你调用的 OpenGL 函数写代码呢？这个答案是 GPU 制造商，所以如果你使用的是 NVIDIA 显卡，那么你的显卡驱动（也就是 NVIDIA 驱动）实际上包含了 OpenGL 的实现，每个显卡制造商比如 AMD、Intel 等都会有它们自己的实现，每家关于 OpenGL 的实现都会有些不同，这也就是有些游戏能在 NVIDIA 驱动的显卡上运行但在一个 AMD 电视或者其他显卡设备上运行有些区别、甚至会出现问题的原因。</p><p>但不管怎么说，关键在于你的显卡制造商实现的 OpenGL，这又可能导致下一个有关 OpenGL 常见的误解：它是开源的。我不知道人们为什么会这么觉得，也许是名字中带着“Open”，但是它根本不是开源的，你看不到 OpenGL 的源码，因为首先它是由 GPU 制造商实现的，它们肯定不会发布它们的驱动源码。</p><br><p>OpenGL 提供了什么能激发和导致许多人不幸地说 OpenGL 是无与伦比的？原因在于它是跨平台的，所以你的 OpenGL 代码可以在 Windows、Mac、Linux 和 Android 上正常执行，以至于人们立马就会意识到 OpenGL 比 Direct3D 更优越，因为它能在所有平台上运行，但是请不要这么说。</p><p>从我 EA 技术中心并处理过许多引擎中图形接口的经验来看，因为 OpenGL 是跨平台的 API，而制作一款游戏不会只涉及实现一个独立的图形 API。如果游戏引擎是跨平台的，那意味着它不仅实现了 Xbox，也包括其他一些平台，它们不得不实现大量其他的图形接口。</p><p>因此，我们面临的问题是图形 API 是为特定平台设计的。例如 Direct3D 是微软为 Windows 设计的，它在 Windows 上的表现要比跨平台的 API 好些。现在请记住，实际编写这些代码的人不是微软，即使微软的确为了更好的代码质量和 GPU 制造商合作过。所以关于 API 的比较是没有任何意义的，因为通常平台原生的东西会更健壮更友好。</p><br><p>就 OpenGL 的复杂性而言，它可以说是现在可以学习的最简单的 API 了，所以 OpenGL 是绝对值得学习的。Vulkan 是另一个跨平台的 API，但它更底层更严谨，不适合初学者直接入门，老实说我并不想使用 Vulkan 去开发游戏，OpenGL 更加稳定。</p><h4 id="传统与现代OpenGL"><a href="#传统与现代OpenGL" class="headerlink" title="传统与现代OpenGL"></a>传统与现代OpenGL</h4><p>另外本系列学习的主要是现代 OpenGL。OpenGL 于 90 年代发布，那时的情况和现在大不相同，那时的 GPU 是可编程的，十分灵活，制造商给了程序员和开发者更多的控制权。</p><p>传统 OpenGL 和现代 OpenGL 之间最大的区别就是着色器。如果你对图形学感兴趣的话可能听说过着色器，它可能有点像 shadow 这个单词或者是光源，有些人将它和光源或其他比较。抛开这些，着色器是程序，它是在你 GPU 上运行的代码，这就是着色器，它是在你 GPU 上运行的一段程序。。</p><p>那么如果你用 C++、Java 或 C# 或不管什么语言写代码，这段代码都会运行在你的 CPU 上。但当我们开始处理图形的大部分时间里，我们想要更为精确的控制显卡运行，可能要将大部分代码从 CPU 转到 GPU 上，因为它在 GPU 上运行更快，这就是着色器存在的意义：允许我们在 GPU 上运行代码。所以可编程的着色器是最大的区别。</p><h3 id="设置OpenGL和C-中创建一个窗口"><a href="#设置OpenGL和C-中创建一个窗口" class="headerlink" title="设置OpenGL和C++中创建一个窗口"></a>设置OpenGL和C++中创建一个窗口</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=466583251&amp;page=2&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>上一节我们只说了 OpenGL 到底是什么以及这个系列实际会讲什么。今天我们的任务是让我的操作系统为我创造一个窗口，在未来我们可能会在窗口内绘制图形。</p><br><p>我们会使用一个向我提供窗口创建和窗口管理的实际代码类库，不管 Windows、Mac 还是 Linux。GLFW 就是满足上述条件的类库，我喜欢这个类库的原因是它确实是一个轻量级类库，它虽然不如 SDL 那么全面（实际上它就是个渲染器），但依然可以创建窗口、OpenGL context 以及给我们访问一些类似输入之类的基础东西。</p><h4 id="下载类库"><a href="#下载类库" class="headerlink" title="下载类库"></a>下载类库</h4><p>由于我使用的是 Mac，所以使用 brew 下载：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">brew install glew</span><br><span class="line">brew install glfw   </span><br></pre></td></tr></tbody></table></figure><p>下载后默认的路径为 <code>/usr/local/Cellar/</code>。</p><h4 id="配置CMake文件"><a href="#配置CMake文件" class="headerlink" title="配置CMake文件"></a>配置CMake文件</h4><p>我将项目名称设置为 <code>OpenGL</code>，在 CLion 中配置：</p><figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(OpenGL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add head file</span></span><br><span class="line"><span class="keyword">set</span>(GLEW_H /usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/<span class="keyword">include</span>/GL)</span><br><span class="line"><span class="keyword">set</span>(GLFW_H /usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">7</span>/<span class="keyword">include</span>/GLFW)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${GLEW_H}</span> <span class="variable">${GLFW_H}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add target link</span></span><br><span class="line"><span class="keyword">set</span>(GLEW_LINK /usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/lib/libGLEW.<span class="number">2.2</span>.dylib)</span><br><span class="line"><span class="keyword">set</span>(GLFW_LINK /usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">7</span>/lib/libglfw.<span class="number">3</span>.dylib)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">${OPENGL}</span> <span class="variable">${GLEW_LINK}</span> <span class="variable">${GLFW_LINK}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(OpenGL <span class="variable">${SOURCE_FILES}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (APPLE)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(OpenGL <span class="string">"-framework OpenGL"</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(OpenGL <span class="string">"-framework GLUT"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></tbody></table></figure><h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><p>复制下面内容到 <code>main.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行代码，我们会得到一个黑色的窗口。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220513001615672.png"></p><h4 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h4><p>下面我们用传统 OpenGL 设定三个顶点，绘制一个三角形：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;glew.h&gt;</span><br><span class="line">#include &lt;glfw3.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    /* Initialize the library */</span><br><span class="line">    if(!glfwInit())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    /* Create a Windowed mode and its OpenGL context */</span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);</span><br><span class="line">    if(!window)</span><br><span class="line">    {</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /* Make the window's context current */</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    /* Loop until the user closes the window */</span><br><span class="line">    while(!glfwWindowShouldClose(window))</span><br><span class="line">    {</span><br><span class="line">        /* Render here */</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="addition">+       glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="addition">+       glVertex2f(-0.5f, -0.5f);</span></span><br><span class="line"><span class="addition">+       glVertex2f( 0.0f,  0.5f);</span></span><br><span class="line"><span class="addition">+       glVertex2f( 0.5f, -0.5f);</span></span><br><span class="line"><span class="addition">+       glEnd();</span></span><br><span class="line"></span><br><span class="line">        /* Swap front and back buffers */</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        /* Poll for and events */</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220513001355838.png"></p><h3 id="在C-中使用现代OpenGL"><a href="#在C-中使用现代OpenGL" class="headerlink" title="在C++中使用现代OpenGL"></a>在C++中使用现代OpenGL</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=3&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="顶点缓冲区和在现代OpenGL中画一个三角形"><a href="#顶点缓冲区和在现代OpenGL中画一个三角形" class="headerlink" title="顶点缓冲区和在现代OpenGL中画一个三角形"></a>顶点缓冲区和在现代OpenGL中画一个三角形</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=4&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>现代 OpenGL 比那种传统 OpenGL 更具可编程性，它的扩展性更好也更加强大，你可以用它做许多事情，但代价是在绘制一个简单三角形前，我们实际上需要做很多设置。而前面我们已经用传统方法简单绘制了三角形，非常简单并且不需要什么设置。</p><p>让我们聊聊需要什么东西才可以绘制一个三角形。对于现代 OpenGL 而言，首先我们需要能够创建一个顶点缓冲区，然后还要创建一个着色器（之后可能会单独讲一下图形渲染管线是如何运行的，特别是 OpenGL）。让我们快速地说一下这两个东西是什么吧。</p><h4 id="顶点缓冲区与着色器"><a href="#顶点缓冲区与着色器" class="headerlink" title="顶点缓冲区与着色器"></a>顶点缓冲区与着色器</h4><p>顶点缓冲区基本上就是去掉 vertex，它只是一个内存缓冲区，一个内存字节数组，从字面上讲就是一块用来存字节的内存。但是顶点缓冲区又和 C++ 中像字符数组的内存缓冲区不太一样，它是 OpenG 中的内存缓冲区，这意味着它实际上在显卡显存（Video RAM）上。</p><p>所以这里的基本思路就是我要定义一些数据来表示三角形，我要把它放入显卡的 VRAM 中，然后还需要发出 DrawCall 绘制指令。实际上我们还需要告诉显卡如何读取和解释这些数据，以及如何把它放到我们屏幕上，一旦我们发出 DrawCall 指令，我们需要告诉显卡：好了，一旦你在显卡端获得了这些数据，我要你像这样把它摆出来，我希望你把它画出来在屏幕上给我显示一个三角形。所以我们需要告诉显卡怎么做，需要对显卡编程，这就是着色器，着色器只是一个运行在显卡上的程序，它是一堆我们可以编写的在显卡上以一种非常特殊的方式运行的代码。</p><br><p>听起来很复杂，但是不要想太多。简而言之我们有一个可以指定的内存，还有一些我可以指定的数据，告诉显卡：嘿，这是数据。然后从显卡那边说：好了，现在读一下这些数据并解释一下（例如屏幕上的位置），可能的话把它们连成一个三角形。这就是整件事的原理，也是 OpenGL 渲染的流程。</p><p>要注意 OpenGL 是作为一个状态机来运行的，这意味着你不必把它当作一个对象或任何类似的东西来对待，你所做的是设置一系列的状态，然后当你说一些事比如给我画一个三角形，这是非常 contextual 的。我的意思是，我不只是说，嘿，给我画一个三角形，然后传递 OpenGL 需要绘制三角形的所有东西。实际上它已经知道画三角形需要什么了，因为那是状态的一部分。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><p>让我们来创建这个顶点缓冲区来看看能做些什么。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line"><span class="built_in">glVertex2f</span>(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line"><span class="built_in">glVertex2f</span>( <span class="number">0.0f</span>,  <span class="number">0.5f</span>);</span><br><span class="line"><span class="built_in">glVertex2f</span>( <span class="number">0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></tbody></table></figure><p>这是之前使用传统 OpenGL 绘制三角形的代码。现代 OpenGL 需要创建顶点缓冲区，发送到 OpenGL 显存，然后发出一个 DrawCall 指令说：嘿，请画出我的缓冲区。</p><p>首先我们要创建自己的缓冲区，这个过程非常简单，只需要调用 <code>glGenBuffers()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220515233624735.png"></p><p>第一个参数指定需要几个缓冲区；第二个参数指定返回整数的内存地址，这也是生成的缓冲区的 id。记住 OpenGL 是作为一个状态机工作，这意味着你可以生成一切，而 OpenGL 中生成所有东西都分配了一个唯一的标识符，它只是一个整数，也是你实际对象的 id，当你想要使用这个对象的时候就用这个数字。</p><p>因为我要渲染我的三角形，需要说明用哪个缓冲区来渲染三角形，只需要传递这个整数即可。现在我们有了这个 id，一旦创建缓冲区后，我们现在就要选择那个缓冲区。选择（Selecting）在 OpenGL 中被称为绑定（Binding）:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220515233946266.png"></p><p>下一步是指定数据。一个简单的方式是在声明数据的时候直接把顶点数据填充进去：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着调用 <code>glBufferData()</code> ，查阅文档： </p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516000555444.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516000710441.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure><p>很好，现在我们为 OpenGL 指定了 <code>positions</code>，通常还需要创建一个索引缓冲区，也都是后话了。不过我们还没有着色器，去解释如何用这些数据进行绘制，我们将在下一期讨论那个问题。今天我们要做的只是想看看能不能把它绘制出来。</p><p>在没有索引缓冲区的情况下我们可以调用 <code>glDrawArrays()</code> 绘制指定图元：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/* Render here */</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="deletion">-glVertex2f(-0.5f, -0.5f);</span></span><br><span class="line"><span class="deletion">-glVertex2f( 0.0f,  0.5f);</span></span><br><span class="line"><span class="deletion">-glVertex2f( 0.5f, -0.5f);</span></span><br><span class="line"><span class="deletion">-glEnd();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br></pre></td></tr></tbody></table></figure><p>我喜欢用 Photoshop 打比方。如果我选择一个图层，然后在该图层上用画笔绘制一些东西，它只会影响这一图层。然而如果我没有选择任何东西或者选错了东西，它不会影响到我想绘制的那个图层。OpenGL 也是一样，在使用它之前你需要选择或绑定所有东西，因为这就是它的运行原理，它是上下文相关的，它是一个状态机。</p><h3 id="OpenGL中顶点的属性和布局"><a href="#OpenGL中顶点的属性和布局" class="headerlink" title="OpenGL中顶点的属性和布局"></a>OpenGL中顶点的属性和布局</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=5&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>上一节我们讨论了顶点缓冲区，但实际上有一些部分我们忽略了：顶点属性和着色器。今天我们将学习顶点属性。</p><h4 id="顶点属性"><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h4><p>所以什么是顶点属性？OpenGL 渲染管线的工作原理是我们为我们的显卡提供数据，我们在显卡上存储一些内存，它包含了我们想要绘制的所有数据；然后我们使用一个着色器在显卡上读取数据，并且完全显示在屏幕上。</p><p>通常我们绘制几何图元的方式就是使用一个叫顶点缓冲区的东西，也就是一个存储在显卡上的内存缓冲区，所以当对着色器编程时实际上是从读取顶点缓冲区开始的，它需要知道缓冲区的布局，这个缓冲区包含的浮点数指定了每个顶点的位置、纹理坐标、法线之类的。</p><h4 id="代码实践-1"><a href="#代码实践-1" class="headerlink" title="代码实践"></a>代码实践</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在我继续之前想先定义顶点是什么意思，因为人们在错误的使用这个词。</p><p>顶点与位置无关，顶点就是几何图形上的一个点。大多数人在视觉上对它们的明显印象是通过它的位置，所以如果我给你画一个三角形，你会看到三个顶点。但顶点不是位置，一个顶点可以不仅仅包含一个位置，顶点可以包含位置更多的数据例如纹理坐标、法线、颜色等等，它们可能都在一个顶点。所以我们需要告诉 OpenGL 外面的数据布局，调用 <code>glVertexAttribPointer()</code> 函数。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220516230107887.png"></p><ul><li><p><code>index</code>：Specifies the index of the generic vertex attribute to be modified.</p><p>基本上我们的着色器读取所有这些的方式是通过索引。一般来说如果我们有一个位置在索引 0 处，我们需要把它作为索引 0 来引用；而当我们有三种属性，我想让我的位置在下标 0，纹理坐标在索引 1，法线在索引 2.所以当我开始从着色器和显卡读取数据时，然后进入那个缓冲区，我可以简单地引用它们。这就是索引，它只是缓冲区实际属性的索引。</p></li><li><p><code>size</code>：Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant <code>GL_BGRA</code> is accepted by <code>glVertexAttribPointer</code>. The initial value is 4.</p><p>这里的 <code>size</code> 可能有点误导人，它是每个通用顶点属性的组件数，只能是 1，2，3，4。所以这个 <code>size</code> 和字节没有关系，和它们实际占用了多少内存也没关系。在本例中每个顶点的坐标有 x 和 y 两组分量，所以 <code>size</code> 为 2。</p></li><li><p><code>type</code>：Specifies the data type of each component in the array. The symbolic constants <code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>, <code>GL_UNSIGNED_SHORT</code>, <code>GL_INT</code>, and <code>GL_UNSIGNED_INT</code> are accepted by <code>glVertexAttribPointer</code> and <code>glVertexAttribIPointer</code>. Additionally <code>GL_HALF_FLOAT</code>, <code>GL_FLOAT</code>, <code>GL_DOUBLE</code>, <code>GL_FIXED</code>, <code>GL_INT_2_10_10_10_REV</code>, <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> and <code>GL_UNSIGNED_INT_10F_11F_11F_REV</code> are accepted by <code>glVertexAttribPointer</code>. <code>GL_DOUBLE</code> is also accepted by <code>glVertexAttribLPointer</code> and is the only token accepted by the <em><code>type</code></em> parameter for that function. The initial value is <code>GL_FLOAT</code>.</p><p>这里是我们指定数据类型 <code>type</code>，在本例中则是位置的浮点类型 <code>GL_FLOAT</code>。</p></li><li><p><code>normalized</code>：For <code>glVertexAttribPointer</code>, specifies whether fixed-point data values should be normalized (<code>GL_TRUE</code>) or converted directly as fixed-point values (<code>GL_FALSE</code>) when they are accessed.</p><p>标准化其实不用太担心，如果我们处理的是浮点数，因为它们已经被规范化了。假设我们要指定一个颜色字节在 0 到 255 之间，它在我们的实际着色器作为一个浮点数需要被规范化到 0 到 1 之间，这不是一个你可以在 CPU 上做的事情，但你可以让 OpenGL 替你做。</p></li><li><p><code>stride</code>：Specifies the byte offset between consecutive generic vertex attributes. If <em><code>stride</code></em> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</p><p><code>stride</code> 指针会让很多人感到困惑，如文档所示它就是连续通用顶点属性之间的字节偏移量，也可以理解为每个顶点之间的字节数。举个例子我们有位置 <code>vec3</code>、纹理坐标 <code>vec2</code> 和法线  <code>vec3</code>，那么我们的 stride 就是 3 * 4 + 2 * 4 + 3 * 4 = 32 字节，它是每个顶点的字节大小。</p><p>如果我们想从一个顶点跳到下一个顶点，我需要在缓冲区中加上 32 个字节。所以如果我们有一个指针指向缓冲区的开始，然后经过缓冲区的 32 个字节，我应该在下一个顶点的起点，这就是 stride。</p></li><li><p><code>pointer</code>:Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the <code>GL_ARRAY_BUFFER</code> target. The initial value is 0.</p><p><code>pointer</code> 文档的表述上第一个组件的一个偏移量，它是指向实际属性的指针。不要管有多少个顶点，聚焦于一个顶点，里面包含位置、纹理坐标和法线。对于位置偏移量为 0，因为它是缓冲区的第一个字节；然后我们前进 12 个字节到达纹理坐标，所以对于我的纹理坐标属性这个值（pointer）是 12；最后再前进 8 字节得到顶点的法线，所以对于顶点法线属性 20 是这个 pointer 的值。</p></li></ul><p>最后别忘了调用 <code>glEnableVertexAttribArray()</code> 去启用 <code>glVertexAttribPointer()</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p>这两段代码告诉 OpenGL 缓冲区的布局是什么，理论上如果有一个着色器就可以看到在屏幕上看到三角形了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">            <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">             <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">             <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220517191158369.png"></p><h3 id="OpenGL中着色器的原理"><a href="#OpenGL中着色器的原理" class="headerlink" title="OpenGL中着色器的原理"></a>OpenGL中着色器的原理</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=6&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们讨论的都是关于着色器。</p><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>每个新手脑海里的第一个问题是什么是着色器？</p><p>着色器就是一个运行在显卡上的程序代码，它是我们可以在计算机上以文本或者字符串形式编写的代码，然后我们可以把它给 OpenGL 发到显卡上像其他程序一样编译链接，最后运行它，不同的是它是在我们的显卡上运行而不是 C++ 那样在我们的 CPU 上。那么为什么我们需要程序完全在显卡上运行呢？</p><p>究其原因是我们希望能够告诉显卡该做些什么，显卡处理图形的速度要快得多，我们想要利用显卡的能力在屏幕上绘制图形。这并不意味着所有的工作必须在显卡上完成，CPU 有自己擅长的部分，也许之后我们可以将结果数据发送给显卡同时仍然在 CPU 上进行处理。</p><h4 id="着色器类型"><a href="#着色器类型" class="headerlink" title="着色器类型"></a>着色器类型</h4><p>对于大多数图形编程，我们会把重点放在两种着色器：顶点着色器和片段着色器（又称像素着色器）。</p><p>虽然还没有正式讲过标准图形渲染管线，但是我们应该对它大致是如何工作的应该了解：我们在 CPU 上写了一堆数据，向显卡发送这些数据并且发出一个叫做 DrawCall 指令的东西，也绑定了某些状态，最后我们进入了着色器阶段，GPU 实际处理 DrawCall 指令并在屏幕上绘制一些东西。这个特定的过程基本上就是渲染管道，我们如何在屏幕上从数据到结果的。</p><p>现在当显卡开始绘制三角形时，着色器就派上用场了。顶点着色器和片段着色器是渲染管线两种不同的着色器类型，所以当我们真正发出 DrawCall 指令时，顶点着色器会被调用，然后片段着色器会被调用，最后我们会在屏幕上看到结果。</p><br><h5 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h5><p>那么顶点着色器是做什么的？</p><p>它会被我们渲染的每个顶点调用，在这个例子中我们有一个三角形三个顶点，这意味着顶点着色器会被调用三次，每个顶点调用一次。顶点着色器的主要目的是告诉 OpenGL 你希望这个顶点在屏幕空间的什么位置。再强调一次，顶点着色器的主要目的是提供那些顶点的位置，如果有必要我们需要能够提供一些变换以便 OpenGL 能把这些数字转化成屏幕坐标，这样我们就能在窗口中看到我们的图形在对的位置。</p><h5 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h5><p>一旦顶点着色器运行结束，我们就进入了管道的下一个阶段：片段着色器或者像素着色器。</p><p>虽然片段和像素在术语上有点小差别，但现在你可以把像素当成片段或者把片段想象成像素，因为片段着色器会为每个需要光栅化的像素运行一次。我们的窗口基本上是由像素组成的，我们指定的那三个顶点组成我们的三角形现在需要用实际的像素填充，这就是光栅化阶段所做的。</p><p>片段着色器或像素着色器就是对三角形中需要填充的每个像素调用一次，主要决定这个像素是什么颜色，这就是它的作用，它决定了像素的输出颜色，这样像素就可以用正确的颜色着色。形象一点可以把它想象成一本涂色本，当你只有东西的轮廓时需要给它上色，这就是片段着色器的职责。</p><br><p>相比于顶点着色器，片段着色器里面的东西代价要高得多，因为它会为每个像素运行。</p><p>话虽如此，有些东西显然需要按像素计算例如光源。如果你在计算光源，每个像素都有一个颜色值，这个值是由很多东西决定：光源、环境、纹理、提供给表面的材质……所有这些一起来确定一个特定像素的正确颜色。显然这取决于一些输入，例如相机的位置在哪里，而这些所有的东西结束后你在片段着色器中的决定仅仅是单个像素的颜色，这就是片段着色器的作用。</p><h3 id="OpenGL中写一个着色器"><a href="#OpenGL中写一个着色器" class="headerlink" title="OpenGL中写一个着色器"></a>OpenGL中写一个着色器</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=7&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>让我们开始写一些着色器代码吧。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先创建一个 <code>CreateShader()</code> 创建着色器函数，传入两个着色器字符串，这些字符串都是实际的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>和创建缓冲区一致，我们需要返回一个整型作为标识符，当我们想绑定的时候可以绑定那个缓冲区 id。</p><p>所以我们要做的第一件事就是创建一个程序，基本上我们只需要输入 <code>glCreateProgram()</code>，该函数不需要传入整数引用之类的东西，它会返回一个无符号的整数（顺带一提，这里和后面不使用 OpenGL 自带类型的原因是个人处理多种类型的图形 API，更倾向于 C++ 类型）：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br></pre></td></tr></tbody></table></figure><p>接下来我们需要做的是创建我们的两个着色器对象：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br></pre></td></tr></tbody></table></figure><p>考虑到这个工作在今后的复用性，可以另创建一个函数 <code>CompileShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后可以加一个初始化函数，查找字符串中的第一个字符然后返回它的内存地址：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// const char* src = &amp;source[0];</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br></pre></td></tr></tbody></table></figure><p>最后就是调用 <code>glShaderSource()</code> 和 <code>glCompileShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到 <code>CreateShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个过程很像 C++编译中将两个不同的文件链接在一起，以便可以同时使用它们：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="built_in">glValidateProgram</span>(program);</span><br></pre></td></tr></tbody></table></figure><p>最后我们实际上现在可以删了我们的着色器，因为它们已经被链接到一个程序中，所以我们可以删除这些中间文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fs);</span><br></pre></td></tr></tbody></table></figure><p>最终我们的函数源码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>让我们快速做一下这个错误处理。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译着色器实际上不会返回任何东西，所以如果任何东西出错我们无法检索找出问题。但我们可以通过调用 <code>glGetShaderiv()</code> 实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br></pre></td></tr></tbody></table></figure><p>判断 <code>result</code>，检索错误信息的长度并输出信息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to complie "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="着色器编写"><a href="#着色器编写" class="headerlink" title="着色器编写"></a>着色器编写</h4><p>首先 <code>#version 330 core</code> 意味着我们将使用 GLSL（OpenGL 的着色器），其次指定位置和颜色：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line">std::string vertexShader = R"(</span><br><span class="line">    <span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">gl_Position</span> = position;</span><br><span class="line">    }</span><br><span class="line">)";</span><br><span class="line"></span><br><span class="line">std::string fragmentShader = R"(</span><br><span class="line">    <span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()</span><br><span class="line">    {</span><br><span class="line">        color = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    }</span><br><span class="line">)";</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span>(result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">" shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Window"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    std::string vertexShader =</span><br><span class="line">    <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"layout(location = 0) in vec4 position;\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"{\n"</span></span><br><span class="line">    <span class="string">"   glPosition = position;\n"</span></span><br><span class="line">    <span class="string">"}\n"</span>;</span><br><span class="line">    </span><br><span class="line">    std::string fragmentShader =</span><br><span class="line">    <span class="string">"#version 450 core\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"layout(location = 0) out vec4 colour;\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"{\n"</span></span><br><span class="line">    <span class="string">"   colour = vec4(1.0, 0.0, 0.0, 1.0);\n"</span></span><br><span class="line">    <span class="string">"}\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="整理错误"><a href="#整理错误" class="headerlink" title="整理错误"></a>整理错误</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Failed to compile vertex shader!</span><br><span class="line">ERROR: 0:1: '' :  version '330' is not supported</span><br><span class="line">ERROR: 0:1: '' : syntax error: #version</span><br><span class="line">ERROR: 0:3: 'layout' : syntax error: syntax error</span><br><span class="line"></span><br><span class="line">Failed to compile fragment shader!</span><br><span class="line">ERROR: 0:1: '' :  version '450' is not supported</span><br><span class="line">ERROR: 0:1: '' : syntax error: #version</span><br><span class="line">ERROR: 0:3: 'layout' : syntax error: syntax error</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519175413584.png"></p><p>在 <a href="https://stackoverflow.com/questions/62990972/why-is-opengl-giving-me-the-error-error-01-version-330-is-not-support">stackoverflow</a> 有人遇到了相同的问题，解决方法如下：</p><ol><li>add these line of code in front of <code>glCreateWindow</code></li><li>add VAO as @Ali ASkari memtion above (Modern OpenGL requires a VAO be defined and bound if you are using the core profile.)</li></ol><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// GLEW</span><br><span class="line">#include &lt;glew.h&gt;</span><br><span class="line"></span><br><span class="line">// GLFW</span><br><span class="line">#include &lt;glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">static unsigned int CompileShader(unsigned int type, const std::string&amp; source)</span><br><span class="line">{</span><br><span class="line">    unsigned int id = glCreateShader(type);</span><br><span class="line">    const char* src = source.c_str();</span><br><span class="line">    glShaderSource(id, 1, &amp;src, nullptr);</span><br><span class="line">    glCompileShader(id);</span><br><span class="line"></span><br><span class="line">    // TODO: Error handling</span><br><span class="line">    int result;</span><br><span class="line">    glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    if (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        int length;</span><br><span class="line">        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">        char* message = (char*)alloca(length * sizeof(char));</span><br><span class="line">        glGetShaderInfoLog(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "Failed to complie " &lt;&lt; (type == GL_VERTEX_SHADER ? "vertex" : "fragment") &lt;&lt; "shader!" &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        glDeleteShader(id);</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">static unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader)</span><br><span class="line">{</span><br><span class="line">    unsigned int program = glCreateProgram();</span><br><span class="line">    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    glAttachShader(program, vs);</span><br><span class="line">    glAttachShader(program, fs);</span><br><span class="line">    glLinkProgram(program);</span><br><span class="line">    glValidateProgram(program);</span><br><span class="line"></span><br><span class="line">    glDeleteShader(vs);</span><br><span class="line">    glDeleteShader(fs);</span><br><span class="line"></span><br><span class="line">    return program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    /* Initialize the library */</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">    if(!glfwInit())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span></span><br><span class="line"><span class="addition">+   #ifdef __APPLE__</span></span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; "I'm apple machine" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+       glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line"><span class="addition">+   #endif</span></span><br><span class="line">    unsigned int width = 800;</span><br><span class="line">    unsigned int height = 600;</span><br><span class="line">    /* Create a Windowed mode and its OpenGL context */</span><br><span class="line">    window = glfwCreateWindow(width, height, "Hello World", NULL, NULL);</span><br><span class="line">    if(!window)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; " can't create window!!!" &lt;&lt; std::endl;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    unsigned int major = glfwGetWindowAttrib(window, GLFW_CONTEXT_VERSION_MAJOR);</span><br><span class="line">    unsigned int minor = glfwGetWindowAttrib(window, GLFW_CONTEXT_VERSION_MINOR);</span><br><span class="line">    std::cout &lt;&lt; "opengl shader version: " &lt;&lt; major &lt;&lt; "." &lt;&lt; minor &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    /* Make the window's context current */</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(glewInit() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    float positions[6] = {</span><br><span class="line">            -0.5f, -0.5f,</span><br><span class="line">             0.0f,  0.5f,</span><br><span class="line">             0.5f, -0.5f</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="addition">+   unsigned int VBO, VAO;</span></span><br><span class="line"><span class="addition">+   glGenBuffers(1, &amp;VBO);</span></span><br><span class="line"><span class="addition">+   glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="addition">+   glBindVertexArray(VAO);</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glEnableVertexAttribArray(0);</span><br><span class="line">    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);</span><br><span class="line"></span><br><span class="line">    std::string vertexShader = R"(</span><br><span class="line">        #version 330 core</span><br><span class="line"></span><br><span class="line">        layout(location = 0) in vec4 position;</span><br><span class="line"></span><br><span class="line">        void main()</span><br><span class="line">        {</span><br><span class="line">            gl_Position = position;</span><br><span class="line">        }</span><br><span class="line">    )";</span><br><span class="line"></span><br><span class="line">    std::string fragmentShader = R"(</span><br><span class="line">        #version 330 core</span><br><span class="line"></span><br><span class="line">        layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line">        void main()</span><br><span class="line">        {</span><br><span class="line">            color = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">        }</span><br><span class="line">    )";</span><br><span class="line"></span><br><span class="line">    unsigned int shader = CreateShader(vertexShader, fragmentShader);</span><br><span class="line">    glUseProgram(shader);</span><br><span class="line"></span><br><span class="line">    /* Loop until the user closes the window */</span><br><span class="line">    while(!glfwWindowShouldClose(window))</span><br><span class="line">    {</span><br><span class="line">        /* Render here */</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line"></span><br><span class="line">        /* Swap front and back buffers */</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        /* Poll for and events */</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="addition">+   glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line">    glDeleteProgram(shader);</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519190823652.png"></p><h3 id="OpenGL中如何处理着色器"><a href="#OpenGL中如何处理着色器" class="headerlink" title="OpenGL中如何处理着色器"></a>OpenGL中如何处理着色器</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=8&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>个人习惯将两个着色器合并到一个只有顶点和片段着色器的文件中。不管怎样，让我们进入代码展示这一切的原理。</p><h4 id="着色器合并"><a href="#着色器合并" class="headerlink" title="着色器合并"></a>着色器合并</h4><p>首先我们实际上要做的是创建一个包含这两个着色器的文件，以便我们了解是如何处理它们的。</p><p>在项目目录中创建一个放置资源的 <code>res</code> 文件夹，在该文件夹下创建专门放置着色器的 <code>shaders</code> 文件夹，在之后我们可能会有像纹理之类的其他资源。最后在 <code>shaders/</code> 下新建文件 <code>Basic.shader</code>：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220519194358890.png"></p><p>现在我们有了一个着色器文本，你可以看到它没有显示 C++ 图标，这非常重要因为我们不想把它编译成 C++ 代码。将之前的着色器代码复制粘贴到文件中：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">gl_Position</span> = position;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment    </span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    color = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们就无需在两个不同的着色器文件之间切换，并且很简单干净有条理。</p><h4 id="着色器读取与使用"><a href="#着色器读取与使用" class="headerlink" title="着色器读取与使用"></a>着色器读取与使用</h4><p>下面我们要做的就是读取这个文件，然后把它分成两块字符串，一个是我们的片段着色器，而另一个就是我们的顶点着色器源码。引入头文件 <code>#include&lt;fstream&gt;</code>，打开文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::fstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以现在我们需要做的就是一行一行地浏览那个文件，然后只去检查是否是指定的着色器类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">            <span class="comment">// set mode to vertex</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>添加着色器类型并在分支设定正确的类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">    NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">            type = ShaderType::VERTEX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">            type = ShaderType::FRAGMENT;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;            </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">std::string VertexSource;</span><br><span class="line">std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::VERTEX;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::FRAGMENT;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line"><span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 Mac 出现的各种错误太多了，相同代码跑不通太浪费时间了，所以还是转到了 Windows 上：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521172242769.png"></p><h3 id="OpenGL中的索引缓冲区"><a href="#OpenGL中的索引缓冲区" class="headerlink" title="OpenGL中的索引缓冲区"></a>OpenGL中的索引缓冲区</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=9&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们会讨论索引缓冲区。</p><h4 id="绘制四边形"><a href="#绘制四边形" class="headerlink" title="绘制四边形"></a>绘制四边形</h4><p>在我们讨论索引缓冲区为什么用它以及它到底是什么之前，让我们先考虑一个图形编程的基础的问题：去画一个正方形。</p><p>显然我们可以通过拼接两个三角形实现，先画出来第一个三角形：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521184045420.png"></p><p>回到我们的代码增加另一个三角形的三个顶点（其中两个顶点与第一个三角形重合）：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+float positions[12] = {</span></span><br><span class="line">    -0.5f, -0.5f,</span><br><span class="line">     0.5f, -0.5f,</span><br><span class="line">     0.5f,  0.5f,</span><br><span class="line"></span><br><span class="line"><span class="addition">+    0.5f,  0.5f,</span></span><br><span class="line"><span class="addition">+   -0.5f,  0.5f,</span></span><br><span class="line"><span class="addition">+   -0.5f, -0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>同时更改一下缓冲区的设置：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">unsigned int buffer;</span><br><span class="line">glGenBuffers(1, &amp;buffer);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="addition">+glBufferData(GL_ARRAY_BUFFER, 6 * 2 * sizeof(float), positions, GL_STATIC_DRAW);</span></span><br></pre></td></tr></tbody></table></figure><p>由于我们绘制的是六个顶点，所以这里也要改：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220521185412152.png"></p><p>这里不是正方形的原因是因为窗口原因。</p><p>很酷！我们已经画出了一个正方形，它并不太难，但是绘制这个正方形的方式有些东西不太理想：我们的两个顶点是完全一样的，也就是在复制我们的内存，我们在显存中存储相同顶点的相同字节，存储了多次。因为显存并不是无限的，而我们想要降低它的内存使用。</p><h4 id="索引缓冲区"><a href="#索引缓冲区" class="headerlink" title="索引缓冲区"></a>索引缓冲区</h4><p>所以我们能做的就是使用一个叫做索引缓冲区的东西，这允许我们重用现有的顶点。对于矩形或者正方形而言可能还好，它看起来可能并不浪费，因为它没有太多的东西。然而当它换成游戏中的 3D 模型如宇宙飞船，每一个组成那个飞船的独立三角形会被连接到另一个三角形，这意味着你已经立马重复了至少两个顶点，每个顶点再包含法线、切线、纹理坐标的数据，那么你不得不复制整个缓冲区，它一次又一次地构成了那个实际的顶点，那是完全不现实的。</p><p>让我们来转换一下这种顶点缓冲，添加一个索引缓冲区并删除那些重复的冗余内存。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着创建一个无符号整型数组 <code>indices</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 0</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 1</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>,<span class="comment">// 2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span><span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这实际就是一个索引缓冲区，我们需要说明 OpenGL 如何去渲染这个三角形或者正方形，而不是给它提供冗余或重复的顶点位置。在这个例子中我们只有位置，但实际应用中可能会有更多的数据。</p><p>现在我们需要把它们发送到显卡上，并且告诉 OpenGL 用它们去渲染。而我们实现的方式非常类似于创建顶点缓冲区：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure><p><code>ibo</code> 代表索引缓冲区对象，表示这个特定的索引缓冲区。这里唯一的区别是把 <code>GL_ARRAY_BUFFER</code> 换为 <code>GL_ELEMENT_ARRAY_BUFFER</code>，<code>positions</code> 替换为之前的 <code>indices</code>。</p><p>需要说明一下我们会在所有这些例子中使用 <code>unsigned int</code>，因为在这种情况下不会有任何的性能差异，这里的关键是必须使用无符号类型。</p><br><p>最后需要改变的是我们的 DrawCall：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line"><span class="addition">+glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</span></span><br></pre></td></tr></tbody></table></figure><p><code>count</code> 就是我们需要绘制的 6 个索引，绘制索引的数量而非我们绘制顶点的数量；<code>type</code> 就是在索引缓冲区中的数据类型，在本例中是 <code>GL_UNSIGNED_INT</code>；最后是指向那个索引缓冲区的指针，而前面我们已经绑定了 <code>ibo</code>，所以这里可以填 <code>nullptr</code>。这就是我们绘制三角形的实际 DrawCall 指令。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523105558657.png"></p><p>运行程序，你可以看到我们得到了一个漂亮的矩形。</p><p>我们已经删除了任何重复的顶点，在顶点缓冲区中得到了完全唯一的顶点，之后创建了一个索引以便多次绘制顶点；然后我们用 <code>ibo</code> 绑定代码把索引缓冲区发送给显卡；最终我们使用 <code>glDrawElements()</code> 绘制图形。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">std::string VertexSource;</span><br><span class="line">std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::VERTEX;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::FRAGMENT;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line"><span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 0</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 1</span></span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>,<span class="comment">// 2</span></span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span><span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenGL中处理错误"><a href="#OpenGL中处理错误" class="headerlink" title="OpenGL中处理错误"></a>OpenGL中处理错误</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=10&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们要讨论的都是错误，我们怎么知道我们做错了什么以及如何尽快地调试并修复它。</p><h4 id="glGetError"><a href="#glGetError" class="headerlink" title="glGetError"></a>glGetError</h4><p>我们有两种主要的方式来检查 OpenGL 中的错误，其中一个一个叫做 <code>glGetError()</code>，它是一个我们可以调用的 OpenGL 内置函数。它能够兼容所有版本并且原理相对简单：在我们调用 OpenGL 时如果发生错误，内存中有一个标志会被内部设置，其会说明发生了什么类型的错误，并且当我们调用 <code>glGetError()</code> 时它会返回一个标志（或者说错误码）。如果我们继续调用 <code>glGetError()</code> 它会把所有标志返回给我们，因为我们可能会产生多个类型的错误。</p><br><p>回到上次渲染正方形的代码，我们可以更改索引缓冲区类型导致错误：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</span></span><br><span class="line"><span class="addition">+glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523155149402.png"></p><p>可以看到小小的改动得到的就是黑屏，我们的矩形根本没有渲染，这太糟糕了。</p><h4 id="glDebugMessageCallback"><a href="#glDebugMessageCallback" class="headerlink" title="glDebugMessageCallback"></a>glDebugMessageCallback</h4><p>在最近的 OpenGL 4.3 中添加了一个新的函数 <code>glDebugMessageCallback()</code>。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523163539153.png"></p><p>查阅文档，可以发现它允许我们指定一个指向 OpenGL 的函数指针，当错误发生时 OpenGL 会调用我们的那个函数。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523163715052.png"></p><p>唯一的问题在于兼容性，它只在 4.3 及以上版本，所以你不能再早期版本中使用它。优点也很明显，它不会仅仅给你一个错误码，会提供更详细的信息。根据我的经验， <code>glDebugMessageCallback()</code> 总体上非常好，比 <code>glGetError()</code> 好得多。但今天我们只讨论 <code>glGetError()</code>。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523165538131.png"></p><p>可以创建一个循环调用的报错函数 <code>GLClearError()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// while (glGetError() != GL_NO_ERROR);</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glGetError</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来创建另一个打印出实际错误的函数 <code>GLCheckError()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在让我们调用一下刚才的函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+GLClearError();</span></span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span><br><span class="line"><span class="addition">+GLCheckError();</span></span><br></pre></td></tr></tbody></table></figure><p>首先排除其他的错误，相当于调试的断言。通过这样的方式我们可以确保所有的错误实际上都是来自这个函数。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220523201100782.png"></p><p>可以看到错误代码是 1280。在源码中搜索 1280 找不到任何东西，因为 OpenGL 采用的是十六进制表示错误码。所以我们可以换为十六进制：0x0500。再返回 <code>&lt;glew.h&gt;</code> 文件检索：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL_INVALID_ENUM 0x0500</span></span><br></pre></td></tr></tbody></table></figure><p>500 意味着无效的枚举，而 <code>GL_INT</code>确实是我们实际传递的无效枚举，它应该是无符号整型。</p><p>实际上 <code>glClearError()</code> 和 <code>glCheckError()</code> 还是比较笨重，并且让扩展变得更加困难。但我们实际上可以做的就是得到实际的调试器，暂时执行并在导致错误的代码行上中断。我们可以通过使用断言来实现这一点，如果那个条件是 false，你通常要么将消息写入控制台，要么只是停止程序的执行并且在那行中断。</p><p>为此我需要修改 <code>GLCheckError()</code> 变为 <code>GLLogCall()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着在头文件下面定义宏断言：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  ASSERT(x) <span class="keyword">if</span> (!(x))   __debugbreak();</span></span><br></pre></td></tr></tbody></table></figure><p>这是 MSVC 特有的，在 clang、gcc 或者其他编译器中都不起作用。最后插入断言：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">GLClearError();</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span><br><span class="line"><span class="deletion">-GLCheckError();</span></span><br><span class="line"><span class="addition">+ASSERT(GLLogCall());</span></span><br></pre></td></tr></tbody></table></figure><p>为了方便起见定义宏 <code>GLCall()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError(); x; ASSERT(GLLogCall())</span></span><br></pre></td></tr></tbody></table></figure><p>更改调用：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/e6c9d24egy1h2lt68j6klj211x0kiq6s-20220526221235055.jpg"></p><p>最后加一些调试信息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError();  x;  ASSERT(GLLogCall(#x, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">"): "</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">" "</span> &lt;&lt; file &lt;&lt; <span class="string">":"</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/3H98MK.png"></p><h3 id="OpenGL中的统一变量"><a href="#OpenGL中的统一变量" class="headerlink" title="OpenGL中的统一变量"></a>OpenGL中的统一变量</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=11&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们要讨论的是统一变量。</p><p>那么首先统一变量是一个非常单一的概念，它对于我们而言实际上是一种从 CPU 端获取数据的方式。在本例中是从 C++ 到我们的着色器，所以我们实际上把它当一个变量使用。</p><h4 id="颜色变量"><a href="#颜色变量" class="headerlink" title="颜色变量"></a>颜色变量</h4><p>回到着色器我们创建一个 <code>u_Color</code> 并赋值：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="addition">+uniform vec4 u_Color;</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line"><span class="deletion">-   color = vec4(0.0, 0.2, 0.8, 1.0);</span></span><br><span class="line"><span class="addition">+   color = u_Color;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每个统一变量都有一个 id，这样我们就可以引用它了。而我们查找 id 的方式通常是通过它的名称，所以我们基本上就是问我们的着色器 <code>u_Color</code> 变量的位置。</p><p>在更现代的 OpenGL 版本，你实际上可以设置和索引。所以从 4.3 开始你可以指定一个明确的统一变量位置，这是一种非常现代的新功能。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">ShaderProgramSource source = ParseShader("res/shader/basic.shader");</span><br><span class="line">unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);</span><br><span class="line">GLCall(glUseProgram(shader));</span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(int location = glGetUniformLocation(shader, "u_Color"));</span></span><br><span class="line"><span class="addition">+ASSERT(location != -1);</span></span><br><span class="line"><span class="addition">+GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line"></span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><p>总结一下，我通过使用实际的着色器 id 编写 <code>glUseProgram()</code> 绑定着色器，获取这个颜色变量的实际位置。而当我获取那个位置的时候，就调用 <code>glUniform4f()</code> 在着色器中设置我的数据。如果一切顺利，我应该将这个颜色值写入我的矩形每个像素的实际输出颜色：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/VJAoqd.png"></p><p>可以看到我们得到了与之前完全相同的结果，为了区分明显一点修改颜色：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line"><span class="addition">+GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/R9IiGp.png"></p><h4 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h4><p>好了，那么现在做点更令人兴奋的事情吧：让我们这个颜色动起来并且在渲染循环中随时间改变它。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+float r = 0.0f;</span></span><br><span class="line"><span class="addition">+float increment = 0.05f;</span></span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line">GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span><br><span class="line"></span><br><span class="line"><span class="addition">+if (r &gt; 1.0f)</span></span><br><span class="line"><span class="addition">+increment = -0.05f;</span></span><br><span class="line"><span class="addition">+else if (r &lt; 0.0f)</span></span><br><span class="line"><span class="addition">+increment = 0.05f;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+r += increment;</span></span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">GLCall(glDeleteProgram(shader));</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行程序会发现颜色变化比较快，因为我们没有限制帧率：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"><span class="addition">+glfwSwapInterval(1);</span></span><br></pre></td></tr></tbody></table></figure><p>该设置可以同步我们主频的帧率，得到更平滑的动画。</p><h3 id="OpenGL中的顶点数组"><a href="#OpenGL中的顶点数组" class="headerlink" title="OpenGL中的顶点数组"></a>OpenGL中的顶点数组</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=12&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们会讲 OpenGL 的顶点数组。</p><p>我们讲了很多 OpenGL 的基本概念甚至一般的图形编程，但 OpenGL 实际上有一个顶点数组。乍一看你可能会说顶点数组、顶点缓冲区它们之间的区别是什么，它们听起来非常相似。确实如此，并且这并不是 DirectX 等其他渲染接口中真正存在的东西，它是 OpenGL 独有的，也可以说是 OpenGL 的一个原始接口。它们基本上是一种通过特定的规范绑定顶点缓冲区的方式，用于实际顶点缓冲区的布局。</p><p>在我们的代码中，我们创建了 <code>buffer</code> 包含所有的顶点数据，然后创建缓冲区之后也做了绑定，启用了顶点属性指定实际数据的布局。现在一个顶点数组对象允许我们通过 <code>glVertexAttribArray()</code> 绑定指定的顶点规范到实际的顶点缓冲区，可能对于 OpenGL 的初学者比较难以理解，如果屏幕上有多个对象、多个网格、多个顶点缓冲区，需要我们绑定顶点和索引缓冲区，然后绘制实际的对象。</p><p>但我们绑定顶点缓冲区之后，我们实际也需要指定布局，让我们看看解绑一切会发生什么：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">GLCall(int location = glGetUniformLocation(shader, "u_Color"));</span><br><span class="line">ASSERT(location != -1);</span><br><span class="line">GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(glUseProgram(0));</span></span><br><span class="line"><span class="addition">+GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));</span></span><br><span class="line"><span class="addition">+GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));</span></span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line">/* Loop until the user closes the window */</span><br></pre></td></tr></tbody></table></figure><p>这里我基本上解绑了所有的东西，到了绘制的时候我们需要实际上绑定我们需要的所有东西，让 DrawCall 工作以此正确渲染所有东西：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">GLCall(glUseProgram(shader));</span><br><span class="line">GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));</span></span><br><span class="line"><span class="addition">+GLCall(glEnableVertexAttribArray(0));</span></span><br><span class="line"><span class="addition">+GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span></span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们绑定着色器，设置统一变量，绑定顶点缓冲区，设置顶点缓冲区的布局，最后绑定索引缓冲区调用 <code>glDrawElements()</code>。运行这段代码看看会发生什么：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/m3fzfo.png"></p><p>得到了和之前一样的结果，完美。这里值得商榷的是这里：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><p>我们是否每次都要这样做？答案是肯定的，因为如果我们用不同的布局绘制另一个对象，它们可能已经改变了。所以顶点数组对象实际上就是包含这种状态的对象，因此如果我们正确地利用顶点数组对象例如为几何体的每个部分创建不同的顶点数组对象，然后只需要绑定顶点数组对象就完事儿了，因为顶点数组对象将包含顶点缓冲区之间的绑定、布局。</p><p>因此，我们的绘制方式从绑定我们的着色器、绑定我们的顶点缓冲区、设置顶点布局、绑定我们的索引缓冲区、然后发出实际的 DrawCall 指令变为了绑定我们的着色器、<strong>绑定顶点数组</strong>、绑定索引缓冲区、最终发出实际的 DrawCall 指令。所以绑定顶点缓冲区并设置其布局变为了绑定顶点数组对象，因为它包含了我们实际需要的所有状态。</p><br><p>我需要在这里提一件事情，从技术上讲顶点数组对象是必须的，它们现在正在被使用，这就是为什么我说即使我们没有创建它们这个状态仍由顶点数组对象保持。这个东西是 OpenGL 兼容性配置文件，默认情况下兼容性配置文件实际上为我们创建了一个顶点数组对象。</p><h3 id="抽象顶点索引缓冲区成类"><a href="#抽象顶点索引缓冲区成类" class="headerlink" title="抽象顶点索引缓冲区成类"></a>抽象顶点索引缓冲区成类</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=13&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenGL中的缓冲区和布局的抽象"><a href="#OpenGL中的缓冲区和布局的抽象" class="headerlink" title="OpenGL中的缓冲区和布局的抽象"></a>OpenGL中的缓冲区和布局的抽象</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=14&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenG中抽象着色器"><a href="#OpenG中抽象着色器" class="headerlink" title="OpenG中抽象着色器"></a>OpenG中抽象着色器</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=15&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenGL写一个基础的渲染器类"><a href="#OpenGL写一个基础的渲染器类" class="headerlink" title="OpenGL写一个基础的渲染器类"></a>OpenGL写一个基础的渲染器类</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=16&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenGL中的纹理"><a href="#OpenGL中的纹理" class="headerlink" title="OpenGL中的纹理"></a>OpenGL中的纹理</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=17&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenGL中的混合"><a href="#OpenGL中的混合" class="headerlink" title="OpenGL中的混合"></a>OpenGL中的混合</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=18&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenGL中的数学"><a href="#OpenGL中的数学" class="headerlink" title="OpenGL中的数学"></a>OpenGL中的数学</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=19&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenGL中的投影矩阵"><a href="#OpenGL中的投影矩阵" class="headerlink" title="OpenGL中的投影矩阵"></a>OpenGL中的投影矩阵</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=20&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenGL中的模型视图投影矩阵"><a href="#OpenGL中的模型视图投影矩阵" class="headerlink" title="OpenGL中的模型视图投影矩阵"></a>OpenGL中的模型视图投影矩阵</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=21&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="OpenGL中的ImGui"><a href="#OpenGL中的ImGui" class="headerlink" title="OpenGL中的ImGui"></a>OpenGL中的ImGui</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=22&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="批量渲染对象"><a href="#批量渲染对象" class="headerlink" title="批量渲染对象"></a>批量渲染对象</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=23&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="为OpenGL建立一个测试框架"><a href="#为OpenGL建立一个测试框架" class="headerlink" title="为OpenGL建立一个测试框架"></a>为OpenGL建立一个测试框架</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=24&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=25&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="创建一个纹理测试"><a href="#创建一个纹理测试" class="headerlink" title="创建一个纹理测试"></a>创建一个纹理测试</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=26&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="如何让统一变量更快"><a href="#如何让统一变量更快" class="headerlink" title="如何让统一变量更快"></a>如何让统一变量更快</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=27&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="批渲染"><a href="#批渲染" class="headerlink" title="批渲染"></a>批渲染</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=28&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=29&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=30&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="动态几何"><a href="#动态几何" class="headerlink" title="动态几何"></a>动态几何</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=31&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=32&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="挑战一小时完成批渲染器"><a href="#挑战一小时完成批渲染器" class="headerlink" title="挑战一小时完成批渲染器"></a>挑战一小时完成批渲染器</h3><iframe src="//player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=33&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/geexlab-opengl-21-demopack-20190921.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。&lt;/p&gt;</summary>
    
    
    
    <category term="Cherno的C++笔记 (Cherno C++)" scheme="https://yousazoe.top/categories/Cherno%E7%9A%84C-%E7%AC%94%E8%AE%B0-Cherno-C/"/>
    
    
    <category term="OpenGL" scheme="https://yousazoe.top/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>如何用很短的代码创造「秋日氛围感」？</title>
    <link href="https://yousazoe.top/archives/781b26a.html"/>
    <id>https://yousazoe.top/archives/781b26a.html</id>
    <published>2022-05-07T13:00:37.000Z</published>
    <updated>2022-07-01T09:23:45.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/view3.jpg"></p><span id="more"></span><h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>两三个月前，我和匡冶去上海出差，周日下午坐高铁回北京。忙活了一周，我们俩都精疲力竭地坐在高铁上。还有 3 个小时才到北京，不如写点代码消磨时间，也算放松一下身心。正好聊到 Minecraft （“别人的世界”） 和 MagicaVoxel，于是我们决定来个 Hackathon，用 Taichi 整个 GPU 光线追踪体素渲染器。在快到北京南站之前，我们有了第一版雏形：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507213539823.gif"></p><p>Taichi 是嵌入在 Python 中的并行编程语言，这使得我们的渲染器几乎可以在任何操作系统上运行，并且和 Python 很容易地交互。据我们所知，目前 Python 生态系统里面还没有工具能够实现跨平台的 GPU 光线追踪体素渲染器。Taichi 只需要大约 300 行代码就可以实现这个渲染器 ¹。</p><p>写完代码，我们才发现一个更严峻的问题：对我们老图形程序员来说，造个光线追踪渲染器容易，渲染出好看的图反而更难。加上写 UI 是个工作量很大的事情，我们只支持一个体素一个体素地编辑，这得猴年马月才能做出想要的结果…</p><p>好在 “批量操作体素” 这个事情本身也是可以写代码完成的。Minecraft 大神们可以用各种搭建技法创建自己的体素世界，咱没那个技法，要不直接写代码生成吧！开动！</p><h3 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h3><p>做任何事情之前先要有个美好的愿景，才能确保自己在正确的方向上。在网上找了一些 Voxel 大佬的艺术作品，发现森林是一个常见题材。于是我找了找森林的照片，找到一张秋天的，意境很不错：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220507210543397.png"></p><p>于是我决定照着这张照片和一些体素艺术家的作品，还原一个秋天的场景，再用光线追踪渲染出来，应该会挺有意思~</p><p>以下内容只需要一些基础的 Python 知识就可以阅读。Taichi 是一个嵌入在 Python 中的编程语言，能够让你的程序被 GPU 加速。</p><h3 id="运行代码，3D-漫游！"><a href="#运行代码，3D-漫游！" class="headerlink" title="运行代码，3D 漫游！"></a>运行代码，3D 漫游！</h3><p>Follow 完这篇教程，你会得到一个 3D 场景并在里面漫游。代码是跨平台的，我的 Macbook 笔记本上也可以运行（20 FPS）。如果你有 RTX 3090 之类的核武器那运行得会更流畅。我的笔记本上移动相机的时候会稍有噪点，停下来很快就收敛了。</p><p>如果你想体验这个场景，浏览完整的 91 行代码，可以 clone 作品仓库 ²。如果你想创建自己的场景，可以从我们的模板仓库 ³ 开始。</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzkzNDI3NDY4Mw==&amp;mid=2247493185&amp;idx=1&amp;sn=3a51e2134ccc671bac407342d5e4fa0f&amp;chksm=c2bd1555f5ca9c434a224a3339cea37a24d00d532e35a99a46be2531b9156f7d3a50dd167641&amp;scene=21#wechat_redirect">首届 Taichi 体素创意大赛</a>正在如火如荼地进行，更多规则请见 GitHub，欢迎有兴趣的同学参加，一起切磋代码技能。</p><p>*另外有同学反馈表示 1.0.1 在某些环境上有些 Vulkan 兼容性的问题，使用 1.0.0 就可以解决。输入命令行 pip install taichi==1.0.0 即可。同时，这个 bug 已经修复了，下一个版本会 ship 这个 bug fix。</p><p>*相关 issue：<a href="https://github.com/taichi-dev/taichi/issues/4891">https://github.com/taichi-dev/taichi/issues/4891</a></p><h3 id="用体素搭建秋日小树林"><a href="#用体素搭建秋日小树林" class="headerlink" title="用体素搭建秋日小树林"></a>用体素搭建秋日小树林</h3><p>先分析一下“愿景图”，里面有几个关键元素：枫(?)树，铺满落叶的地面和体积雾。我们的渲染器并不支持体积雾，好在我们可以用一个 45° 的斜阳（directional_light）加上偏黄的色温来模拟这个场景。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scene <span class="keyword">import</span> Scene</span><br><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line"><span class="keyword">from</span> taichi.math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">scene = Scene(voxel_edges=<span class="number">0</span>, exposure=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 创建场景，指定体素描边宽度和曝光值</span></span><br><span class="line">scene.set_floor(<span class="number">0</span>, (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line"><span class="comment"># 地面高度</span></span><br><span class="line">scene.set_background_color((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.4</span>))</span><br><span class="line"><span class="comment"># 天空颜色</span></span><br><span class="line">scene.set_directional_light((<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>), <span class="number">0.2</span>, (<span class="number">1</span>, <span class="number">0.8</span>, <span class="number">0.6</span>))</span><br><span class="line"><span class="comment"># 光线方向和颜色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_voxels</span>():</span><br><span class="line">    scene.set_voxel(vec3(<span class="number">0</span>), <span class="number">1</span>, vec3(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 在 (0, 0, 0) 加入一个白色 (1, 1, 1) 的体素！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">initialize_voxels()</span><br><span class="line"></span><br><span class="line">scene.finish()</span><br></pre></td></tr></tbody></table></figure><p>你就能得到如下场景：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/TAICHI-V1-0.png"></p><h4 id="基座"><a href="#基座" class="headerlink" title="基座"></a><strong>基座</strong></h4><p>看了几个大佬的体素作品，发现他们常用的一个技法是 “蛋糕切块”，也就是通过截面表现一些平时不容易看到的东西，比如说土地内部的结构，作为作品的基座：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211542014.png"></p><p>那我们依葫芦画瓢，做一个泥土的基座。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211604350.png"></p><p>其实也不是太难，我们一层一层来。如果只考虑相同颜色的一层，那其实就是一个立方体，带上一些随机性。</p><p>我们首先要实现一个函数，来生成一个从 (pos[0], pos[1], pos[2]) 开始，大小是 size[0] x size[1] x size[2] 的立方体。当然，我们可以指定颜色 color。为了增加真实感，我们不能让这个立方体看起来太完美，所以加上一些噪声 color_noise：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_block</span>(<span class="params">pos, size, color, color_noise</span>):</span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> ti.grouped(</span><br><span class="line">            ti.ndrange((pos[<span class="number">0</span>], pos[<span class="number">0</span>] + size[<span class="number">0</span>]),</span><br><span class="line">                       (pos[<span class="number">1</span>], pos[<span class="number">1</span>] + size[<span class="number">1</span>]),</span><br><span class="line">                       (pos[<span class="number">2</span>], pos[<span class="number">2</span>] + size[<span class="number">2</span>]))):</span><br><span class="line">        scene.set_voxel(I, <span class="number">1</span>, color + color_noise * ti.random())</span><br></pre></td></tr></tbody></table></figure><p>这里利用过了一个技巧：<code>ti.ndrange</code>，它能够在一行中实现一个多层 for 循环（否则要写 3 层 for loop，比较麻烦）。配上 <code>ti.grouped</code>，我们将 <code>i</code>, <code>j</code>, <code>k</code> 三个循环变量塞到一个向量 <code>I = (i, j, k)</code> 里面。</p><p>有了这个函数，我们就可以绘制一个大大的方块：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_voxels</span>():</span><br><span class="line">    create_block(pos=ivec3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                 size=ivec3(<span class="number">20</span>, <span class="number">40</span>, <span class="number">30</span>),</span><br><span class="line">                 color=vec3(<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.3</span>),</span><br><span class="line">                 color_noise=vec3(<span class="number">0.1</span>))</span><br></pre></td></tr></tbody></table></figure><p>注意</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211835057.png"></p><p>紧接着，我们只要用一个 4 层的 for 循环，把每一层绘制出来：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_voxels</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        create_block(ivec3(-<span class="number">60</span>, -(i + <span class="number">1</span>)**<span class="number">2</span> - <span class="number">40</span>, -<span class="number">60</span>),</span><br><span class="line">                     ivec3(<span class="number">120</span>, <span class="number">2</span> * i + <span class="number">1</span>, <span class="number">120</span>),</span><br><span class="line">                     vec3(<span class="number">0.5</span> - i * <span class="number">0.1</span>) * vec3(<span class="number">1.0</span>, <span class="number">0.8</span>, <span class="number">0.6</span>),</span><br><span class="line">                     vec3(<span class="number">0.05</span> * (<span class="number">3</span> - i)))</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211903427.png"></p><p>现在有个问题：地表颜色有点淡，我们来加一层地表：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211924785.png"></p><p>好的，说回来，我们并不是在做蛋糕，但是这个蛋糕形状的底座作为整个作品的基座还是不错的。于是，我们的基座就这样完成了！</p><h4 id="树和落叶"><a href="#树和落叶" class="headerlink" title="树和落叶"></a>树和落叶</h4><p>有了基座，我们来点树。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211952667.png"></p><p>首先，因为我们有很多树，代码行数也有限，我们需要有个画树的函数：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_tree</span>(<span class="params">pos, height, radius, color</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><p>四个参数：</p><ul><li><code>pos</code>: 树根的位置</li><li><code>height</code>：树的高度</li><li><code>radius</code>：树叶半径</li><li><code>color</code>：树叶颜色</li></ul><p>我们一步步来。先搞个树干。这个比较简单，reuse 我们之前的 <code>create_block</code> 就好：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_tree</span>(<span class="params">pos, height, radius, color</span>):</span><br><span class="line">    create_block(pos, ivec3(<span class="number">3</span>, height - radius * <span class="number">0.5</span>, <span class="number">3</span>), vec3(<span class="number">0.7</span>), vec3(<span class="number">0.3</span>))</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212119872.png"></p><p>只有光秃秃的树干好像还有些枯燥。我们来加点叶子。这里我们加一个函数。先假设一棵树的叶子分布的区域是一个圆柱，圆柱中的每一个 voxel 都有一定概率存在或者不存在。我们希望这个概率离圆柱重心越远，就越小。于是我们得到了下面这个函数：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_leaves</span>(<span class="params">pos, radius, color</span>):</span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> ti.grouped(</span><br><span class="line">            ti.ndrange((-radius, radius), (-radius, radius),</span><br><span class="line">                       (-radius, +radius))):</span><br><span class="line">        f = I / radius</span><br><span class="line">        d = vec2(f[<span class="number">0</span>], f[<span class="number">2</span>]).norm() <span class="comment"># 到圆柱中轴线的距离</span></span><br><span class="line">        prob = <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span> - d)**<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> ti.random() &lt; prob:</span><br><span class="line">            scene.set_voxel(pos + I, <span class="number">1</span>, color + (ti.random() - <span class="number">0.5</span>) * <span class="number">0.2</span>)</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212148520.png"></p><p>好吧，看起来不是很自然… 通过一些脑补出来的数学函数和一些噪声，我们稍微优化一下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_leaves</span>(<span class="params">pos, radius, color</span>):</span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> ti.grouped(</span><br><span class="line">            ti.ndrange((-radius, radius), (-radius, radius),</span><br><span class="line">                       (-radius, +radius))):</span><br><span class="line">        f = I / radius</span><br><span class="line">        h = <span class="number">0.5</span> - <span class="built_in">max</span>(f[<span class="number">1</span>], -<span class="number">0.5</span>) * <span class="number">0.5</span></span><br><span class="line">        d = vec2(f[<span class="number">0</span>], f[<span class="number">2</span>]).norm()</span><br><span class="line">        prob = <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span> - d)**<span class="number">2</span> * h  <span class="comment"># xz mask</span></span><br><span class="line">        prob *= h  <span class="comment"># y mask</span></span><br><span class="line">        <span class="comment"># noise</span></span><br><span class="line">        prob += ti.sin(f[<span class="number">0</span>] * <span class="number">5</span> + pos[<span class="number">0</span>]) * <span class="number">0.02</span></span><br><span class="line">        prob += ti.sin(f[<span class="number">1</span>] * <span class="number">9</span> + pos[<span class="number">1</span>]) * <span class="number">0.01</span></span><br><span class="line">        prob += ti.sin(f[<span class="number">2</span>] * <span class="number">10</span> + pos[<span class="number">2</span>]) * <span class="number">0.03</span></span><br><span class="line">        <span class="keyword">if</span> prob &lt; <span class="number">0.1</span>:</span><br><span class="line">            prob = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">if</span> ti.random() &lt; prob:</span><br><span class="line">            scene.set_voxel(pos + I, <span class="number">1</span>, color + (ti.random() - <span class="number">0.5</span>) * <span class="number">0.2</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个函数还有些复杂，但是整体的思路是对于树叶区域的每个体素，计算一个概率，概率和这个体素在空间中的位置有一些关系，还有一些噪声。加上其他细节，就大功告成啦！</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212259763.png"></p><p>我们只要多调用几次 create_tree，就有了一片小树林。注意优化一下每棵树的位置、高度、颜色：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">create_tree(ivec3(-<span class="number">20</span>, -<span class="number">40</span>, <span class="number">25</span>), <span class="number">65</span>, <span class="number">35</span>, vec3(<span class="number">1.0</span>, <span class="number">0.3</span>, <span class="number">0.15</span>))</span><br><span class="line">create_tree(ivec3(<span class="number">45</span>, -<span class="number">40</span>, -<span class="number">45</span>), <span class="number">15</span>, <span class="number">10</span>, vec3(<span class="number">0.8</span>, <span class="number">0.4</span>, <span class="number">0.1</span>))</span><br><span class="line">create_tree(ivec3(<span class="number">20</span>, -<span class="number">40</span>, <span class="number">0</span>), <span class="number">45</span>, <span class="number">25</span>, vec3(<span class="number">1.0</span>, <span class="number">0.4</span>, <span class="number">0.1</span>))</span><br><span class="line">create_tree(ivec3(<span class="number">30</span>, -<span class="number">40</span>, -<span class="number">20</span>), <span class="number">25</span>, <span class="number">15</span>, vec3(<span class="number">1.0</span>, <span class="number">0.4</span>, <span class="number">0.1</span>))</span><br><span class="line">create_tree(ivec3(<span class="number">30</span>, -<span class="number">40</span>, <span class="number">30</span>), <span class="number">45</span>, <span class="number">25</span>, vec3(<span class="number">1.0</span>, <span class="number">0.4</span>, <span class="number">0.1</span>))</span><br></pre></td></tr></tbody></table></figure><p>树的部分收工！</p><h4 id="围栏"><a href="#围栏" class="headerlink" title="围栏"></a>围栏</h4><p>最后一步了，其实也比较简单，就是沿着一个方向加入一段长条，然后每隔一段距离加个小竖条就行：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_fence</span>(<span class="params">start, direction, length</span>):</span><br><span class="line">    color = vec3(<span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">0.2</span>)</span><br><span class="line">    create_block(start, direction * length + ivec3(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>), color, vec3(<span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line">    fence_dist = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length // fence_dist + <span class="number">1</span>):</span><br><span class="line">        create_block(start + direction * i * fence_dist + ivec3(<span class="number">1</span>, -<span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">                     ivec3(<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>), color, vec3(<span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212415607.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212430778.png"></p><p>至此，我们完成了<strong>基座</strong>、<strong>树和落叶</strong>、<strong>围栏</strong>，收工！</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212535555.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212600089.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212628999.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212657240.png"></p><h3 id="我也要玩！"><a href="#我也要玩！" class="headerlink" title="我也要玩！"></a>我也要玩！</h3><p>参赛用到的体素渲染器只需要 Python 环境，支持 Windows、Mac、Linux，没有 GPU 的话也可以运行。</p><p>复制文末链接 ⁴，即可查看更多参赛教程及内部测试时候的作品集 ⁵（都有源代码）。</p><p>以上。</p><p>99 行代码的体素大赛截止时间是 5 月 18 日，优秀作品有纪念奖品哦！（可惜我不能参赛，要不然 Switch 一定是我的 hhh）</p><p>只要会 Python，并且有一颗喜欢创造的心，相信你一定能创建出自己喜欢的体素作品！</p><p><strong>References</strong></p><ol><li><p><a href="https://github.com/taichi-dev/voxel-challenge/blob/main/renderer.py">https://github.com/taichi-dev/voxel-challenge/blob/main/renderer.py</a></p></li><li><p><a href="https://github.com/yuanming-hu/voxel-art">https://github.com/yuanming-hu/voxel-art</a></p></li><li><p><a href="https://github.com/taichi-dev/voxel-challenge/">https://github.com/taichi-dev/voxel-challenge/</a></p></li><li><p><a href="https://github.com/taichi-dev/community/blob/main/events/voxel-challenge/reference-zh_cn.md">https://github.com/taichi-dev/community/blob/main/events/voxel-challenge/reference-zh_cn.md</a></p></li><li><p><a href="https://github.com/taichi-dev/voxel-challenge/issues/1">https://github.com/taichi-dev/voxel-challenge/issues/1</a></p></li></ol><p>本文转载自胡渊鸣的知乎文章《99 行代码能干啥？造个体素小世界！》，摘录了创造体素秋景的教程，完整内容请点击“<a href="https://zhuanlan.zhihu.com/p/507362284">阅读原文</a>”查看。也期待大家参与比赛、创造自己的体素小世界！</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/view3.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="太极图形学 (TaiChi Computer Graphics)" scheme="https://yousazoe.top/categories/%E5%A4%AA%E6%9E%81%E5%9B%BE%E5%BD%A2%E5%AD%A6-TaiChi-Computer-Graphics/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
    <category term="Taichi" scheme="https://yousazoe.top/tags/Taichi/"/>
    
    <category term="Voxel" scheme="https://yousazoe.top/tags/Voxel/"/>
    
  </entry>
  
  <entry>
    <title>恋如花期，爱情美在两人共同绽放之时--《花束般的恋爱》</title>
    <link href="https://yousazoe.top/archives/3610aecb.html"/>
    <id>https://yousazoe.top/archives/3610aecb.html</id>
    <published>2022-05-05T15:42:43.000Z</published>
    <updated>2022-07-01T09:23:45.783Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV9.webp"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>山音麦和八谷绢因错过尾班车而相遇，在深夜咖啡馆聊起文学、电影和音乐，喜好竟奇蹟地相似，二人瞬间坠入爱河。他们毕业后开始一边兼职工作，一边开始同居生活，更一起养拾回来的街猫，最大的目标就是维持俩口子的日常。 但时日流逝，不想改变也得改变。他失约于《牯岭街》， 她独赏郭利斯马基黑色幽默。五年盛放，世上唯一的花未必结果，爱情若只如初见。</p><span id="more"></span><h3 id="命运邂逅"><a href="#命运邂逅" class="headerlink" title="命运邂逅"></a>命运邂逅</h3><blockquote><p>「有种说法是一起吃三次饭，还是没告白的话就只能当普通朋友。」</p></blockquote><p>如果是其他人的剧本，这部片可能只会是典型的日本纯爱电影，但在编剧坂元裕二的执笔，加上导演土井裕泰对于戏剧性精准的执行之下，揉合出近来在我心中最出色的爱情电影。坂元裕二是出了名的金句王，他的戏剧作品中总是满满的金句，除了上面写到的「三次饭局论」，电影中还有「吐司掉地论」、「花语记忆论」，这些都来自于他对生活的洞见，看到有人可以把生活里被忽略的小细节写出来，还可以延伸出人生哲学，令人不禁佩服他敏锐的观察力。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p2625028951.webp"></p><blockquote><p>「相遇总是藏着别离，开始是结束的开端。」</p></blockquote><p>就像金句总是会现身在坂元裕二的周遭，很多美好的事物也会在我们身边无预警的出现，如果有掌握住就可以拾成一把花束，像是那稍纵即逝的缘份。宫崎骏大家都能聊，但《攻壳机动队》的押井守可就不是人人都能搭上话题，要不是女主角绢在查觉到这么一点不一样时就及时上前搭话，也不会有后面这段恋情。而在多聊一些之后又发现两人更多相似之处，像是错过同一场展览、一样会用电影票根当书签、家里有几乎一样的藏书，连对剪刀石头布都有同一套哲学理论，各种契合都轻轻推了他们一把，命运既然让这两人遇上了，就很难不让他们在一起吧。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p2625028954.webp"></p><h4 id="爱如花期"><a href="#爱如花期" class="headerlink" title="爱如花期"></a>爱如花期</h4><blockquote><p>「我要在几%不到的恋爱生存率下存活下来。」</p></blockquote><p>因为种种个性和兴趣上的契合，他们以相当高的机率在一起，但又有多少机率能够一起走到最后呢？两人开始同居后，日日恩爱夜夜缠绵，一起经历找工作的困顿期，一路相互扶持，过着连天使都嫉妒的生活。只是工作后开始慢慢印证了「恋爱这种东西，可不能一人一半，恋爱就是一人一份。」，两人不再像以前一样天天腻在一块，而是在自己的空间各自度过。他们的争吵总是悄悄的来又迅速的离开，也没有彼此越看越不顺眼，根本没有征兆称得上是分开的理由。</p><p>那到底是什么拆散了他们？剧本故意排除一般爱情电影会出现的「外力」，像是第三者介入、生活出现困难、健康状况恶化、家庭反对等等，让我们专心聚焦在两个人的改变上。曾经是聊起来就像势均力敌的抛接球，现在则是球被晾在一边泄了气，球员也懒得动了。我想大家看到这边会有不同看法，觉得是麦在工作上的「变」影响到生活，或是绢心态上的「不变」已经跟不上现实，但在结尾安排他们因为「耳机成对论」而撞见，证明他们还是像电影前段一样契合，单纯只是爱在他们心中开出一朵不具名的花，花语是「我爱你，但也不爱你了」。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p2617652208.webp"></p><h3 id="恋如雨止"><a href="#恋如雨止" class="headerlink" title="恋如雨止"></a>恋如雨止</h3><blockquote><p>「我们一路走来的风景很美，就只差了一步。」</p></blockquote><p>两人在谈分手时的那场戏，再次见证坂原裕二对笔下角色一点也不心软，让正在分手的两人遇见热恋时的彼此，怎么会有如此残忍的安排！看着有说有笑的年轻情侣仿佛看到了自己，想到从一开始的等待对方告白，到后来同样在等待对方把分手说出口，这难熬的时刻他们脑中应该是不断的在想，到底有什么方法可以不要改变吧，毕竟谁都不想让手臂上的成对刺青变成食言的证明。只是那些永远不变的改变，谁都阻止不了它的出现，只差最后一步却再也走不下去，食之无味弃之可惜的抉择，做什么决定都无法再完美。</p><p>看完《花束般的恋爱》，想到当年看完《乐来越爱你》的惆怅，明明是百年奇遇的天作之合，却还是敌不过爱情的质变，半衰期总是在你还没意识时就已经到来。不管是剧情本身有多贴近我们对爱情的认知，或是刻意放进许多流行文化，让我们意识到年代和我们是如此接近(《牯岭街少年杀人事件》的重映和《萨尔达传说旷野之息》都是在 2017 年 3 月的事)，并借此意识到时间的流动，去比对两人前后的变化。菅田将晖在戏外采访给麦的一句话是：「不是像花束一样的爱，而是希望成为花束。」就像最后 Google 街景见证了他们最热恋的时光，或许爱情在我们眼中最美的不是一起走到最后，而是两人最用力绽放的时候吧。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p2675132273.webp"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV9.webp&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;山音麦和八谷绢因错过尾班车而相遇，在深夜咖啡馆聊起文学、电影和音乐，喜好竟奇蹟地相似，二人瞬间坠入爱河。他们毕业后开始一边兼职工作，一边开始同居生活，更一起养拾回来的街猫，最大的目标就是维持俩口子的日常。 但时日流逝，不想改变也得改变。他失约于《牯岭街》， 她独赏郭利斯马基黑色幽默。五年盛放，世上唯一的花未必结果，爱情若只如初见。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>Build and Run Pilot Engine</title>
    <link href="https://yousazoe.top/archives/69c425a2.html"/>
    <id>https://yousazoe.top/archives/69c425a2.html</id>
    <published>2022-05-01T08:42:50.000Z</published>
    <updated>2022-07-01T09:23:45.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104-pa1.png"></p><span id="more"></span><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h3><ul><li>Building Pilot engine development environment for upcoming programming assignments</li><li>Getting familiar with Smartchair (Assignment Submission Platform) submission flow</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Building Pilot engine development environment</p><h4 id="Downloading-Source-Code"><a href="#Downloading-Source-Code" class="headerlink" title="Downloading Source Code"></a>Downloading Source Code</h4><h4 id="Install-CMake"><a href="#Install-CMake" class="headerlink" title="Install CMake"></a>Install CMake</h4><p>Pilot Engine uses CMake to generate project files. Please refer <a href="https://cmake.org/download/">https://cmake.org/download/</a> for downloading and installing CMake</p><h4 id="Build-and-Run-Pilot"><a href="#Build-and-Run-Pilot" class="headerlink" title="Build and Run Pilot"></a>Build and Run Pilot</h4><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p><strong>Visual Studio 2019 or later</strong> is the recommended IDE on Windows.</p><h6 id="Generate-the-project-files-with-CMake"><a href="#Generate-the-project-files-with-CMake" class="headerlink" title="Generate the project files with CMake"></a>Generate the project files with CMake</h6><ul><li><p>Run the following command from <strong>Pilot root directory</strong>:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -S engine/ -B build</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h6 id="Open-Pilot-sln-with-Visual-Studio"><a href="#Open-Pilot-sln-with-Visual-Studio" class="headerlink" title="Open Pilot.sln with Visual Studio"></a>Open Pilot.sln with Visual Studio</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img10.jpg"></p><h6 id="Set-PilotEditor-project-as-Startup-Project"><a href="#Set-PilotEditor-project-as-Startup-Project" class="headerlink" title="Set PilotEditor project as Startup Project"></a>Set PilotEditor project as Startup Project</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img12.jpg"></p><h6 id="Build-Solution"><a href="#Build-Solution" class="headerlink" title="Build Solution"></a>Build Solution</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img14.jpg"></p><h6 id="Run-PilotEditor"><a href="#Run-PilotEditor" class="headerlink" title="Run PilotEditor"></a>Run PilotEditor</h6><ul><li>You can use keyboard shortcut F5 (Start debugging) or Ctrl + F5 (Start Without debugging).</li></ul><h5 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h5><p>Xcode is the recommended IDE on MacOS</p><h6 id="Generate-the-project-files-with-CMake-1"><a href="#Generate-the-project-files-with-CMake-1" class="headerlink" title="Generate the project files with CMake"></a>Generate the project files with CMake</h6><ul><li><p>Run the following command from Pilot root directory:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -S engine/ -B build -G <span class="string">"Xcode"</span></span></span><br></pre></td></tr></tbody></table></figure></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img16.jpg"></p><h6 id="Open-Pilot-xcodeproj-with-Xcode"><a href="#Open-Pilot-xcodeproj-with-Xcode" class="headerlink" title="Open Pilot.xcodeproj with Xcode"></a>Open Pilot.xcodeproj with Xcode</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img18.jpg"></p><h6 id="Set-PilotEditor-project-as-Startup-Project-1"><a href="#Set-PilotEditor-project-as-Startup-Project-1" class="headerlink" title="Set PilotEditor project as Startup Project"></a>Set PilotEditor project as Startup Project</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img20.jpg"></p><h6 id="Build-Solution-1"><a href="#Build-Solution-1" class="headerlink" title="Build Solution"></a>Build Solution</h6><ul><li>You can use keyboard shortcut ⌘B (Cmd + B)</li></ul><h6 id="Run-PilotEditor-1"><a href="#Run-PilotEditor-1" class="headerlink" title="Run PilotEditor"></a>Run PilotEditor</h6><ul><li>You can use keyboard shortcut ⌘R (Cmd + R)</li></ul><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><p>VSCode is the recommended IDE on Linux.</p><p>Following procedures were tested on Ubuntu 20.04 LTS.</p><h6 id="Configure-development-environment"><a href="#Configure-development-environment" class="headerlink" title="Configure development environment"></a>Configure development environment</h6><ul><li>Follow the instruction in README.md.</li></ul><h6 id="Open-the-root-directory-with-VSCode"><a href="#Open-the-root-directory-with-VSCode" class="headerlink" title="Open the root directory with VSCode"></a>Open the root directory with VSCode</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img22.jpg"></p><h6 id="Build-Solution-2"><a href="#Build-Solution-2" class="headerlink" title="Build Solution"></a>Build Solution</h6><ul><li>Terminal → Run build task → build linux debug</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img61.jpg"></p><h6 id="Run-PilotEditor-2"><a href="#Run-PilotEditor-2" class="headerlink" title="Run PilotEditor"></a>Run PilotEditor</h6><ul><li>Run → Run Without Debugging</li></ul><h4 id="Play-around-in-PilotEditor"><a href="#Play-around-in-PilotEditor" class="headerlink" title="Play around in PilotEditor"></a>Play around in PilotEditor</h4><h5 id="Editor-Mode"><a href="#Editor-Mode" class="headerlink" title="Editor Mode"></a>Editor Mode</h5><ul><li>Translate, rotate, and scale game objects</li><li>Add and delete game objects</li><li>Reload and save current level</li></ul><h5 id="Game-Mode"><a href="#Game-Mode" class="headerlink" title="Game Mode"></a>Game Mode</h5><ul><li>Controlling the robot (ASWD to run and press shift for sprint)</li></ul><h4 id="Submission"><a href="#Submission" class="headerlink" title="Submission"></a>Submission</h4><ul><li>After running PilotEditor successfully, choose your favorite view and take a screenshot.</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img63.jpg"></p><ul><li><p>Submit the screenshot image on Smartchair.</p><p>For SmartChair operating instructions, please refer:</p><ul><li><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_SmartChair_Submission_Guide.pdf">https://cdn.boomingtech.com/games104_static/upload/GAMES104_SmartChair_Submission_Guide.pdf</a></li></ul></li></ul><h4 id="Deadline"><a href="#Deadline" class="headerlink" title="Deadline"></a>Deadline</h4><ul><li>Deadline for submmision: <strong>GMT+8 20::00::00 Apr 18, 2022</strong></li></ul><h3 id="Grading-and-Q-amp-A"><a href="#Grading-and-Q-amp-A" class="headerlink" title="Grading and Q&amp;A"></a>Grading and Q&amp;A</h3><ul><li>The objectives for this assignment are building development environment and getting familiar with Smartchair submission flow. So this assignment will not be graded.</li><li>If you have any question during building Pilot development envrionment, you can ask in our Wechat Course Group or post on our course forum. Course Team and Course Supporters will answer.<ul><li><strong>Course Forum</strong> : <a href="https://games-cn.org/forums/forum/games104-forum/">https://games-cn.org/forums/forum/games104-forum/</a></li><li><strong>Wechat Course Group</strong> : Please add <strong>gameswebinar</strong> as Friend and send “<strong>104</strong>“ to enter the course group</li></ul></li></ul><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><ul><li>Each assignments must be accomplished independently.</li><li>Please submit your assignment before the deadline.</li></ul><br><center><a class="btn" href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_PA01.pdf">            <i class="fas fa-download"></i>GAMES104_PA01          </a></center></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104-pa1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
  <entry>
    <title>Rendering on Game Engine</title>
    <link href="https://yousazoe.top/archives/7d19d591.html"/>
    <id>https://yousazoe.top/archives/7d19d591.html</id>
    <published>2022-04-05T12:21:32.000Z</published>
    <updated>2022-07-01T09:23:45.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0001.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的渲染实践。</p><span id="more"></span><!--suppress ALL --><iframe src="//player.bilibili.com/player.html?aid=767919594&amp;bvid=BV14r4y1p7tt&amp;cid=570873645&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="Rendering-System-in-Games"><a href="#Rendering-System-in-Games" class="headerlink" title="Rendering System in Games"></a>Rendering System in Games</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0002.jpg"></p><p>从游戏刚刚开始的时候，我们就和绘制渲染走在一起。</p><p>最早的游戏需要显示在示波器上，而那时我们就已经想努力表现画面了。到了红白机时代即使硬件只能显示几种颜色，人们依旧构建了绘制系统奉献了诸多优秀的游戏。实际上现代游戏的绘制系统越来越丰富，越来越复杂，很多人提到游戏引擎下意识会说：“游戏引擎是不是就是绘制引擎？”。游戏引擎显然不止绘制，但它从技术难度和专业壁垒来讲确实是非常重要的一环。</p><p>那么这里顺带一提，没有渲染系统的游戏也是存在的：文字游戏。</p><h4 id="Rendering-on-Graphics-Theory"><a href="#Rendering-on-Graphics-Theory" class="headerlink" title="Rendering on Graphics Theory"></a>Rendering on Graphics Theory</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0003.jpg"></p><p>GAMES101 课程给大家系统地讲了计算机图形学的一些理论，这些算法是游戏渲染的基础。但同时游戏的渲染也存在一些区别：</p><ul><li>图形学解决的问题是明确的</li><li>图形学不会特别关注硬件是如何实现的，而更关注算法和数学上的正确性</li><li>实时 Realtime（30 FPS）/ 交互 Interactive（10 FPS）/ 离线渲染 Offline Rendering</li></ul><h4 id="Challenges-on-Game-Rendering"><a href="#Challenges-on-Game-Rendering" class="headerlink" title="Challenges on Game Rendering"></a>Challenges on Game Rendering</h4><p>在游戏中的绘制系统我们遇到的挑战都有什么呢？</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0004.jpg"></p><p>第一个挑战是游戏中需要处理的物体对象和各种效果是极其复杂的。举个例子，在我的场景中有成千上万的对象，并且每个对象的形式都不尽相同：植被、角色、天空云……我们需要用到的算法也随之不同，整体上还要加大量的后处理和光照运算，所以游戏的绘制系统是一个 All in One 的组合。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0005.jpg"></p><p>第二个挑战是我们并不是跑在一个理想的设备上，我们的任务不是验证其正确性而是让它跑在现代的设备上。所有的算法必须基于这些 PC、主机或者小小的 Switch 上面，所以需要我们对硬件的了解非常深，适配当代的硬件。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0006.jpg"></p><p>第三个挑战是在图形学效果不错的帧率放到游戏中可能就不够看了，并且帧率必须要稳定。近年的游戏给我们的时间越来越少，画面要求却越来越高。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0007.jpg"></p><p>最后一个挑战是显卡可以 100% 吃掉，但 CPU 的利用率却提不起来。所以在真实的游戏引擎中我们不能像计算机图形学项目那样把所有计算资源全部吃掉，需要留给前面说的游戏逻辑、物理、人工智能等等系统。</p><h4 id="Rendering-on-Game-Engine"><a href="#Rendering-on-Game-Engine" class="headerlink" title="Rendering on Game Engine"></a>Rendering on Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0008.jpg"></p><p>在讲之前需要说明，接下来要讲的所有东西它不是一个理论模型，它是一个工程实践经过这个行业近三十年迭代优化的软件工程系统，属于实践科学。</p><h4 id="Outline-of-Rendering"><a href="#Outline-of-Rendering" class="headerlink" title="Outline of Rendering"></a>Outline of Rendering</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0009.jpg"></p><p>如何把游戏引擎的渲染系统简化到四节课中呢？</p><ol><li><p><strong>Basics of Game Rendering</strong></p><p>基础 GPU 硬件、渲染数据组织结构、可见性裁剪等基础内容</p></li><li><p><strong>Materials, Shaders and Lighting</strong></p><p>现代游戏的光照模型、标准的材质系统、着色模型等行业标杆内容</p></li><li><p><strong>Special Rendering</strong></p><p>地形系统、天空/烟雾系统以及后处理系统等重要的引擎子系统内容</p></li><li><p><strong>Pipeline</strong></p><p>渲染管线以及前沿渲染技术</p></li></ol><h4 id="What-is-not-Included"><a href="#What-is-not-Included" class="headerlink" title="What is not Included"></a>What is not Included</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0010.jpg"></p><p>卡通化渲染、二维渲染引擎、毛发皮肤材质渲染等等由于课程安排原因暂时无法涉及。</p><h3 id="Building-Blocks-of-Rendering"><a href="#Building-Blocks-of-Rendering" class="headerlink" title="Building Blocks of Rendering"></a>Building Blocks of Rendering</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0011.jpg"></p><h4 id="Rendering-Pipeline-and-Data"><a href="#Rendering-Pipeline-and-Data" class="headerlink" title="Rendering Pipeline and Data"></a>Rendering Pipeline and Data</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0012.jpg"></p><p>渲染其实看起来也没那么难，就是空间上的顶点连城一个个的面，这些面经过一个投影矩阵投到我的屏幕上，再光栅化成一个个小像素点，在每个像素点上找到对应的材质、纹理渲染成各种各样的颜色，最后做出我们的效果。</p><h4 id="Computation-Projection-and-Rasterization"><a href="#Computation-Projection-and-Rasterization" class="headerlink" title="Computation - Projection and Rasterization"></a>Computation - Projection and Rasterization</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0013.jpg"></p><p>这里面我们可以看到绘制最核心的工作是 Computation，最基础的则是投影和光栅化。这些在 101 课程中讲得比较多，我们找一个相机位置进行（正交/透视）投影，然后得到屏幕空间的三角形之后把它光栅化成一个一个的像素，这就是我们的投影。</p><h4 id="Computation-Shading"><a href="#Computation-Shading" class="headerlink" title="Computation - Shading"></a>Computation - Shading</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0014.jpg"></p><p>投影光栅化之后就开始对它进行着色绘制。这里我们取一段简单的代码示例，可以发现它的运算也就几种：从常量里取常量，例如屏幕的长宽像素都是常数；中间会做大量加减乘除运算，例如 Phong 模型需要知道法线在哪里、光线在哪里、眼睛在哪里就可以算出来光有多少会被衰减掉；图中的小球上有很多花纹需要存到二维的贴图上……这些东西就像炒一盘菜，用这几种数学运算、常数变量的访问才能得到想要的结果。</p><h4 id="Computation-Texture-Sampling"><a href="#Computation-Texture-Sampling" class="headerlink" title="Computation - Texture Sampling"></a>Computation - Texture Sampling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0015.jpg"></p><p>这个东西听上去很简单，但这里面 Texture 的过程十分的复杂。</p><p>我们在人身上贴个花纹做个砖墙，离你很近的时候会看到一个一个的像素，但离你非常非常远的时候在屏幕上看到的像素其实隔了很多像素。这个时候如果我们不去对它低频滤波的话，那么当砖墙由近及远移动的时候画面会一直在抖动：走样。</p><p>在纹理上我们每一张贴图会存很多很多层，当我作为一个屏幕上小小的像素点取一个纹理的时候实际上要取四个点对它进行插值，然后还要每层三次双线性差值。图中也表明了要取 8 个像素点，所以纹理映射一次需要 3 + 3 + 1 = 7 次插值。</p><h4 id="Understand-the-Hardware"><a href="#Understand-the-Hardware" class="headerlink" title="Understand the Hardware"></a>Understand the Hardware</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0016.jpg"></p><p>所以要隆重介绍今天的主角：GPU 或者大家平时讲的显卡。</p><p>显卡是一个非常了不起的发明创造，现代很多引擎能够有突飞猛进的变化就是因为独立显卡的出现许多复杂的运算可以通过更高效的机器处理，这样极大地解放了 CPU，游戏画面也越来越精细。</p><p>如果你想成为一名游戏引擎的图形程序员，那这是你最好的伙伴。</p><h4 id="SIMD-and-SIMT"><a href="#SIMD-and-SIMT" class="headerlink" title="SIMD and SIMT"></a>SIMD and SIMT</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0017.jpg"></p><p>要想了解显卡，首先要建立两个概念：SIMD（Single Instruction Multiple Data）和 SIMT（Single Instruction Multiple Threads）。</p><p>听上去很高大上，其实 SIMD 就是 CPU 广泛使用的单指令多数据数据运算，例如做一次加法运算它的 <code>x</code>、<code>y</code>、<code>z</code>、<code>w</code> 四个坐标同时运算，一个指令完成四个加法或者四个减法。想象一下我们在渲染的时候就是有大量的矩阵、坐标运算，SIMD 就是我们最好的朋友。</p><p>但是在现代显卡里 SIMT 的概念更有趣值得了解。它的想法是如果我的计算内核做的很小但有很多个，这样一条指令可以在很多核上做同样的指令操作。假设我有 100 个核，一条指令就可以做 100 个数的加减乘除，我的计算效率可以 * 4 * 100 = 400。现代显卡类似于一个大蜂巢，里面包含了无数个小小的核，也是为什么现代显卡算力强的原因。</p><p>SIMT 结构给我们一个启示，在做绘制渲染的时候要尽可能用同样的代码让大家一起跑，每个人分别访问自己的数据，这样会在显卡上跑得非常快远远超过在 CPU 上算出来的东西，这是做图形程序最重要要掌握的概念。</p><h4 id="GPU-Architecture"><a href="#GPU-Architecture" class="headerlink" title="GPU Architecture"></a>GPU Architecture</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0018.jpg"></p><p>有了这些概念就可以窥探一下现代 GPU 的架构了。</p><p>这张图是十年前 N 卡的费米架构。一块显卡上放了很多的内核，但它分成一组一组的，每一组叫作 GPC（Graphics Processing Cluster）图形处理集群。在图形处理集群里面可以看到很多的 SM（Streaming Multiprocessor），这些 SM 包含了许多小内核，N 卡一般放的是 CUDA 内核。这些内核会处理大量的数学运算，其专门的硬件会支持前面提到的纹理采样的工作，包括比较复杂的数学运算也是由 RT Core 去做支撑。</p><h4 id="Data-Flow-from-CPU-to-GPU"><a href="#Data-Flow-from-CPU-to-GPU" class="headerlink" title="Data Flow from CPU to GPU"></a>Data Flow from CPU to GPU</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0019.jpg"></p><p>我们的数据在计算机里流动的时候是有成本的。</p><p>从计算机诞生开始的时候用的是冯诺依曼架构：计算和数据分开。这个架构会让硬件设计变得比较简单，但带来的问题是我每一个计算都需要去找数据，而找数据并在计算单元中搬来搬去这件事又特别特别慢。</p><p>所以游戏引擎设计中有一个原则就是数据尽量单向传输，CPU 送到显卡，尽可能不要从显卡里读数据。</p><h4 id="Be-Aware-of-Cache-Efficiency"><a href="#Be-Aware-of-Cache-Efficiency" class="headerlink" title="Be Aware of Cache Efficiency"></a>Be Aware of Cache Efficiency</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0020.jpg"></p><p>下一个概念是 Cache 缓存。</p><p>缓存对现代计算的影响是非常非常大的，可能远远超过大家的想象。在 CPU 上如果做一次加减乘除，可能一个 clock 就做完了；但是 A + B 的 A 找不到了，要从内存里取数据实际上要等 100 多个时钟周期。</p><p>做计算的时候如果数据恰好都在缓存上，我们称为 cache-hit 缓存被命中；数据不在缓存中则称为 cache-miss。所以在计算机图形中如果纹理没做好老是让计算机产生 cache-miss 效率会直线下降。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0021.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0022.jpg"></p><p>支持游戏的硬件结构一直在变，从 DX11 时代就可以做细分曲面、更加灵活的 Shader，到今天可以更灵活处理的 Mesh Shader。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0023.jpg"></p><p>主机是 UMA 内存共享的架构，对于引擎而言又是另一种情况。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0024.jpg"></p><p>移动端的游戏则更加考虑手机处理芯片的能力，许多采用的是 Tiled-Based Rendering。游戏引擎的架构都是和硬件的架构息息相关的，所以在讲渲染之前特别希望先了解一下显卡是如何工作的。</p><h3 id="Renderable"><a href="#Renderable" class="headerlink" title="Renderable"></a>Renderable</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0025.jpg"></p><h4 id="Mesh-Render-Component"><a href="#Mesh-Render-Component" class="headerlink" title="Mesh Render Component"></a>Mesh Render Component</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0026.jpg"></p><p>上节课我们讲到 GameObject 构建了这个世界，但需要区分逻辑表达的游戏对象和真实绘制的东西。</p><p>在 Mesh Render Component 中一般会存 Renderable 可绘制物体，这是我们绘制系统的核心数据对象。</p><h4 id="Building-Blocks-of-Renderable"><a href="#Building-Blocks-of-Renderable" class="headerlink" title="Building Blocks of Renderable"></a>Building Blocks of Renderable</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0027.jpg"></p><p>那么一个 Renderable 是怎么来的呢？</p><p>先来看物体本身吧，以图中这个士兵角色为例，他有 Mesh 网格和几何形体，每一个 Mesh 有各种各样的金属皮肤材质，这些材质上还有许多花纹 Texture，其实还有 Normal 去表达 Mesh 表达不了的细节……这就是 Renderable 最简单的一个 Building Block。</p><h4 id="Mesh-Primitive"><a href="#Mesh-Primitive" class="headerlink" title="Mesh Primitive"></a>Mesh Primitive</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0028.jpg"></p><p>Mesh 在引擎中是怎么表达呢？</p><p>首先我们需要先定义一个 Mesh Primitive，最简单的顶点应该包含位置、法线朝向、uv 以及其他各种各样的属性。而每三个顶点放在一起则构成了一个三角形，许多三角形放在一起就形成了表面外观。</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line">struct Vertex</span><br><span class="line">{</span><br><span class="line">    Vector3 m_position;</span><br><span class="line">    <span class="comment">// other data</span></span><br><span class="line">    UByte4 m_color;</span><br><span class="line">    Vector3 m_normal;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct Triangle</span><br><span class="line">{</span><br><span class="line">    Vertex m_vertex[<span class="number">3</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Vertex-and-Index-Buffer"><a href="#Vertex-and-Index-Buffer" class="headerlink" title="Vertex and Index Buffer"></a>Vertex and Index Buffer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0029.jpg"></p><p>但是上面的存储方式很笨，如果同学们写过 OpenGL 或者 DirectX 基础的图形学代码就会知道我们会把数据用 Index Data 和 Vertex Data 去定义。我们把所有的顶点放在一起，三角形不会再把顶点数据再存一遍，而只存顶点的索引值。</p><p>实际模型中会发现很多顶点是被很多三角形公用的，数学也可以算出来顶点数量大约是三角面的一半，而三角形又有三个顶点，理论上使用 Index 这种存储方法可以节约六倍以上。</p><h4 id="Why-We-Need-Per-Vertex-Normal"><a href="#Why-We-Need-Per-Vertex-Normal" class="headerlink" title="Why We Need Per-Vertex Normal"></a>Why We Need Per-Vertex Normal</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0030.jpg"></p><p>为什么每个顶点都要存一个法向？</p><p>这里面有一个很简单的数学知识，虽然三角形三个顶点可以算出顶点朝向在大部分情况下是对的，但一旦表面是硬表面有一条折线的时候，我们会发现两个顶点的位置是重合的法向却完全不一样。</p><p>所以在写游戏引擎的绘制系统定义顶点数据时一定要单独定义法向方向。</p><h4 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0031.jpg"></p><p>材质系统来自于我们真实的生活，表达上接近于我们在物理世界对物体的感知。</p><p>这些材质系统需要和后面物理系统的物理材质做一些区分，物理材质更多的是表达物体的摩擦系数、弹性等等……和这里的材质相近，但在现代引擎的绘制系统定义的只是视觉材质，物理材质则会单独定义。</p><h4 id="Famous-Material-Models"><a href="#Famous-Material-Models" class="headerlink" title="Famous Material Models"></a>Famous Material Models</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0032.jpg"></p><p>材质系统经过图形学发展，从经典的 Phong 模型到现在的 Physically Based Rendering PBR 模型，包括一些特殊的效果如半透明材质，我们其实已经积累了很多非常优质的材质模型。</p><h4 id="Various-Texture-in-Materials"><a href="#Various-Texture-in-Materials" class="headerlink" title="Various Texture in Materials"></a>Various Texture in Materials</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0033.jpg"></p><p>有了这些材质模型，我们需要纹理。</p><p>表达材质的时候纹理扮演了非常非常重要的作用，现代引擎里你觉得材质像金属还是非金属表面并不是由材质的参数决定的，很多时候是由纹理决定的。</p><h4 id="Variety-of-Shaders"><a href="#Variety-of-Shaders" class="headerlink" title="Variety of Shaders"></a>Variety of Shaders</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0034.jpg"></p><p>那是不是我们有了材质的表达、纹理、Mesh 就能绘制出我的东西呢？ 这里面有个无名英雄：Shader。</p><h3 id="Render-Objects-in-Engine"><a href="#Render-Objects-in-Engine" class="headerlink" title="Render Objects in Engine"></a>Render Objects in Engine</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0035.jpg"></p><h4 id="Coordinate-System-and-Transformation"><a href="#Coordinate-System-and-Transformation" class="headerlink" title="Coordinate System and Transformation"></a>Coordinate System and Transformation</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0036.jpg"></p><p>先来做个投影变换吧。</p><p>首先给物体乘模型矩阵从自身的坐标系移到世界坐标系；之后确定相机位置用一个视图矩阵再投影到相机坐标系；最后再选择正交或者透视投影变成屏幕坐标系里的东西。</p><h4 id="Object-with-Many-Materials"><a href="#Object-with-Many-Materials" class="headerlink" title="Object with Many Materials"></a>Object with Many Materials</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0037.jpg"></p><p>接下来先把 Vertex Buffer、Index Buffer 这些 Mesh 的东西提交上去，然后把材质参数、Texture 和 Shader 提交给显卡，一个物体就被绘制出来了。</p><p>这样我们就从一个抽象的 GameObject 游戏对象变成了一个 Renderable 绘制物体。</p><h4 id="How-to-Display-Different-Textures-on-a-Single-Model"><a href="#How-to-Display-Different-Textures-on-a-Single-Model" class="headerlink" title="How to Display Different Textures on a Single Model"></a>How to Display Different Textures on a Single Model</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0038.jpg"></p><p>但有些聪明的小伙伴会发现，这个物体并不是单一材质纹理的，这些数据又该如何去整理呢？这里我们想引入一个非常重要的概念：SubMesh。</p><p>现代游戏引擎中对一个 GO 会根据它材质的不同切分成子 Mesh，每个 SubMesh 会对应自己的材质纹理和着色器代码。但是一般会把它的顶点、三角形全部放到一个大的 Buffer 里面去，每个 SubMesh 只需要存一个偏移量就好了。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0039.jpg"></p><p>但在绘制多个对象的时候如果每一个 GO 都存储整套 Mesh 和材质，这个数据量会非常的大。仔细观察这些 Mesh 和贴图，你会发现它们其实都是一样的，那我们怎么节约这个空间呢？</p><h4 id="Resource-Pool"><a href="#Resource-Pool" class="headerlink" title="Resource Pool"></a>Resource Pool</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0040.jpg"></p><p>现代引擎中我们一般的做法是建立一个 Pool，把所有的 Mesh、Texture 放在一起。</p><h4 id="Instance-Use-Handle-to-Reuse-Resources"><a href="#Instance-Use-Handle-to-Reuse-Resources" class="headerlink" title="Instance: Use Handle to Reuse Resources"></a>Instance: Use Handle to Reuse Resources</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0041.jpg"></p><p>这样的话当我绘制一个拥有各种各样小兵的场景，你会发现它只是通过一个指引指向了各自所需要的材质、Mesh 网格。这是游戏引擎很经典的架构：Instance 实例化。</p><h4 id="Sort-by-Material"><a href="#Sort-by-Material" class="headerlink" title="Sort by Material"></a>Sort by Material</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0042.jpg"></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Initalize Resource Pools</span><br><span class="line">Load Resource</span><br><span class="line"></span><br><span class="line">Sort <span class="built_in">all</span> Submeshes by Materials</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each Materials</span><br><span class="line">   Update Parameters</span><br><span class="line">   Update Textures</span><br><span class="line">   Update Shader</span><br><span class="line">   Update VetexBuffer</span><br><span class="line">   Update IndexBuffer</span><br><span class="line">   <span class="keyword">for</span> each Submeshes</span><br><span class="line">      Draw Primitive</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><h4 id="GPU-Batch-Rendering"><a href="#GPU-Batch-Rendering" class="headerlink" title="GPU Batch Rendering"></a>GPU Batch Rendering</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0043.jpg"></p><p>实际上很多子物体是一模一样的，这些物体依次设置 VertexBuffer、IndexBuffer 也是很浪费的。所以我们现在可以一个 DrawCall 设置一次 VB、IB 把成百上千个东西全部创建出来，这就是 GPU Batch Rendering 的思想。</p><p>总结下来就是现在的游戏引擎架构中，我们会尽可能把绘制计算交给 GPU 而非 CPU。</p><h3 id="Visibility-Culling"><a href="#Visibility-Culling" class="headerlink" title="Visibility Culling"></a>Visibility Culling</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0044.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0045.jpg"></p><p>现在我们已经可以绘制画面了，但它并不高效。</p><p>事件锥实际上是一个锥形的东西，绝大部分东西我们是看不见的。如图当相机开始移动的时候，其实 7～80% 的空间我们是看不见的，那里面的物体、地形、粒子效果可以不绘制。<strong>可见性裁剪</strong> 是游戏系统中很基层的底层系统。</p><h4 id="Culling-One-Object"><a href="#Culling-One-Object" class="headerlink" title="Culling One Object"></a>Culling One Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0046.jpg"></p><p>那这个可见性裁剪如何去实现呢？</p><p>上节课我们讲过每个物体都有包围盒，当我们给一个四棱锥的 view frustum 可以判断包围盒是不是在事件锥里面，这其实就是 Culling 一个最基础的思想。</p><h4 id="Using-the-Simplest-Bound-to-Create-Culling"><a href="#Using-the-Simplest-Bound-to-Create-Culling" class="headerlink" title="Using the Simplest Bound to Create Culling"></a>Using the Simplest Bound to Create Culling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0047.jpg"></p><p>包围盒是一个非常重要的概念。</p><p>它有很多种形式，最基础的是把整个物体包围进球里的 Bounding Sphere，也有更常用的 AABB 轴对称包围盒，存储两个端点就可以构建出 AABB Box，而且它的计算效率也是最高的。 有的时候我们的包围盒是贴着物体，被称为 Oriented Bounding Box：OBB；还有用凸包 Convex Hull 的包围盒……</p><p>所以其实无论我们在做什么，对物体形状的表达是非常复杂的。例如一个角色包含几万个面，不可能和这几万个面进行一一计算，而包围盒大致表真判断结果是很多计算的基础。</p><h4 id="Hierarchical-View-Frustum-Culling"><a href="#Hierarchical-View-Frustum-Culling" class="headerlink" title="Hierarchical View Frustum Culling"></a>Hierarchical View Frustum Culling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0048.jpg"></p><p>上节课我们还讲了对空间里的物体进行各种各样的划分，诸如四叉树、BVH 可以让 Culling 运算一层层去问，计算复杂度也会下降非常多。</p><h4 id="Construction-and-Insertion-of-BVH-in-Game-Engine"><a href="#Construction-and-Insertion-of-BVH-in-Game-Engine" class="headerlink" title="Construction and Insertion of BVH in Game Engine"></a>Construction and Insertion of BVH in Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0049.jpg"></p><p>BVH 算是现代游戏引擎最普遍的选择。</p><p>虽然它很简单也不是最高效的算法，但现代游戏里”动”的东西很多，当 BVH 构建好但节点发生变动，重新构建的成本要尽可能的低。</p><h4 id="PVS-Potential-Visibility-Set"><a href="#PVS-Potential-Visibility-Set" class="headerlink" title="PVS(Potential Visibility Set)"></a>PVS(Potential Visibility Set)</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0050.jpg"></p><p>其中我想介绍一个非常有意思的算法：PVS。</p><p>我们首先用 BSP-Tree 把空间划分成一个个小的格子，每个格子通过 Portal 连接。假设现在我们身处豪华的大平层，有很多房间，那么身处任意一个房间通过 Portal 看到的房间是固定的。</p><h4 id="Portal-and-PVS-Data"><a href="#Portal-and-PVS-Data" class="headerlink" title="Portal and PVS Data"></a>Portal and PVS Data</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0051.jpg"></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> each portals</span><br><span class="line">   getSamplingPoints();</span><br><span class="line">   <span class="keyword">for</span> each portal faces</span><br><span class="line">      <span class="keyword">for</span> each leaf</span><br><span class="line">         do ray casting between portal face <span class="keyword">and</span> leaf</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>所以 PVS 的想法非常淳朴，身处某个房间通过门或窗最多能看到哪几个房间。如图你站在七号房间，最多只能看到 6-1-2-3 四个房间，意味着只需要渲染这四个房间。</p><h4 id="The-Idea-of-Using-PVS-in-Stand-alone-Games"><a href="#The-Idea-of-Using-PVS-in-Stand-alone-Games" class="headerlink" title="The Idea of Using PVS in Stand-alone Games"></a>The Idea of Using PVS in Stand-alone Games</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0052.jpg"></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> each GreenBoxs</span><br><span class="line">   <span class="keyword">for</span> each BlueCells</span><br><span class="line">      do ray casting between box <span class="keyword">and</span> cell</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>其实真正应用 PVS 的已经不多了，但这个思想非常有用，帮助我们对资源进行调度。</p><h4 id="GPU-Culling"><a href="#GPU-Culling" class="headerlink" title="GPU Culling"></a>GPU Culling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0053.jpg"></p><p>随着硬件性能发生突飞猛进的变化，越来越多的 Culling 已经不再用这些传统的算法裁剪，GPU Based Culling 就可以完成。</p><h3 id="Texture-Compression"><a href="#Texture-Compression" class="headerlink" title="Texture Compression"></a>Texture Compression</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0054.jpg"></p><h4 id="Texture-Compression-1"><a href="#Texture-Compression-1" class="headerlink" title="Texture Compression"></a>Texture Compression</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0055.jpg"></p><p>游戏引擎里一般不会以图片的形式存储纹理，取而代之会把纹理进行压缩。 绘制系统中不能用那些非常好的算法，因为这些算法不能随机访问，而且计算复杂度非常高。 </p><h4 id="Block-Compression"><a href="#Block-Compression" class="headerlink" title="Block Compression"></a>Block Compression</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0056.jpg"></p><p>我们一般采取的策略是 Block Based，把图片切成一个个小块再压缩。</p><p>这里介绍一个非常经典的算法，假设我有一个 4x4 的小色块，找出颜色最鲜艳和最暗淡的点，我们认为其他点都是这两个点的差值。因为很多图片相邻像素都有关联度，所以可以通过两个极值的比例关系近似表达这个像素的颜色。</p><p>其实整个计算机图形学的 Texture Compression 都是基于这个这个 Block Compression 思想。</p><h3 id="Authoring-Tools-of-Modeling"><a href="#Authoring-Tools-of-Modeling" class="headerlink" title="Authoring Tools of Modeling"></a>Authoring Tools of Modeling</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0057.jpg"></p><h4 id="Modeling-Polymodeling"><a href="#Modeling-Polymodeling" class="headerlink" title="Modeling - Polymodeling"></a>Modeling - Polymodeling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0058.jpg"></p><p>构建一个模型最经典的是 3DMAX、MAYA 以及现在越来越流行的 BLENDER，点线面去构建各种各样酷炫的模型。</p><h4 id="Modeling-Sculpting"><a href="#Modeling-Sculpting" class="headerlink" title="Modeling - Sculpting"></a>Modeling - Sculpting</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0059.jpg"></p><p>ZBrush 雕刻性的素材生成工具正在替代传统建模方式。</p><p>真实世界塑造形体的时候雕刻家会不断把材料切削掉成自己的形状，实际上这种雕刻行为在计算机里可以更自由，构建更加自由的形体。</p><h4 id="Modeling-Scanning"><a href="#Modeling-Scanning" class="headerlink" title="Modeling - Scanning"></a>Modeling - Scanning</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0060.jpg"></p><p>实体扫描建模得益于深度学习算法的提升，可以得到高精度细腻的网格，远远超过手工构建。</p><h4 id="Modeling-Procedural-Modeling"><a href="#Modeling-Procedural-Modeling" class="headerlink" title="Modeling - Procedural Modeling"></a>Modeling - Procedural Modeling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0061.jpg"></p><p>通过一些算法或者规则自动生成网格的程序化建模可以把我们的艺术家从繁琐的细节工作解放出来，专注于创意本身。</p><h4 id="Comparison-of-Authoring-Methods"><a href="#Comparison-of-Authoring-Methods" class="headerlink" title="Comparison of Authoring Methods"></a>Comparison of Authoring Methods</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0062.jpg"></p><p>这四种方法各有利弊。</p><h3 id="Cluster-Based-Mesh-Pipeline"><a href="#Cluster-Based-Mesh-Pipeline" class="headerlink" title="Cluster-Based Mesh Pipeline"></a>Cluster-Based Mesh Pipeline</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0063.jpg"></p><h4 id="Sculpting-Tools-Create-Infinite-Details"><a href="#Sculpting-Tools-Create-Infinite-Details" class="headerlink" title="Sculpting Tools Create Infinite Details"></a>Sculpting Tools Create Infinite Details</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0064.jpg"></p><h4 id="Cluster-Based-Mesh-Pipeline-1"><a href="#Cluster-Based-Mesh-Pipeline-1" class="headerlink" title="Cluster-Based Mesh Pipeline"></a>Cluster-Based Mesh Pipeline</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0065.jpg"></p><p>Cluster-Based Mesh Pipeline 是一种新的模型表达管线。</p><p>它的基本思想是当我面对一个非常精细的模型时，我把它分成一个一个的小 Cluster。这样做的目的在于现代计算机显卡已经能够基于数据非常高效的创建几何细节，而传统管线则要预先把 VertexBuffer、IndexBuffer 构建好。</p><h4 id="Programmable-Mesh-Pipeline"><a href="#Programmable-Mesh-Pipeline" class="headerlink" title="Programmable Mesh Pipeline"></a>Programmable Mesh Pipeline</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0066.jpg"></p><p>随着硬件的发展，MeshShader 可以用一个算法基于数据凭空生成很多的几何，还可以根据相机的远近选择精度。 </p><h4 id="GPU-Culling-in-Cluster-Based-Mesh"><a href="#GPU-Culling-in-Cluster-Based-Mesh" class="headerlink" title="GPU Culling in Cluster-Based Mesh"></a>GPU Culling in Cluster-Based Mesh</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0067.jpg"></p><h4 id="Nanite"><a href="#Nanite" class="headerlink" title="Nanite"></a>Nanite</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0068.jpg"></p><p>Nanite 则是在此基础上更符合工业化更加成熟，也是现代游戏引擎发展的一个重要方向。</p><h4 id="Take-Away"><a href="#Take-Away" class="headerlink" title="Take Away"></a>Take Away</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0069.jpg"></p><ol><li><p>游戏引擎的绘制系统是工程科学，非常依赖于现代图形硬件的理解</p></li><li><p>游戏引擎需要解决的核心是模型、材质和网格这些数据之间的关系</p></li><li><p>绘制时尽可能通过一些运算把绘制减到越少越好</p></li><li><p>绘制和一些复杂处理尽可能从 CPU 移到 GPU</p></li></ol><h3 id="PILOT"><a href="#PILOT" class="headerlink" title="PILOT"></a>PILOT</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0070.jpg"></p><h4 id="Pilot-Engine-Editor-and-Game"><a href="#Pilot-Engine-Editor-and-Game" class="headerlink" title="Pilot Engine - Editor and Game"></a>Pilot Engine - Editor and Game</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0071.jpg"></p><h4 id="Pilot-Engine-Source-Code"><a href="#Pilot-Engine-Source-Code" class="headerlink" title="Pilot Engine - Source Code"></a>Pilot Engine - Source Code</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0072.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0073.jpg"></p><h4 id="Pilot-Engine-Download"><a href="#Pilot-Engine-Download" class="headerlink" title="Pilot Engine Download"></a>Pilot Engine Download</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0074.jpg"></p><h4 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0075.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0076.jpg"></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0077.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0078.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0079.jpg"></p><br><center><a class="btn" href="https://slides.games-cn.org/course/GAMES104_Lecture04.pdf">            <i class="fas fa-download"></i>GAMES104_Lecture_04          </a></center></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0001.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的渲染实践。&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
  <entry>
    <title>How to Build a Game World</title>
    <link href="https://yousazoe.top/archives/a8468b72.html"/>
    <id>https://yousazoe.top/archives/a8468b72.html</id>
    <published>2022-03-28T13:46:17.000Z</published>
    <updated>2022-07-01T09:23:45.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的数据组织和管理。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=640213987&amp;bvid=BV1YY4y1p74P&amp;cid=561986062&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="How-to-bring-the-game-world-to-life"><a href="#How-to-bring-the-game-world-to-life" class="headerlink" title="How to bring the game world to life"></a>How to bring the game world to life</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0002.jpg"></p><p>上一节课我们介绍了游戏引擎的基本结构。</p><p>有了这些知识只是知道这栋大厦长得是什么样子，但是我们并不知道里面的砖石、水电是怎么 work 的。而今天我们将带大家了解怎么去构建一个游戏世界。</p><h4 id="Dynamic-Game-Objects"><a href="#Dynamic-Game-Objects" class="headerlink" title="Dynamic Game Objects"></a>Dynamic Game Objects</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0003.jpg"></p><p>首先的话我们需要对游戏世界进行拆解。</p><p>如图所示，坦克、士兵等动态的游戏对象是我们最容易关注的东西，在现代游戏引擎里被称为 Dynamic Game Objects。</p><h4 id="Static-Game-Object"><a href="#Static-Game-Object" class="headerlink" title="Static Game Object"></a>Static Game Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0004.jpg"></p><p>另一类与之相对的就是静态物体。</p><p>例如高高的瞭望塔、机场的机棚、房子等，虽然这些物体无法交互，但是整个构成了游戏的各种各样的 GamePlay 元素。</p><h4 id="Environments"><a href="#Environments" class="headerlink" title="Environments"></a>Environments</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0005.jpg"></p><p>除了静态物和动态物之外还有无处不在的地形系统，它是支撑前面两者的托盘。</p><h4 id="Other-Game-Object"><a href="#Other-Game-Object" class="headerlink" title="Other Game Object"></a>Other Game Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0006.jpg"></p><p>游戏中还存在大量的物体例如检测体、空气墙等等，甚至玩法规则本身也可以抽象成一个物体。</p><h4 id="Everything-is-a-Game-Object"><a href="#Everything-is-a-Game-Object" class="headerlink" title="Everything is a Game Object"></a>Everything is a Game Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0007.jpg"></p><p>无论你是静态的还是动态的，我们都会把它统一抽象为 <strong>游戏对象</strong>（Game Object）。现代游戏引擎中我们一般会把所有的这些东西全部统一抽象成 GO。</p><h4 id="How-to-Describe-a-Game-Object"><a href="#How-to-Describe-a-Game-Object" class="headerlink" title="How to Describe a Game Object"></a>How to Describe a Game Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0008.jpg"></p><h4 id="How-Do-We-Describe-a-Drone-in-Reality"><a href="#How-Do-We-Describe-a-Drone-in-Reality" class="headerlink" title="How Do We Describe a Drone in Reality"></a>How Do We Describe a Drone in Reality</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0009.jpg"></p><p>当我们在游戏世界描述物体的时候可以归类成两类：属性（property）和行为（behavior）。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0010.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Drone</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/* Properties */</span> </span><br><span class="line">Vector3 position;</span><br><span class="line"><span class="type">float</span> health;</span><br><span class="line">    <span class="type">float</span> fuel;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Behavior */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scout</span><span class="params">()</span></span>;</span><br><span class="line">... </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0011.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArmedDrone</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/* Properties */</span> </span><br><span class="line">Vector3 position;</span><br><span class="line"><span class="type">float</span> health;</span><br><span class="line">    <span class="type">float</span> fuel;</span><br><span class="line">    <span class="type">float</span> ammo;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Behavior */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fire</span><span class="params">()</span></span>;</span><br><span class="line">... </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基于此我们可以做更多的变换，比如设计一款查打一体的无人机。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0012.jpg"></p><p>如果大家有一定的语言基础就会意识到，可以用对象的派生和继承关系定义一个无人机 <code>Drone</code> 类，然后再派生一个查打一体无人机 <code>ArmedDrone</code>。这也是非常经典的面向对象的行为方式。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0013.jpg"></p><p>这个方法虽然简单易懂，但是缺陷在于随着我们的游戏世界越做越复杂，这些物体并没有特别清晰的父子关系。</p><h4 id="Component-Base"><a href="#Component-Base" class="headerlink" title="Component Base"></a>Component Base</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0014.jpg"></p><p>现代游戏引擎的常用解决方法是 <strong>组件化</strong>。</p><p>我们把对象的行为拆分为无数的组件，如图所示玩具挖土机的铲子可以换成各种各样的部件，组件可以把同一个基础的物体变为各种各样的物体。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0015.jpg"></p><p>同样的，在玩现代射击游戏中我们可以定制枪械的组件和模块。</p><h4 id="Components-of-a-Drone"><a href="#Components-of-a-Drone" class="headerlink" title="Components of a Drone"></a>Components of a Drone</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0016.jpg"></p><p>回到无人机的案例，我们可以将它的行为和属性拆分为组件：</p><ul><li>Transform</li><li>Motor</li><li>Model</li><li>Animation Physics</li><li>AI</li></ul><p>这些属性和行为都变成一个一个的小组件，最终拼接为自己的无人机。</p><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0017.jpg"></p><p>代码实现只需 <code>ComponentBase</code> 的基类，它统一好每个基础行为接口。然后位移、模型、动画这些类全部派生自这个基类，各种各样的小组件就可以协同工作。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0018.jpg"></p><p>再回到无人机的例子，我们只需替换 AI 模块和战斗模块就拼接为查打一体的无人机。</p><p>所以现代游戏引擎的核心理念是尽可能符合大家的直觉，整个基础结构需要让开发者好维护好理解，同时要交给大量的艺术家和设计师去使用。如第一节课所述，游戏引擎架构它不是技术炫耀体，它是一个生产力工具，大家方便理解才是架构设计的底层需求。</p><h4 id="Components-in-Commercial-Engines"><a href="#Components-in-Commercial-Engines" class="headerlink" title="Components in Commercial Engines"></a>Components in Commercial Engines</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0019.jpg"></p><p>Unity 和 Unreal 等商业引擎都会去提供 Component 的概念。</p><p>需要注意的是 Unreal 的 UObject 不是我们讲的 GO，更像是高级语言的 Object 用于确定对象生命周期的管理。而真正的 GO 则更像是 Actor。</p><h4 id="Takeaways"><a href="#Takeaways" class="headerlink" title="Takeaways"></a>Takeaways</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0020.jpg"></p><ul><li>Everything is a game object in the game world</li><li>Game object could be described in component-based way</li></ul><h3 id="How-to-Make-the-World-Alive"><a href="#How-to-Make-the-World-Alive" class="headerlink" title="How to Make the World Alive"></a>How to Make the World Alive</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0021.jpg"></p><h4 id="Object-based-Tick"><a href="#Object-based-Tick" class="headerlink" title="Object-based Tick"></a>Object-based Tick</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0022.jpg"></p><p>我把每一个 GO 的 Component 依次 Tick 一遍，游戏世界就动起来了，也非常符合我们的直觉。</p><h4 id="Component-based-Tick"><a href="#Component-based-Tick" class="headerlink" title="Component-based Tick"></a>Component-based Tick</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0023.jpg"></p><p>但是在现代游戏引擎中我们一般不是按照每个对象 Tick，而是把一个个系统 Tick。</p><h4 id="Objected-based-Tick-vs-Component-based-Tick"><a href="#Objected-based-Tick-vs-Component-based-Tick" class="headerlink" title="Objected-based Tick vs. Component-based Tick"></a>Objected-based Tick vs. Component-based Tick</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0024.jpg"></p><p>这可能有些反直觉，我们可以举一个例子。</p><p>汉堡的直觉制作方法是每个人烤面包、烤牛肉、洗蔬菜，最后组装在一起。而这样的生产效率并不高，现代工业的核心概念是流水线，最高效的方法是有人专门去烤面包，有人专门去洗蔬菜……大家配合好最后组装成汉堡。</p><h3 id="How-to-Explode-an-Ammo-in-a-Game"><a href="#How-to-Explode-an-Ammo-in-a-Game" class="headerlink" title="How to Explode an Ammo in a Game"></a>How to Explode an Ammo in a Game</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0025.jpg"></p><h4 id="Hardcode"><a href="#Hardcode" class="headerlink" title="Hardcode"></a>Hardcode</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0026.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bomb::explode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span>(go_type)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> GoType.humen_type:</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* process soldier */</span></span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">case</span> GoType.drone_type:</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* process drone */</span></span><br><span class="line">            ...</span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">case</span> GoType.tank_type:    </span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* process tank */</span></span><br><span class="line">            ...</span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">case</span> GoType.stone_type:</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* process stone */</span></span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0027.jpg"></p><p>现代游戏引擎使用事件系统来优雅地解决这个问题，在系统架构中被称为解耦合。</p><h4 id="Events-mechanism-in-Commercial-Engines"><a href="#Events-mechanism-in-Commercial-Engines" class="headerlink" title="Events mechanism in Commercial Engines"></a>Events mechanism in Commercial Engines</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0028.jpg"></p><h3 id="How-to-Manage-Game-Objects"><a href="#How-to-Manage-Game-Objects" class="headerlink" title="How to Manage Game Objects"></a>How to Manage Game Objects</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0029.jpg"></p><p>很多游戏的 GO 动辄成百上千个，那我发生的每一件事情是如何通知的呢？</p><h4 id="Scene-Management"><a href="#Scene-Management" class="headerlink" title="Scene Management"></a>Scene Management</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0030.jpg"></p><ul><li>每个游戏 GO 会有一个唯一的编号 UID（类比资源管理的 GUID）</li><li>每个物体在空间上都会有位置 position</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0031.jpg"></p><p>最简单的方式就是分而治之划格子，但当场景分布不均匀时可能会出现问题。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0032.jpg"></p><p>就像我们的地图一样，整个世界很大，但是我们可以把世界分成国家、国家分成行省、行省分成城镇、城镇分成区块……假设有一件事件发生，我只需要在某个区块去找就可以了。</p><p>这样一个 Hierarchical 的场景管理方法就是一个非常有效的场景管理方法。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0033.jpg"></p><p>回到刚才的示例，以空间四叉进行划分形成树状结构，也就是数据结构中典型的四叉树。</p><h4 id="Spatial-Data-Structures"><a href="#Spatial-Data-Structures" class="headerlink" title="Spatial Data Structures"></a>Spatial Data Structures</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0034.jpg"></p><p>这其中也分很多流派，有二叉树、八叉树等等。现在游戏引擎比较流行 BVH 层次包围盒技术可以帮助我们快速定位，空间上的数据管理是场景管理的核心。</p><h4 id="Takeaways-1"><a href="#Takeaways-1" class="headerlink" title="Takeaways"></a>Takeaways</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0035.jpg"></p><ul><li>Everything is an object</li><li>Game object could be described in the component-based way</li><li>States of game objects are updated in tick loops</li><li>Game objects interact with each other via event mechanism</li><li>Game objects are managed in a scene with efficient strategies</li></ul><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0036.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0037.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0038.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0039.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0040.jpg"></p><ul><li><strong>如果一个 tick 时间过长怎么办？</strong></li></ul><p>一个比较简单的解决方案是直接跳过 tick。如果某个 tick 计算过于复杂，我们不必要把这些计算放在一帧处理而是分成几批，差个五帧处理完，而五帧在人的视觉中也就 0.2s 左右可以接受。</p><ul><li><strong>空气墙和其他 GO 有什么区别？</strong></li></ul><p>空气墙其实并不是一个很好的例子，游戏中我们用到最多的是透明的 Trigger。空气墙大部分情况作为一个 GO 就解决掉了，有时也会分为许多小 GO，作为引擎开发者不需要考虑这些策略，只需要知道空气墙一般使用最简单的形体来构建即可。</p><ul><li><strong>tick 时，渲染线程和逻辑线程怎么同步？</strong></li></ul><p>一般来讲渲染线程和逻辑线程会分开，而 <code>tickLogic()</code> 会比 <code>tickRender()</code> 早一点。</p><ul><li><strong>空间划分怎么处理动态的游戏对象？</strong></li></ul><p>树的数据结构可以插入或者删除，前面提到的 BVH、BSP 等等都存在更新问题。一般会选择更新轻量化的算法与数据结构以提高效率，所以引擎推荐支持两到三种经典的空间划分算法，游戏产品根据自己的需求去选择。</p><ul><li><strong>组件模式有什么缺点？</strong></li></ul><p>组件模式的第一个缺点是组件模式如果是很基础的实现，它的效率肯定没有直接写一个 class 效率高。后面讲的 ECS 会把同样的组件、数据全放在一起，用方法快速处理这些数据，避免了切换成本过高。</p><p>组件模式的第二个缺点是组件之间需要有一套通讯接口机制，而这个机制在高频调用时对效率的影响是非常大的。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0041.jpg"></p><br><center><a class="btn" href="https://slides.games-cn.org/course/GAMES104_Lecture03.pdf">            <i class="fas fa-download"></i>GAMES104_Lecture_03          </a></center></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的数据组织和管理。&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
  <entry>
    <title>Document Style Guide</title>
    <link href="https://yousazoe.top/archives/73e9efed.html"/>
    <id>https://yousazoe.top/archives/73e9efed.html</id>
    <published>2022-03-27T13:35:36.000Z</published>
    <updated>2022-07-01T09:23:45.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MD3.png"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>中文技术文档的写作规范。</p><span id="more"></span><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><h4 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h4><p>标题分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><p>下面是示例。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题</span></span><br></pre></td></tr></tbody></table></figure><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>（1）一级标题下，不能直接出现三级标题。</p><p>示例：下面的文章结构，缺少二级标题。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></tbody></table></figure><p>（2）标题要避免孤立编号（即同级标题只有一个）。</p><p>示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">## 二级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题 B</span></span><br></pre></td></tr></tbody></table></figure><p>（3）下级标题不重复上一级标题的名字。</p><p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">## 概述</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 概述</span></span><br></pre></td></tr></tbody></table></figure><p>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</p><p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p><p>示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">结构一</span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 B</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 C</span></span><br><span class="line"></span><br><span class="line">结构二</span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（1）A**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（2）B**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（3）C**</span></span><br></pre></td></tr></tbody></table></figure><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h4><p>（1）全角中文字符与半角英文字符之间，应有一个半角空格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：本文介绍如何快速启动Windows系统。</span><br><span class="line"></span><br><span class="line">正确：本文介绍如何快速启动 Windows 系统。</span><br></pre></td></tr></tbody></table></figure><p>（2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</span><br><span class="line"></span><br><span class="line">正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。</span><br></pre></td></tr></tbody></table></figure><p>半角的百分号，视同阿拉伯数字。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">正确：今年我国经济增长率是6.5%。</span><br><span class="line"></span><br><span class="line">正确：今年我国经济增长率是 6.5%。</span><br></pre></td></tr></tbody></table></figure><p>（3）英文单位若不翻译，单位前的阿拉伯数字与单位符号之间，应留出适当的空隙。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例1：一部容量为 16 GB 的智能手机</span><br><span class="line"></span><br><span class="line">例2：1 h = 60 min = 3,600 s</span><br></pre></td></tr></tbody></table></figure><p>（4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：他的电脑是 MacBook Air 。</span><br><span class="line"></span><br><span class="line">正确：他的电脑是 MacBook Air。</span><br></pre></td></tr></tbody></table></figure><h4 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h4><p>（1）避免使用长句。</p><p>不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</span><br><span class="line"></span><br><span class="line">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</span><br></pre></td></tr></tbody></table></figure><p>逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。</p><p>（2）尽量使用简单句和并列句，避免使用复合句。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">并列句：他昨天生病了，没有参加会议。</span><br><span class="line"></span><br><span class="line">复合句：那个昨天生病的人没有参加会议。</span><br></pre></td></tr></tbody></table></figure><p>（3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：请确认没有接通装置的电源。</span><br><span class="line"></span><br><span class="line">正确：请确认装置的电源已关闭。</span><br></pre></td></tr></tbody></table></figure><p>（4）避免使用双重否定句。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：没有删除权限的用户，不能删除此文件。</span><br><span class="line"></span><br><span class="line">正确：用户必须拥有删除权限，才能删除此文件。</span><br></pre></td></tr></tbody></table></figure><h4 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h4><p>（1）尽量不使用被动语态，改为使用主动语态。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：假如此软件尚未被安装，</span><br><span class="line"></span><br><span class="line">正确：假如尚未安装这个软件，</span><br></pre></td></tr></tbody></table></figure><p>（2）不使用非正式的语言风格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</span><br><span class="line"></span><br><span class="line">正确：无法参加本次活动，我深感遗憾。</span><br></pre></td></tr></tbody></table></figure><p>（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：这是唯二的快速启动的方法。</span><br><span class="line"></span><br><span class="line">正确：这是仅有的两种快速启动的方法。</span><br></pre></td></tr></tbody></table></figure><p>（4）用对“的”、“地”、“得”。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">她露出了开心的笑容。</span><br><span class="line">（形容词＋的＋名词）</span><br><span class="line"></span><br><span class="line">她开心地笑了。</span><br><span class="line">（副词＋地＋动词）</span><br><span class="line"></span><br><span class="line">她笑得很开心。</span><br><span class="line">（动词＋得＋副词）</span><br></pre></td></tr></tbody></table></figure><p>（5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</span><br><span class="line"></span><br><span class="line">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</span><br></pre></td></tr></tbody></table></figure><p>（6）名词前不要使用过多的形容词。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</span><br><span class="line"></span><br><span class="line">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</span><br></pre></td></tr></tbody></table></figure><h4 id="英文处理"><a href="#英文处理" class="headerlink" title="英文处理"></a>英文处理</h4><p>（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">英文：...information stored in random access memory (RAMs)...</span><br><span class="line"></span><br><span class="line">中文：⋯⋯存储在随机存取存储器（RAM）里的信息⋯⋯</span><br></pre></td></tr></tbody></table></figure><p>（2）外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">U.S.A.</span><br><span class="line">Apple, Inc.</span><br></pre></td></tr></tbody></table></figure><p>（3）表示中文时，英文省略号（<code>...</code>）应改为中文省略号（<code>⋯⋯</code>）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">英文：5 minutes later...</span><br><span class="line"></span><br><span class="line">中文：5 分钟过去了⋯⋯</span><br></pre></td></tr></tbody></table></figure><p>（4）英文书名或电影名改用中文表达时，双引号应改为书名号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">英文：He published an article entitled "The Future of the Aviation".</span><br><span class="line"></span><br><span class="line">中文：他发表了一篇名为《航空业的未来》的文章。</span><br></pre></td></tr></tbody></table></figure><p>（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</span><br></pre></td></tr></tbody></table></figure><p>（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。</span><br><span class="line"></span><br><span class="line">“online transaction processing”（在线事务处理）不是专有名词，不应大写。</span><br></pre></td></tr></tbody></table></figure><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><h4 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h4><ul><li>一个段落只能有一个主题，或一个中心句子。</li><li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li><li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li><li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li><li>段落之间使用一个空行隔开。</li><li>段落开头不要留出空白字符。</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用第三方内容时，应注明出处。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">One man’s constant is another man’s variable. — Alan Perlis</span><br></pre></td></tr></tbody></table></figure><p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">本文转载自 WikiQuote</span><br></pre></td></tr></tbody></table></figure><p>使用外部图片时，必须在图片下方或文末标明来源。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">本文部分图片来自 Wikipedia</span><br></pre></td></tr></tbody></table></figure><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><h4 id="半角数字"><a href="#半角数字" class="headerlink" title="半角数字"></a>半角数字</h4><p>阿拉伯数字一律使用半角形式，不得使用全角形式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：这件商品的价格是１０００元。</span><br><span class="line"></span><br><span class="line">正确：这件商品的价格是 1000 元。</span><br></pre></td></tr></tbody></table></figure><h4 id="千分号"><a href="#千分号" class="headerlink" title="千分号"></a>千分号</h4><p>数值为千位以上，应添加千分号（半角逗号）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">XXX 公司的实收资本为 ￥1,258,000 人民币。</span><br></pre></td></tr></tbody></table></figure><p>对于 4 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于 4 位以上的数值，应添加千分号。</p><h4 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h4><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$1,000</span><br><span class="line">1,000 美元</span><br></pre></td></tr></tbody></table></figure><p>英文的货币名称，建议参考国际标准 <a href="https://en.wikipedia.org/wiki/ISO_4217">ISO 4217</a>。</p><h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>表示数值范围时，用波浪线（<code>～</code>）或一字线（<code>—</code>）连接。参见《标点符号》一节的“连接号”部分。</p><p>带有单位或百分号时，两个数字建议都要加上单位或百分号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">132 kg～234 kg</span><br><span class="line"></span><br><span class="line">67%～89%</span><br></pre></td></tr></tbody></table></figure><h4 id="变化程度的表示法"><a href="#变化程度的表示法" class="headerlink" title="变化程度的表示法"></a>变化程度的表示法</h4><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">增加到过去的两倍</span><br><span class="line">（过去为一，现在为二）</span><br><span class="line"></span><br><span class="line">增加了两倍</span><br><span class="line">（过去为一，现在为三）</span><br></pre></td></tr></tbody></table></figure><p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">降低到百分之八十</span><br><span class="line">（定额是一百，现在是八十）</span><br><span class="line"></span><br><span class="line">降低了百分之八十</span><br><span class="line">（原来是一百，现在是二十）</span><br></pre></td></tr></tbody></table></figure><p>不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><h4 id="原则-2"><a href="#原则-2" class="headerlink" title="原则"></a>原则</h4><p>（1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。</p><p>（2）如果整句为英文，则该句使用英文/半角标点。</p><p>（3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</p><p>（4）点号（句号、逗号、顿号、分号、冒号）不得出现在标题的末尾，而标号（引号、括号、破折号、省略号、书名号、着重号、间隔号、叹号、问号）可以。</p><h4 id="句号"><a href="#句号" class="headerlink" title="句号"></a>句号</h4><p>（1）中文语句的结尾处应该用全角句号（<code>。</code>）。</p><p>（2）句子末尾用括号加注时，句号应在括号之外。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）</span><br><span class="line"></span><br><span class="line">正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。</span><br></pre></td></tr></tbody></table></figure><h4 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h4><p>（1）逗号（<code>，</code>）表示句子内部的一般性停顿。</p><p>（2）注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p><h4 id="顿号"><a href="#顿号" class="headerlink" title="顿号"></a>顿号</h4><p>（1）句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></tbody></table></figure><p>（2）英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.</span><br></pre></td></tr></tbody></table></figure><p>（3）中文句子内部的并列词，最后一个尽量使用（<code>和</code>）来连接，使句子读起来更加连贯，下面两个句子都可以，第二个更优。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里，以及百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></tbody></table></figure><h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>（1）分号（<code>；</code>）表示复句内部并列分句之间的停顿。</p><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>（1）引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</span><br></pre></td></tr></tbody></table></figure><p>（2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</span><br></pre></td></tr></tbody></table></figure><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>（1）补充说明时，使用全角圆括号（<code>（）</code>），括号前后不加空格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</span><br></pre></td></tr></tbody></table></figure><p>（2）几种括号的中英文名称。</p><table><thead><tr><th></th><th>英文</th><th>中文</th></tr></thead><tbody><tr><td><code>{ }</code></td><td>braces 或 curly brackets</td><td>大括号</td></tr><tr><td><code>[ ]</code></td><td>square brackets 或 brackets</td><td>方括号</td></tr><tr><td><code>&lt; &gt;</code></td><td>angled brackets</td><td>尖括号</td></tr><tr><td><code>( )</code></td><td>parentheses</td><td>圆括号</td></tr></tbody></table><h4 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h4><p>（1）全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：请确认以下几项内容：时间、地点、活动名称和来宾数量。</span><br></pre></td></tr></tbody></table></figure><p>（2）表示时间时，应使用半角冒号（<code>:</code>）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：早上 8:00</span><br></pre></td></tr></tbody></table></figure><h4 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h4><p>（1）省略号（<code>⋯⋯</code>）表示语句未完、或者语气的不连续。</p><p>（2）省略号占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p><p>（3）省略号不应与“等”这个词一起使用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨⋯⋯</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</span><br></pre></td></tr></tbody></table></figure><h4 id="感叹号"><a href="#感叹号" class="headerlink" title="感叹号"></a>感叹号</h4><p>（1）应该使用平静的语气叙述，尽量避免使用感叹号（<code>！</code>）。</p><p>（2）不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p><h4 id="破折号"><a href="#破折号" class="headerlink" title="破折号"></a>破折号</h4><p>（1）破折号<code>————</code>一般用于进一步解释。</p><p>（2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</span><br><span class="line"></span><br><span class="line">例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。</span><br></pre></td></tr></tbody></table></figure><h4 id="连接号"><a href="#连接号" class="headerlink" title="连接号"></a>连接号</h4><p>（1）连接号用于连接两个类似的词。</p><p>（2）以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p><ul><li>两个名词的复合</li><li>图表编号</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：氧化-还原反应</span><br><span class="line"></span><br><span class="line">例句：图 1-1</span><br></pre></td></tr></tbody></table></figure><p>（3）数值范围（例如日期、时间或数字）应该使用波浪连接号（<code>～</code>）或一字号（<code>—</code>），占一个全角字符的位置。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：2009 年～2011 年</span><br></pre></td></tr></tbody></table></figure><p>注意，波浪连接号前后两个值都建议加上单位。</p><p>（4）波浪连接号也可以用汉字“至”代替。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：周围温度：-20 °C 至 -10 °C</span><br></pre></td></tr></tbody></table></figure><h3 id="文档体系"><a href="#文档体系" class="headerlink" title="文档体系"></a>文档体系</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li><p><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</p></li><li><p><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</p></li><li><p>入门篇</p><p>（Basics）： [必备] [目录] 又称“使用篇”，提供初级的使用教程</p><ul><li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li><li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li><p><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称“开发篇”，提供中高级的开发教程</p></li><li><p><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</p></li><li><p><strong>FAQ</strong>：[可选] [文件] 常见问题解答</p></li><li><p>附录</p><p>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容</p><ul><li><strong>Glossary</strong>：[可选] [文件] 名词解释</li><li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li><li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li><li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li><li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li></ul></li></ul><p>下面是两个真实范例，可参考。</p><ul><li><a href="https://redux.js.org/introduction/getting-started">Redux 手册</a></li><li><a href="http://flight-manual.atom.io/">Atom 手册</a></li></ul><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：名词解释.md</span><br><span class="line"></span><br><span class="line">正确：glossary.md</span><br></pre></td></tr></tbody></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：TroubleShooting.md</span><br><span class="line"></span><br><span class="line">正确：troubleshooting.md</span><br></pre></td></tr></tbody></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">不佳：advanced_usage.md</span><br><span class="line"></span><br><span class="line">正确：advanced-usage.md</span><br></pre></td></tr></tbody></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.taodocs.com/p-51273.html">产品手册中文写作规范</a>, by 华为</li><li><a href="http://guide.daocloud.io/dcs/%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83%E5%92%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83-9153803.html">写作规范和格式规范</a>, by DaoCloud</li><li><a href="http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf">技术写作技巧在日汉翻译中的应用</a>, by 刘方</li><li><a href="https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf">简体中文规范指南</a>, by lengoo</li><li><a href="https://open.leancloud.cn/copywriting-style-guide.html">文档风格指南</a>, by LeanCloud</li><li><a href="https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit">豌豆荚文案风格指南</a>, by 豌豆荚</li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines">中文文案排版指北</a>, by sparanoid</li><li><a href="http://w3c.github.io/clreq/">中文排版需求</a>, by W3C</li><li><a href="http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html">为什么文件名要小写？</a>, by 阮一峰</li><li><a href="https://developers.google.com/style/">Google Developer Documentation Style Guide</a>, by Google</li><li><a href="http://www.moe.gov.cn/ewebeditor/uploadfile/2015/01/13/20150113091154536.pdf">出版物上数字用法的规定（国家标准GBT15835－2011）</a></li><li><a href="https://zh.wikisource.org/zh-hans/GB_3100-1993_%E5%9B%BD%E9%99%85%E5%8D%95%E4%BD%8D%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8">GB 3100-1993 国际单位制及其应用</a></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MD3.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;中文技术文档的写作规范。&lt;/p&gt;</summary>
    
    
    
    <category term="写作技巧 (Write Skill)" scheme="https://yousazoe.top/categories/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7-Write-Skill/"/>
    
    
    <category term="Write" scheme="https://yousazoe.top/tags/Write/"/>
    
    <category term="Markdown" scheme="https://yousazoe.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Layered Architecture of Game Engine</title>
    <link href="https://yousazoe.top/archives/df41bbe4.html"/>
    <id>https://yousazoe.top/archives/df41bbe4.html</id>
    <published>2022-03-21T14:53:31.000Z</published>
    <updated>2022-07-01T09:23:45.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0001.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的分层架构。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=382628067&amp;bvid=BV12Z4y1B7th&amp;cid=560857068&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0002.jpg"></p><p>同学们开始学习游戏引擎知识的时候，大家第一个困惑是恐惧感。那么多的文件，那么多的代码我该从何开始？这其实是学习游戏引擎一个很天然的感觉，而对一个事物的认知讲究由浅入深。</p><h3 id="A-Glance-of-Game-Engine-layers"><a href="#A-Glance-of-Game-Engine-layers" class="headerlink" title="A Glance of Game Engine layers"></a>A Glance of Game Engine layers</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0003.jpg"></p><p>所以先不用着急，先浮光掠影感受一下一个游戏引擎大概有哪些层次，下面来做一个快速的旅行。</p><h4 id="Tool-Layer"><a href="#Tool-Layer" class="headerlink" title="Tool Layer"></a>Tool Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0004.jpg"></p><p>一个现代游戏引擎下载下来首先看到的不是源代码，是各种各样的编辑器。</p><p>我们可以在里面编辑我们的关卡、做角色动画……看上去眼花缭乱，编辑器本身功能非常丰富，拖拖拽拽好像真的可以做出想象中的游戏世界。这是大家对游戏引擎的最直观的第一印象，所以这个时候接触了引擎的最上层：<strong>工具层</strong>（<strong>Tool Layer</strong>）。</p><h4 id="Function-Layer"><a href="#Function-Layer" class="headerlink" title="Function Layer"></a>Function Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0005.jpg"></p><p>做一款游戏首先要绘制出来，游戏的绘制过程本质上是把一个虚拟的三维世界转换为一帧一帧的二维图像，也就是<strong>渲染</strong> (Rendering)；这里面所有的东西不一定都是静止的，我们可能还需要一些<strong>动画</strong> (Animation) 让它们动起来；如果这个世界需要碰撞，<strong>物理</strong> (Physics) 的表达必不可少；除此之外可能还需要<strong>脚本</strong> (Script)、<strong>状态机</strong> (FSM)、AI 等等……</p><h4 id="Resource-Layer"><a href="#Resource-Layer" class="headerlink" title="Resource Layer"></a>Resource Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0006.jpg"></p><p>游戏引擎不是只通过一堆代码就可以跑起来，其中还包含了大量的数据和文件。</p><p>而这些数据和文件来自不同的软件，例如 Photoshop、3dMax、Maya 等。这么多的图形、几何、音视频和各种复杂的数据，在游戏引擎里是由 <strong>资源层</strong>（<strong>Resource Layer</strong>） 负责加载、管理这些资源。 </p><h4 id="Core-Layer"><a href="#Core-Layer" class="headerlink" title="Core Layer"></a>Core Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0007.jpg"></p><p>到这里对于普通开发者引擎已经可以跑了，但可以观察到上面的动画、物理、渲染等系统会频繁调用一些很底层的代码，例如最基础的容器的创建、内存的分配和线程管理。</p><p>这些东西好像并没有出现在功能层或是资源层，意味着我们触碰到引擎的 <strong>核心层</strong>（<strong>Core Layer</strong>）。核心层就像一个工具箱或者瑞士军刀，上面的游戏相关的逻辑管理全部是架在底座 Core 下面。</p><h4 id="Platform-Layer"><a href="#Platform-Layer" class="headerlink" title="Platform Layer"></a>Platform Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0008.jpg"></p><p>还有一个非常容易被忽略的分层：<strong>平台层</strong>（<strong>Platform Layer</strong>）。</p><p>游戏引擎生产的游戏最终是会发布给用户的，但用户的设备千千万万，有人可能是 PC，有的人可能是 iMac，还有的人可能是手机。输入设备的不同也会产生显著影响，常见的键盘鼠标显然要与手柄分开，更有甚者可能会使用体感设备。</p><p>所以无论来自什么样的输入设备，到我的游戏世界里面都要翻译成一个统一的语言。而这种平台的差异不仅体现在硬件设备上，还包括软件的发布平台比如我们的 STEAM 和 EPIC，它们的接口和收费模型完全不一样。</p><h4 id="3rd-Party-Libraries"><a href="#3rd-Party-Libraries" class="headerlink" title="3rd Party Libraries"></a>3rd Party Libraries</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0009.jpg"></p><h4 id="Explore-Game-Engine-layers"><a href="#Explore-Game-Engine-layers" class="headerlink" title="Explore Game Engine layers"></a>Explore Game Engine layers</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0010.jpg"></p><h4 id="Practice-is-the-Best-Way-to-Learn"><a href="#Practice-is-the-Best-Way-to-Learn" class="headerlink" title="Practice is the Best Way to Learn"></a>Practice is the Best Way to Learn</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0011.jpg"></p><p>人们常说实践是最好的老师，那么现在有一个挑战：如何在引擎中写出一个简单的角色动画控制器？</p><h3 id="Resource-Layer-1"><a href="#Resource-Layer-1" class="headerlink" title="Resource Layer"></a>Resource Layer</h3><h4 id="How-to-Access-My-Data"><a href="#How-to-Access-My-Data" class="headerlink" title="How to Access My Data"></a>How to Access My Data</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0012.jpg"></p><p>首先拜托美术同学用三维建模软件制作了角色，还做了很多的贴图和动画。</p><p>这些资源每个的数据格式都是不一样的：<code>.max</code>、<code>.maya</code>……这些数据肯定不可能在引擎中一一打开读取这些数据格式，并且这些数据格式实际上是为自己的工具服务的，其中包含了大量无效的信息，如果全部在引擎中加载效率会非常低。所以我们会对 Resource 做一步转换，变为引擎的高效格式：<strong>资产</strong>（<strong>Access</strong>）。</p><p>所以第一步是要把这些数据进行引擎化，变成我们的资产。</p><h4 id="Runtime-Asset-Manager"><a href="#Runtime-Asset-Manager" class="headerlink" title="Runtime Asset Manager"></a>Runtime Asset Manager</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0013.jpg"></p><p>当我们把原始散乱的文件变成引擎的资产时，会发现其实还需要一个实时的资产管理器。</p><p>这些资产在 Runtime Resource Management 中它们会互相指向对方，这个时候在游戏引擎设计中会经常有一个重要的 handle 系统。简单解释它就像一个邮箱，我始终有邮箱的钥匙，这样邮箱主人有没有、邮箱主人在不在只要问这个邮箱就知道了。</p><h4 id="Manage-Asset-Life-Cycle"><a href="#Manage-Asset-Life-Cycle" class="headerlink" title="Manage Asset Life Cycle"></a>Manage Asset Life Cycle</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0014.jpg"></p><p>简而言之，资源层在游戏中最核心的是管理所有这些资产的生命周期。</p><p>为什么资产的生命周期如此重要？可能大家没有注意，现代游戏关卡中随着进度的推进许多资产会无效，同时要加载许多新的资产，其中的关系是非常复杂的。</p><p>同样的 GC 垃圾回收概念也是如此，现代游戏如果 GC 做不好会让整个系统效率变得非常低下。</p><h3 id="Function-Layer-1"><a href="#Function-Layer-1" class="headerlink" title="Function Layer"></a>Function Layer</h3><h4 id="How-to-Make-the-World-Alive"><a href="#How-to-Make-the-World-Alive" class="headerlink" title="How to Make the World Alive"></a>How to Make the World Alive</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0015.jpg"></p><p>那怎么让角色动起来呢？</p><p>这里面有一个很重要的概念：Tick。它会每隔一个非常短的时间把世界往前推一小格，可以类比普朗克时间，我们认为任何一个物理过程不可能小于普朗克时间。</p><p>在游戏中的话每经历一个 Tick 我们的系统会把该做的事情做完，比如读入输入输出、动一下相机、动一下人物和角色、绘制一帧的画面、做一下 Memory GC…..整个逻辑往前走一点，在游戏的世界其实就是利用现代计算机非常高的计算速度每隔 1/30 秒把整个世界的逻辑和绘制全部跑了一遍，这就是 Tick 的魔力。</p><h4 id="Dive-into-Ticks"><a href="#Dive-into-Ticks" class="headerlink" title="Dive into Ticks"></a>Dive into Ticks</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0016.jpg"></p><p>现代游戏引擎的 <code>mian()</code> 函数中一般会出现两个非常重要的函数：<code>tickLogic()</code> 和 <code>tickRender()</code>。我们以模拟世界为先，随后再把它表现渲染出来。</p><h4 id="Tick-the-Animation-and-Renderer"><a href="#Tick-the-Animation-and-Renderer" class="headerlink" title="Tick the Animation and Renderer"></a>Tick the Animation and Renderer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0017.jpg"></p><p>动画的基础理论是视觉残留，而这一点在现代游戏中会充分利用。</p><h4 id="Heavy-duty-Hotchpotch"><a href="#Heavy-duty-Hotchpotch" class="headerlink" title="Heavy-duty Hotchpotch"></a>Heavy-duty Hotchpotch</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0018.jpg"></p><h4 id="Multi-Threading"><a href="#Multi-Threading" class="headerlink" title="Multi-Threading"></a>Multi-Threading</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0019.jpg"></p><p>现代计算机架构逐渐从单核走向多核，未来的多核时代会是游戏引擎很重要的一个方向。</p><p>最早的游戏引擎是单线程的，后面多核最简单的做法是把 <code>Logic()</code> 和 <code>Render()</code> 分到两个线程里面去。现在的商业引擎则会把一些特别容易并行化的物理或动画计算单独 Fork 出来分散到线程中，如中图所示。</p><p>未来引擎架构则考量能否把 Job 任务变成原子的，把每个核物尽其用安排满满的。</p><h3 id="Core-Layer-1"><a href="#Core-Layer-1" class="headerlink" title="Core Layer"></a>Core Layer</h3><h4 id="Math-Library"><a href="#Math-Library" class="headerlink" title="Math Library"></a>Math Library</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0020.jpg"></p><p>核心层最容易引起关注的就是数学库。</p><p>游戏引擎中大部分的数学并不是特别的高深，大学的线性代数基本上够用了。那为什么游戏引擎里这些数学库会单独列出来呢？</p><h4 id="Math-Efficiency"><a href="#Math-Efficiency" class="headerlink" title="Math Efficiency"></a>Math Efficiency</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0021.jpg"></p><p>这就牵扯到游戏引擎中一个独特的需求：游戏引擎的一切都是为效率服务的，它是一个 Real-Time 的 Application，所有用户的输入和反馈必须是实时的，玩家对效率是非常敏感的。一个经典的例子就是 Quake 引擎中的求倒数平方根：<a href="https://www.yousazoe.top/archives/e094b83a.html">Fast Inverse Square Root — a Quake III Algorithm</a>。</p><p>SIMD 也是现代计算机需要注意的一个东西。在游戏引擎中很多时候就是矩阵和向量的加减乘除，于是诞生了 Single Instruction Multiple Data 的概念，也是在数学库中广泛使用的技术。</p><h4 id="Data-Structure-and-Containers"><a href="#Data-Structure-and-Containers" class="headerlink" title="Data Structure and Containers"></a>Data Structure and Containers</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0022.jpg"></p><p>核心层不止数学，它为上层的所有逻辑提供基础服务，其中最重要的就是数据结构。</p><p>C++ 的 STL 提供了标准容器，那为什么引擎核心层还要再做一遍？不难发现当容器被高频访问、添加删除数据时，它会在内存中产生大量碎片，访问效率会受到影响。 </p><h4 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0023.jpg"></p><p>所以游戏引擎的开发可以类比于操作系统，尤其是在内存管理方面。C++17 或者 C++21的高端功能许多人学得感觉云里雾里，但实际上的底层逻辑无非三条：</p><ul><li>把数据放在一起</li><li>尽可能顺序访问数据</li><li>尽可能一起读写数据</li></ul><h4 id="Foundation-of-Game-Engine"><a href="#Foundation-of-Game-Engine" class="headerlink" title="Foundation of Game Engine"></a>Foundation of Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0024.jpg"></p><h3 id="Platform-Layer-1"><a href="#Platform-Layer-1" class="headerlink" title="Platform Layer"></a>Platform Layer</h3><h4 id="Target-on-Different-Platform"><a href="#Target-on-Different-Platform" class="headerlink" title="Target on Different Platform"></a>Target on Different Platform</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0025.jpg"></p><p>不同的平台甚至连文件路径的格式都不一样，但又不可能把引擎中的这些代码从头到尾改一遍，这个时候平台层就会变得非常重要。</p><p>平台层本质上就是人们在上面写核心写功能，可以无视这些平台的区别而直接写它核心的逻辑。平台无关性就是把所有平台的差异全部掩盖掉，这一层也是现代游戏引擎非常核心的东西。</p><h4 id="Graphics-API"><a href="#Graphics-API" class="headerlink" title="Graphics API"></a>Graphics API</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0026.jpg"></p><p>现代游戏引擎中有一个非常重要的东西：Render Hardware Interface（RHI），它重新定义图形 API，把各个硬件的 SDK 区别封装起来。所以平台层是一个很容易被大家忽略的一层，但其实也是体现引擎水平高下很重要的一层。</p><h4 id="Hardware-Architecture"><a href="#Hardware-Architecture" class="headerlink" title="Hardware Architecture"></a>Hardware Architecture</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0027.jpg"></p><h3 id="Tool-Layer-1"><a href="#Tool-Layer-1" class="headerlink" title="Tool Layer"></a>Tool Layer</h3><h4 id="Allow-Anyone-to-Create-Game"><a href="#Allow-Anyone-to-Create-Game" class="headerlink" title="Allow Anyone to Create Game"></a>Allow Anyone to Create Game</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0028.jpg"></p><p><strong>Unleash the Creativity</strong></p><ul><li>Build upon game engine</li><li>Create, edit and exchange game play assets</li></ul><p>工具层代码选择以开发效率优先如 C++ 和 QT，而不是以运行效率为优先。</p><h4 id="Digital-Content-Creation"><a href="#Digital-Content-Creation" class="headerlink" title="Digital Content Creation"></a>Digital Content Creation</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0029.jpg"></p><p>DCC（Digital Content Creation），翻译一下就是别人开发的资产生产工具。大名鼎鼎的 MAYA、3DMAX、Houdini 生产的数字资产通过一条 Asset Conditioning Pipline 导出管线变为引擎统一的 Asset。</p><h3 id="Why-Layered-Architecture"><a href="#Why-Layered-Architecture" class="headerlink" title="Why Layered Architecture"></a>Why Layered Architecture</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0030.jpg"></p><p>那么引擎为什么要分层呢？主要有两点：</p><ul><li>Decoupling 复杂度</li><li>Response 不断变化的需求</li></ul><p>各个层次之间的调用一般只允许上面的层次调用下面的层次，而绝对不允许反向调用。</p><h3 id="Mini-Engine-Pilot"><a href="#Mini-Engine-Pilot" class="headerlink" title="Mini Engine - Pilot"></a>Mini Engine - Pilot</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0031.jpg"></p><h4 id="Neat-PILOT-Engine"><a href="#Neat-PILOT-Engine" class="headerlink" title="Neat PILOT Engine"></a>Neat PILOT Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0032.jpg"></p><h4 id="Release-Plan"><a href="#Release-Plan" class="headerlink" title="Release Plan"></a>Release Plan</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0034.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0035.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0036.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0037.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0038.jpg"></p><br><a class="btn" href="https://slides.games-cn.org/course/GAMES104_Lecture02.pdf">            <i class="fas fa-download"></i>GAMES104_Lecture_02          </a></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0001.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的分层架构。&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
  <entry>
    <title>OVERVIEW of GAME ENGINE</title>
    <link href="https://yousazoe.top/archives/fdbb87de.html"/>
    <id>https://yousazoe.top/archives/fdbb87de.html</id>
    <published>2022-03-14T11:49:52.000Z</published>
    <updated>2022-07-01T09:23:45.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0001.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是对游戏引擎的概念做一个简单的了解。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=682363653&amp;bvid=BV1oU4y1R7Km&amp;cid=550830500&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0002.jpg"></p><p>那么首先的话呢，介绍一下我自己。那个实际上我的背景非常有意思，我本科是就读于浙江大学，我是在CAD/CG实验室，那个是很老牌的中国图形学的这个圣地吧。</p><p>然后我研究生的时候去了清华。在清华的同时，我去了微软亚洲研究院，在那个时代是一个非常热血的时代，就是我们一群中国的科研的小伙子们在老师的带领下去挑战SIGGRAPH，去挑战全球最前沿的这样的一个图形技术研究。</p><p>我到现在还记得那个时候我们被关在那个小黑屋里面，然后跟我们讲说你们是中国科研的国家队，你们并不比斯坦福MIT的学生笨 那你们去一起去冲击那个顶级会议的论文。所以其实那个时代给我们铸就了一种信念，就是说如果我们努力、如果我们是真的去用功的话，我们也可以做出世界顶级的东西。</p><br><p>那么其实在那之后的话呢，我本来认为我的职业路径一直是走这个学术，但是那个时候发生了一件事情，就是2004年虚幻三引擎面世。当时整个行业都被震撼到了，因为那个时代真正让大家见识到了什么叫次世代，然后那样的一个精彩的光影细节。我身边的朋友知道问我说：哎 王希你能不能够就是也做一个一样的东西出来，那这里面有什么技术，你们会不会做。当时我看完之后，我觉得：哎，这些技术好像我们都会做呀，对吧 因为你做完 research 时你会认为所有的系统它无非就是算法，每个算法我们都知道怎么去做。</p><p>但是的话我那时候在想，就是为什么我们做不出这样的一个大型的系统和平台？所以当时也怀着这个问题吧，我那个时候就决定说不再去做 research，而是去真的到工业去去看。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0003.jpg"></p><p>所以那时候就决定离开研究院，跑到那个美国去参加那个 bungie studio。那到bungie studio 的时候呢，实际上对我来讲是一个非常 interesting 的一个 journal。在 bungie 的话呢实际上，我用了大概五年时间参与了四款游戏：</p><ul><li>Halo3</li><li>Halo ODST</li><li>Halo: Reach</li><li>DESTINY</li></ul><p>特别是在 bungie 的最后三年那个时候，我们在做下一代的游戏引擎。大家知道最早 Halo 用的是自己的 InHouse 引擎，但是等我们决定启动做命运的时候，我们会发现就是这个行业发生了巨大的变化，游戏引擎我们要跑在一个完全不一样的计算机的软硬件架构上面，那个时候我会面临多核的时代。</p><p>还有一点就是过去我们做的是单机游戏，那未来我们要做的是什么呢？是可以在线上无数的玩家可以互联的这样一个游戏，那么他的体系结构需要发生这样的一次革命。我在美国整整待了五年吧，那个时候我毕业的时候这个转变是非常非常大的。</p><p>就是也是我今天开这门课的一个很大的原因就是说我们的同学可以在学校里学到很多的算法、计算机科学的基础知识，但是我们有了这样一些算法，我们可以发顶级的 paper，和我们做一个高水平的系统这之间的差距到底是什么呢？</p><p>其实我刚去美国的时候，我就想想回答这个问题。跟大家分享一个小故事 就是我在微软研究院的研究院的时候我还自以为自己编程还可以，但是等我到了那个 bungie 的时候我的前半年几乎说没有办法往那个引擎里面去加入你任何一行代码。为什么呢？你必须要理解那几百万行的那个系统它是按什么逻辑什么架构做出来的，所以今天那个 HALO3 的纪录片中间还有一个我的镜头就是他们早上六点钟跑去在拍摄早晨大家上班的样子，结果等他们摄影组到了我们的工作室时候发现有一个人没有走，然后我就趴在桌上的睡着了。他问我为什么没有走，我说我的 feature 还没有 checking。</p><p>所以在 HALO3 的时候，那时候我记得我做的是那个可交互的水体嘛。其实那个系统的话还是非常非常有意思的一个系统，所以我在讲就是其实用整整两年的时间吧，就是我自己亲身经历如何从一个 algorithm 算法 feature 到一个真的系统的变化。</p><p>所以十年前，也就是2011年那个时候我决定从美国回来创立了不鸣团队。为什么呢？我觉得中国有很多很聪明的人，但是我们没有人愿意聚集起来去做一个比较复杂的一个系统，真的把这些系统这些东西集合成一个 system。因为算法和系统是有本质区别的，就算法是这样的，就是说我有个很酷的 idea，我花几个月把它实现了，然后我就能发表一篇paper，这个周期是很短的，大概六个月左右。但是如果你做一个系统的话首先你要接受非常良好的，系统工程的训练 知道一个大型软件系统是怎么架构的，就是你需要知道你的特定系统怎么架，当我们真的开始去架的时候可能是一年时间你什么都看不见。</p><p>所以我们今天的话也非常开心有这样一个机会就是通过 GAMES104 这个平台，也是把我们的毕生所学系统性的整理出来，也是希望有更多的就是同学们会对这样的东西会感兴趣。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0004.jpg"></p><p>那么今天的课程我们讲的是现代游戏引擎的理论与实践，其实游戏引擎是为游戏服务的。那说起游戏的话每个同学都应该是非常的熟悉，我相信未来的时代一定是一个 Gamer 的时代，就是说我相信游戏会改变世界，那么这是一个让我热血了整整 20 年的一个行业。</p><p>这里面的话我们剪了一段视频，其实我们的编导组做完这个视频的时候我有一个小小的抱怨，就是为什么做只有地平线没有老头环，难道你们觉得老头环画面不够好吗？所以说其实我每每看到这个视频我都会很激动，但是老头环没有做进去我的激动会稍微少那么一点点。</p><p>那么其实游戏它最奇妙的一个地方是什么呢，就是每个人都很熟悉，就像你身边的手机一样，每个人都会用手机，但是有多少人能意识到其实在一个小小的手机里面集成了全世界最前沿的半导体技术、最前沿的材料技术、最前沿的计算机技术 。</p><p>其实游戏你看到的每一个画面、每一个细节，它都是在计算机里面用 01 去模拟出来的。这就是为什么今天我们去说一个游戏做的好不好，有这样的细节，那样的细节，我们会讲起来非常的轻松。但是真正的能做出一款游戏，它非常的难，它几乎集成了 Computer Science 里面几乎所有的知识门类，它本身的复杂度就是一个操作系统。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0005.jpg"></p><p>所以我认为就是说游戏实际上作为虚拟现实，是作为现代计算机科学的一个非常核心的一个应用。而且这个应用的话，它的技术含量也是最高的，那么游戏引擎的话就是我们讲的这个皇冠上的钻石，因为它是躲在下面看不见的东西。</p><p>其实中国的话我相信有将近几亿的游戏用户，那么会做游戏开发的人，我觉得应该有几百万很多人觉得我会用Unity、我会用Unreal。但是会用游戏引擎是你学会了开车，今天我们再问一个问题是中国有多少人会造车？</p><p>而造车的话，你就需要知道怎么去造发动机、发动机的底层工作原理是什么、它需要什么样的一些技术、有什么样的问题、什么样的这个材料……所以你会发现越到核心的东西，即使不止在中国，在全球真正做这件事情的人就会越来越少。所以 Game Engine 是实际上是我们这个行业的皇冠上的珍珠，它的技术壁垒也是最高的。</p><h3 id="Topic-1-WHY-WE-NEED-TO-LEARN"><a href="#Topic-1-WHY-WE-NEED-TO-LEARN" class="headerlink" title="Topic 1 WHY WE NEED TO LEARN"></a>Topic 1 WHY WE NEED TO LEARN</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0006.jpg"></p><p>那么为什么我们要学游戏引擎？</p><p>这个问题其实非常有意思，刚才我看到同学们弹幕里很多人在外说：我是不是要学很多其他的课程我才能够去上这门游戏引擎课。还有同学说：我如果不会 C++ 这个课我是不是上得了这个。</p><p>其实是我们当时在设计这个课程的时候我们很重点的在想的一个问题，就是说我简单来讲一下，我们立个Flag，就是我们尽可能在整个课程中讲人话，也就是说并不一定需要你有非常非常多的计算机的编程、开发的技术，但是你学完这门课程的时候你会对这样的一个现代的一个大型软件系统的架构有一个基本的一个理解。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0007.jpg"></p><p>为什么这件事情很重要的，这就是我特别想跟大家分享，为什么我们很愿意去做这门课，跟大家分享一下游戏引擎的底层架构知识。因为我们相信下一个时代将会是用游戏引擎技术，构造的一个虚拟现实的一个时代，就大家今天看到的很多东西，其实他背后底层用的基础都是游戏引擎技术。</p><h4 id="METAHUMAN"><a href="#METAHUMAN" class="headerlink" title="METAHUMAN"></a>METAHUMAN</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0008.jpg"></p><p>现在越来越火的虚拟人技术，这是我们那个虚幻引擎的 METAHUMAN。也就是在过去的这个 10 年到 20 年在游戏中，我们对人的皮肤的三维材质、我们对毛发的 simulation 大家是不是觉得很好看对吧。那么大家想象一下未来以后我们打开我们的支付宝，打开我们的银行终端，那这样的一个技术它背后就是有游戏引擎，而且未来的虚拟人会越来越多的进入到我们的生活。</p><h4 id="CINEMATIC-amp-ANIMATION"><a href="#CINEMATIC-amp-ANIMATION" class="headerlink" title="CINEMATIC &amp; ANIMATION"></a>CINEMATIC &amp; ANIMATION</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0009.jpg"></p><p>那么引擎这件事情到底重不重要，那么另外一个很大的领域是什么呢，大家可能想象不到：就是影视行业。上面是好莱坞的用那个就是游戏引擎，在一个巨大的 LED 屏上形成了一个虚景。</p><p>然后这样演员可以对着他进行拍摄，所以今天我们在就是很多广告或者是电影里看到的场景，它其实用游戏引擎技术渲染出来的，这和传统大家理解的那个 offline 就是这个离线的渲染农场的方法已经又不一样了。这样的话我们的导播、我们的导演可以在现场调整光照调整布景。</p><h4 id="SIMULATION"><a href="#SIMULATION" class="headerlink" title="SIMULATION"></a>SIMULATION</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0010.jpg"></p><p>那么第三个的话呢这个也是大家会觉得非常 exciting 就是说军事模拟。</p><p>其实大家知不知道就是我们世界各国都在用游戏引擎技术在训练自己的军队，因为只有游戏引擎能够提供这么真实的这样的一个场景。大家想象下我玩的很多那个战争游戏是不是他就是一个战争模拟器，无论你是这个步兵、还是开着这个坦克车、还是开着这个坦克车 还是开着飞机 其实他都需要最前沿的荧屏技术帮助大家去这个还是开着飞机其实它都需要最前沿的荧屏技术帮助大家去这个就是身临其境的演练你的战术，去检测你的战法。</p><p>其实这件事情的重要度现在已是越来越高了，因为现代化的战争是越来越复杂，是系统对系统的对抗。</p><h4 id="DIGITAL-TWIN"><a href="#DIGITAL-TWIN" class="headerlink" title="DIGITAL TWIN"></a>DIGITAL TWIN</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0011.jpg"></p><p>那么另外一个很大的领域的话，就是数字孪生。</p><p>这个概念我相信同学们可能最近听说过一些非常 hot 的概念，比如说工业4.0、工业数字数字化，那么这个背后有个很热门的概念叫做数字孪生，包括最近大家一直在讲的元宇宙。</p><p>那么 其实数字孪生的话呢，我们可以认为就是说它会把现实世界的很多东西把它虚拟化的表达的计算机事件里面，这样能帮助我们更好的去理解，更好的去管理，更好的去构建未来的世界。</p><p>那这里面我举个简单的例子吧 比如说我们现在最热的这个无人驾驶，其实所有的无人驾驶车 99.9% 的驾驶旅程其实是跑在那个游戏引擎里面，因为我不可能把车子在路上开十亿公里。所以这个时候我们就要用游戏引擎模拟各种各样的下雨啊，各种各样的路面的情况啊，包括行人各种异常的情况。</p><h3 id="Topic-2-HISTORY-OF-GAME-ENGINE"><a href="#Topic-2-HISTORY-OF-GAME-ENGINE" class="headerlink" title="Topic 2 HISTORY OF GAME ENGINE"></a>Topic 2 HISTORY OF GAME ENGINE</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0012.jpg"></p><p>我们开始这门课的话这一part，我们就先讲一下这个游戏引擎的历史。</p><h4 id="Early-Age-of-Video-Games"><a href="#Early-Age-of-Video-Games" class="headerlink" title="Early Age of Video Games"></a>Early Age of Video Games</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0013.jpg"></p><p>一切的都是从最原始的时代开始。</p><p>其实我们这个行业非常的短，大概只有50多年的历史嘛。那最早的时候其实这个行业最早的时候的话呢，我们的机器很简陋，这个机器我不知道有没有同学玩过叫红白机，那上面有很多我们童年的快乐了，比如说魂斗罗、马里奥对吧，大家都觉得特别特别的经典。</p><p>但是在那个时代的话呢，实际上没有有游戏引擎的概念，游戏都非常的简单。然后那时候开发游戏最核心的能力是什么是，如何把一个复杂的这个元素把它放入到一个非常小的比如 40kb 的这样的存储空间里面去。</p><p>那么这个时候大家如果去看那个任天堂的有些报告，它会告诉你说那个时候为了节约资源我一个云彩，我把它变个原色比如说把白色的云彩这张贴图变个颜色放到地上，它就变成一个草丛；做一只小乌龟我把它正面、反面来回播放，你就看起来个小乌龟在地上走，其实那个时候其实做游戏是一个非常有趣的事情。</p><h4 id="Father-of-Game-Engine"><a href="#Father-of-Game-Engine" class="headerlink" title="Father of Game Engine"></a>Father of Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0014.jpg"></p><p>那第一个提出游戏引擎的人是谁呢？那我觉得这里面我一定要去这个提这个John Carmack，就我们我们传说中的叫卡神，他绝对是我们这个行业里面我认为是这个教父级的人物，直到今天他还在为 Facebook 的那个 Oculus 在努力。我还非常非常的就是崇拜和敬佩他，就是说他还是那么谦卑，而且那么的务实在讲一些具体东西。</p><p>但其实他是个非常睿智的人，就是说在那个时代他是最早做了一款游戏叫Wolfenstein，就是重返德军总部。如果小伙伴们关心游戏的话，知道最近好像有一款重置的 3d 版再上线，那么这也是这个非常经典的一款游戏，就是可以说是开创了 fps 这个时代。</p><br><p>我们在做游戏的时候，我经常跟我们团队在讲大家千万不要被现成的东西给束缚住，因为有的时候比如说今天我们要游戏从业者，我们会说：哎呀，这个我要做一款什么什么类型的游戏。但是其实任何一种现在我们看见的游戏类型都是为被一款产品给创造出来给定义出来的，所以说未来世界我觉得会有很多新的引擎会出来、新的游戏类型会出来。</p><p>而在那个时代的话，世界上没有一个物种叫做游戏引擎。但是就卡马克他看见了一个东西，他说：当我在写各种各样的游戏的时候，中间有很多的代码是可以重用的，那么这些重用的东西我能不能抽出来呢？在这些产品中共用这些东西，我要不要把它定义成叫做一个 game engine 的东西？</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0015.jpg"></p><p>所以这个老哥就说干就干，然后他做了第二款游戏，也是经典中的战斗机：Doom。Doom 的话 我忘了中文叫什么名字了，反正到现在 Doom 还是一个非常棒的一款射击游戏 。</p><p>在做 Doom 的时候 他把 Doom 里面的核心代码变成了一个游戏引擎。后这个引擎他授权给了另外一家公司，另外一家公司做了一款游戏叫做 ShadowCaster，就是这个暗影施法者。所以如果说我们今天在学习游戏引擎的话，我们会认为卡马克的这个 Doom 应该是全球的第一款的游戏引擎，而且很幸运的是第一款已经上在商业上就已经成功了。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0016.jpg"></p><p>不过今天我们这个课程叫现代游戏引擎，早期的游戏引擎大家只是意识到说我只是一些代码的共用。但是真正的现代游戏引擎的概念的话，我认为还是从 Quake 时代开始。</p><p>这个 Quake 实际上也是卡马克大神卡神的这个作品，在那个时代 Quake 是最经典的射击游戏。如果讲一个就是很有年代感的东西就是 Quake 一个很著名的叫做火箭跳，就是你可以拿这个 RPG 对着地上去轰，然后反作用力会让你跳得更高。</p><br><p>那为什么会出现这样的一个质的飞跃呢？这里面不得不讲一个划时代的东西：显卡。显卡今天的话同学们如果你们喜欢打游戏、如果想做游戏开发，每个同学每天脑子里心心念念的是：哎，我的那块 3080 什么时候能到对吧，现在肯定是买不到了。</p><p>那么其实在最早的时代，游戏计算机是没有显卡的，直到很后面大家才意识到说形运算和这个逻辑运算是不一样的，图形运算是大量的向量运算 + 大量并行化的运算。所以说如果我拿 CPU 去做图形的话很麻烦，第一代的显卡 Voodoo 显卡出来了。而 Quake 就抓住那个时代，所以他做了第一代的这样的一个 3D 的游戏。当时他的画面、他的沉浸感实际上是震撼了那个时代所有的玩家。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0017.jpg"></p><p>游戏引擎为什么会越来越发达？游戏引擎为何会越来越重要？其实这里面讲一个核心的一个关联度叫做硬件的发展。</p><p>其实在那个时候，我们在思考就是说，我们这个技术平平台的 driver 到底是什么，我一直认为是硬件的发展。我们以 PlayStation 为例的话，第一代的PlayStation 它的算力只有 0.066 个 g；那么一直到 PS2、PS3、PS4 到我们现在的 PS5，那 PS5 的算力是多少了？十个 tflops！</p><br><p>同学们这意味着什么？很多很多的游戏从业者、包括我们很多玩家会说：哇，太棒了，我可以做一个很棒很棒的东西出来，对不对？但实际上这个从软件工程上来讲的话，这是一场巨大的挑战。因为随着你的计算机算力会越来越丰富 越来越强大之后，你的系统就会越来越复杂。</p><p>这就像那个操作系统，最早期的时候操作系统谁都能做，很多人都能做。但是为什么到现在操作系统只有极少数的这个公司才有能力做，为什么？那是上亿万行的代码！那同样的游戏引擎也这样。</p><p>早期的游戏引擎其实是非常非常简单的，但是到现代游戏引擎的时候动辄就是几百万行到上千万行代码，而且里面的算法非常的复杂，游戏引擎的算法密度是非常非常高的。</p><h4 id="Family-of-Game-Engines"><a href="#Family-of-Game-Engines" class="headerlink" title="Family of Game Engines"></a>Family of Game Engines</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0018.jpg"></p><p>所以经过这将近 30 年的发展，今天我们可以看到一个非常丰富的游戏引擎的生态：大家非常熟悉的这个虚幻引擎、Unity 引擎还有前些年其实非常厉害的 CryEngine。</p><h4 id="Middleware-of-Game-Engine"><a href="#Middleware-of-Game-Engine" class="headerlink" title="Middleware of Game Engine"></a>Middleware of Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0019.jpg"></p><p>同时大家去理解这个引擎的生态的话，引擎中间内部的东西实际上是随着游戏行业的发展变得非常的复杂，比如说物理运算。早期的游戏引擎里面都会自己写物理，比如怎么去做物理碰撞的检测，但后来大家发现这个问题越来越复杂，就会出现专门的做物理的这个模块的中间件。</p><p>这里面多说一句就说 Middleware 公司总是会不停的爆发出来，但是一般生命周期都不是很长。我们经常开个玩笑的，就是中间件公司最好的归宿是被某个游戏大厂或者游戏引擎大厂收购，但是其实他在整个游戏引擎生态里面扮演了一个非常重要的一个模块。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0020.jpg"></p><h3 id="Topic3-WHAT-IS-GAME-ENGINE"><a href="#Topic3-WHAT-IS-GAME-ENGINE" class="headerlink" title="Topic3 WHAT IS GAME ENGINE"></a>Topic3 WHAT IS GAME ENGINE</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0021.jpg"></p><p>好，那接下来的话呢，就是我们进入到我们课程的正文了。首先的话介绍一下什么叫游戏引擎。</p><h4 id="What’s-Game-Engine"><a href="#What’s-Game-Engine" class="headerlink" title="What’s Game Engine"></a>What’s Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0022.jpg"></p><p>传统的异能，就是我们一般讲什么定义意思，最首先寻找的是 Wikipedia。维基百科告诉我们什么叫游戏引擎，这是我从维基百科上扒下的一句话：游戏引擎是一个软件的这个框架，专门设计为游戏开发做的这样一系列的软件的工具的合集。</p><p>这句话的我听完之后我的感觉就是基本上等于什么都没有讲，循环论证了。那么当然了后面也有些好心人就说游戏引擎已经包括什么场景管理呀什么讲了一大堆的这个更具体的细节。</p><h4 id="Our-Definition-What’s-Game-Engine"><a href="#Our-Definition-What’s-Game-Engine" class="headerlink" title="Our Definition: What’s Game Engine"></a>Our Definition: What’s Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0023.jpg"></p><p>其实我觉得这两个定义都不是特别的准确，因为一个是太概括了，就像是说什么是人？哦，两只脚吃饭能走路的叫人？那肯定不是人对吧。还有一个就是想哦，这个人有眼睛、有鼻子、有耳朵，这些都不是人的本身。</p><p>那么 什么是游戏引擎呢？我觉得我给了一个定义，就是说首先它是一个<strong>构建黑客帝国矩阵的技术底层框架</strong>（Technology Foundation of Matrix）。黑客帝国里面构建了一个非常伟大的一个想法：我们是不是生活在一个虚拟的世界。今天我们虽然能够感知到彼此，我们觉得好像我们生活在一个真实世界里面，但是我们是缸中之脑（注：又称桶中之脑，是知识论中的一个思想实验，实验的基础是人所体验到的一切最终都要在大脑中转化为神经信号）。</p><p>而其实 游戏引擎在过去的 30 年在做的一切的事情都是说在模拟一个虚拟世界，也就是未来。当我们戴上了 VR 的眼镜、插上了耳塞、当我们身体穿上了触感的皮肤，我们可能无法区分我们是生活在一个虚拟世界还是一个真实世界，而游戏引擎所有的软件和体系的架构都在为这件事情在服务。</p><br><p>那么第二个游戏引擎的定义，我认为是一个<strong>生产力的工具</strong>。也就是说通过这样的一个一套工具体系，我们可以把我们想象的那个世界 在这一个虚拟的空间里面构建出来：我们可以构建一个高达几英里高的一个一个巨大的一个建筑物；我们可以创造一个从来没有存在过的外星星球。</p><p>在过去我们对这种东西想象是停留在哪的？停留在我们的书本上、我们写一个故事或者停留在我们的画一幅画，或者我们拍部电影。但是游戏引擎提供了这样的一个工具，让大家把这个世界真的能够身临其境的创造出来，就是摆在我们的面前。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0024.jpg"></p><p>那么最后一个这是我个人的一个观点，我认为他是一个复杂性的艺术，因为当你有这么强大的需求和能力的时候，这个系统绝对不简单。</p><p>它是非常复杂，所以说几乎不存在一个完美的、紧致的一个引擎架构，实际上 它是一系列妥协、一系列决策的一个结果，所以我认为是一个复杂性系统的一个艺术。</p><p>这是我十年前我才去讲游戏引擎的时候我特别喜欢用一张图，这张图展现的是一个吸满血的蚊子。当我们用这个显微摄像机拍下来的时候，我们可以看到这么的美：它身体的那个材质无数的细节。所以其实大家想象一下就是今天我们看了游戏，我们说我们的次时代画面无比的真实，但是你跟大自然相比我觉得我们还差的特别的远。</p><br><p>这里面跟大家剧透一下为什么我这么热爱这个这个事业。</p><p>我记得十年前当时我看完那个阿凡达这部电影的时候，我特别的激动。我跟我的小伙伴讲，我说十年之内我不会失业，为什么？我们要十年甚至更久的时间把那样的一个美轮美奂的世界 真的通过游戏展示在大家的面前，让大家真的在这个世界里面可以交互。但今年育碧刚刚做了一个这个阿凡达的游戏，实话说我个人觉得还是没有达到我的期望。</p><h4 id="Complexity-of-Simulation-by-0-x2F-1"><a href="#Complexity-of-Simulation-by-0-x2F-1" class="headerlink" title="Complexity of Simulation by 0/1"></a>Complexity of Simulation by 0/1</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0025.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0026.jpg"></p><p>我特别希望大家能够建立的一个概念，就是这个课程的话就是上完之后当有人告诉你说：哎，我会做很多的 Renderer 很多的渲染，所以我就能做游戏引擎了。那上过我们这个 GAMES104 的课程，可能同学就说：NO，这个事情绝对没有那么简单。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0027.jpg"></p><p>这个是游戏引擎非常经典的一本书，叫作《Game Engine Architecture》，他画了一个游戏引擎的结构图。我自己是学图形学的科班出身的嘛，但是我很卑微的发现，就是原来我们的大图形学只在整个游戏进行中占那么小的一个部分。</p><p>我是大概差不多本科、研究生都在研究图形学，那时候觉得自己做学习还可以 但是没想到当我做游戏引擎的时候又整整花了 15 年学习他所有的相关的一个知识体系。所以的话以后有人问你说我做绘制是不是就能做游戏引擎了，那么学了我们 GAMES104 课程的同学就可以很自豪的回答 NO，你还要学另外百分之九十的知识，那就是游戏引擎。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0028.jpg"></p><p> 它最大的一个挑战是什么呢？我们刚才讲的是说我们是构建一个黑客帝国，构建一个虚拟的世界，但是我们真实的世界假设全是虚拟的。</p><p>我经常在想上帝老人家特别厉害，为什么？它有无限的算力，它没有带宽的延迟，它有无限的存储，它可以采用暴力算法。但是很可悲的是在现代计算机里面们的算力是被严格的限制住的，那个计算机的 CPU 主频一直在涨对不对，但是你没有发现这几年主频涨的速度也是变慢了，我们几乎已经 hit 到了摩尔定律的这个上限。</p><p>游戏引擎的一个核心设计的边界条件就是 realtime 实时，这个是大家学游戏引擎特别要记住的一个关键性的概念。无论我有多么 fancy 的、多么厉害的算法，我能做出多么好的效果，如果你不能够在 1/30 秒 也就是 33 毫秒之内把这个计算结果给提交出去的话，那你这个算法就是无效的。而且这个实际上也不可能给你那么大的算力，比如说我们在做游戏引擎的时候我们的整个预算只有 33 毫秒，比如我做一个非常酷的这个物理爆炸，我可能只给你一毫秒到两毫秒。</p><p>而且同学们现在玩现代游戏的时候我们会对什么东西要求越来越高？讲的帧率对不对，玩一个动作游戏如果你低于 60 帧，我就觉得这个画面没有办法接受了。60 帧意味着什么？我的计算只有 15 毫秒！到一个这么短的一个时间片里面 这其实就是现代游戏引擎设计的核心难点。</p><p>所以 realtime 将会是引擎的一个核心关键点。</p><h4 id="Toolchain-for-Creators"><a href="#Toolchain-for-Creators" class="headerlink" title="Toolchain for Creators"></a>Toolchain for Creators</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0029.jpg"></p><p>其实引擎它不仅仅是一系列的算法，它是一个生产力的工具。其实从最早期的 Quake 时代开始大家就意识到了，游戏引擎真正最大的用户是什么？是设计师和我们的艺术家。</p><p>艺术家需要有一整套工具在里面去构建他的世界，我要摆放、我要把关卡的规则放好、我要放各种各样的敌人 NPC……那么在早期的时候工具链是很简单很简单的，比如在 Quake 时代大家看到的就是这一个编辑器就可以了。但是大家打开一个现代游戏引擎的话则是一个庞大的工具体系，而且非常有意思的是说每一个工具它的使用者都是学习不同专业技能的人：我们的动画师会用角色编辑器，在里面编辑角色所有的动画所有的行为；我们这个关卡的设计师会在设计这个关卡里面所有的山川河流……</p><p>也就是说一个引擎他如果只是一大堆的代码，只是一个 SDK 的话实际上他是没有办法用的，它实际上必须要提供一个非常强大的工具体系，这也是我们上完 GAMES104 课程同学们要建立的一个非常强的概念就是做引擎，首先要学会的是做工具。而且工具的用户不是程序员，而是我们的艺术家和我们的设计师。</p><h4 id="Developer-Platform"><a href="#Developer-Platform" class="headerlink" title="Developer Platform"></a>Developer Platform</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0030.jpg"></p><p>当然了，其实程序员也是引擎的一个非常重要的用户。为什么呢？因为当我们在设计这样的一个技术底层的时候，我们不可能知道所有的游戏类型。比如说我要做一个场闯关动作游戏；我要做一个开放世界的冒险游戏；我要作为一个剧情的 MMORPG……那其实每一款游戏你的玩法变化都是多种多样的，这样的话我不可能把所有的玩法都做进到游戏引擎里面去，所以就要求让我们的这个游戏的程序员能够快速的去开发出他的特定的玩法，所以一个引擎在上面进行二次开发的能力的强弱也是一个引擎最重要的一个评判标准之一。</p><p>生产力工具一个很重要的一个属性叫做协作，可协作的生产力工具。一个现代游戏工作室动辄就是上百人，而且这上百人的话大概有 20 - 30 个大的分工，每个人的技能都不一样。会写写程序的人非常的少，也不是所有的艺术家都是共通的，有的人很会画贴图，有的人很会建模，有的人很会做动画，有的人很会去搭这个环境，有的人很适合去做过场动画……</p><p>那好，这样的人在一起我们怎么去协作呢？这个时候引擎的工具链非常的重要。虽然做引擎很挑战很难，但是我们一定要把自己放的特别的低，因为我们的目标是服务好这些优秀的艺术家和设计师，所以工具是生产力，工具是引擎第二个非常重要的标签。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0031.jpg"></p><p>那么最后一个其实就是引擎的复杂度 。</p><p>当我们把整个这套体系设计好，这些工具设计好之后是不是就完事了？其实不是的，随着时间的推移我们要不断的去对他进行完善升级：更好的算法，更好的展现，更好的一些 feature 比如说我会把光照做得越来越漂亮；我会把东西做得越来越细腻；可以做更逼真的物理模拟等等……</p><p>但是你这些底层技术一直在升级的时候过去大家做的那些资产，做的那些游戏逻辑必须都要全部能跑得起来。不能够说你一升级大家就不能跑了，所以我们行业里面有一句话叫做“你要在一架飞起来的飞机上把他的零部件逐渐换掉，甚至把整个引擎都换掉，他这个飞机是不能掉下来”。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0032.jpg"></p><p>所以如果同学们，当然我就是将来有机会去参与到真正的引擎研发的时候，我觉得我们一定要做好这样的一个觉悟，就是我们面对的是一个超复杂的系统。</p><p>我每次都特别喜欢用这张图，因为这真的代表当你面对上千万行的游戏引擎代码的时候你的内心的真实的感受。但是我们这群人最厉害的地方就在于能理解这个。</p><h3 id="Topic-4-HOW-TO-STUDY"><a href="#Topic-4-HOW-TO-STUDY" class="headerlink" title="Topic 4 HOW TO STUDY"></a>Topic 4 HOW TO STUDY</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0033.jpg"></p><p>好的，那接下来就到了大家最关心的问题了，就是我怎么去学游戏引擎。我真的能学吗？我连 C 语言都不会，我能做游戏引擎吗？</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0034.jpg"></p><p>这是我们在那个就是其实在我们行业里有个大牛，他在 github 上发了一个长图就说：你要成为一个游戏程序员，你要去这个学多少的书。当时我把那个图看了一遍然后我说：哎呀，我的天哪，好像好多书我也没看。</p><p>如果说今天大家真的想去做专业的游戏引擎开发，你会涵盖到 Computer Science 几乎所有的专业领域。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0035.jpg"></p><p>但是现在第一个是时间有限，第二个我们只有 20 节课的课时。所以我们的挑战就会非常大，就说：哎，那我们怎么样子用这么短的课时能够把大家带入到这个世界里面的话呢？所以我们定了一个课程的策略：只沿着主干道行径。</p><p>如果我们认为游戏引擎是那个远处的珠峰峰顶，你看到的是个云遮雾扰的一个山峰。但是你可以往左走、往右走、往前走，所有东西都和你有关，但是我们只找一条路径沿着那条主干道我们一路走上去，其他的东西我们都会点到，但是我们不会去。</p><p>为什么呢？因为其实这门课程我认为最核心的目的是帮助大家建立一个知识的体系结构，这就相当于是说我们上完了大学，上完大学并不意味着我们会成为专家，但是你上完大学之后当你未来在你的真实的场景中遇到任何挑战的时候 你知道去图书馆翻哪一本书，然后我去啃他就好了。</p><p>所以我们认为在学习这种大型的系统工程的时候体系结构 Framework 非常的重要。而且这门课的话最核心的目标就是帮助我们的同学建立现代游戏引擎的知识体系框架，而且每一个体系大家先不用急着钻的太深，因为未来我们有大把的时间去往你们去钻。</p><h3 id="Topic-5-COURSE-CONTENT"><a href="#Topic-5-COURSE-CONTENT" class="headerlink" title="Topic 5 COURSE CONTENT"></a>Topic 5 COURSE CONTENT</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0036.jpg"></p><p>好，那接下来的话呢我给大家就快速的介绍一下我们接下来 20 节课的课程内容。</p><h4 id="Basic-Elements"><a href="#Basic-Elements" class="headerlink" title="Basic Elements"></a>Basic Elements</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0037.jpg"></p><p>我们的课程的第一节课会介绍一些游戏引擎的最基础的构建。</p><p>当你面对一个这么复杂的问题，你按什么方法去理解他去设计他，比如说怎么去理解 MVVM 的这个设计模式。这个听上去有点抽象，我们不讲那么复杂，我们讲人话就是游戏已经到底分几层，比如说第一层为什么我要把整个操作各个硬件平台、操作系统全部要虚拟化掉；第二层为什么我们要抽象出很多公用的东西……我们会一层层跟大家讲。</p><h4 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0038.jpg"></p><p>那么第二节课我们讲 Renderer。</p><p>Renderer 的话 GAMES101 闫令琪教的那个图形学那个课讲得非常的好，但游戏引擎的渲染的话可以不需要有图形学的基础知识，没关系我们讲的是一些基础的算法。</p><p>我们讲的是体系结构，就是说当我知道了这个世界有材质、有光照、有这个网格、有动画、有这个大气构成的时候，我怎么把这些东西拼到一起，我怎么把这么多东西 fit in 到 1 - 30 毫秒里面去，那我怎该怎么用什么一种 pipline 去组织这些元素。</p><p>大家会知道一些很有趣的一些点，举个例子比如说一个小小的玻璃板透明物体 就会给我们整个渲染管线带来巨大的困难，这个地方如果有好多好多的玻璃，这个渲染就会非常的挑战，包括大家看到很多很前沿的卡通化渲染。</p><p>当我们学完这门课程的时候，我希望同学们说到：哦，我懂了，其实这只是各种图形学算法的组合。那我根据不同的应用场景找到这些部件，按照逻辑把它们拼到一起，那这就是游戏引擎课里面所讲的渲染，所以说我们不会讲太深的算法，但是我们会讲这么多算法是按着什么结构拼到一起去的。</p><h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0039.jpg"></p><p>我们的课程的第三环节是讲动画了。</p><p>动画的话其实也是一个非常大家很熟悉的概念，我们的角色只要动下来了我们就要动画。那么当我们用这个 Max、Maya 做出了很多很精彩的动画素材的时候，我怎么样把它变成一个可以玩起来的东西。</p><h4 id="Physics"><a href="#Physics" class="headerlink" title="Physics"></a>Physics</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0040.jpg"></p><p>接着就是我们讲的这个物理。</p><p>物理其实是个非常有意思的概念，大家如果玩过这个 一些现代游戏或者现代游戏引擎的话，比如说你看见地上有个方块，你就想一脚去踢他那个方块，他就会动、他就会跑起来。</p><p>前面那三节它只是把东西展现在你的面前了，但是如果你真的让这个世界真的互动起来，其实这些所有的东西有另外一层的表达，我们叫做物理表达，也就是说这个表达是个孪生世界。</p><p>那么在这个物理表达里面，我们要用最简单的刚体、Box、Capsule 胶囊体躯表达这个世界；我们要用刚体力学模拟它各种运动；如果我们再复杂一点假设这个世界是软的，可以压的变形的 那我们是不是要一些弹性力学的东西；然后我们这时候有水、有烟、有头发，流体模拟学又来了……</p><p>那其实这些东西在我们认为现实生活中很自然的事情，在游戏的这个引擎里面的话 Physics 是一个非常重要的一个底层框架。我们不会讲的那么深，但是我们会把整个这个结构告诉大家。</p><h4 id="Gameplay"><a href="#Gameplay" class="headerlink" title="Gameplay"></a>Gameplay</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0041.jpg"></p><p>接下来的话也是游戏引擎架构最核心的一个东西，叫做游戏性的架构。</p><p>因为有前面的渲染、物理、动画对吧，那我们其实是可以构建一个世界。这个世界你拿脚踹他一下，你会觉得这已经有点真实了，但是这是一个游戏吗？这不是游戏，它只是一个世界的 Simulator 模拟器，只是把这些东西放在这，你能和它交互，它本身并不是一个好玩的东西。</p><p>由我们的设计师设计出来的游戏规则是怎么样子用告诉计算机的呢？那我们怎么样的让设计师来表达这个世界呢？</p><h4 id="Misc-Systems"><a href="#Misc-Systems" class="headerlink" title="Misc. Systems"></a>Misc. Systems</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0042.jpg"></p><p>讲完这些的话我觉得基本上同学们就可以做一个自己想做的游戏了。那这个时候我们会给大家补充一些颜值比较高的系统，比如说我们特别喜欢的特效系统。</p><p>那其实大家想象一下就是我突然要冒个烟冒个火，那么其实特效系统的话它的设计有意思的地方就在于他不能用程序写死，它也要提供一整套的框架和结构让艺术家可以创造各种各样的可能性。我们经常讲一个电影拍的不好就五毛钱的特效，其实游戏里面如果特效做的不好的话也是五毛钱的特效。</p><br><p>还有一些杂相系统，比如寻路系统。我们在游戏里看到很多的智能体 AI 这些东西，它是怎么知道路的，它怎么知道往左拐往右拐等等。 </p><p>最后一个是大家可能会注意不到，但是其实每天你打游戏都会感觉到的相机系统（或者说传说中的 3C 系统）。大家如果喜欢玩射击游戏的话，你会发现就是那个枪杆、那个镜头感是非常非常重要。</p><h4 id="Toolchain"><a href="#Toolchain" class="headerlink" title="Toolchain"></a>Toolchain</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0043.jpg"></p><p>所以这些系统和前面的系统配合在一起的话，大家基本上就可以做一个比较有意思的小游戏了。到这一节的话，我们开始介绍一些跟游戏工业化比较连接的比较紧的东西，第一个就是它的工具链。</p><p>游戏引擎的研发的话，最核心的是要构建一个就是工具体系。在我们的这个课程里面我们不会去介绍这些编辑器怎么用，我们是讲如何去构建一个可以给别人用的起来的一个游戏开发工具体系。 </p><p>那这里面最重要的概念就是反射体系，这个就比较抽象了，它会比较高能。然后会告诉大家就是说如何你做了一整套工具，你后面会不停的升级它的数据格式 但是过去的数据、未来的数据你能否兼容。</p><h4 id="Online-Gaming"><a href="#Online-Gaming" class="headerlink" title="Online Gaming"></a>Online Gaming</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0044.jpg"></p><p>网络这一块实际上在现代游戏引擎中我们认为是越来越重要，包括那些商业引擎在过去这一方面做的实际上是比较弱的，但是现在我们会发现我们越来越需要连接到彼此。 </p><h4 id="Advanced-Technology"><a href="#Advanced-Technology" class="headerlink" title="Advanced Technology"></a>Advanced Technology</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0045.jpg"></p><p>在这个课程的最后三节课，我就讲一些大家喜闻乐见的东西，因为我当时答应我们的 GAMES 就说我们会给他同学们介绍一些比较前沿的概念。那还是老规矩，我们尽可能讲人话让大家能听懂。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0046.jpg"></p><p>那么前沿技术的话，第二节的话那就比较硬核了。我们会给大家介绍一些最前沿的这个游戏引擎的架构理论，比如说面向数据的编程（DOP）还有多线程的任务系统。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0047.jpg"></p><p>那么最后一节也是大家非常喜欢乐见的业界标杆，比如说虚幻引擎。</p><p>大家都觉得虚幻五特别棒，那虚幻五最重要的两个 Feature 是什么呢？一个就是全局光照，大家觉得这个光照美轮美奂，那就是著名的 Luman 技术；还有它无限的几何细节，上一个像素级的这种面片，就是我们的 Nanite 技术。</p><br><p>GAMES104 课程的精神是什么？就是把一切的高深的技术全部给平民化，两节课的时间就把这个神秘的面纱给大家。接下来如果大家有兴趣去研究这这些技术的时候至少知道从哪下手，知道它的要点在哪里。 </p><h3 id="Topic-6-COURSE-LOGISTICS"><a href="#Topic-6-COURSE-LOGISTICS" class="headerlink" title="Topic 6 COURSE LOGISTICS"></a>Topic 6 COURSE LOGISTICS</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0048.jpg"></p><h4 id="General-Information"><a href="#General-Information" class="headerlink" title="General Information"></a>General Information</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0049.jpg"></p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0050.jpg"></p><h4 id="Mini-Engine"><a href="#Mini-Engine" class="headerlink" title="Mini Engine"></a>Mini Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0051.jpg"></p><h4 id="Assignments"><a href="#Assignments" class="headerlink" title="Assignments"></a>Assignments</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0052.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0053.jpg"></p><h4 id="Course-Contributor"><a href="#Course-Contributor" class="headerlink" title="Course Contributor"></a>Course Contributor</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0054.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0055.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0056.jpg"></p><br><center><a class="btn" href="https://slides.games-cn.org/course/GAMES104_Lecture01.pdf">            <i class="fas fa-download"></i>GAMES104_Lecture_01          </a></center></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture1_page-0001.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是对游戏引擎的概念做一个简单的了解。&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
  <entry>
    <title>试验性质的互动电影--Death Come True</title>
    <link href="https://yousazoe.top/archives/41c38174.html"/>
    <id>https://yousazoe.top/archives/41c38174.html</id>
    <published>2022-03-12T13:56:13.000Z</published>
    <updated>2022-07-01T09:23:45.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/(null)-20220316230631362.(null)"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这是一个可以通过选择决定下一步行动，并进而影响结局的，全新互动式影像游戏。 由【弹丸论破】系列策划人，人称鬼才的小高和刚氏所精心撰写的SF悬疑推理作品。</p><span id="more"></span><p><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.cloudflare.steamstatic.com/steam/apps/1321070/header.jpg?t=1641917439">       <source id="mp4" src="https://cdn.cloudflare.steamstatic.com/steam/apps/256791715/movie_max_vp9.webm?t=1593836662" type="video/mp4">       </video></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p>这是一个可以通过选择决定下一步行动，并进而影响结局的，全新互动式影像游戏。</p><p>由【弹丸论破】系列策划人，人称鬼才的小高和刚氏所精心撰写的SF悬疑推理作品。</p><p>玩家只需滑屏确认周围环境，并点击选项做出选择即可。即使不常玩游戏的朋友，也可以当做一部电影来欣赏。</p><p>剧情进行中，有多处需要玩家的选择。您所做的选择，究竟会迎来一个怎样的结局呢？</p><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h3 id="互动游戏的兴起"><a href="#互动游戏的兴起" class="headerlink" title="互动游戏的兴起"></a>互动游戏的兴起</h3><p>近年来，由于电脑读取速度与影像拍摄画质的进步，真人演出形式的互动式冒险游戏开始跃出台面，例如颇受好评的《黑镜：潘达斯奈基》，仍在台湾影城上映的《晚班》，或是号称每次结局都会变化的《化身侦探》等等。如今《死亡成真》（Death Come True）又是一款同类型的新作，该游戏即将在7月移植上架Steam。</p><p>由《枪弹辩驳》剧作家小高和刚成立的日本游戏公司 Too Kyo Games 制作的《死亡成真》是一款互动式电影游戏，本作剧本亦由小高和刚执笔，结合热门日本影星本郷奏多（《斗牌传说》的赤木茂）与栗山千明（《大逃杀》的千草贵子）担纲演出。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/ss_945b87d32160cbecec898e5f2e92d6b802b14f18-05877739267adde3133b7dbff202bcceaa765046.jpg"></p><p>所谓的电影式互动式冒险游戏，就是游戏的游玩方式类似于看电影，只有在关键的选择时，玩家可以从数个选择选出一个，然后电影会依造你的选择变换剧情，毫无停滞的继续播放下去，就游戏内容来说算是冒险游戏AVG 的类别，通常都会搭配多种结局，让玩家可以玩好几次。</p><h4 id="选择的自由表现"><a href="#选择的自由表现" class="headerlink" title="选择的自由表现"></a>选择的自由表现</h4><p>《死亡成真》与其他之前提到的电影式游戏差别最大也最令人赞赏的是「选择的表现方式」。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/ss_c60e507a8e7101d3c7a388a1dca14fbf10003233-63b6ca4a14a9c42d74c6af5d0e540499c3ed5894.jpg"></p><p>《黑镜：潘达斯奈基》与《晚班》都有一个问题，就是要让玩家选择剧情走向的时候，为了要维持电影播放的流畅度，都要刻意切一个长镜头，给玩家3～5 秒的时间选择，配上很简短的选项。 </p><p>这种做法对某些玩家来说其实是个困扰：依笔者自身与朋友一起看《晚班》的经验，常常在选项时必须赶快按下暂停，一群人一起讨论剧情发展，还有猜测选项的意义——不过这么做一方面就伤害了观影体验（因为你手动强制暂停），一方面也让人觉得选项内容太过简陋。</p><p>不过《死亡成真》这方面则做得不错，每当出现选项时，镜头会流畅的固定在类似VR 的第一人称视角后让玩家可以自由的左右选择，还有无限的思考时间，甚至还有一小段选择内容的动画影片，以观影体验来说十分顺畅，没有被打断的感觉——就像在看日剧一样。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/ss_bc26a725db127ba8dd3eeba8fe26108143da6727-bd657c55a5da7951e97dbbd1d7d9e0fbcf146384.jpg"></p><h4 id="游戏结局过少"><a href="#游戏结局过少" class="headerlink" title="游戏结局过少"></a>游戏结局过少</h4><p>本作缺点不少，但其中最让人感到遗憾的便是游戏结局过少，导致游戏时长很短，如果只要全破一轮，全结局大概只要两小时左右。没错，大概就是一场电影的时间。</p><p> <img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/ss_fe40ee0f0e63973fee23f396097674f953483120-df4815f75caa0a5a1187dded63300329c9081343.jpg"></p><p>如果期待像是《枪弹辩驳》或是《极限脱出9小时9人9扇门》这样复杂剧情的玩家，想必会非常失望。虽然剧情上没有很大的漏洞，但是正是因为没有很大的漏洞，所以很多地方都可以猜得到接下来的发展，缺少一些出人意料的爆点。</p><p>有点像是期待吃到一套大餐，却只上了前菜就结束了的感觉。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我想说的是，我们首先本来就不能期待这个作品可以媲美弹丸论破的深度与厚度哪怕只有一半。这不是制作人“江郎才尽”决定的，而是全动态影像自主选择这种游戏模式决定的。与传统的AVG相比，真人影像有着更好的现场体验，但整体的表达性则是相差甚远。因此，我们比较这部作品的对象应该是诸如《隐形守护者》，而不是《弹丸论破》。</p><p>显而易见，小高和刚完全没有搞懂互动影像游戏的内核是什么。当玩家在看过一段电影之后面临一份选择（通常是四择但本作多为两择）时，玩家渴望的是通过自己敏锐的观察力，以及在电影过程中对关键信息的遴选与记忆，确保自己做出正确的选择。然而开玩本作不超过五分钟你就会发现，并不存在正确的选择，也可以说不存在你自主的判断，你只是在一个选择的表皮下按照导演早设计好的唯一一条道路前进。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/(null)-20220316230631362.(null)&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这是一个可以通过选择决定下一步行动，并进而影响结局的，全新互动式影像游戏。 由【弹丸论破】系列策划人，人称鬼才的小高和刚氏所精心撰写的SF悬疑推理作品。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Attacking and Defeating the Enemy</title>
    <link href="https://yousazoe.top/archives/ebbc29f6.html"/>
    <id>https://yousazoe.top/archives/ebbc29f6.html</id>
    <published>2022-03-11T12:03:46.000Z</published>
    <updated>2022-07-01T09:23:45.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/SCII3.jpeg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Welcome to part 3 of the Starcraft AI with Python series. In the previous tutorials we learned the basics of writing an AI agent within Starcraft 2, but we’ve not yet been able to defeat the enemy computer player. In order to do this, we’re going to need to go on the offensive. There are many different types of units that we can go with to play more offensively, but my unit of choice is going to be the Void Ray. This is a good general purpose unit that flies around and shoots a laser beam.</p><span id="more"></span><iframe width="560" height="315" src="https://www.youtube.com/embed/FyhxoHKFIiY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe src="//player.bilibili.com/player.html?aid=937613128&amp;bvid=BV1vT4y1i7mW&amp;cid=557780479&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>The Void Ray isn’t necessarily the best unit to use in all situations, but we’re just here to have fun and learn for now.</p><p>In order to build a Void Ray, we need a Stargate. In order to build a Stargate, we need a Cybernetics Core, and for that…we need a Gateway! In order to build the Stargate, as well as the Void Ray units, we’re going to also need “gas.” For gas, we need to build assimilators to extract the vespene gas. To handle for all of this, we’ll again mostly revisit the <code>elif</code> chain. Our first order of business will be to build 2 assimilators. At least on this map, we seem to always start next to 2 vespene gas sources.</p><p>I think Pylons are more important in the order of needs than the assimilators, so right after those, I’ll add:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> self.structures(UnitTypeId.ASSIMILATOR).amount &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> nexus <span class="keyword">in</span> self.structures(UnitTypeId.NEXUS):</span><br><span class="line">        vespenes = self.vespene_geyser.closer_than(<span class="number">15</span>, nexus)</span><br><span class="line">        <span class="keyword">for</span> vespene <span class="keyword">in</span> vespenes:</span><br><span class="line">            <span class="keyword">if</span> self.can_afford(UnitTypeId.ASSIMILATOR) <span class="keyword">and</span> <span class="keyword">not</span> self.already_pending(UnitTypeId.ASSIMILATOR):</span><br><span class="line">                <span class="keyword">await</span> self.build(UnitTypeId.ASSIMILATOR, vespene)</span><br></pre></td></tr></tbody></table></figure><p>Take all of my orders with a grain of salt, it may be wise to test out different things, but for now we’ll do this. Later, we could maybe make this dynamic by checking how many vespenes we have close, and simply building assimilators on any unoccupied vespenes. I think the assimilators are more important than the forges and cannons, but I suspect it’s best to hold off on further buildings until we have some more defenses. After our cannons are built, however, we should go ahead and build the Gateway, Cybernetics Core, then Stargate:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># a gateway? this gets us towards cyb core &gt; stargate &gt; void ray</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.GATEWAY):</span><br><span class="line">    <span class="keyword">if</span> self.can_afford(UnitTypeId.GATEWAY):</span><br><span class="line">        <span class="keyword">await</span> self.build(UnitTypeId.GATEWAY, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line"></span><br><span class="line"><span class="comment"># a cyber core? this gets us towards stargate &gt; void ray</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.CYBERNETICSCORE):</span><br><span class="line">    <span class="keyword">if</span> self.can_afford(UnitTypeId.CYBERNETICSCORE):</span><br><span class="line">        <span class="keyword">await</span> self.build(UnitTypeId.CYBERNETICSCORE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line"></span><br><span class="line"><span class="comment"># a stargate? this gets us towards void ray</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.STARGATE):</span><br><span class="line">    <span class="keyword">if</span> self.can_afford(UnitTypeId.STARGATE):</span><br><span class="line">        <span class="keyword">await</span> self.build(UnitTypeId.STARGATE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br></pre></td></tr></tbody></table></figure><p>With all of this, we can build Void Rays, but I would argue that Void Rays are one of our top priorities, and we can also build Void Rays while we do other things. For this reason, I will actually just put this above the if/elif logic, after the nexus definition:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># if we have less than 10 voidrays, build one:</span></span><br><span class="line"><span class="keyword">if</span> self.structures(UnitTypeId.VOIDRAY).amount &lt; <span class="number">10</span> <span class="keyword">and</span> self.can_afford(UnitTypeId.VOIDRAY):</span><br><span class="line">    <span class="keyword">for</span> sg <span class="keyword">in</span> self.structures(UnitTypeId.STARGATE).ready.idle:</span><br><span class="line">        <span class="keyword">if</span> self.can_afford(UnitTypeId.VOIDRAY):</span><br><span class="line">            sg.train(UnitTypeId.VOIDRAY)</span><br></pre></td></tr></tbody></table></figure><p>In this case, I am going to just try to build up to 10 total. Maybe I’ll change this later, I just picked a random number that seemed reasonable. The last thing we need to is control our probe creation. Since we’re building infinite probes, we’ll always be able to build another probe, because a probe takse up 1 supply. A Void Ray costs us 4 supply, so we should probably always leave some room for at least 1 Void Ray. Maybe once we <em>can</em> build Void Rays, we can progressively open this up, or build more pylons to make more supply space. Again, this is all just a first pass of effort, there’s definitely a ton of improvement that could be made.</p><p>We can calc the supply remaining with:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">supply_remaining = self.supply_cap - self.supply_used</span><br></pre></td></tr></tbody></table></figure><p>Then we can just add another <code>and</code> to the if statement for the Pylons:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># leave room to build void rays</span></span><br><span class="line">supply_remaining = self.supply_cap - self.supply_used</span><br><span class="line"><span class="keyword">if</span> nexus.is_idle <span class="keyword">and</span> self.can_afford(UnitTypeId.PROBE) <span class="keyword">and</span> supply_remaining &gt; <span class="number">4</span>:</span><br><span class="line">    nexus.train(UnitTypeId.PROBE)</span><br></pre></td></tr></tbody></table></figure><p>Okay, we’ve added quite a bit up to this point. Here’s our code:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sc2.bot_ai <span class="keyword">import</span> BotAI  <span class="comment"># parent class we inherit from</span></span><br><span class="line"><span class="keyword">from</span> sc2.data <span class="keyword">import</span> Difficulty, Race  <span class="comment"># difficulty for bots, race for the 1 of 3 races</span></span><br><span class="line"><span class="keyword">from</span> sc2.main <span class="keyword">import</span> run_game  <span class="comment"># function that facilitates actually running the agents in games</span></span><br><span class="line"><span class="keyword">from</span> sc2.player <span class="keyword">import</span> Bot, Computer  <span class="comment">#wrapper for whether or not the agent is one of your bots, or a "computer" player</span></span><br><span class="line"><span class="keyword">from</span> sc2 <span class="keyword">import</span> maps  <span class="comment"># maps method for loading maps to play in.</span></span><br><span class="line"><span class="keyword">from</span> sc2.ids.unit_typeid <span class="keyword">import</span> UnitTypeId</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncrediBot</span>(<span class="title class_ inherited__">BotAI</span>): <span class="comment"># inhereits from BotAI (part of BurnySC2)</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_step</span>(<span class="params">self, iteration: <span class="built_in">int</span></span>): <span class="comment"># on_step is a method that is called every step of the game.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{iteration}</span>, n_workers: <span class="subst">{self.workers.amount}</span>, n_idle_workers: <span class="subst">{self.workers.idle.amount}</span>,"</span>, \</span><br><span class="line">            <span class="string">f"minerals: <span class="subst">{self.minerals}</span>, gas: <span class="subst">{self.vespene}</span>, cannons: <span class="subst">{self.structures(UnitTypeId.PHOTONCANNON).amount}</span>,"</span>, \</span><br><span class="line">            <span class="string">f"pylons: <span class="subst">{self.structures(UnitTypeId.PYLON).amount}</span>, nexus: <span class="subst">{self.structures(UnitTypeId.NEXUS).amount}</span>"</span>, \</span><br><span class="line">            <span class="string">f"gateways: <span class="subst">{self.structures(UnitTypeId.GATEWAY).amount}</span>, cybernetics cores: <span class="subst">{self.structures(UnitTypeId.CYBERNETICSCORE).amount}</span>"</span>, \</span><br><span class="line">            <span class="string">f"stargates: <span class="subst">{self.structures(UnitTypeId.STARGATE).amount}</span>, voidrays: <span class="subst">{self.units(UnitTypeId.VOIDRAY).amount}</span>, supply: <span class="subst">{self.supply_used}</span>/<span class="subst">{self.supply_cap}</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># begin logic:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> self.distribute_workers() <span class="comment"># put idle workers back to work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.townhalls:  <span class="comment"># do we have a nexus?</span></span><br><span class="line">            nexus = self.townhalls.random  <span class="comment"># select one (will just be one for now)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we have less than 10 voidrays, build one:</span></span><br><span class="line">            <span class="keyword">if</span> self.structures(UnitTypeId.VOIDRAY).amount &lt; <span class="number">10</span> <span class="keyword">and</span> self.can_afford(UnitTypeId.VOIDRAY):</span><br><span class="line">                <span class="keyword">for</span> sg <span class="keyword">in</span> self.structures(UnitTypeId.STARGATE).ready.idle:</span><br><span class="line">                    <span class="keyword">if</span> self.can_afford(UnitTypeId.VOIDRAY):</span><br><span class="line">                        sg.train(UnitTypeId.VOIDRAY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># leave room to build void rays</span></span><br><span class="line">            supply_remaining = self.supply_cap - self.supply_used</span><br><span class="line">            <span class="keyword">if</span> nexus.is_idle <span class="keyword">and</span> self.can_afford(UnitTypeId.PROBE) <span class="keyword">and</span> supply_remaining &gt; <span class="number">4</span>:</span><br><span class="line">                nexus.train(UnitTypeId.PROBE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we dont have *any* pylons, we'll build one close to the nexus.</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.PYLON) <span class="keyword">and</span> self.already_pending(UnitTypeId.PYLON) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=nexus)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.PYLON).amount &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">                    <span class="comment"># build from the closest pylon towards the enemy</span></span><br><span class="line">                    target_pylon = self.structures(UnitTypeId.PYLON).closest_to(self.enemy_start_locations[<span class="number">0</span>])</span><br><span class="line">                    <span class="comment"># build as far away from target_pylon as possible:</span></span><br><span class="line">                    pos = target_pylon.position.towards(self.enemy_start_locations[<span class="number">0</span>], random.randrange(<span class="number">8</span>, <span class="number">15</span>))</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=pos)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.ASSIMILATOR).amount &lt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> nexus <span class="keyword">in</span> self.structures(UnitTypeId.NEXUS):</span><br><span class="line">                    vespenes = self.vespene_geyser.closer_than(<span class="number">15</span>, nexus)</span><br><span class="line">                    <span class="keyword">for</span> vespene <span class="keyword">in</span> vespenes:</span><br><span class="line">                        <span class="keyword">if</span> self.can_afford(UnitTypeId.ASSIMILATOR) <span class="keyword">and</span> <span class="keyword">not</span> self.already_pending(UnitTypeId.ASSIMILATOR):</span><br><span class="line">                            <span class="keyword">await</span> self.build(UnitTypeId.ASSIMILATOR, vespene)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.FORGE):  <span class="comment"># if we don't have a forge:</span></span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.FORGE):  <span class="comment"># and we can afford one:</span></span><br><span class="line">                    <span class="comment"># build one near the Pylon that is closest to the nexus:</span></span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.FORGE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we have less than 3 cannons, let's build some more if possible:</span></span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.FORGE).ready <span class="keyword">and</span> self.structures(UnitTypeId.PHOTONCANNON).amount &lt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PHOTONCANNON):  <span class="comment"># can we afford a cannon?</span></span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PHOTONCANNON, near=nexus)  <span class="comment"># build one near the nexus</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># a gateway? this gets us towards cyb core &gt; stargate &gt; void ray</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.GATEWAY):</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.GATEWAY):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.GATEWAY, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># a cyber core? this gets us towards stargate &gt; void ray</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.CYBERNETICSCORE):</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.CYBERNETICSCORE):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.CYBERNETICSCORE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># a stargate? this gets us towards void ray</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.STARGATE):</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.STARGATE):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.STARGATE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.can_afford(UnitTypeId.NEXUS):  <span class="comment"># can we afford one?</span></span><br><span class="line">                <span class="keyword">await</span> self.expand_now()  <span class="comment"># build one!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_game(  <span class="comment"># run_game is a function that runs the game.</span></span><br><span class="line">    maps.get(<span class="string">"2000AtmospheresAIE"</span>), <span class="comment"># the map we are playing on</span></span><br><span class="line">    [Bot(Race.Protoss, IncrediBot()), <span class="comment"># runs our coded bot, protoss race, and we pass our bot object </span></span><br><span class="line">     Computer(Race.Zerg, Difficulty.Hard)], <span class="comment"># runs a pre-made computer agent, zerg race, with a hard difficulty.</span></span><br><span class="line">    realtime=<span class="literal">False</span>, <span class="comment"># When set to True, the agent is limited in how long each step can take to process.</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Running this, things actually look fairly decent. We wind up building 2 Starbases, and a few extra Void Rays, but we are definitely able to hold off the enemy for quite some time with this group:</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/void-rays-defense.jpg"></p><p>So we’ve definitely got a strong defense when needed with these Void Rays, but that’s not the reason we built them. We built these for battle! For the extra buildings, we can add a pending building check, same for Void Rays. It’s probably not a huge mistake to have a couple Starbases, since that means we can build Void Rays faster, but it would probably be a waste to have multiple Cybernetics Cores or something.</p><p>But, before I address that, I want to see an attack. To command this force, I propose we do it outside of the Nexus check. Our army of Void Rays does not need a Nexus to attack, so we can have their commands sit outside of the Nexus check. Void Rays also can’t build a Nexus back, so it’s fairly irrelevant. For now, in order to attack, I think it’s best we attack with more than just 1 Void Ray. I really don’t know if that’s true, and I’ll just arbitrarily set the number required for attack: 4.</p><p>The next question is: where do we attack?</p><p>We have access to some data about our game, as noted <a href="https://burnysc2.github.io/python-sc2/docs/text_files/introduction.html#available-information-in-the-game">here</a>. We can see that we can access enemy units, enemy structures, and the enemy start location. If we’ve seen enemy units or buildings, then we might as well target those first. If we don’t know where any enemy units are, then let’s head towards the enemy’s starting location, because we’ll probably find some enemies there!</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># if we have more than 3 voidrays, let's attack!</span></span><br><span class="line"><span class="keyword">if</span> self.units(UnitTypeId.VOIDRAY).amount &gt;= <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> self.enemy_units:</span><br><span class="line">        <span class="keyword">for</span> vr <span class="keyword">in</span> self.units(UnitTypeId.VOIDRAY).idle:</span><br><span class="line">            vr.attack(random.choice(self.enemy_units))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">elif</span> self.enemy_structures:</span><br><span class="line">        <span class="keyword">for</span> vr <span class="keyword">in</span> self.units(UnitTypeId.VOIDRAY).idle:</span><br><span class="line">            vr.attack(random.choice(self.enemy_structures))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># otherwise attack enemy starting position</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> vr <span class="keyword">in</span> self.units(UnitTypeId.VOIDRAY).idle:</span><br><span class="line">            vr.attack(self.enemy_start_locations[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure><p>Now, full code is:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sc2.bot_ai <span class="keyword">import</span> BotAI  <span class="comment"># parent class we inherit from</span></span><br><span class="line"><span class="keyword">from</span> sc2.data <span class="keyword">import</span> Difficulty, Race  <span class="comment"># difficulty for bots, race for the 1 of 3 races</span></span><br><span class="line"><span class="keyword">from</span> sc2.main <span class="keyword">import</span> run_game  <span class="comment"># function that facilitates actually running the agents in games</span></span><br><span class="line"><span class="keyword">from</span> sc2.player <span class="keyword">import</span> Bot, Computer  <span class="comment">#wrapper for whether or not the agent is one of your bots, or a "computer" player</span></span><br><span class="line"><span class="keyword">from</span> sc2 <span class="keyword">import</span> maps  <span class="comment"># maps method for loading maps to play in.</span></span><br><span class="line"><span class="keyword">from</span> sc2.ids.unit_typeid <span class="keyword">import</span> UnitTypeId</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncrediBot</span>(<span class="title class_ inherited__">BotAI</span>): <span class="comment"># inhereits from BotAI (part of BurnySC2)</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_step</span>(<span class="params">self, iteration: <span class="built_in">int</span></span>): <span class="comment"># on_step is a method that is called every step of the game.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{iteration}</span>, n_workers: <span class="subst">{self.workers.amount}</span>, n_idle_workers: <span class="subst">{self.workers.idle.amount}</span>,"</span>, \</span><br><span class="line">            <span class="string">f"minerals: <span class="subst">{self.minerals}</span>, gas: <span class="subst">{self.vespene}</span>, cannons: <span class="subst">{self.structures(UnitTypeId.PHOTONCANNON).amount}</span>,"</span>, \</span><br><span class="line">            <span class="string">f"pylons: <span class="subst">{self.structures(UnitTypeId.PYLON).amount}</span>, nexus: <span class="subst">{self.structures(UnitTypeId.NEXUS).amount}</span>"</span>, \</span><br><span class="line">            <span class="string">f"gateways: <span class="subst">{self.structures(UnitTypeId.GATEWAY).amount}</span>, cybernetics cores: <span class="subst">{self.structures(UnitTypeId.CYBERNETICSCORE).amount}</span>"</span>, \</span><br><span class="line">            <span class="string">f"stargates: <span class="subst">{self.structures(UnitTypeId.STARGATE).amount}</span>, voidrays: <span class="subst">{self.units(UnitTypeId.VOIDRAY).amount}</span>, supply: <span class="subst">{self.supply_used}</span>/<span class="subst">{self.supply_cap}</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># begin logic:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> self.distribute_workers() <span class="comment"># put idle workers back to work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.townhalls:  <span class="comment"># do we have a nexus?</span></span><br><span class="line">            nexus = self.townhalls.random  <span class="comment"># select one (will just be one for now)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we have less than 10 voidrays, build one:</span></span><br><span class="line">            <span class="keyword">if</span> self.structures(UnitTypeId.VOIDRAY).amount &lt; <span class="number">10</span> <span class="keyword">and</span> self.can_afford(UnitTypeId.VOIDRAY):</span><br><span class="line">                <span class="keyword">for</span> sg <span class="keyword">in</span> self.structures(UnitTypeId.STARGATE).ready.idle:</span><br><span class="line">                    <span class="keyword">if</span> self.can_afford(UnitTypeId.VOIDRAY):</span><br><span class="line">                        sg.train(UnitTypeId.VOIDRAY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># leave room to build void rays</span></span><br><span class="line">            supply_remaining = self.supply_cap - self.supply_used</span><br><span class="line">            <span class="keyword">if</span> nexus.is_idle <span class="keyword">and</span> self.can_afford(UnitTypeId.PROBE) <span class="keyword">and</span> supply_remaining &gt; <span class="number">4</span>:</span><br><span class="line">                nexus.train(UnitTypeId.PROBE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we dont have *any* pylons, we'll build one close to the nexus.</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.PYLON) <span class="keyword">and</span> self.already_pending(UnitTypeId.PYLON) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=nexus)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.PYLON).amount &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">                    <span class="comment"># build from the closest pylon towards the enemy</span></span><br><span class="line">                    target_pylon = self.structures(UnitTypeId.PYLON).closest_to(self.enemy_start_locations[<span class="number">0</span>])</span><br><span class="line">                    <span class="comment"># build as far away from target_pylon as possible:</span></span><br><span class="line">                    pos = target_pylon.position.towards(self.enemy_start_locations[<span class="number">0</span>], random.randrange(<span class="number">8</span>, <span class="number">15</span>))</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=pos)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.ASSIMILATOR).amount &lt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> nexus <span class="keyword">in</span> self.structures(UnitTypeId.NEXUS):</span><br><span class="line">                    vespenes = self.vespene_geyser.closer_than(<span class="number">15</span>, nexus)</span><br><span class="line">                    <span class="keyword">for</span> vespene <span class="keyword">in</span> vespenes:</span><br><span class="line">                        <span class="keyword">if</span> self.can_afford(UnitTypeId.ASSIMILATOR) <span class="keyword">and</span> <span class="keyword">not</span> self.already_pending(UnitTypeId.ASSIMILATOR):</span><br><span class="line">                            <span class="keyword">await</span> self.build(UnitTypeId.ASSIMILATOR, vespene)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.FORGE):  <span class="comment"># if we don't have a forge:</span></span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.FORGE):  <span class="comment"># and we can afford one:</span></span><br><span class="line">                    <span class="comment"># build one near the Pylon that is closest to the nexus:</span></span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.FORGE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we have less than 3 cannons, let's build some more if possible:</span></span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.FORGE).ready <span class="keyword">and</span> self.structures(UnitTypeId.PHOTONCANNON).amount &lt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PHOTONCANNON):  <span class="comment"># can we afford a cannon?</span></span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PHOTONCANNON, near=nexus)  <span class="comment"># build one near the nexus</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># a gateway? this gets us towards cyb core &gt; stargate &gt; void ray</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.GATEWAY):</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.GATEWAY):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.GATEWAY, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># a cyber core? this gets us towards stargate &gt; void ray</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.CYBERNETICSCORE):</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.CYBERNETICSCORE):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.CYBERNETICSCORE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># a stargate? this gets us towards void ray</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.STARGATE):</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.STARGATE):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.STARGATE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.can_afford(UnitTypeId.NEXUS):  <span class="comment"># can we afford one?</span></span><br><span class="line">                <span class="keyword">await</span> self.expand_now()  <span class="comment"># build one!</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># if we have more than 3 voidrays, let's attack!</span></span><br><span class="line">        <span class="keyword">if</span> self.units(UnitTypeId.VOIDRAY).amount &gt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> self.enemy_units:</span><br><span class="line">                <span class="keyword">for</span> vr <span class="keyword">in</span> self.units(UnitTypeId.VOIDRAY).idle:</span><br><span class="line">                    vr.attack(random.choice(self.enemy_units))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> self.enemy_structures:</span><br><span class="line">                <span class="keyword">for</span> vr <span class="keyword">in</span> self.units(UnitTypeId.VOIDRAY).idle:</span><br><span class="line">                    vr.attack(random.choice(self.enemy_structures))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># otherwise attack enemy starting position</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> vr <span class="keyword">in</span> self.units(UnitTypeId.VOIDRAY).idle:</span><br><span class="line">                    vr.attack(self.enemy_start_locations[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_game(  <span class="comment"># run_game is a function that runs the game.</span></span><br><span class="line">    maps.get(<span class="string">"2000AtmospheresAIE"</span>), <span class="comment"># the map we are playing on</span></span><br><span class="line">    [Bot(Race.Protoss, IncrediBot()), <span class="comment"># runs our coded bot, protoss race, and we pass our bot object </span></span><br><span class="line">     Computer(Race.Zerg, Difficulty.Hard)], <span class="comment"># runs a pre-made computer agent, zerg race, with a hard difficulty.</span></span><br><span class="line">    realtime=<span class="literal">False</span>, <span class="comment"># When set to True, the agent is limited in how long each step can take to process.</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Running this, we make some void rays and can see them promptly go to the enemy starting location across the map, wreaking immediate havoc on the enemy:</p><iframe src="//player.bilibili.com/player.html?aid=510002180&amp;bvid=BV1Bu411q7bi&amp;cid=557729934&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>The enemy does propose to surrender, but we don’t accept this. Eventually:</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/void-ray-victory.jpg"></p><p>Running this a few times seems to yield similar results. It seems like Void Rays do pretty well here, at least up to the Hard Zerg computer. When poking around, I saw that Void Rays apparently don’t do well against terran. Let’s change the computer to Terran race instead:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">run_game(  <span class="comment"># run_game is a function that runs the game.</span></span><br><span class="line">    maps.get(<span class="string">"2000AtmospheresAIE"</span>), <span class="comment"># the map we are playing on</span></span><br><span class="line">    [Bot(Race.Protoss, IncrediBot()), <span class="comment"># runs our coded bot, protoss race, and we pass our bot object </span></span><br><span class="line">     Computer(Race.Terran, Difficulty.Hard)], <span class="comment"># runs a pre-made computer agent, zerg race, with a hard difficulty.</span></span><br><span class="line">    realtime=<span class="literal">False</span>, <span class="comment"># When set to True, the agent is limited in how long each step can take to process.</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>While the fight definitely looked a bit harder, it certainly wasn’t as swift of a defeat and we lost more Void Rays, we still won. Running again, the victory seems to come even easier:</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/void-rays-vs-terran.jpg"></p><p>It does seem like the Terrans can handle Void Rays better, and that probably harder bots will require a better strategy, but I’d say this is a pretty good start.</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/SCII3.jpeg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Welcome to part 3 of the Starcraft AI with Python series. In the previous tutorials we learned the basics of writing an AI agent within Starcraft 2, but we’ve not yet been able to defeat the enemy computer player. In order to do this, we’re going to need to go on the offensive. There are many different types of units that we can go with to play more offensively, but my unit of choice is going to be the Void Ray. This is a good general purpose unit that flies around and shoots a laser beam.&lt;/p&gt;</summary>
    
    
    
    <category term="星际争霸2与人工智能 (Building Starcraft 2 AI in Python with Python-sc2)" scheme="https://yousazoe.top/categories/%E6%98%9F%E9%99%85%E4%BA%89%E9%9C%B82%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-Building-Starcraft-2-AI-in-Python-with-Python-sc2/"/>
    
    
    <category term="Python" scheme="https://yousazoe.top/tags/Python/"/>
    
    <category term="StarCraft2" scheme="https://yousazoe.top/tags/StarCraft2/"/>
    
  </entry>
  
  <entry>
    <title>Defending Ourselves</title>
    <link href="https://yousazoe.top/archives/1c1975a5.html"/>
    <id>https://yousazoe.top/archives/1c1975a5.html</id>
    <published>2022-03-10T14:00:38.000Z</published>
    <updated>2022-07-01T09:23:45.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/SCII2.webp"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Adding logic to the Starcraft 2 artificial intelligence to defend our main base.</p><span id="more"></span><iframe width="560" height="315" src="https://www.youtube.com/embed/fqEzFZ2z6S4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe src="//player.bilibili.com/player.html?aid=767590395&amp;bvid=BV1Lr4y1W7b9&amp;cid=557746922&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>Welcome to part 2 of the Starcraft 2 tutorials. Where we left off, we had established some of the basics of the game, as well as writing and running our own basic script to start. The code so far:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sc2.bot_ai <span class="keyword">import</span> BotAI  <span class="comment"># parent class we inherit from</span></span><br><span class="line"><span class="keyword">from</span> sc2.data <span class="keyword">import</span> Difficulty, Race  <span class="comment"># difficulty for bots, race for the 1 of 3 races</span></span><br><span class="line"><span class="keyword">from</span> sc2.main <span class="keyword">import</span> run_game  <span class="comment"># function that facilitates actually running the agents in games</span></span><br><span class="line"><span class="keyword">from</span> sc2.player <span class="keyword">import</span> Bot, Computer  <span class="comment">#wrapper for whether or not the agent is one of your bots, or a "computer" player</span></span><br><span class="line"><span class="keyword">from</span> sc2 <span class="keyword">import</span> maps  <span class="comment"># maps method for loading maps to play in.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncrediBot</span>(<span class="title class_ inherited__">BotAI</span>): <span class="comment"># inhereits from BotAI (part of BurnySC2)</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_step</span>(<span class="params">self, iteration: <span class="built_in">int</span></span>): <span class="comment"># on_step is a method that is called every step of the game.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"This is my bot in iteration <span class="subst">{iteration}</span>"</span>) <span class="comment"># prints out the iteration number (ie: the step).</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_game(  <span class="comment"># run_game is a function that runs the game.</span></span><br><span class="line">    maps.get(<span class="string">"2000AtmospheresAIE"</span>), <span class="comment"># the map we are playing on</span></span><br><span class="line">    [Bot(Race.Protoss, IncrediBot()), <span class="comment"># runs our coded bot, protoss race, and we pass our bot object </span></span><br><span class="line">     Computer(Race.Zerg, Difficulty.Hard)], <span class="comment"># runs a pre-made computer agent, zerg race, with a hard difficulty.</span></span><br><span class="line">    realtime=<span class="literal">False</span>, <span class="comment"># When set to True, the agent is limited in how long each step can take to process.</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>To continue, I’ll start by modifying the print statement a bit to contain information on our buildings and units:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_step</span>(<span class="params">self, iteration: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="comment">#print(f"This is my bot in iteration {iteration}, workers: {self.workers}, idle workers: {self.workers.idle}, supply: {self.supply_used}/{self.supply_cap}")</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"<span class="subst">{iteration}</span>, n_workers: <span class="subst">{self.workers.amount}</span>, n_idle_workers: <span class="subst">{self.workers.idle.amount}</span>,"</span>, \</span><br><span class="line">        <span class="string">f"minerals: <span class="subst">{self.minerals}</span>, gas: <span class="subst">{self.vespene}</span>, cannons: <span class="subst">{self.structures(UnitTypeId.PHOTONCANNON).amount}</span>,"</span>, \</span><br><span class="line">        <span class="string">f"pylons: <span class="subst">{self.structures(UnitTypeId.PYLON).amount}</span>, nexus: <span class="subst">{self.structures(UnitTypeId.NEXUS).amount}</span>"</span>, \</span><br><span class="line">        <span class="string">f"gateways: <span class="subst">{self.structures(UnitTypeId.GATEWAY).amount}</span>, cybernetics cores: <span class="subst">{self.structures(UnitTypeId.CYBERNETICSCORE).amount}</span>"</span>, \</span><br><span class="line">        <span class="string">f"stargates: <span class="subst">{self.structures(UnitTypeId.STARGATE).amount}</span>, voidrays: <span class="subst">{self.units(UnitTypeId.VOIDRAY).amount}</span>, supply: <span class="subst">{self.supply_used}</span>/<span class="subst">{self.supply_cap}</span>"</span>)</span><br><span class="line">  </span><br></pre></td></tr></tbody></table></figure><p>Here, we’re just outputting the numbers of various buildings, units, and supply information. The idea here is mainly just for debugging purposes. If we add logic that we think will build a Stargate, but one isn’t built, then the next question we’d have is if a Cybernetics core exists and if we had the supplies necessary to build the Stargate.</p><p>We’re also using <code>UnitTypeId</code> here, so we’ll need to import that:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sc2.ids.unit_typeid <span class="keyword">import</span> UnitTypeId</span><br></pre></td></tr></tbody></table></figure><p>Next, since the game is very hierarchical, everything we do (nearly) requires us to have at least one Nexus. If we’ve lost the Nexus, then really our top priority is to make another one as soon as possible, or I suppose maybe destroy the enemy if you can. So, our logic, at least for now, will start with a Nexus check (note that we use self.townhalls here, which is race-generic for checking the existence of this sort of main building):</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># begin logic:</span></span><br><span class="line"><span class="keyword">if</span> self.townhalls:  <span class="comment"># do we have a nexus?</span></span><br><span class="line">    nexus = self.townhalls.random  <span class="comment"># select one (will just be one for now)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> self.can_afford(UnitTypeId.NEXUS):  <span class="comment"># can we afford one?</span></span><br><span class="line">        <span class="keyword">await</span> self.expand_now()  <span class="comment"># build one!</span></span><br></pre></td></tr></tbody></table></figure><p>For now, we’ll be peaceful and just build a bunch of workers (if we have a nexus).</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> nexus.is_idle <span class="keyword">and</span> self.can_afford(UnitTypeId.PROBE):</span><br><span class="line">nexus.train(UnitTypeId.PROBE)</span><br></pre></td></tr></tbody></table></figure><p>Full code up to this point:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sc2.bot_ai <span class="keyword">import</span> BotAI  <span class="comment"># parent class we inherit from</span></span><br><span class="line"><span class="keyword">from</span> sc2.data <span class="keyword">import</span> Difficulty, Race  <span class="comment"># difficulty for bots, race for the 1 of 3 races</span></span><br><span class="line"><span class="keyword">from</span> sc2.main <span class="keyword">import</span> run_game  <span class="comment"># function that facilitates actually running the agents in games</span></span><br><span class="line"><span class="keyword">from</span> sc2.player <span class="keyword">import</span> Bot, Computer  <span class="comment">#wrapper for whether or not the agent is one of your bots, or a "computer" player</span></span><br><span class="line"><span class="keyword">from</span> sc2 <span class="keyword">import</span> maps  <span class="comment"># maps method for loading maps to play in.</span></span><br><span class="line"><span class="keyword">from</span> sc2.ids.unit_typeid <span class="keyword">import</span> UnitTypeId</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncrediBot</span>(<span class="title class_ inherited__">BotAI</span>): <span class="comment"># inhereits from BotAI (part of BurnySC2)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_step</span>(<span class="params">self, iteration: <span class="built_in">int</span></span>): <span class="comment"># on_step is a method that is called every step of the game.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"<span class="subst">{iteration}</span>, n_workers: <span class="subst">{self.workers.amount}</span>, n_idle_workers: <span class="subst">{self.workers.idle.amount}</span>,"</span>, \</span><br><span class="line"><span class="string">f"minerals: <span class="subst">{self.minerals}</span>, gas: <span class="subst">{self.vespene}</span>, cannons: <span class="subst">{self.structures(UnitTypeId.PHOTONCANNON).amount}</span>,"</span>, \</span><br><span class="line"><span class="string">f"pylons: <span class="subst">{self.structures(UnitTypeId.PYLON).amount}</span>, nexus: <span class="subst">{self.structures(UnitTypeId.NEXUS).amount}</span>"</span>, \</span><br><span class="line"><span class="string">f"gateways: <span class="subst">{self.structures(UnitTypeId.GATEWAY).amount}</span>, cybernetics cores: <span class="subst">{self.structures(UnitTypeId.CYBERNETICSCORE).amount}</span>"</span>, \</span><br><span class="line"><span class="string">f"stargates: <span class="subst">{self.structures(UnitTypeId.STARGATE).amount}</span>, voidrays: <span class="subst">{self.units(UnitTypeId.VOIDRAY).amount}</span>, supply: <span class="subst">{self.supply_used}</span>/<span class="subst">{self.supply_cap}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># begin logic:</span></span><br><span class="line"><span class="keyword">if</span> self.townhalls:  <span class="comment"># do we have a nexus?</span></span><br><span class="line">nexus = self.townhalls.random  <span class="comment"># select one (will just be one for now)</span></span><br><span class="line"><span class="keyword">if</span> nexus.is_idle <span class="keyword">and</span> self.can_afford(UnitTypeId.PROBE):  </span><br><span class="line">nexus.train(UnitTypeId.PROBE)  <span class="comment"># train a probe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> self.can_afford(UnitTypeId.NEXUS):  <span class="comment"># can we afford one?</span></span><br><span class="line"><span class="keyword">await</span> self.expand_now()  <span class="comment"># build one!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_game(  <span class="comment"># run_game is a function that runs the game.</span></span><br><span class="line">maps.get(<span class="string">"2000AtmospheresAIE"</span>), <span class="comment"># the map we are playing on</span></span><br><span class="line">[Bot(Race.Protoss, IncrediBot()), <span class="comment"># runs our coded bot, protoss race, and we pass our bot object </span></span><br><span class="line">Computer(Race.Zerg, Difficulty.Hard)], <span class="comment"># runs a pre-made computer agent, zerg race, with a hard difficulty.</span></span><br><span class="line">realtime=<span class="literal">False</span>, <span class="comment"># When set to True, the agent is limited in how long each step can take to process.</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Running this, it looks pretty similar to our runs before:</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/basic-game-running-20220311122828031.jpg"></p><p>Before we can do much, we definitely need resources, and we might want more units. To increase units, we need more <code>Supply</code>. For that, with Protoss, we need Pylons. I’ll just come up with some logic to put down, but where you place these Pylons does matter. These are what powers your buildings and dictates where units can be warped in. Strategically, these matter a lot. For now, we just need some. So, to begin, we’ll start our main <code>elif</code> chain, which essentially is a ranking of things, in the order of how important they are to us to exist, and all of this is contained under the if statement checking to see if a Nexus exists.</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># if we dont have *any* pylons, we'll build one close to the nexus.</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.PYLON) <span class="keyword">and</span> self.already_pending(UnitTypeId.PYLON) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">        <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=nexus)</span><br></pre></td></tr></tbody></table></figure><p>As far as I can tell, the SC2 package takes care of grabbing a worker and building things when you ask it to. I am sure there’s a way you can take control of this to be more precise. For now, however, this works well. In order to make room for more buildings and our attack units, we’ll probably want more pylons than this. For now, let’s presume we want 5.</p><p>These Pylons need to be close to eachother to build a “matrix,” so we want them close, but if we just build all of them near our Nexus, chances are we’ll put them way too close together and possibly even block ourselves from leaving our starting area, so we want to employ some logic about how to “expand” outwards. For now, that logic will be to build near the nearest-to-the-enemy pylon, continuing towards the enemy:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> self.structures(UnitTypeId.PYLON).amount &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">        <span class="comment"># build from the closest pylon towards the enemy</span></span><br><span class="line">        target_pylon = self.structures(UnitTypeId.PYLON).closest_to(self.enemy_start_locations[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># build as far away from target_pylon as possible:</span></span><br><span class="line">        pos = target_pylon.position.towards(self.enemy_start_locations[<span class="number">0</span>], random.randrange(<span class="number">8</span>, <span class="number">15</span>))</span><br><span class="line">        <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=pos)</span><br></pre></td></tr></tbody></table></figure><p>Full code up to this point:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sc2.bot_ai <span class="keyword">import</span> BotAI  <span class="comment"># parent class we inherit from</span></span><br><span class="line"><span class="keyword">from</span> sc2.data <span class="keyword">import</span> Difficulty, Race  <span class="comment"># difficulty for bots, race for the 1 of 3 races</span></span><br><span class="line"><span class="keyword">from</span> sc2.main <span class="keyword">import</span> run_game  <span class="comment"># function that facilitates actually running the agents in games</span></span><br><span class="line"><span class="keyword">from</span> sc2.player <span class="keyword">import</span> Bot, Computer  <span class="comment">#wrapper for whether or not the agent is one of your bots, or a "computer" player</span></span><br><span class="line"><span class="keyword">from</span> sc2 <span class="keyword">import</span> maps  <span class="comment"># maps method for loading maps to play in.</span></span><br><span class="line"><span class="keyword">from</span> sc2.ids.unit_typeid <span class="keyword">import</span> UnitTypeId</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncrediBot</span>(<span class="title class_ inherited__">BotAI</span>): <span class="comment"># inhereits from BotAI (part of BurnySC2)</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_step</span>(<span class="params">self, iteration: <span class="built_in">int</span></span>): <span class="comment"># on_step is a method that is called every step of the game.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{iteration}</span>, n_workers: <span class="subst">{self.workers.amount}</span>, n_idle_workers: <span class="subst">{self.workers.idle.amount}</span>,"</span>, \</span><br><span class="line">            <span class="string">f"minerals: <span class="subst">{self.minerals}</span>, gas: <span class="subst">{self.vespene}</span>, cannons: <span class="subst">{self.structures(UnitTypeId.PHOTONCANNON).amount}</span>,"</span>, \</span><br><span class="line">            <span class="string">f"pylons: <span class="subst">{self.structures(UnitTypeId.PYLON).amount}</span>, nexus: <span class="subst">{self.structures(UnitTypeId.NEXUS).amount}</span>"</span>, \</span><br><span class="line">            <span class="string">f"gateways: <span class="subst">{self.structures(UnitTypeId.GATEWAY).amount}</span>, cybernetics cores: <span class="subst">{self.structures(UnitTypeId.CYBERNETICSCORE).amount}</span>"</span>, \</span><br><span class="line">            <span class="string">f"stargates: <span class="subst">{self.structures(UnitTypeId.STARGATE).amount}</span>, voidrays: <span class="subst">{self.units(UnitTypeId.VOIDRAY).amount}</span>, supply: <span class="subst">{self.supply_used}</span>/<span class="subst">{self.supply_cap}</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># begin logic:</span></span><br><span class="line">        <span class="keyword">if</span> self.townhalls:  <span class="comment"># do we have a nexus?</span></span><br><span class="line">            nexus = self.townhalls.random  <span class="comment"># select one (will just be one for now)</span></span><br><span class="line">            <span class="keyword">if</span> nexus.is_idle <span class="keyword">and</span> self.can_afford(UnitTypeId.PROBE):  </span><br><span class="line">                nexus.train(UnitTypeId.PROBE)  <span class="comment"># train a probe</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we dont have *any* pylons, we'll build one close to the nexus.</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.PYLON) <span class="keyword">and</span> self.already_pending(UnitTypeId.PYLON) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=nexus)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.PYLON).amount &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">                    <span class="comment"># build from the closest pylon towards the enemy</span></span><br><span class="line">                    target_pylon = self.structures(UnitTypeId.PYLON).closest_to(self.enemy_start_locations[<span class="number">0</span>])</span><br><span class="line">                    <span class="comment"># build as far away from target_pylon as possible:</span></span><br><span class="line">                    pos = target_pylon.position.towards(self.enemy_start_locations[<span class="number">0</span>], random.randrange(<span class="number">8</span>, <span class="number">15</span>))</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=pos)</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.can_afford(UnitTypeId.NEXUS):  <span class="comment"># can we afford one?</span></span><br><span class="line">                <span class="keyword">await</span> self.expand_now()  <span class="comment"># build one!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_game(  <span class="comment"># run_game is a function that runs the game.</span></span><br><span class="line">    maps.get(<span class="string">"2000AtmospheresAIE"</span>), <span class="comment"># the map we are playing on</span></span><br><span class="line">    [Bot(Race.Protoss, IncrediBot()), <span class="comment"># runs our coded bot, protoss race, and we pass our bot object </span></span><br><span class="line">     Computer(Race.Zerg, Difficulty.Hard)], <span class="comment"># runs a pre-made computer agent, zerg race, with a hard difficulty.</span></span><br><span class="line">    realtime=<span class="literal">False</span>, <span class="comment"># When set to True, the agent is limited in how long each step can take to process.</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><iframe src="//player.bilibili.com/player.html?aid=510002180&amp;bvid=BV1Bu411q7bi&amp;cid=557729934&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/more-workers.jpg"></p><p>In this example, we have 24/16 workers, but we will wind up likely with even more as the game progresses. With protoss, at 16 units per Nexus, you have the most efficiency per worker. This declines a bit to 24/16, and if I understand correctly, workers will wind up essentially being idle at more than 24 per nexus.</p><p>Next, we still find ourselves under attack usually within 1,000 steps of the game:</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/no-defenses.jpg"></p><p>To possibly help with this, we can build Cannons. Cannons are stationary, yet powerful buildings that can do a healthy amount of damage. There’s even a strategy with Protoss to quickly build cannons at the enemy’s base. We won’t be doing that for now, and will instead just try to build up our defenses a bit to deter enemy attacks.</p><p>You may also have noticed that we have idle workers. While we have way too many workers per nexus, this doesn’t really matter much, but this could catch us off guard later. To handle for this, the very first thing we’ll do in the loop after the print statement is:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> self.distribute_workers()</span><br></pre></td></tr></tbody></table></figure><p>This will put the workers back to work. They probably went idle after building a building.</p><p>Since we want to build cannons, we need to revist the <a href="https://liquipedia.net/starcraft2/Protoss_Units_(Legacy_of_the_Void)"><strong>Protoss Unit tree</strong></a>. This informs us that, if we want cannons, we first need to build a <code>Forge</code>. I’ll add this to the <code>elif</code> list.</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.FORGE):  <span class="comment"># if we don't have a forge:</span></span><br><span class="line">    <span class="keyword">if</span> self.can_afford(UnitTypeId.FORGE):  <span class="comment"># and we can afford one:</span></span><br><span class="line">        <span class="comment"># build one near the Pylon that is closest to the nexus:</span></span><br><span class="line">        <span class="keyword">await</span> self.build(UnitTypeId.FORGE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br></pre></td></tr></tbody></table></figure><p>Take note here of all of the helper methods that we have available to us for logically building/placing things, especially with that build line, allowing us to build a forge not just close to a Pylon (recall we need to build buildings within the matrix of Pylons), but also close to the Pylon that’s closest to the Nexus. Again, there are certainly ways to take full control over exact building locations, and this might help you to be even more strategic, but all these helper capabilities sure do make building SC2 agent logic very fast and easy!</p><p>Once we have a forge, let’s build up to 3 cannons around our base for defenses:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># if we have less than 3 cannons, let's build some more if possible:</span></span><br><span class="line"><span class="keyword">elif</span> self.structures(UnitTypeId.FORGE).ready <span class="keyword">and</span> self.structures(UnitTypeId.PHOTONCANNON).amount &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> self.can_afford(UnitTypeId.PHOTONCANNON):  <span class="comment"># can we afford a cannon?</span></span><br><span class="line">        <span class="keyword">await</span> self.build(UnitTypeId.PHOTONCANNON, near=nexus)  <span class="comment"># build one near the nexus</span></span><br></pre></td></tr></tbody></table></figure><p>With this, the full SC2 <code>IncrediBot</code> code is:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sc2.bot_ai <span class="keyword">import</span> BotAI  <span class="comment"># parent class we inherit from</span></span><br><span class="line"><span class="keyword">from</span> sc2.data <span class="keyword">import</span> Difficulty, Race  <span class="comment"># difficulty for bots, race for the 1 of 3 races</span></span><br><span class="line"><span class="keyword">from</span> sc2.main <span class="keyword">import</span> run_game  <span class="comment"># function that facilitates actually running the agents in games</span></span><br><span class="line"><span class="keyword">from</span> sc2.player <span class="keyword">import</span> Bot, Computer  <span class="comment">#wrapper for whether or not the agent is one of your bots, or a "computer" player</span></span><br><span class="line"><span class="keyword">from</span> sc2 <span class="keyword">import</span> maps  <span class="comment"># maps method for loading maps to play in.</span></span><br><span class="line"><span class="keyword">from</span> sc2.ids.unit_typeid <span class="keyword">import</span> UnitTypeId</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncrediBot</span>(<span class="title class_ inherited__">BotAI</span>): <span class="comment"># inhereits from BotAI (part of BurnySC2)</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_step</span>(<span class="params">self, iteration: <span class="built_in">int</span></span>): <span class="comment"># on_step is a method that is called every step of the game.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{iteration}</span>, n_workers: <span class="subst">{self.workers.amount}</span>, n_idle_workers: <span class="subst">{self.workers.idle.amount}</span>,"</span>, \</span><br><span class="line">            <span class="string">f"minerals: <span class="subst">{self.minerals}</span>, gas: <span class="subst">{self.vespene}</span>, cannons: <span class="subst">{self.structures(UnitTypeId.PHOTONCANNON).amount}</span>,"</span>, \</span><br><span class="line">            <span class="string">f"pylons: <span class="subst">{self.structures(UnitTypeId.PYLON).amount}</span>, nexus: <span class="subst">{self.structures(UnitTypeId.NEXUS).amount}</span>"</span>, \</span><br><span class="line">            <span class="string">f"gateways: <span class="subst">{self.structures(UnitTypeId.GATEWAY).amount}</span>, cybernetics cores: <span class="subst">{self.structures(UnitTypeId.CYBERNETICSCORE).amount}</span>"</span>, \</span><br><span class="line">            <span class="string">f"stargates: <span class="subst">{self.structures(UnitTypeId.STARGATE).amount}</span>, voidrays: <span class="subst">{self.units(UnitTypeId.VOIDRAY).amount}</span>, supply: <span class="subst">{self.supply_used}</span>/<span class="subst">{self.supply_cap}</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># begin logic:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> self.distribute_workers() <span class="comment"># put idle workers back to work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.townhalls:  <span class="comment"># do we have a nexus?</span></span><br><span class="line">            nexus = self.townhalls.random  <span class="comment"># select one (will just be one for now)</span></span><br><span class="line">            <span class="keyword">if</span> nexus.is_idle <span class="keyword">and</span> self.can_afford(UnitTypeId.PROBE):  </span><br><span class="line">                nexus.train(UnitTypeId.PROBE)  <span class="comment"># train a probe</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we dont have *any* pylons, we'll build one close to the nexus.</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.PYLON) <span class="keyword">and</span> self.already_pending(UnitTypeId.PYLON) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=nexus)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.PYLON).amount &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PYLON):</span><br><span class="line">                    <span class="comment"># build from the closest pylon towards the enemy</span></span><br><span class="line">                    target_pylon = self.structures(UnitTypeId.PYLON).closest_to(self.enemy_start_locations[<span class="number">0</span>])</span><br><span class="line">                    <span class="comment"># build as far away from target_pylon as possible:</span></span><br><span class="line">                    pos = target_pylon.position.towards(self.enemy_start_locations[<span class="number">0</span>], random.randrange(<span class="number">8</span>, <span class="number">15</span>))</span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PYLON, near=pos)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.structures(UnitTypeId.FORGE):  <span class="comment"># if we don't have a forge:</span></span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.FORGE):  <span class="comment"># and we can afford one:</span></span><br><span class="line">                    <span class="comment"># build one near the Pylon that is closest to the nexus:</span></span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.FORGE, near=self.structures(UnitTypeId.PYLON).closest_to(nexus))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if we have less than 3 cannons, let's build some more if possible:</span></span><br><span class="line">            <span class="keyword">elif</span> self.structures(UnitTypeId.FORGE).ready <span class="keyword">and</span> self.structures(UnitTypeId.PHOTONCANNON).amount &lt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> self.can_afford(UnitTypeId.PHOTONCANNON):  <span class="comment"># can we afford a cannon?</span></span><br><span class="line">                    <span class="keyword">await</span> self.build(UnitTypeId.PHOTONCANNON, near=nexus)  <span class="comment"># build one near the nexus</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.can_afford(UnitTypeId.NEXUS):  <span class="comment"># can we afford one?</span></span><br><span class="line">                <span class="keyword">await</span> self.expand_now()  <span class="comment"># build one!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_game(  <span class="comment"># run_game is a function that runs the game.</span></span><br><span class="line">    maps.get(<span class="string">"2000AtmospheresAIE"</span>), <span class="comment"># the map we are playing on</span></span><br><span class="line">    [Bot(Race.Protoss, IncrediBot()), <span class="comment"># runs our coded bot, protoss race, and we pass our bot object </span></span><br><span class="line">     Computer(Race.Zerg, Difficulty.Hard)], <span class="comment"># runs a pre-made computer agent, zerg race, with a hard difficulty.</span></span><br><span class="line">    realtime=<span class="literal">False</span>, <span class="comment"># When set to True, the agent is limited in how long each step can take to process.</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Running this, we should see things are fairly improved. For example, we do still get attacked around 1,000 to 1,200 steps in:</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/intial-attack-with-cannons.jpg"></p><p>With multiple runs, sometimes we’re still defeated, but sometimes we actually survive the attack, like here:</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/post-attack-with-cannon-defenses.jpg"></p><p>Of course, eventually we’ll still be defeated here, without either expanding more and making even more defenses, making it essentially impossible for the enemy to have enough resources to kill us, or, for us to go on the offensive, and to actually attack the enemy. With cannons, we can’t really move them, but with quite a few units, we can actually move them and use them both for defense as well as offense. This will be the focus of the next tutorial.</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/SCII2.webp&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Adding logic to the Starcraft 2 artificial intelligence to defend our main base.&lt;/p&gt;</summary>
    
    
    
    <category term="星际争霸2与人工智能 (Building Starcraft 2 AI in Python with Python-sc2)" scheme="https://yousazoe.top/categories/%E6%98%9F%E9%99%85%E4%BA%89%E9%9C%B82%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-Building-Starcraft-2-AI-in-Python-with-Python-sc2/"/>
    
    
    <category term="Python" scheme="https://yousazoe.top/tags/Python/"/>
    
    <category term="StarCraft2" scheme="https://yousazoe.top/tags/StarCraft2/"/>
    
  </entry>
  
</feed>

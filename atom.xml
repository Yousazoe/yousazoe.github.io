<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fl0w3r</title>
  
  <subtitle>carpe diem</subtitle>
  <link href="https://yousazoe.top/atom.xml" rel="self"/>
  
  <link href="https://yousazoe.top/"/>
  <updated>2023-01-24T07:20:37.083Z</updated>
  <id>https://yousazoe.top/</id>
  
  <author>
    <name>Yousazoe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初次体验 Github Copilot</title>
    <link href="https://yousazoe.top/archives/ff967b76.html"/>
    <id>https://yousazoe.top/archives/ff967b76.html</id>
    <published>2023-01-24T03:21:57.000Z</published>
    <updated>2023-01-24T07:20:37.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/BTZRHX.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近一段时间，AI 技术的进步则让代码补全有了更上一层楼的机会。接下来，我们为大家介绍的 Github Copilot 就是这样一款基于 AI 的代码补全工具。</p><span id="more"></span><p>我们编程时写出的代码，在未编译前通常以纯文本格式存在。因此，实际上我们能使用任何文本编辑器来编写代码，包括系统自带的记事本。但是，好的工具能够让我们事半功倍。面对复杂的工作任务，我们需要 IDE（集成开发环境）这样的生产力工具。IDE 本质上就是更高级的文本编辑器，集成了许多人性化功能来提升效率，比如：自动补全变量，提示可能会用到的函数列表，语法高亮，显示语法错误等等。</p><p>IDE 本身也在不断进化。我的第一门使用 IDE 的编程语言是 Java，使用的是 Eclipse，当时自动补全功能还比较简陋，局限于符号的提示与选单，我也没有对 IDE 究竟有多强大建立起概念。后来，开始学习开发框架后，我慢慢接触到 JetBrains 出品的 IDEA。IDEA 的提示更智能，例如：可以在数组后输入「.for」自动构成 foreach 循环，也可以使用快捷键自动生成 Getter/Setter、构造函数、重载函数等等。毫无疑问，JetBrains 系列产品为编码工作带来了更高的效率，提供了更加全面、智能的补全功能。</p><h3 id="GitHub-Copilot-是什么"><a href="#GitHub-Copilot-是什么" class="headerlink" title="GitHub Copilot 是什么"></a>GitHub Copilot 是什么</h3><p>Github Copilot 是 GitHub 和 OpenAI 合作开发的人工智能工具，可以在编辑代码时帮助你自动生成可能会需要的代码。</p><p>GitHub Copilot 能够提取代码上下文，给出整行代码或整个函数的补全建议。它可以帮助我们完成下列任务：</p><ul><li>将注释转化为代码； </li><li>自动填充重复代码； </li><li>编写测试； </li><li>快速发现解决问题的替代方法； </li><li>无需网络搜索即可快速探索新的 API； </li><li>适应用户编写代码的方式，帮助用户更快地完成工作。</li></ul><h4 id="原理是什么？"><a href="#原理是什么？" class="headerlink" title="原理是什么？"></a>原理是什么？</h4><p>我们先介绍一下 GPT-3。GPT-3（Generative Pre-trained Transformer 3）是一个用于处理自然语言的 AI 模型，由 OpenAI 训练开发。GPT-3 通过阅读几乎一切人类可阅读的内容来进行训练，理论上，它能够完成一切通过语言完成的工作，而且完成效果还非常接近人类。已经有实验证明 GPT-3 可用于撰写文章、回答问题、编写代码生成应用程序、设计表格、开发游戏、将文字描述便携为成型的网页等等。</p><p>而 OpenAI Codex 则是基于 GPT-3 开发的一款针对编程所设计的 AI 模型。Codex 从公共代码仓库学习人类编写的代码，其代码来源包括 Github 上的公共代码仓库。官网原文如下：</p><blockquote><p>OpenAI Codex is a descendant of GPT-3; its training data contains both natural language and billions of lines of source code from publicly available sources, including code in public GitHub repositories. （OpenAI Codex 是 GPT-3 的衍生项目；它的训练数据包括自然语言和数以亿计来自公开可用来源的源代码，其中包括 Github 公开仓库的代码。）</p></blockquote><p>最后，GitHub Copilot 则是使用了 Codex 进行研发的一款商业产品。Github 将算法进行包装，做成了插件和网页，进行应用分发。现在 GitHub Copilot 支持在 Visual Studio Code、Visual Studio、JetBrains Rider 上通过插件形式集成进 IDE，以便我们使用。</p><h3 id="使用-amp-体验"><a href="#使用-amp-体验" class="headerlink" title="使用 &amp; 体验"></a>使用 &amp; 体验</h3><p>要想使用 GitHub Copilot，首先需要注册一个 Github 账号。有了帐号后，按下面的步骤可以找到并启用 GitHub Copilot：</p><ol><li><strong>找到设置页面</strong>：在任何页面的右上角，单击个人资料照片，然后单击“设置”。</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/YeXRqN.jpg"></p><ol start="2"><li><p><strong>找到 GitHub Copilot 设置页面</strong>：在边栏的「代码、规划和自动化」部分，单击「GitHub Copilot」。</p></li><li><p><strong>启用 GitHub Copilot</strong>：在 GitHub Copilot 设置页面上，单击「启用 GitHub Copilot」。</p></li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/vtDoan.jpg"></p><ol start="4"><li><strong>选择付费方式（月付/年付）</strong>：GitHub Copilot 可以免费试用 60 个自然日，随后需要以 $10/月 的价格订阅。如果你是学生的话，可享受教育优惠，免费使用 GitHub Copilot。</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/6CHQ0X.jpg"></p><h4 id="在-Rider-IDE-进行设置"><a href="#在-Rider-IDE-进行设置" class="headerlink" title="在 Rider IDE 进行设置"></a>在 Rider IDE 进行设置</h4><ol><li>在偏好设置里安装 Github Copilot Plugin； </li><li>重启 IDE； </li><li>登陆 Github 完成验证。</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/LIJYV8.jpg"></p><p>设置完成后，IDE 提示可以使用「Tab」来自动补全代码，使用「⌥ + ]」或者「⌥ + [」来选择其他候选的补全选项。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/k8KwOS.jpg"></p><h4 id="体验如何"><a href="#体验如何" class="headerlink" title="体验如何"></a>体验如何</h4><p>在编写代码的过程中，Github Copilot 会自动提示可能的补全方案，此时按下「Tab」即可完成补全。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/exmaple.gif"></p><p>有时，AI 并不会一次给出完整的提示代码，例如，图示的代码就并非一次性生成的，而是逐行自动补全，最终生成了一个可以实际使用的函数（甚至包括注释）。下图的例子在 Unity3D 中绘制了一条射线用于检测前方是否有物品，只有第一行注释是我写下的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/jgOixr.jpg"></p><p>下面的例子很有趣：当我尝试把乐谱的音高编写成数组时，Github Copilot 也给出了他所理解的音乐：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE5/qICjGP.jpg"></p><p>在这样的例子中，对重复的流行乐片段，Github Copilot 有时可以给出不错的答案。比如预先输入《卡农》的重复性模进片段，Github Copilot 往往可以完全正确地补全乐谱。可见，在面临重复性较高的功能开发，或是使用一些常用的算法时，依靠 AI 补全是一个称得上非常可靠的选择。不过，如果需求非常复杂，大部分情况下，它并不能独立地给出完美的解决方案。GitHub 团队在对一组 Python 函数进行基准性测试后发现尝试十次后，大约 57% 情况下可以给出正确的答案。部分情况下，Github Copilot 也会给出无法通过编译的代码。</p><h3 id="Github-Copilot-的不足之处"><a href="#Github-Copilot-的不足之处" class="headerlink" title="Github Copilot 的不足之处"></a>Github Copilot 的不足之处</h3><p>使用 Github Copilot 很久后，Reddit 大佬 Colin Eberhardt 指出了几点不足：</p><ol><li>Github Copilot 很多时候响应得不够快。虽然它已经快到秒出答案，但这对快速输出状态的程序员来说仍然是不够的。要么它的提示还没出现你就继续输入了，要么你会因为等它而暂时停下思路。 </li><li>Github Copilot 总是会自动提示。这种提示和输入存在冲突：有时，当你需要等等看提示怎么说另一些时，会不断有内容弹出，接着消失。或许，自动模式并不是 Github Copilot 的「最佳打开方式」？ </li><li>Github Copilot 生成代码质量不足。它生成的代码可以满足大部分简单且重复的功能需求，但对于熟练的程序员，可能会额外浪费很多精力来校验它自动生成的代码是否正确。</li></ol><h4 id="Github-Copilot-版权问题"><a href="#Github-Copilot-版权问题" class="headerlink" title="Github Copilot 版权问题"></a>Github Copilot 版权问题</h4><p>许多人指出 Github Copilot 会使用有版权的代码作为提示内容（参见 Jacob Crume 的文章“GitHub Copilot is Now Available for All and Not Everyone Likes It”）。少数派作者 100gle 在《GitHub Copilot：革命未竟，未来可期》中更是举出了很多例子。最为出名的莫过于，如果你在编辑器中输入 <code>Fast inverse square root</code>，便会得到一段代码，它和当年《雷神之锤》使用的算法完全一致。</p><p>现代开源软件多使用 GPL （GNU General Public License）协议，这个协议要求你也将代码开源，且使用 GPL 协议。而通过 Github Copilot 补全时我们并不确定这段代码的作者为它指定的协议。开源许可证的主要作用是对软件的使用、复制、修改和再发布等进行限制。而显然使用 AI 补全显然会破坏这一点。</p><p>可以预见的是，同当今各种 AI 作画工具面对的种种争议一样，Github Copilot 也一定会因为版权问题，难以被大型企业所用，至少短期内如此。</p><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul><li>Github Copilot 能帮助初学者面对不那么熟悉的编程语言或开发框架时，快速学习常用的接口调用方式和简单的实现方案。这意味着我们可以不用为了某些基础问题反复翻找 API 手册，或体验 CSDN 这样的技术博客网站的层层传送门。 </li><li>Github Copilot 可以帮助我们在不熟悉的领域快速上手，只需要一些注释便可快速生成部分业务逻辑，然后进行测试。当然，最终代码的可靠性还是需要开发者人为辨别和控制。 </li><li>Github Copilot 可以在重复性劳动时显著提升效率。比如你需要写一大堆单元测试，它们无法靠复制/粘贴批量生成，同时有一些细微的逻辑变化需要处理。又或是你需要开发一些重复性功能，比如批量声明一些数据类型好几十次。这时 Github Copilot 补全的代码往往很可靠。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Github Copilot 或许并不能承载类似“AI 即将取代程序员”的想象，但在当下，它无疑是程序员的好帮手。作为辅助，它提供的补全并没有智能到让完全不会编程的用户完成开发，但也并不只是简单的提示工具。合理运用 Github Copilot 能够为开发者的学习成长带来很大帮助。</p><p>与此同时，它不可避免地存在一些缺陷，代码的版权问题也限制了它商业化的应用前景。不够熟练的程序员可能也会对它失望——就像它名字中的 Copilot 一样，Github Copilot 更接近优秀的副驾驶角色，但工作总归还是需要一位优秀的主驾驶领导。</p><p>最好的旅行靴已经送到我们手中，走出什么样的路还需要开发者自己去定夺。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CODE5/BTZRHX.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;最近一段时间，AI 技术的进步则让代码补全有了更上一层楼的机会。接下来，我们为大家介绍的 Github Copilot 就是这样一款基于 AI 的代码补全工具。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧 (Coding Skill)" scheme="https://yousazoe.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-Coding-Skill/"/>
    
    
    <category term="Github Copilot" scheme="https://yousazoe.top/tags/Github-Copilot/"/>
    
  </entry>
  
  <entry>
    <title>Jetbrains IDE 开发环境激活方式记录</title>
    <link href="https://yousazoe.top/archives/a906a6fe.html"/>
    <id>https://yousazoe.top/archives/a906a6fe.html</id>
    <published>2023-01-15T04:46:31.000Z</published>
    <updated>2023-01-24T07:20:37.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_jetbrains-banner.png"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Jetbrains 全家桶开发还是比较顺手的，但工作之后学生认证到期了，所以需要重新激活，特此写一篇博文记录自己使用 Jetbrains 产品的各种激活方式。</p><span id="more"></span><blockquote><p>需要提前声明，Jetbrains 也提供了社区版供学生和初学者使用，本文仅作激活操作记录，使用激活的软件请勿用作商业用途，如有条件请务必支持正版购买许可证。 </p></blockquote><h3 id="学生认证"><a href="#学生认证" class="headerlink" title="学生认证"></a>学生认证</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/007S8ZIlly1gf3sypo104j31hc0u0ae8.jpg"></p><p>Github 的学生认证可以通过上传学校信息的方式获取正规免费的许可，在 <a href="https://www.yousazoe.top/archives/e8e3308a.html">Unity Student Plan 申请指南</a> 这篇文章有详细操作。</p><p>如果是在读学生，完全可以用这种方式激活 Jetbrains 相关产品。</p><h3 id="注册机激活"><a href="#注册机激活" class="headerlink" title="注册机激活"></a>注册机激活</h3><p>不推荐这种激活方式。</p><p>之前我使用这种方式激活，因为之前有一些相关文件未删除，会导致整个软件闪退无法使用，在 Mac 上折腾了很长一段时间。</p><h3 id="服务器激活"><a href="#服务器激活" class="headerlink" title="服务器激活"></a>服务器激活</h3><p>先打开这个网站：<a href="https://search.censys.io/">https://search.censys.io/</a></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_censys-website.png"></p><p>然后搜索框输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">services.http.response.headers.location: account.jetbrains.com/fls-auth</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_censys-search.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_censys-search-result.png"></p><p>选择第一个搜索结果，右击进去：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13-censys-server.png"></p><p>将网址到 Jetbrains，选择许可证服务器 <code>/License server</code>，粘贴刚刚复制的网址 <code>http://134.53.225.196</code>，激活。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_licenses%20active.png"></p><p>大功告成，顺带一提，这个好像是迈阿密大学的服务器……</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/BLOG13/BLOG13_jetbrains-banner.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Jetbrains 全家桶开发还是比较顺手的，但工作之后学生认证到期了，所以需要重新激活，特此写一篇博文记录自己使用 Jetbrains 产品的各种激活方式。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建 (Blog Building)" scheme="https://yousazoe.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Blog-Building/"/>
    
    
    <category term="Blog" scheme="https://yousazoe.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>GStarCAD笔试&amp;面试总结</title>
    <link href="https://yousazoe.top/archives/2fcb9e48.html"/>
    <id>https://yousazoe.top/archives/2fcb9e48.html</id>
    <published>2023-01-01T05:43:05.000Z</published>
    <updated>2023-01-24T07:20:37.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/117842739/Low-Poly-Game-Assets"><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE4/CODE4.png"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>GStarCAD 笔试和机试总结。笔试题主要考核 C++、代码阅读理解、基本几何运算、英文阅读能力，机试题主要考察 VC++、MFC 的实际编程操作能力。</p><span id="more"></span><h3 id="笔试部分"><a href="#笔试部分" class="headerlink" title="笔试部分"></a>笔试部分</h3><p>笔试题主要考核 C++、代码阅读理解、基本几何运算、英文阅读能力。</p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>下列代码有问题、或有可改进之处吗？如有，请直接修改，并写明原因.</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span></span><br><span class="line">{</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CBase</span>(){m_nVal = <span class="number">100</span>;}</span><br><span class="line">    ~<span class="built_in">CBase</span>(){}</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>{<span class="keyword">return</span> m_nVal;}</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetDouble</span><span class="params">()</span> <span class="type">const</span> </span>{m_nVal *= <span class="number">3</span>; <span class="keyword">return</span> m_nVal;}</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_nVal;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CBase base;</span><br><span class="line">    std::cout &lt;&lt; “val = ”&lt;&lt; base.<span class="built_in">GetDouble</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><p>答：<code>int GetDouble() const {m_nVal *= 3; return m_nVal;}</code> 若需要对成员变量进行赋值需删除 <code>const</code>。</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>请写出 <code>main</code> 函数的输出结果，并写明理由.</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span></span><br><span class="line">{</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">voidSend</span><span class="params">()</span></span>{std::cout &lt;&lt; <span class="string">"\nSend :"</span>&lt;&lt; m_nVal &lt;&lt; std::endl;}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">()</span></span>{<span class="built_in">Send</span>();}</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_nVal;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CUser</span> : <span class="keyword">public</span> CBase</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CUser</span>(){m_nVal = <span class="number">101</span>;}</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">voidSend</span><span class="params">()</span></span>{m_nVal++;std::cout &lt;&lt; “\nSend :”&lt;&lt;m_nVal&lt;&lt; std::endl;}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">()</span></span>{CBase::<span class="built_in">Send</span>();}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CUser user;</span><br><span class="line">    CBase &amp;base=user;</span><br><span class="line">    base.<span class="built_in">Send</span>();<span class="comment">//输出：</span></span><br><span class="line">    CBase *pBase=&amp;base;</span><br><span class="line">    pBase-&gt;<span class="built_in">Output</span>();<span class="comment">//输出：</span></span><br><span class="line">    user.<span class="built_in">Output</span>();<span class="comment">//输出:</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Send：102</span><br><span class="line">Send：103</span><br><span class="line">Send：103</span><br></pre></td></tr></tbody></table></figure><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>阅读理解类声明代码，并使用之实现功能。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AcGePoint2d</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AcGePoint2d</span>();</span><br><span class="line">    <span class="built_in">AcGePoint2d</span>(<span class="type">double</span> x, <span class="type">double</span> y);</span><br><span class="line">    <span class="function">AcGePoint2d&amp; <span class="title">set</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AcGeLinearEnt2d</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">boolintersectWith</span>(<span class="type">const</span> AcGeLinearEnt2d&amp; line, AcGePoint2d&amp; intPnt,<span class="type">const</span> AcGeTol&amp; tol = AcGeContext::gTol) <span class="type">const</span>;<span class="comment">//求直线交点函数</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">AcGeLinearEnt2d</span> ();</span><br><span class="line">    <span class="built_in">AcGeLinearEnt2d</span> (<span class="type">const</span> AcGeLinearEnt2d&amp;);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AcGeLineSeg2d</span>: <span class="keyword">public</span> AcGeLinearEnt2d</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:<span class="built_in">AcGeLineSeg2d</span> ();</span><br><span class="line">  <span class="built_in">AcGeLineSeg2d</span> (<span class="type">const</span> AcGeLineSeg2d &amp; line);</span><br><span class="line">  <span class="built_in">AcGeLineSeg2d</span> (<span class="type">const</span> AcGePoint2d&amp; pnt1, <span class="type">const</span> AcGePoint2d&amp; pnt2);</span><br><span class="line">  <span class="function">AcGeLineSeg2d &amp; <span class="title">set</span> <span class="params">(<span class="type">const</span> AcGePoint2d&amp; pnt1, <span class="type">const</span> AcGePoint2d&amp; pnt2)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//请使用上述类和类成员函数，在本函数中实现两直线段求交点，并输出。</span></span><br><span class="line">    <span class="comment">//这两个直线段分别是从点(0,0) 到(500,500); 从点(600,0) 到(200,900)。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h5><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">class AcGePoint2d</span><br><span class="line">{</span><br><span class="line">  public:</span><br><span class="line">    AcGePoint2d();</span><br><span class="line">    AcGePoint2d(double x, double y);</span><br><span class="line">    AcGePoint2d&amp; set(double x, double y);</span><br><span class="line">    </span><br><span class="line">    double x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class AcGeLinearEnt2d</span><br><span class="line">{</span><br><span class="line">  public:</span><br><span class="line">    boolintersectWith(const AcGeLinearEnt2d&amp; line, AcGePoint2d&amp; intPnt,const AcGeTol&amp; tol = AcGeContext::gTol) const;//求直线交点函数</span><br><span class="line">   </span><br><span class="line">  protected:</span><br><span class="line">    AcGeLinearEnt2d ();</span><br><span class="line">    AcGeLinearEnt2d (const AcGeLinearEnt2d&amp;);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class AcGeLineSeg2d: public AcGeLinearEnt2d</span><br><span class="line">{</span><br><span class="line">  public:AcGeLineSeg2d ();</span><br><span class="line">  AcGeLineSeg2d (const AcGeLineSeg2d &amp; line);</span><br><span class="line">  AcGeLineSeg2d (const AcGePoint2d&amp; pnt1, const AcGePoint2d&amp; pnt2);</span><br><span class="line">  AcGeLineSeg2d &amp; set (const AcGePoint2d&amp; pnt1, const AcGePoint2d&amp; pnt2);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">{</span><br><span class="line">    //请使用上述类和类成员函数，在本函数中实现两直线段求交点，并输出。</span><br><span class="line">    //这两个直线段分别是从点(0,0) 到(500,500); 从点(600,0) 到(200,900)。</span><br><span class="line"></span><br><span class="line"><span class="addition">+   AcGeLineSeg2dline1(AcGePoint2d(0,0),AcGePoint2d(500,500));</span></span><br><span class="line"><span class="addition">+   AcGeLineSeg2dline2(AcGePoint2d(600,0),AcGePoint2d(200,900));</span></span><br><span class="line"><span class="addition">+   AcGePoint2d pt;Line1.intersectWith(line2,pt);</span></span><br><span class="line"><span class="addition">+   Printf(“x:%.2f,y:%.2f”,pt.x,pt.y);</span></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>基本几何运算。</p><ol><li>已知两点 <code>pt1</code>,<code>pt2</code>，如何计算从起点 <code>pt1</code> 到终点 <code>pt2</code> 的向量 <code>v</code>？</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">V = pt2 - pt1</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>已知向量 <code>v1{1.0,0.0,0.0}</code>,<code>v2{0.0,1.0,0.0}</code>，<code>v3 = v1 - v2</code> ，则v3 =？</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{1.0,-1.0,0.0}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>已知向量v1{1.0,0.0,0.0},v2{0.0,1.0,0.0}，v3=v1×v2 ，则v3=？</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{0.0,0.0,1.0}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>两向量的点积 <code>v1·v2</code> 等于 0 ，意味着两向量是什么关系？</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">垂直</span><br></pre></td></tr></tbody></table></figure><h4 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h4><p>翻译英文资料。</p><blockquote><p>An ObjectARXapplication  is  a  dynamic  link  library  (DLL)  that  shares  the  address  space  of AutoCAD  and  makes  direct  function  calls  to AutoCAD.  You  can  add  new  classes  to  the ObjectARXprogram environment and export them for use by other programs. </p></blockquote><p>一个 ObjectARX 应用是一个的动态链接库（DLL），它共享 AutoCAD 地址空间，并直接调用函数操作 AutoCAD。你可以在 ObjectARX 程序环境中新增新的类，并将其导出给其他程序使用。</p><blockquote><p><code>CDialog::DoModal()</code> Call  this  member  function  to  invoke  the  modal  dialog  box  and return the dialog-box result when done. This member function handles all interaction with the user while the dialog box is active.</p></blockquote><p><code>CDialog::DoModal()</code>，使用这一成员函数可调出模态对话框，并且当其使用完成后可返回对话框的结果。当对话框激活时，这一成员函数处理所有与用户的交互。</p><blockquote><p>AutoCADstores  the  values  for  its  operating  environment  in  system  variables.  Each  system variable  has  an  associated  type:  integer,  real,  point,  or  text  string.  You  can  examine  any  system variable  and  change  any  writable  system  variable  directly  on  the  command  line  by  entering  the system variable name. Many system variables are also accessible through dialog box options.</p></blockquote><p>AutoCAD 保存与操作环境相关的值于系统变量中。每个系统变量有一个相关类型：整形，实型，点或字符串。你可以检测任何系统变量，并通过在命令行输入系统变量名称直接改变系统变量。许多系统变量也可以通过对话框选项设置。</p><h3 id="机试部分"><a href="#机试部分" class="headerlink" title="机试部分"></a>机试部分</h3><p>机试题主要考察 VC++、MFC 的实际编程操作能力。</p><h4 id="控件窗口操作"><a href="#控件窗口操作" class="headerlink" title="控件窗口操作"></a>控件窗口操作</h4><ul><li>新建基于对话框的 MFC 工程。</li><li>定义 <code>CEdit</code> 的派生类 <code>CMyEdit</code>。在 <code>CMyEdit</code> 类中定义成员函数 <code>void  SetIndex（int index）</code>，调用本函数后，编辑框内显示 <code>index</code> 数值。</li><li>对话框初始创建4个大小不一的控件，分别是：<code>CMyEdit</code>、<code>CButton</code>、<code>CComboBox</code>、<code>CEdit</code>，分别对齐对话框4个角。</li><li>在对话框类内定义一个指针数组成员变量：<code>CArray&lt;CWnd*&gt;  m_arrCtrl</code>，并在对话框初始化时将上述4控件的对象指针按逆时针顺序保存到 <code>m_arrCtrl</code> 数组（第1个为左上角控件）。</li><li>对话框窗口支持调整大小，对话框窗口大小改变后，4个控件大小不变，但位置自动跟随调整（总是对齐4个角）。</li><li>每隔1秒，沿逆时针方向自动旋转切换上述4个控件位置（控件大小不变，只是位置改变，左上角控件跑到左下角，左下角跑到右下角，以此类推），<code>m_arrCtrl</code> 中控件指针也同步切换位置（第1个始终是左上角控件）。每次切换控件位置后，需从指针数组中找到其中唯一的 <code>CMyEdit</code> 控件，并调用它的 <code>SetIndex(index)</code>成员函数，<code>index</code> 为 <code>CMyEdit</code> 对象在 <code>m_arrCtrl</code> 数组中的新索引（0-3）。</li><li><strong>注：对话框内可以定义其它成员变量，但除对话框的构造函数、<code>DoDataExchange</code> 和 <code>OnInitDialog</code> 函数外，对话框其它函数中只能使用 <code>m_arrCtrl</code> 成员变量，不能使用其它成员变量（也不能使用全局变量和静态变量）。</strong></li></ul><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><ul><li>新建基于对话框的 MFC 工程。</li><li>在对话框上绘制一个编辑框和一个排序按钮。</li><li>编辑框内可输入一系列的数，用空格分开。单击排序按钮，则对这些数由小到大排序，并重新显示在编辑框中。</li><li><strong>注：需自写排序算法。</strong></li></ul><h4 id="目录浏览"><a href="#目录浏览" class="headerlink" title="目录浏览"></a>目录浏览</h4><ul><li>新建基于对话框的 MFC 工程。</li><li>对话框左侧显示一个树控件，显示一个两层目录，一级目录为学校，二级为班级。对话框右侧显示一个 <code>LISTBOX</code>。</li><li>当在左侧选中不同的学校或班级，右侧 <code>LISTBOX</code> 刷新显示为本学校或本班级的所有学生姓名。</li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/117842739/Low-Poly-Game-Assets&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CODE4/CODE4.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;GStarCAD 笔试和机试总结。笔试题主要考核 C++、代码阅读理解、基本几何运算、英文阅读能力，机试题主要考察 VC++、MFC 的实际编程操作能力。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧 (Coding Skill)" scheme="https://yousazoe.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-Coding-Skill/"/>
    
    
  </entry>
  
  <entry>
    <title>Google开源项目C++风格指南</title>
    <link href="https://yousazoe.top/archives/bf0a0e19.html"/>
    <id>https://yousazoe.top/archives/bf0a0e19.html</id>
    <published>2022-10-23T14:12:06.000Z</published>
    <updated>2022-11-21T13:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CODE3/X4uzvL.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码。但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交者造成不小的困扰。Google 因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google 的编程风格。</p><span id="more"></span><p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.</p><p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p><p>风格, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p><p>使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.</p><p>本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.</p><p>Google 主导的开源项目均符合本指南的规定.</p><p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>通常每一个 <code>.cc</code> 文件都有一个对应的 <code>.h</code> 文件. 也有一些常见例外, 如单元测试代码和只包含 <code>main()</code> 函数的 <code>.cc</code> 文件.</p><p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p><p>下面的规则将引导你规避使用头文件时的各种陷阱.</p><h4 id="Self-contained-头文件"><a href="#Self-contained-头文件" class="headerlink" title="Self-contained 头文件"></a>Self-contained 头文件</h4><blockquote><p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code>.h</code> 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code> 头文件的做法.</p></blockquote><p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 <code>#define</code> 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.</p><p>不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 <code>.inc</code> 文件扩展名。</p><p>如果 <code>.h</code> 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 <code>.cc</code> 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 <code>-inl.h</code> 文件里（译者注：过去该规范曾提倡把定义放到 <code>-inl.h</code> 里过）。</p><p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 <code>.cc</code> 文件里。</p><h4 id="define-保护"><a href="#define-保护" class="headerlink" title="#define 保护"></a>#define 保护</h4><blockquote><p>所有头文件都应该有 <code>#define</code> 保护来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code> .</p></blockquote><p>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 <code>foo</code> 中的头文件 <code>foo/src/bar/baz.h</code> 可按如下方式保护:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><blockquote><p>尽可能地避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</p></blockquote><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul><li>前置声明能够节省编译时间，多余的 <code>#include</code> 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 <code>#include</code> 使代码因为头文件中无关的改动而被重新编译多次。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li></ul><ul><li>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li><li>前置声明来自命名空间 <code>std::</code> 的 symbol 时，其行为未定义。</li><li>很难判断什么时候该用前置声明，什么时候该用 <code>#include</code> 。极端情况下，用前置声明代替 <code>#include</code> 甚至都会暗暗地改变代码的含义：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// b.h:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> {};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B {};</span><br><span class="line"></span><br><span class="line"><span class="comment">// good_user.cc:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"b.h"</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>{ <span class="built_in">f</span>(x); }  <span class="comment">// calls f(B*)</span></span><br></pre></td></tr></tbody></table></figure><p>如果 <code>#include</code> 被 <code>B</code> 和 <code>D</code> 的前置声明替代， <code>test()</code> 就会调用 <code>f(void*)</code> .</p><ul><li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 <code>include</code> 冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li></ul><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><blockquote><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p></blockquote><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p><p>另一个实用的经验准则: 内联那些包含循环或 <code>switch</code> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <code>switch</code> 语句从不被执行).</p><p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p><h4 id="include-的路径及顺序"><a href="#include-的路径及顺序" class="headerlink" title="#include 的路径及顺序"></a><code>#include</code> 的路径及顺序</h4><blockquote><p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.</p></blockquote><p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <code>.</code> (当前目录) 或 <code>..</code> (上级目录). 例如, <code>google-awesome-project/src/base/logging.h</code> 应该按如下方式包含:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"base/logging.h"</span></span></span><br></pre></td></tr></tbody></table></figure><p>又如, <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p><blockquote><ol><li><code>dir2/foo2.h</code> (优先位置, 详情如下)</li><li>C 系统文件</li><li>C++ 系统文件</li><li>其他库的 <code>.h</code> 文件</li><li>本项目内 <code>.h</code> 文件</li></ol></blockquote><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p><code>dir/foo.cc</code> 和 <code>dir2/foo2.h</code> 通常位于同一目录下 (如 <code>base/basictypes_unittest.cc</code> 和 <code>base/basictypes.h</code>), 但也可以放在不同目录下.</p><p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p><p>您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，前置声明 (forward declarations) 情况除外。比如您要用到 <code>bar.h</code> 中的某个符号, 哪怕您所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code> 就够了，不用再管后者所包含的其它内容。</p><p>举例来说, <code>google-awesome-project/src/foo/internal/fooserver.cc</code> 的包含次序如下:</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"foo/public/fooserver.h"</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"base/basictypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"base/commandlineflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"foo/public/bar.h"</span></span></span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>例外：</strong></p><p>有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"foo/public/fooserver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"base/port.h"</span>  <span class="comment">// For LANG_CXX11.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LANG_CXX11</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// LANG_CXX11</span></span></span><br></pre></td></tr></tbody></table></figure></blockquote><h5 id="译者-YuleFox-笔记"><a href="#译者-YuleFox-笔记" class="headerlink" title="译者 (YuleFox) 笔记"></a>译者 (YuleFox) 笔记</h5><ol><li>避免多重包含是学编程时最基本的要求;</li><li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li><li>内联函数的合理使用可提高代码执行效率;</li><li><code>-inl.h</code> 可提高代码可读性 (一般用不到吧:D);</li><li>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li><li>包含文件的名称使用 <code>.</code> 和 <code>..</code> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</li></ol><h5 id="译者（acgtyrant）笔记"><a href="#译者（acgtyrant）笔记" class="headerlink" title="译者（acgtyrant）笔记"></a>译者（acgtyrant）笔记</h5><ol><li>原来还真有项目用 <code>#includes</code> 来插入文本，且其文件扩展名 <code>.inc</code> 看上去也很科学。</li><li>Google 已经不再提倡 <code>-inl.h</code> 用法。</li><li>注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li><li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 <code>.cc</code> 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li><li>在 <code>#include</code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code>.h</code> 和本项目内的 <code>.h</code> 是个好习惯。</li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>鼓励在 <code>.cc</code> 文件内使用匿名命名空间或 <code>static</code> 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层.</p><p>举例来说, 两个不同项目的全局作用域都有一个类 <code>Foo</code>, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, <code>project1::Foo</code> 和 <code>project2::Foo</code> 作为不同符号自然不会冲突.</p><p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X {</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y {</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">}  <span class="comment">// namespace Y</span></span><br><span class="line">}  <span class="comment">// namespace X</span></span><br></pre></td></tr></tbody></table></figure><p><code>X::Y::foo()</code> 与 <code>X::foo()</code> 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>命名空间具有迷惑性, 因为它们使得区分两个相同命名所指代的定义更加困难。</p><p>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p><p>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。</p><p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</p><h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>根据下文将要提到的策略合理使用命名空间.</p><ul><li>遵守命名空间命名中的规则。</li><li>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</li><li>用命名空间把文件包含, <a href="https://gflags.github.io/gflags/">gflags</a> 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:<blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace {</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">} <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace {</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">} <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></tbody></table></figure><p>更复杂的 <code>.cc</code> 文件包含更多, 更复杂的细节, 比如 gflags 或 using 声明。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"a.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_FLAG</span>(<span class="type">bool</span>, someflag, <span class="literal">false</span>, <span class="string">"dummy flag"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> a {</span><br><span class="line"></span><br><span class="line">...code <span class="keyword">for</span> a...                <span class="comment">// 左对齐</span></span><br><span class="line"></span><br><span class="line">} <span class="comment">// namespace a</span></span><br></pre></td></tr></tbody></table></figure></blockquote></li><li>不要在命名空间 <code>std</code> 内声明任何东西, 包括标准库的类前置声明. 在 <code>std</code> 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</li><li>不应该使用 <em>using 指示</em> 引入整个命名空间的标识符号。<blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止 —— 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li>不要在头文件中使用 <em>命名空间别名</em> 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。<blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .cc 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .h 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> librarian {</span><br><span class="line"><span class="keyword">namespace</span> impl {  <span class="comment">// 仅限内部使用</span></span><br><span class="line"><span class="keyword">namespace</span> sidetable = ::pipeline_diagnostics::sidetable;</span><br><span class="line">}  <span class="comment">// namespace impl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// 限制在一个函数中的命名空间别名</span></span><br><span class="line">  <span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line">}  <span class="comment">// namespace librarian</span></span><br></pre></td></tr></tbody></table></figure></blockquote></li><li>禁止用内联命名空间</li></ul><h4 id="匿名命名空间和静态变量"><a href="#匿名命名空间和静态变量" class="headerlink" title="匿名命名空间和静态变量"></a>匿名命名空间和静态变量</h4><blockquote><p>在 <code>.cc</code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p></blockquote><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 <code>static</code> 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p><h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h5><p>推荐、鼓励在 <code>.cc</code> 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 <code>.h</code> 中使用。</p><p>匿名命名空间的声明和具名的格式相同，在最后注释上 <code>namespace</code> :</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> {</span><br><span class="line">...</span><br><span class="line">}  <span class="comment">// namespace</span></span><br></pre></td></tr></tbody></table></figure><h4 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h4><blockquote><p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p></blockquote><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点:"></a>优点:</h5><p>某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域.</p><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.</p><h5 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h5><p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 2.1. 命名空间。举例而言，对于头文件 <code>myproject/foo_bar.h</code> , 应当使用</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject {</span><br><span class="line"><span class="keyword">namespace</span> foo_bar {</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">}  <span class="comment">// namespace foo_bar</span></span><br><span class="line">}  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></tbody></table></figure><p>而非</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject {</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line">}  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></tbody></table></figure><p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p><p>如果你必须定义非成员函数, 又只是在 <code>.cc</code> 文件中使用它, 可使用匿名 2.1. 命名空间 或 <code>static</code> 链接关键字 (如 <code>static&nbsp;int&nbsp;Foo()&nbsp;{...}</code>) 限定其作用域.</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><blockquote><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p></blockquote><p>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 坏——初始化和声明分离</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 好——初始化时声明</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>, <span class="number">2</span>}; <span class="comment">// 好——v 一开始就初始化</span></span><br></pre></td></tr></tbody></table></figure></blockquote><p>属于 <code>if</code>, <code>while</code> 和 <code>for</code> 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">'/'</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure></blockquote><p>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) {</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在循环作用域外面声明这类变量要高效的多:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) {</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h4><blockquote><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p></blockquote><p>禁止使用类的静态储存周期变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 <code>constexpr</code> 变量除外，毕竟它们又不涉及动态初始化或析构。</p><p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p><p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 <code>getenv()</code> 或 <code>getpid()</code> ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p><blockquote><p>Xris 译注:</p><p>同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。</p></blockquote><p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 <code>main()</code> 返回还是对 <code>exit()</code> 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p><p>改善以上析构问题的办法之一是用 <code>quick_exit()</code> 来代替 <code>exit()</code> 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 <code>atexit()</code> 所绑定的任何 handlers. 如果您想在执行 <code>quick_exit()</code> 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 <code>_at_quick_exit()</code>. 如果您想在 <code>exit()</code> 和 <code>quick_exit()</code> 都用上该 handler, 都绑定上去。</p><p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 <code>vector</code> (使用 C 数组替代) 和 <code>string</code> (使用 <code>const&nbsp;char[]</code>)。</p><p>如果您确实需要一个 <code>class</code> 类型的静态或全局变量，可以考虑在 <code>main()</code> 函数或 <code>pthread_once()</code> 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p><blockquote><p>Yang.Y 译注:</p><p>上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</p></blockquote><h4 id="译者-YuleFox-笔记-1"><a href="#译者-YuleFox-笔记-1" class="headerlink" title="译者 (YuleFox) 笔记"></a>译者 (YuleFox) 笔记</h4><ol><li><code>cc</code>中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用<code>using</code> 关键字污染命名空间;</li><li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code>public</code>;</li><li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</li><li>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</li><li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</li></ol><h4 id="译者（acgtyrant）笔记-1"><a href="#译者（acgtyrant）笔记-1" class="headerlink" title="译者（acgtyrant）笔记"></a>译者（acgtyrant）笔记</h4><ol><li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li><li>匿名命名空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li><li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li><li>注意别在循环犯大量构造和析构的低级错误。</li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><h5 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h5><p>我们倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空.</p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>C++ 函数由返回值提供天然的输出， 有时也通过输出参数（或输入/输出参数）提供. 我们倾向于使用返回值而不是输出参数： 它们提高了可读性， 并且通常提供相同或更好的性能.</p><p>C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 非可选输入参数通常是值参或 <code>const</code> 引用, 非可选输出参数或输入/输出参数通常应该是引用 （不能为空）. 对于可选的参数， 通常使用 <code>std::optional</code> 来表示可选的按值输入， 使用 <code>const</code> 指针来表示可选的其他输入． 使用非常量指针来表示可选输出和可选输入/输出参数．</p><p>避免定义需要 <code>const</code> 引用参数去超出生命周期的函数， 因为 <code>const</code> 引用参数与临时变量绑定． 相反， 要找到某种方法来消除生命周期要求 （例如， 通过复制参数）， 或者通过 <code>const</code> 指针传递它并记录生命周期和非空要求.</p><p>在排序函数参数时， 将所有输入参数放在所有输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.</p><p>这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.</p><h4 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h4><h5 id="总述-1"><a href="#总述-1" class="headerlink" title="总述"></a>总述</h5><p>我们倾向于编写简短, 凝练的函数.</p><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p><p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.</p><p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p><h4 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h4><h5 id="总述-2"><a href="#总述-2" class="headerlink" title="总述"></a>总述</h5><p>所有按引用传递的参数必须加上 <code>const</code>.</p><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code>int&nbsp;foo(int* pval)</code>. 在 C++ 中, 函数还可以声明为引用参数: <code>int&nbsp;foo(int&nbsp;&amp;val)</code>.</p><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><p>定义引用参数可以防止出现 <code>(*pval)++</code> 这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针.</p><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p><h5 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h5><p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">const</span> string &amp;in, string *out)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code>const</code> 引用, 输出参数为指针. 输入参数可以是 <code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数, 除非特殊要求, 比如 <code>swap()</code>.</p><p>有时候, 在输入形参中用 <code>const&nbsp;T*</code> 指针比 <code>const&nbsp;T&amp;</code> 更明智. 比如:</p><ul><li>可能会传递空指针.</li><li>函数要把指针或对地址的引用赋值给输入形参.</li></ul><p>总而言之, 大多时候输入形参往往是 <code>const&nbsp;T&amp;</code>. 若用 <code>const&nbsp;T*</code> 则说明输入另有处理. 所以若要使用 <code>const&nbsp;T*</code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><h5 id="总述-3"><a href="#总述-3" class="headerlink" title="总述"></a>总述</h5><p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数, 然后用另一个参数类型为 <code>const&nbsp;char*</code> 的函数对其进行重载:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">size_t</span> textlen)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><p>通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.</p><h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><p>如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.</p><h5 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h5><p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等, 而不是一口气重载多个 <code>Append()</code>. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code>std::vector</code> 以便使用者可以用列表初始化指定参数.</p><h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><h5 id="总述-4"><a href="#总述-4" class="headerlink" title="总述"></a>总述</h5><p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与函数重载遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p><h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><p>有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”.</p><h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><p>缺省参数实际上是函数重载语义的另一种实现方式, 因此所有不应当使用函数重载的理由也都适用于缺省参数.</p><p>虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p><p>缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值.</p><p>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题.</p><h5 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h5><p>对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 <code>void&nbsp;f(int&nbsp;n&nbsp;=&nbsp;counter++);</code> 这样的代码.)</p><p>在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p><h4 id="函数返回类型后置语法"><a href="#函数返回类型后置语法" class="headerlink" title="函数返回类型后置语法"></a>函数返回类型后置语法</h4><h5 id="总述-5"><a href="#总述-5" class="headerlink" title="总述"></a>总述</h5><p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p><h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><p>C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>C++11 引入了这一新的形式. 现在可以在函数名前使用 <code>auto</code> 关键字, 在参数列表之后后置返回类型. 例如:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> -&gt; <span class="type">int</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>后置返回类型为函数作用域. 对于像 <code>int</code> 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别.</p><h5 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h5><p>后置返回类型是显式地指定Lambda 表达式的返回值的唯一方式. 某些情况下, 编译器可以自动推导出 Lambda 表达式的返回类型, 但并不是在所有的情况下都能实现. 即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了.</p><p>有时在已经出现了的函数参数列表之后指定返回类型, 能够让书写更简单, 也更易读, 尤其是在返回类型依赖于模板参数时. 例如:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>对比下面的例子:</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="keyword">decltype</span>(<span class="built_in">declval</span>&lt;T&amp;&gt;() + <span class="built_in">declval</span>&lt;U&amp;&gt;()) <span class="built_in">add</span>(T t, U u);</span><br></pre></td></tr></tbody></table></figure><h5 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h5><p>后置返回类型相对来说是非常新的语法, 而且在 C 和 Java 中都没有相似的写法, 因此可能对读者来说比较陌生.</p><p>在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍. 因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下, 只使用一种版本是相对来说更规整的形式.</p><h5 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a>结论</h5><p>在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样复杂的模板代码.</p><h3 id="来自Google的奇技"><a href="#来自Google的奇技" class="headerlink" title="来自Google的奇技"></a>来自Google的奇技</h3><p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.</p><h4 id="所有权与智能指针"><a href="#所有权与智能指针" class="headerlink" title="所有权与智能指针"></a>所有权与智能指针</h4><h5 id="总述-6"><a href="#总述-6" class="headerlink" title="总述"></a>总述</h5><p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p><h5 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h5><p>所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.</p><p>智能指针是一个通过重载 <code>*</code> 和 <code>-&gt;</code> 运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位. <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> 是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当 <code>std::unique_ptr</code> 离开作用域时, 对象就会被销毁. <code>std::unique_ptr</code> 不能被复制, 但可以把它移动（move）给新所有主. <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> 同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.</p><h5 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h5><ul><li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li><li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li><li>传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li><li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li><li>可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.</li><li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li></ul><h5 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li><li>其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li><li>如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型.</li><li>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</li><li><code>&lt;span class="pre"&gt;std::unique_ptr&lt;/span&gt;</code> 的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员.</li><li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统.</li><li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li><li>某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁.</li><li>智能指针并不能够完全代替原生指针.</li></ul><h5 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a>结论</h5><p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 <code>std::unique_ptr</code> 来明确所有权传递, 例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">FooFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FooConsumer</span><span class="params">(std::unique_ptr&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 <code>std::shared_ptr&lt;const Foo&gt;</code> ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 <code>std::shared_ptr</code> .</p><p>不要使用 <code>std::auto_ptr</code>, 使用 <code>std::unique_ptr</code> 代替它.</p><h4 id="Cpplint"><a href="#Cpplint" class="headerlink" title="Cpplint"></a>Cpplint</h4><h5 id="总述-7"><a href="#总述-7" class="headerlink" title="总述"></a>总述</h5><p>使用 <code>cpplint.py</code> 检查风格错误.</p><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p><code>cpplint.py</code> 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 <code>// NOLINT</code>, 或在上一行加 <code>//&nbsp;NOLINTNEXTLINE</code>, 可以忽略报错.</p><p>某些项目会指导你如何使用他们的项目工具运行 <code>cpplint.py</code>. 如果你参与的项目没有提供, 你可以单独下载 <a href="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p><h4 id="译者（acgtyrant）笔记-2"><a href="#译者（acgtyrant）笔记-2" class="headerlink" title="译者（acgtyrant）笔记"></a>译者（acgtyrant）笔记</h4><ol><li>把智能指针当成对象来看待的话, 就很好领会它与所指对象之间的关系了.</li><li>原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.</li><li><code>scoped_ptr</code> 和 <code>auto_ptr</code> 已过时. 现在是 <code>shared_ptr</code> 和 <code>uniqued_ptr</code> 的天下了.</li><li>按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.</li><li>Arch Linux 用户注意了, AUR 有对 cpplint 打包.</li></ol><h3 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h3><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.</p><p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.</p><h4 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h4><h5 id="总述-8"><a href="#总述-8" class="headerlink" title="总述"></a>总述</h5><p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p><h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><p>尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> num_errors;            <span class="comment">// "num" 是一个常见的写法</span></span><br><span class="line"><span class="type">int</span> num_dns_connections;   <span class="comment">// 人人都知道 "DNS" 是什么</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="type">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="type">int</span> pc_reader;             <span class="comment">// "pc" 有太多可能的解释了.</span></span><br><span class="line"><span class="type">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></tbody></table></figure><p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code>i</code> 表示迭代变量和用 <code>T</code> 表示模板参数.</p><p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循类型命名的规则, 而非类型模板应当遵循变量命名的规则.</p><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><h5 id="总述-9"><a href="#总述-9" class="headerlink" title="总述"></a>总述</h5><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p><h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p>可接受的文件命名示例:</p><ul><li><code>my_useful_class.cc</code></li><li><code>my-useful-class.cc</code></li><li><code>myusefulclass.cc</code></li><li><code>myusefulclass_test.cc</code> // <code>_unittest</code> 和 <code>_regtest</code> 已弃用.</li></ul><p>C++ 文件要以 <code>.cc</code> 结尾, 头文件以 <code>.h</code> 结尾. 专门插入文本的文件则以 <code>.inc</code> 结尾, 参见头文件自足.</p><p>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 <code>db.h</code>.</p><p>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比 <code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类 <code>FooBar</code>.</p><p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短, 就直接放在 <code>.h</code> 中.</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h3 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h3><p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p><h4 id="现有不合规范的代码"><a href="#现有不合规范的代码" class="headerlink" title="现有不合规范的代码"></a>现有不合规范的代码</h4><h5 id="总述-10"><a href="#总述-10" class="headerlink" title="总述"></a>总述</h5><p>对于现有不符合既定编程风格的代码可以网开一面.</p><h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住, <em>一致性</em> 也包括原有的一致性.</p><h4 id="Windows-代码"><a href="#Windows-代码" class="headerlink" title="Windows 代码"></a>Windows 代码</h4><h5 id="总述-11"><a href="#总述-11" class="headerlink" title="总述"></a>总述</h5><p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p><h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p>如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p><ul><li>不要使用匈牙利命名法 (比如把整型变量命名成 <code>iNum</code>). 使用 Google 命名约定, 包括对源文件使用 <code>.cc</code> 扩展名.</li><li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 <code>DWORD</code>, <code>HANDLE</code> 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 <code>const&nbsp;TCHAR*</code> 而不是 <code>LPCTSTR</code>.</li><li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有警告(warnings)当作错误(errors)处理.</li><li>不要使用 <code>#pragma&nbsp;once</code>; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 <code>#ifndef&nbsp;SRC_DIR_BAR_H_</code>, 参考#define 保护一节).</li><li>除非万不得已, 不要使用任何非标准的扩展, 如 <code>#pragma</code> 和 <code>__declspec</code>. 使用 <code>__declspec(dllimport)</code> 和 <code>__declspec(dllexport)</code> 是允许的, 但必须通过宏来使用, 比如 <code>DLLIMPORT</code> 和 <code>DLLEXPORT</code>, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li></ul><p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p><ul><li>通常我们禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li><li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 <code>_ATL_NO_EXCEPTIONS</code> 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理).</li><li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 <code>StdAfx.h</code> 或 <code>precompile.h</code> 的文件. 为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 <code>precompile.cc</code> 中), 使用 <code>/FI</code> 编译器选项以自动包含该文件.</li><li>资源头文件通常命名为 <code>resource.h</code> 且只包含宏, 这一文件不需要遵守本风格指南.</li></ul><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>运用常识和判断力, 并且保持一致.</p><p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 <code>if</code> 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做.</p><p>风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏, 所以要尽量避免.</p><p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CODE3/X4uzvL.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码。但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交者造成不小的困扰。Google 因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google 的编程风格。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧 (Coding Skill)" scheme="https://yousazoe.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-Coding-Skill/"/>
    
    
  </entry>
  
  <entry>
    <title>向量</title>
    <link href="https://yousazoe.top/archives/8c47f151.html"/>
    <id>https://yousazoe.top/archives/8c47f151.html</id>
    <published>2022-09-29T01:22:20.000Z</published>
    <updated>2023-01-24T07:20:37.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://twitter.com/Rcmedy/status/1572658550563807233"><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/GApBvy.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程旨在围绕各类数据结构的设计与实现，揭示其中的规律原理与方法技巧；同时针对算法设计及其性能分析，使学生了解并掌握主要的套路与手段。本文将讲解数据结构向量及查找和排序。</p><span id="more"></span><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><h4 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0001.jpg"></p><p>向量属于最最基本的线性结构，我们笼统称之为线性序列。</p><p>本章我们将围绕这种数据结构展示和讨论两方面问题：</p><ol><li>如何根据统一的接口规范来定制并实现一个数据结构</li><li>围绕这种数据结构展示如何通过更加有效的算法使得我们对外的接口能够更加高效率地工作：查找、排序</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0002.jpg"></p><p>首先我们要辨析抽象数据类型和数据结构：</p><ul><li>抽象数据类型 = 数据模型 + 定义在该模型的一组操作</li><li>数据结构 = 基于某种特定语言，实现 ADT 的一整套算法</li></ul><p>更形象一点，我们可以将数据结构比喻成某种产品比如汽车。作为用户 Application 而言，他只关心这种产品的外在特性能够提供的功能；而实现者 Implementation 则需要对这些功能以及特性具体如何落实负责。</p><h4 id="向量ADT"><a href="#向量ADT" class="headerlink" title="向量ADT"></a>向量ADT</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0004.jpg"></p><p>所谓向量，实际上是 C++ 等高级编程语言中数组这种数据组织形式的一个推广和泛化。</p><h5 id="循秩访问"><a href="#循秩访问" class="headerlink" title="循秩访问"></a>循秩访问</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0005.jpg"></p><p>在这些高级程序设计语言中所谓的数组实际上就是一段连续的内存空间，它被均匀地划分为若干个单元，而每一个单元都会与一个编号彼此回应，并且可以直接访问。</p><p>而向量可以被认为是数组的抽象与泛化，它同样是由一组抽象的元素按照刚才的线性次序封装而成。不同的是原来通过下标 <code>i</code> 的访问方式变成了秩 rank。</p><p>另外向量中元素的类型得到了拓展，不限于是某一种特定的基本类型，它的所有操作、管理维护更加简化，可以通过统一的接口来完成。</p><h5 id="向量ADT接口"><a href="#向量ADT接口" class="headerlink" title="向量ADT接口"></a>向量ADT接口</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0006.jpg"></p><p>可以通过这些操作接口对向量做各种操作，同时也只能通过这些操作接口对向量进行操作。</p><h4 id="接口操作实例"><a href="#接口操作实例" class="headerlink" title="接口操作实例"></a>接口操作实例</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0007.jpg"></p><h4 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0010.jpg"></p><ul><li><a href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/vector/vector.h.htm">SourceCode</a></li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SRC_VECTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRC_VECTOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CAPACITY 3   <span class="comment">// 默认初始容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Vector {</span><br><span class="line">    <span class="keyword">using</span> Rank = <span class="type">int</span>;       <span class="comment">// 秩</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T* _elem;           <span class="comment">// 数据</span></span><br><span class="line">        Rank _size;         <span class="comment">// 规模</span></span><br><span class="line">        Rank _capacity;     <span class="comment">// 容量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span>;                                      <span class="comment">// 空间不足扩容</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">shrink</span><span class="params">()</span></span>;                                      <span class="comment">// 装填过小压缩</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">copyFrom</span><span class="params">(T <span class="type">const</span>* A, Rank lo, Rank hi)</span></span>;        <span class="comment">// 复制数组区间</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Rank <span class="title">maxItem</span><span class="params">(Rank lo, Rank hi)</span></span>;                     <span class="comment">// 选取最大元素</span></span><br><span class="line">        <span class="function">Rank <span class="title">partition</span><span class="params">(Rank lo, Rank hi)</span></span>;                   <span class="comment">// 轴点构造算法</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(Rank lo, Rank hi)</span></span>;               <span class="comment">// 选择排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">bubble</span><span class="params">(Rank lo, Rank hi)</span></span>;                      <span class="comment">// 扫描交换</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                  <span class="comment">// 起泡排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Rank lo, Rank mid, Rank hi)</span></span>;             <span class="comment">// 归并算法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                   <span class="comment">// 归并排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                    <span class="comment">// 堆排序</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                   <span class="comment">// 快速排序</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(Rank lo, Rank hi)</span></span>;                   <span class="comment">// 希尔排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/* 构造函数 */</span></span><br><span class="line">        <span class="built_in">Vector</span>(<span class="type">int</span> c = DEFAULT_CAPACITY, Rank s = <span class="number">0</span>, T v = <span class="number">0</span>) {</span><br><span class="line">            _elem = <span class="keyword">new</span> T[_capacity = c];</span><br><span class="line">            <span class="keyword">for</span> (_size = <span class="number">0</span>; _size &lt; s; ++_size)</span><br><span class="line">                _elem[_size] = v;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Vector</span>(T <span class="type">const</span>* A, Rank n) { <span class="built_in">copyFrom</span>(A, <span class="number">0</span>, n); }</span><br><span class="line">        <span class="built_in">Vector</span>(T <span class="type">const</span>* A, Rank lo, Rank hi) { <span class="built_in">copyFrom</span>(A, lo, hi); }</span><br><span class="line">        <span class="built_in">Vector</span>(Vector&lt;T&gt; <span class="type">const</span>&amp; V) { <span class="built_in">copyFrom</span>(V._elem, <span class="number">0</span>, V._size); }</span><br><span class="line">        <span class="built_in">Vector</span>(Vector&lt;T&gt; <span class="type">const</span>&amp; V, Rank lo, Rank hi) { <span class="built_in">copyFrom</span>(V._elem, lo, hi); }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 析构函数 */</span></span><br><span class="line">        ~<span class="built_in">Vector</span>() { <span class="keyword">delete</span>[] _elem; }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 只读接口 */</span></span><br><span class="line">        <span class="function">Rank <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> _size; }                           <span class="comment">// 规模</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> !_size; }                         <span class="comment">// 判空</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Rank <span class="title">find</span><span class="params">(T <span class="type">const</span>&amp; e)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">find</span>(e, <span class="number">0</span>, _size); }       <span class="comment">// 无序向量整体查找</span></span><br><span class="line">        <span class="function">Rank <span class="title">find</span><span class="params">(T <span class="type">const</span>&amp; e, Rank lo, Rank hi)</span></span>;                       <span class="comment">// 无序向量区间查找</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Rank <span class="title">search</span><span class="params">(T <span class="type">const</span>&amp; e)</span> <span class="type">const</span> </span>{                               <span class="comment">// 有序向量整体查找</span></span><br><span class="line">            <span class="keyword">return</span> (_size &lt;= <span class="number">0</span>)? <span class="number">-1</span>: <span class="built_in">search</span>(e, <span class="number">0</span>, _size);</span><br><span class="line">        }</span><br><span class="line">        <span class="function">Rank <span class="title">search</span><span class="params">(T <span class="type">const</span>&amp; e, Rank lo, Rank hi)</span> <span class="type">const</span></span>;              <span class="comment">// 有序向量区间查找 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 可写接口 */</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>[] (Rank r);                                       <span class="comment">// 重载下标操作符</span></span><br><span class="line">        <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (Rank r) <span class="type">const</span>;</span><br><span class="line">        Vector&lt;T&gt;&amp; <span class="keyword">operator</span>= (Vector&lt;T&gt; <span class="type">const</span>&amp;);                      <span class="comment">// 重载赋值操作符</span></span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">remove</span><span class="params">(Rank r)</span></span>;                                             <span class="comment">// 删除单一元素</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(Rank lo, Rank hi)</span></span>;                                 <span class="comment">// 删除区间元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="function">Rank <span class="title">insert</span><span class="params">(Rank r, T <span class="type">const</span>&amp; e)</span></span>;                              <span class="comment">// 插入元素</span></span><br><span class="line">        <span class="function">Rank <span class="title">insert</span><span class="params">(T <span class="type">const</span>&amp; e)</span> </span>{ <span class="keyword">return</span> <span class="built_in">insert</span>(_size, e); }          <span class="comment">// 插入末元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(Rank lo, Rank hi)</span></span>;                                  <span class="comment">// 区间排序</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span> </span>{ <span class="built_in">sort</span>(<span class="number">0</span>, _size); }                               <span class="comment">// 整体排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unsort</span><span class="params">(Rank lo, Rank hi)</span></span>;                                <span class="comment">// 区间置乱</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unsort</span><span class="params">()</span> </span>{ <span class="built_in">unsort</span>(<span class="number">0</span>, _size); }                           <span class="comment">// 整体置乱</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 遍历接口 */</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">void</span>(*) (T&amp;))</span></span>;                                  <span class="comment">// 函数指针遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VST&gt; <span class="type">void</span> <span class="title">traverse</span><span class="params">(VST&amp;)</span></span>;                   <span class="comment">// 函数对象遍历</span></span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SRC_VECTOR_H</span></span></span><br></pre></td></tr></tbody></table></figure><p>整个 Vector 被封装起来，来自各种用户 application 的操作接口 interface 提供在外面，相当于一个 Vector 结构的使用说明书。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0011.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">int</span> c = DEFAULT_CAPACITY, Rank s = <span class="number">0</span>, T v = <span class="number">0</span>) {</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = c];</span><br><span class="line">    <span class="keyword">for</span> (_size = <span class="number">0</span>; _size &lt; s; ++_size)</span><br><span class="line">        _elem[_size] = v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vector</span>(T <span class="type">const</span>* A, Rank n) { <span class="built_in">copyFrom</span>(A, <span class="number">0</span>, n); }</span><br><span class="line"><span class="built_in">Vector</span>(T <span class="type">const</span>* A, Rank lo, Rank hi) { <span class="built_in">copyFrom</span>(A, lo, hi); }</span><br><span class="line"><span class="built_in">Vector</span>(Vector&lt;T&gt; <span class="type">const</span>&amp; V) { <span class="built_in">copyFrom</span>(V._elem, <span class="number">0</span>, V._size); }</span><br><span class="line"><span class="built_in">Vector</span>(Vector&lt;T&gt; <span class="type">const</span>&amp; V, Rank lo, Rank hi) { <span class="built_in">copyFrom</span>(V._elem, lo, hi); }</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line">~<span class="built_in">Vector</span>() { <span class="keyword">delete</span>[] _elem; }</span><br></pre></td></tr></tbody></table></figure><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0012.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">copyFrom</span>(<span class="type">const</span> T *A, Rank lo, Rank hi) {</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span>*(hi - lo)];</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">        _elem[_size++] = A[lo++];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>复制操作将 <code>_elem</code> 空间扩展为原来的二倍，然后将区间元素依次复制。</p><h3 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0013.jpg"></p><h4 id="可扩充向量-1"><a href="#可扩充向量-1" class="headerlink" title="可扩充向量"></a>可扩充向量</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0014.jpg"></p><p>现在我们用 <code>_size</code> 表示实际规模，<code>_capacity</code> 表示总容量。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">T* _elem;           <span class="comment">// 数据</span></span><br><span class="line">Rank _size;         <span class="comment">// 规模</span></span><br><span class="line">Rank _capacity;     <span class="comment">// 容量</span></span><br></pre></td></tr></tbody></table></figure><p>这里的问题是 <code>_capacity</code> 一旦确定按照目前的方案它就将一成不变，而这样一种策略显然存在明显的不足。这种不足体现在两个方面：</p><ul><li>上溢(overflow)：<code>_elem[]</code> 不足以存放所有元素，尽管此时系统仍有足够的空间</li><li>下溢(underflow)：<code>_elem[]</code> 中的元素寥寥无几，装填因子 = _size/_capacity &lt;&lt; 50%</li></ul><h4 id="动态空间管理"><a href="#动态空间管理" class="headerlink" title="动态空间管理"></a>动态空间管理</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0015.jpg"></p><p>我们需要从静态管理策略改编为动态管理策略，模仿蝉的做法在即将发生上溢时适当地扩大内部数组容量。</p><p>向量的生命周期：</p><ul><li>(a) 最开始虽然元素很多但不至于出现上溢的情况</li><li>(b) 但剩余空间有可能会逐步地占用，在某一时刻内部数组饱和</li><li>(c) 模仿蝉退掉外壳，动态申请另一个外壳：另一段存放空间，它的大小应该比原来的有所增长</li><li>(d) 把原先存放好的有效元素逐一按次序复制过来，使得它们对外界而言依旧保持原貌</li><li>(e) 新多出的空间足以存放新需要插入的元素，原来占用的空间在此之后被释放并且归还给系统</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0016.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">expand</span>() {</span><br><span class="line">    <span class="keyword">if</span> (_size &lt; _capacity) <span class="keyword">return</span>;</span><br><span class="line">    _capacity = std::<span class="built_in">max</span>(_capacity, DEFAULT_CAPACITY);</span><br><span class="line"></span><br><span class="line">    T* oldElem = _elem;</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i)</span><br><span class="line">        _elem[i] = oldElem[i];</span><br><span class="line">    <span class="keyword">delete</span>[] oldElem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得益于向量的封装，尽管扩容之后数据区的物理地址有所改变，却不致出现野指针。</p><h4 id="递增式扩容"><a href="#递增式扩容" class="headerlink" title="递增式扩容"></a>递增式扩容</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0017.jpg"></p><p>每当发现当前的内部数组即将发生上溢，我们并不是对它进行容量的加倍而只是在原来的容量的基础上追加一个固定的数额：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0018.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity += INCREMENT];</span><br></pre></td></tr></tbody></table></figure><p>对于这种策略而言，每经过 I 次插入操作它都需要进行一次扩容，每次分摊成本为 O(n)。</p><h4 id="加倍式扩容"><a href="#加倍式扩容" class="headerlink" title="加倍式扩容"></a>加倍式扩容</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0019.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure><p>每次的分摊成本为 O(1) 常数时间。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0020.jpg"></p><p>倍增策略通过在空间的效率上做了一个适当的牺牲换取在时间方面的巨大收益。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0021.jpg"></p><h3 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0022.jpg"></p><h4 id="循秩访问-1"><a href="#循秩访问-1" class="headerlink" title="循秩访问"></a>循秩访问</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0023.jpg"></p><p>首先讨论向量元素的访问。表面上看这并不是什么问题，因为在向量 ADT 中已经定义了两个标准的接口 <code>V.get(r)</code> 和 <code>V.put(r, e)</code>。通过它们我们已经可以自如地来写或者是读向量中特定的元素，但这两种接口在形式上还不是那么简洁直观。</p><p>我们期望数组那种直接地访问方式：<code>A[r]</code>，为此需要重载下标操作符 <code>[]</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="type">const</span> { <span class="keyword">return</span> _elem[r]; }</span><br></pre></td></tr></tbody></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0024.jpg"></p><p>再来考察向量的插入算法，如何讲某一个特定的元素插入到向量的特定位置。</p><p>因为原有向量所有元素都是紧邻排列的，所以为了能够插入新的元素我们需要将对应位置之后的所有元素称作它的后继，进行一个整体的右移操作。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Rank Vector&lt;T&gt;::<span class="built_in">insert</span>(Rank r, T <span class="type">const</span>&amp; e) {</span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = _size; i &gt; r; --i)</span><br><span class="line">        _elem[i] = _elem[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    _elem[r] = e;</span><br><span class="line">    _size++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="区间删除"><a href="#区间删除" class="headerlink" title="区间删除"></a>区间删除</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0025.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank lo, Rank hi) {</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hi &lt; _size)</span><br><span class="line">        _elem[lo++] = _elem[hi++];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shrink</span>();</span><br><span class="line">    <span class="keyword">return</span> hi - lo;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单元素删除"><a href="#单元素删除" class="headerlink" title="单元素删除"></a>单元素删除</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0026.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank r) {</span><br><span class="line">    T e = _elem[r];</span><br><span class="line">    <span class="built_in">remove</span>(r, r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0027.jpg"></p><p>无序向量只支持判等操作，有序向量还需要支持其中的元素相互比较大小。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0028.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0029.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0030.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Rank Vector&lt;T&gt;::<span class="built_in">find</span>(T <span class="type">const</span>&amp; e, Rank lo, Rank hi) {</span><br><span class="line">    <span class="keyword">while</span> ((lo &lt; hi--) &amp;&amp; (_elem[hi] != e));</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从 <code>hi</code> 出发逆向逐一取出向量中的各个元素，与目标元素进行比对。如果不相等，就忽略它并且考察它的前驱，整个工作会遍历向量中的所有元素。</p><h4 id="去重-x2F-唯一化"><a href="#去重-x2F-唯一化" class="headerlink" title="去重/唯一化"></a>去重/唯一化</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0031.jpg"></p><p>向量的唯一化需要把其中重复的元素都剔除掉，只保留一个拷贝。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0032.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">deduplicate</span>() {</span><br><span class="line">    <span class="type">int</span> oldSize = _size;</span><br><span class="line">    Rank i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; _size) {                                      </span><br><span class="line">        (<span class="built_in">find</span>(_elem[i], <span class="number">0</span>, i) &lt; <span class="number">0</span>)?                           </span><br><span class="line">            i++:                                             </span><br><span class="line">            <span class="built_in">remove</span>(i);                                       </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oldSize - _size;                                 </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0033.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0034.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">traverse</span>(<span class="built_in">void</span> (*visit) (T&amp;)) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i)</span><br><span class="line">        <span class="built_in">visit</span>(_elem[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">traverse</span>(VST&amp; visit) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i)</span><br><span class="line">        <span class="built_in">visit</span>(_elem[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>利用函数指针机制，只读或局部性修改</li><li>利用函数对象机制，可全局性修改</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0035.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Increase</span> {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; e)</span> </span>{ e++; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(Vector&lt;T&gt;&amp; V)</span> </span>{</span><br><span class="line">    v.<span class="built_in">traverse</span>(<span class="built_in">Increase</span>&lt;T&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h3><h4 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0036.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0037.jpg"></p><p>与起泡排序算法的理解相同，有序/无序序列中，<strong>任意/总有</strong>一对相邻元素<strong>顺序/逆序</strong>。</p><p>因此，相邻逆序对的数目，可用以度量向量的逆序程度。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0038.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">disordered</span>() <span class="type">const</span> {</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; _size; i++)</span><br><span class="line">        n += (_elem[i - <span class="number">1</span>] &gt; _e);</span><br><span class="line">    <span class="keyword">return</span> n;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DS2/Vector_page-0039.jpg"></p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><h4 id="Fib查找"><a href="#Fib查找" class="headerlink" title="Fib查找"></a>Fib查找</h4><h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><h3 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://twitter.com/Rcmedy/status/1572658550563807233&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/DS2/GApBvy.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程旨在围绕各类数据结构的设计与实现，揭示其中的规律原理与方法技巧；同时针对算法设计及其性能分析，使学生了解并掌握主要的套路与手段。本文将讲解数据结构向量及查找和排序。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构 (Data Structure)" scheme="https://yousazoe.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Data-Structure/"/>
    
    
    <category term="Algorithm" scheme="https://yousazoe.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Convex Hull</title>
    <link href="https://yousazoe.top/archives/84b74385.html"/>
    <id>https://yousazoe.top/archives/84b74385.html</id>
    <published>2022-09-21T09:21:29.000Z</published>
    <updated>2023-01-24T07:20:37.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://twitter.com/cyangmou/status/1571176793943457793"><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/qrXkrr.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本节我们将探索计算几何的核心问题：凸包问题。计算几何领域几乎所有的问题都可以“归约”为凸包问题，因此学习凸包问题对整个计算几何体系至关重要。</p><span id="more"></span><h3 id="Convexity"><a href="#Convexity" class="headerlink" title="Convexity"></a>Convexity</h3><h4 id="Why-Convex-Hull"><a href="#Why-Convex-Hull" class="headerlink" title="Why Convex Hull"></a>Why Convex Hull</h4><p>我们计算几何的第一站就是凸包问题，它在计算几何中处于核心位置，这个核心体现在几乎所有的问题从理论上讲都可以归结为凸包问题。</p><h4 id="Nails-In-The-Table"><a href="#Nails-In-The-Table" class="headerlink" title="Nails In The Table"></a>Nails In The Table</h4><p>接下来我们通过一个具体的动手实验领会一下凸包到底是什么。</p><p>为此你需要找到一张桌子或是屏幕，假想在这个桌子上钉上一系列的钉子，然后用皮筋将其撑到足够大以至于它能将桌面上的所有钉子都包含进去。</p><p>接下来的事情非常的轻松，你只要松手就行。那么随着啪的一声，你将会看到这幅图景：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/cvGMfd.png"></p><p>刚才的皮筋就会变成这样一段一段蓝色的线段，它们首尾相连构成了一个紧绷的包围圈。这个蓝色的橡皮筋在在现在这样的一个图景状态就是我们所说的凸包，我们可以看到所谓的凸包是由这上面若干个钉子来决定的，虽然其中有一些钉子并不发挥作用，我们大致可以感觉到因为它们呆在内部。</p><p>那么，这之间的玄机又是什么呢？</p><h4 id="Paint-Blending"><a href="#Paint-Blending" class="headerlink" title="Paint Blending"></a>Paint Blending</h4><p>为了更好地理解什么是凸包，我们再来看一个应用的例子。</p><p>艺术家经常要通过混合得到某种他想要又不是从工厂直接生产出来的颜料。我们知道一般来说每种颜料都可以分成是红绿蓝三个分量的数值指标，每种组合对应的大致都是一种颜料。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/I3MrGz.png"></p><p>我们不妨为了简便起见只考虑红的以及绿的两个分量，所以这样的话每一种颜料也就是它所对应的颜色都可以用红的和绿的这样两个数字，或者说它们在整体的成份中所占的百分比来对应。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C = (R, G)</span><br></pre></td></tr></tbody></table></figure><p>比如说某种颜料 X 它所对应的红的分量可能是 10%，而绿的分量是 35%；另一种颜料比如叫 Y，那么它所对应的这两个分量一个是 16% 一个是 20%。 现在的问题来了，用这两种颜料能否兑出我们所希望的某些颜料呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">X = (10%, 35%)  Y = (16%, 20%)</span><br></pre></td></tr></tbody></table></figure><p>我们来看一下，当颜料混合在一块的时候它们的变化是多端的，有很多很多种组合，每几种颜料它们按照不同的分量、按照不同的比重勾兑在一块所得到的颜色其实都会不同。当然，艺术家有他的勾兑的方法，包括他的灵感，那么如果从数学的角度，从算法的角度来考虑，这其中应该用什么样的指导的方法呢？</p><p>那么从数学上来看我们一般来说都可以认为有一个目标的颜色，比如说这里的 U，这种颜色比如说特定的来说他希望红的占的比重是 12%，而绿的比重是 30%。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">U = (12%, 30%)</span><br></pre></td></tr></tbody></table></figure><p>对于这样的一种目标的颜料我们应该用刚才的 X、Y，这两种来自于工厂的原始颜料用什么样的比例来对它们进行混合和勾兑呢？</p><p>好，我想你已经知道这个答案了。没错 我们应该用两份的 X 和一份的 Y 勾兑起来，就可以得到 U 了。</p><p>你不妨去做个简单的验算，两份的 10% 再加上一份*的 16% 合在一块再除以 3，正好是 12%；而两份的 35%，再加上一份的 20% 也同样的除以 3 恰好也是 30%，所以用 2 比 1 的比例是这个问题的一个解。</p><p>好，如果说我们为此花费这些时间还是值得的话，我们还是希望得到一个方法，否则的话我们会很困惑，因为如果你没有掌握这背后的、统一的方法的话，那么如果下一次换一种颜色比如说这里的 V 它要求的是 13% 和 22%，那你可能又要花费一些时间了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">V = (13%, 22%)</span><br></pre></td></tr></tbody></table></figure><p>那么首先一个问题是这种颜料能不能勾兑出来。并不是像我们这里所说的那样，每两种颜色给定了以后你都能勾兑出所有的颜色。其实在这个时候我们或许需要第三种颜色，比如这里我们也许从厂房里可以拿到第三种颜色 Z，它的对应的比重是 7% 和 15%。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Z = (07%, 15%)</span><br></pre></td></tr></tbody></table></figure><p>好了，这个时候用这三种颜色是否能把它勾兑出来呢？</p><p>好，现在我来揭晓答案。正确的比例应该是一份的 X，三份的 Y 再加上刚才我们新添的第三种颜色 Z 一份 1 比 3 比 1。你可以按照刚才同样的方法去推算一下 验算一下，我想答案应该是它。</p><p>那么所有这里讨论的事情其实都是颜色，或者准确地讲是颜料之间的那种勾兑混合。这个东西和我们这里讨论的计算几何有什么关系呢？其实它们之间有着非常深刻的联系。</p><h4 id="Color-Space"><a href="#Color-Space" class="headerlink" title="Color Space"></a>Color Space</h4><p>既然谈到几何，那么少不了就要谈到它最最基础的一个概念叫做空间，欧氏空间。</p><p>在这里我们将欧氏空间对应于颜色，我们称之为颜色空间，具体来讲我们要将每一种颜色都对应成是这个空间中的一个点。无论这种颜色或者颜料是来自于生产厂家直接供应的那种基础性的颜料，还是艺术家为了创作的需要必须重新勾兑出来的新的颜色。总而言之每一种颜色都对应这个空间中的一个点。</p><p>当然这里因为我们讨论的都是正数，那可以认为它基本上都限于第一个象限，这不是主要的问题。那么现在的问题是在于我们固然可以按照这种方法将我们刚才的三种颜料也就是 X、Y、Z 按照横轴也就是刚才比如红色的分量数值以及纵轴，也就是刚才说的绿色的分量的数值对应地画出一个一个的点，三种颜料，分别是三种点。</p><p>我们刚才看到过，在我们只有 X 和 Y 两种颜料的时候如果我们要勾兑出 U，那个比重是 2 比 1。其实这件事情倒过来，我们在给出了固定的 X 和 Y 之后我可以将我们目标的那个 U 也在这个屏幕上画出来，如果你画出来的话你就会发现其实非常地巧，我们可以验证一下它们三者是所谓共线的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/7XidsU.png"></p><p>如果是这种情况，那么我们认为 U 肯定是能被勾兑出来的，而且它的勾兑比例可以从几何上一目了然的能解释。</p><p>你可以再去计算一下，我会告诉你其实 U 到 X 的距离相对更短，U 到 Y 的距离相对更长，而二者的距离之比其实是 1 比 2，而我们刚才勾兑的比例是反过来的 2 比 1。</p><p>其实这就是一个规律，也就是说如果我要勾兑的一种颜色恰好是位于这两个顶点的那条连接的线段上，而且它们的距离存在一个比的话，那么这种颜色就必然能够被勾兑出来。而且勾兑的方法就蕴含在刚才的那个比例中，只要把刚才那个距离比 1 比 2 颠倒过来变成 2 比 1，它就必然能得到这种颜色。</p><p>你可以作为一个极端的例子去想一下，整个的是如果要勾兑 Y 和勾兑 X 本身的时候另一个分量是 0 是同样的道理。</p><p>好，那么刚才我们也可以解释为什么 V 这种颜色必须要借助第三种颜色才能够勾兑出来。因为你大致可以看出来因为 V 并没有位于 X 和 Y 所确定的这条线段上跑偏了，在这种情况下我们说必然要借助 Z，而之所以要借助 Z 或者说准确地讲按照我们刚才那个比例必须是 1 比 3 比 1 也蕴含在这个图中，原理是一样的。</p><p>如果在这种情况下我们要做的事情就是要首先确认 V 这个颜料所对应的那个点是不是落在 X、Y、Z 所定义的这个三角形的内部，如果是它就一定能勾兑出来；如果不是，至少它是不能勾兑出来的。</p><p>好，如果它能勾兑出来，具体的勾兑的比例是多少呢？在这个图中也给出来了，为此我们只需要去量一下 V 到这三个点的距离，然后找一下它们的比。我们在这里会发现它们的比恰好是 3 比 3 比 1，所以倒过来在这里我们勾兑的比例自然也就是这个最短的最近的这个点对应的那个颜色要取的更多，反其道而行之它要取三份；而到更远的那两个点所对应的颜色所取的比例要更少，完全可以用这个来度量</p><p>当然以上的这些结论你还需要在课后再做仔细的推导和严格的验证，在这里你不妨把这个结论记下来：也就是说如果有一种颜料能够被两种已知的颜料勾兑出来，它必然位于二者之间的那条连线上；如果是对于三种颜料的情况，那么某种目标的颜色能够被勾兑出来当且仅当在颜色空间中它位于这三个点所对应的那个三角形的内部，而勾兑的比例是与他们的距离成反比的。</p><h4 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h4><p>我们虽然不是很喜欢数学，但是不得不还要用一些简单的数学把刚才我们所看到的那个结论严格地表述出来。</p><p>也就是说我们如果给定的是平面二维空间中的一系列的点的话，那么这些点所对应的颜料能构造出哪些新的颜料出来呢？我们会发现其实每一种新的颜料从几何来讲，对应于原来那些颜料的某一个调和方案。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/zuOrJ9.png"></p><p>那么在这里有一些勾兑方案专门地称之为凸的勾兑方案，或者叫作凸组合 Convex Combination。具体而言，如果是一个凸组合需要有哪些条件呢？</p><p>我们说大致有两个主要的条件：</p><ol><li>所有分量的总和必须是 100%</li><li>所有分量必须是非负的</li></ol><h3 id="Extreme-Points"><a href="#Extreme-Points" class="headerlink" title="Extreme Points"></a>Extreme Points</h3><h4 id="Extremity"><a href="#Extremity" class="headerlink" title="Extremity"></a>Extremity</h4><p>在我们最开始给定的这些点中，哪些是最终对凸包有贡献的被皮筋绷住的，哪些是没有实质作用的，这种性质可以归纳为所谓的极性。</p><p>沿着刚才的那个思路，我们观察结论可以表述为这样的一幅图。我们看到在刚才的所有那些钉子中凡事被最终的皮筋绷住的钉子，暂时没有实质作用的这些钉子我们都用青色来表示，有什么本质不同呢？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/KWQXLc.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> there exists a line L through p</span><br><span class="line">    such that</span><br><span class="line">        all points of S lie on the same side of L</span><br></pre></td></tr></tbody></table></figure><p>数学上的观察告诉我们，所谓有用的点都有一个共同的特点：经过它们我们总能找到一条直线使得所有的点都落在这条直线的同一侧。</p><h4 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h4><p>在排序算法中有一个非常有意思的算法：起泡排序 Bubblesort。我们这里的算法设计和它是非常类似的：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/nTOTYN.png"></p><p>如何甄别极点和非极点呢？</p><p>我们需要回忆颜料勾兑的例子，一种颜料能够被其他几种颜料勾兑出来当且仅当它落在某一个三角形的内部。反过来像极点这样不能被其他颜料勾兑出来的颜色它就不可能被包含于任何三角形的内部，这样的话我们又往前转化了一步，将我们的甄别任务转化为某一个点是否会被包含于另外的三个点所确定的三角形内部。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/6fTUE0.png"></p><h4 id="In-Triangle-Test"><a href="#In-Triangle-Test" class="headerlink" title="In-Triangle Test"></a>In-Triangle Test</h4><p>根据刚才的分析，所谓凸包问题可以归结为一系列的判断：任何的一个点是否会落在其他的三个点所对应的三角形内部被它们包围，我们称这个为 In-Triangle Test。</p><p>基于 In-Triangle Test，我们就可以将非极点们一个一个地找出来并且将它们排除在我们的视野之外。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/oos30d.png"></p><p>首先做初始化，要像无罪推论一样将所有的点都设定为极点。接着枚举出所有可能的三角形，对于每个三角形我们还要去考察除它们之外的每一个点 s；一旦我们发现 s 的确是落在当前这个三角形内部，我们就可以立即断定它不是一个极点，从而将它排除在外。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Make all points of S as EXTREME</span><br><span class="line">For each triangle Δ(p, q, r)</span><br><span class="line">    For each s in S\{p, q, r}</span><br><span class="line">        If s in Δ(p, q, r)</span><br><span class="line">            mark s as NON_EXTREME</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/nZts0C.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">extremePoint</span><span class="params">(Point S[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; n; s++)</span><br><span class="line">        S[s].extreme = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each triangle</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; n; p++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q = p + <span class="number">1</span>; q &lt; n; q++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = q + <span class="number">1</span>; r &lt; n; r++) {</span><br><span class="line">                <span class="comment">// For each point</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; n; s++) {</span><br><span class="line">                    <span class="keyword">if</span> (s == p || s == q || s == r || !S[s].extreme)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">InTriangle</span>(S[p], S[q], S[r], S[s]))</span><br><span class="line">                        S[s].extreme = FALSE;    </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h4><p>我们给出的第一个基于极点的凸包算法虽然效率低下，但是它的意义还是很重要的，它会引出 To-Left Test，后面这个测试几乎是贯穿于我们计算几何这个课程的始终。</p><p>每当我们给定了一个点以及一个三角形后，如何来判定这个点是否落在这个三角形的内部？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/r06PyL.png"></p><p>依然是大事化小小事化了，我们将刚才这个 In-Triangle Test 转化为三次 To-Left Test。也就是说一个点如果确实落在某一个三角形的内部的话，那么相对于这个三角形的三条边所做的 To-Left Test 都会统一的返回 true。 </p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/XvoAfS.png"></p><p>所谓 To-Left Test，就是说这个点相对于有向线段而言位于左侧还是右侧。这里的敏锐观察可以归结为一个点如果落在三角形内部，它的充要条件当且仅当它相对于这三条直线的 To-Left Test 都是 true，它同时位于这三条直线的左侧。</p><p>那么现在问题转变为如何判断一个点在线段的左侧/右侧？</p><h4 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/CbRPDq.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ToLeft</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">Area</span><span class="params">(p, q, s)</span> &gt; 0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Area2</span><span class="params">(Point p, Point q, Point s)</span>    </span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> p.x * q.y - p.y * q.x</span></span><br><span class="line"><span class="function">         + q.x * s.y - q.y * s.x</span></span><br><span class="line"><span class="function">         + s.x * p.y - s.y * p.x</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="Extreme-Edges"><a href="#Extreme-Edges" class="headerlink" title="Extreme Edges"></a>Extreme Edges</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>延续极点的思路推广到边，引入所谓的极边。</p><p>极边的候选者其实就是来自于任何两个相邻极点的连边，凡是对最终的凸包有贡献的那些边都称之为极边；凡是那些对凸包没有贡献的就不是极边，或者叫作非极边，non-extreme Edge。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/ea2Xl7.png"></p><p>就像我们定义极点一样，如果有一条这样的连边确实是极边的话，那么所有的点都会同时落在它的同侧，相应的另一侧就必然是空的。更具体来讲，以逆时针次序凸包边界每一条边都有这样一个特性：所有的点都恰好落在它的左侧，它们的右侧都是空的。</p><p>这样我们算法中的实质问题就自然地转化和具体化为如何来甄别任何两个点之间的那条连边是否为极边的问题。</p><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/fmhhQx.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Let EE = null</span><br><span class="line">    For each directed segment pq</span><br><span class="line">        If points in S\{p, q} lie to the same side of pq</span><br><span class="line">            Let {pq} = EE</span><br></pre></td></tr></tbody></table></figure><p>按照极边的思路，我们可以将伪代码细化为这样一段真实的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">markEE</span><span class="params">(Point S[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) </span><br><span class="line">        S[k].extreme = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; n; p++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q = p + <span class="number">1</span>; q &lt; n; q++) </span><br><span class="line">            <span class="built_in">checkEdge</span>(S, n, p, q);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkEdge</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">bool</span> LEmpty = TRUE, REmpty = TRUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n &amp;&amp; (LEmpty || REmpty); k++) {</span><br><span class="line">        <span class="keyword">if</span> (k != p &amp;&amp; k != q) {</span><br><span class="line">            <span class="built_in">ToLeft</span>(S[p], S[q], S[k])? LEmpty = FALSE: REmpty = FALSE;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LEmpty || REmpty)</span><br><span class="line">        S[p].extreme = S[q].extreme = TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Incremental-Construction"><a href="#Incremental-Construction" class="headerlink" title="Incremental Construction"></a>Incremental Construction</h3><h4 id="Decrease-and-Conquer"><a href="#Decrease-and-Conquer" class="headerlink" title="Decrease and Conquer"></a>Decrease and Conquer</h4><p>接下来我们将从一个典型的算法思想减而治之 Decrease and Conquer 进一步改进。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/mzXh86.png"></p><p>一个经典的应该能回忆起来的算法就是插入排序 Insertionsort。插入排序整个思路可以归纳为将整个待排序序列存成线性结构，接下来在任何时候都将它分为排序和未排序两部分，在未排序部分随机找出一个（一般是两者分界的那个元素），通过一次查找在 sorted 子序列中找到这个元素对应的恰当插入位置。</p><p>同理，我们也可以应用于极边算法。</p><h4 id="In-Convex-Polygon-Test"><a href="#In-Convex-Polygon-Test" class="headerlink" title="In-Convex-Polygon Test"></a>In-Convex-Polygon Test</h4><p>递进式的核心技术是 In-Convex-Polygon Test，也就是判别多边形内部或者外部的问题。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/i6u0B3.png"></p><p>我们要判断一个新引入的点是否是当前的极点，其实本质上就是判断当前这个点是否落在此前的凸包的外面或者是里面的位置关系。</p><p>要将刚才那种直觉转化成数学上的判断：每次我们递增式新引入的这个点如果是当前的 extreme point 的话，那么充要条件其实就是看它是否落在当前这个凸包的外面：如果落在外面那它就是下一个 extreme point；否则不是。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/jScreb.png"></p><p>如果凸多边形确实是给定的，而且在此后要反复多次地做这类的查询的话，你是可以对这个多边形做一个预处理（本质上是排序）。</p><p>我们可以大致以一个点作为基础，在其余的 n - 1 个点中可以找到一个居中的连接起来确定一条有向线段。接下来又是我们刚才的惯用的 To-Left Test，经过这样一次常数成本的操作，我们确实可以判断出来这个未知的点到底是落在左边或者是右边，无论是哪边我们都可以将搜索的范围有效地收缩为原先的一半。</p><p>如此往复，我们每一次经过常数时间的成本都可以将这个问题的范围有效地降解为此前的一半，如此下去最终总会到达平凡的情况–trivial case：In-Triangle Test。</p><p>但是这个算法却不可行，最重要的是凸包并不是一成不变的，这种情况下我们的预处理是没有效力的。</p><h4 id="Why-Not-Binary-Search"><a href="#Why-Not-Binary-Search" class="headerlink" title="Why Not Binary Search"></a>Why Not Binary Search</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/vdGYz8.png"></p><p>与插入排序类似，sorted 部分本身就是动态的，即便可以使用二分查找，线性存储所带来的插入成本在最坏情况也会将这种优化无效化。</p><p>回到凸包，对于这种情况朴素的方法反而是最好的。我们可以沿着给定的凸多边形边界做习惯性的 CCW 逆时针旋转遍历，可以发现内部的点一定是在左手一侧的；反之如果我们在任何一段发现某一个点在右侧，那么可以立即断定它并非落在内部。</p><h4 id="Support-Lines"><a href="#Support-Lines" class="headerlink" title="Support-Lines"></a>Support-Lines</h4><p>其实我们还有一个任务要完成，解决如何将新引入的这个点附着或者是增加到原先的凸包上去，要使之成为一个完整的可以继续使用的结构。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/SM3vZw.png"></p><p>凸包切线又被称为 Support Line。</p><h4 id="Pattern-Of-Turns"><a href="#Pattern-Of-Turns" class="headerlink" title="Pattern Of Turns"></a>Pattern Of Turns</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/ibqaRy.png"></p><p>只需要花费两次 To-Left Test，就可以明确确定一个顶点到底是来自 ts(L + R) 还是 st(R + L)。</p><h4 id="Exterior-x2F-Interior"><a href="#Exterior-x2F-Interior" class="headerlink" title="Exterior/Interior"></a>Exterior/Interior</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/X3dd3R.png"></p><h3 id="Jarvis-March"><a href="#Jarvis-March" class="headerlink" title="Jarvis March"></a>Jarvis March</h3><h4 id="Selectionsort"><a href="#Selectionsort" class="headerlink" title="Selectionsort"></a>Selectionsort</h4><p>在介绍 GW 算法之前为了更好地理解它的算法思路，不妨温习一下之前我们很熟悉的选择排序。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/hFprPa.png"></p><p>与刚才的插入排序非常对称，在这里我们的 sorted 和 unsorted 部分是前后颠倒了，这个颠倒实际上是有本质区别的。</p><p>我们需要从 unsorted 部分中去找出一个最大的元素，接着将它进行一次交换挪到刚才 sorted 那个部分的首部。悄然之间，sorted 部分就向前迈进了一步。</p><p>那么这样一个算法思路从宏观的策略来讲我们可以概括为：每次我们都是维护一个局部的解，然后在尚未处理的部分中要去找到一个与当前的这个局部解紧密相关联的一个元素。没错，凸包就可以这么来做。</p><h4 id="Strategy-1"><a href="#Strategy-1" class="headerlink" title="Strategy"></a>Strategy</h4><p>我们如果反思一下在 Extreme Edge 那个算法中为什么会需要多达 n^3 的时间，就会发现根本的原因在于我们实际上考察的对象是遍布所有可能的那些边，这些边的总数会多达 n^2，每个又需要 n 时间鉴别。那么有什么改进的诀窍呢？</p><p>刚才的 selectionsort 就给了我们提示，也就是说我们或许能够将下一个的查找范围缩小到一个足够小的范围。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/xzIg9d.png"></p><p>Jarvis 观察注意到一些结论：</p><ol><li>所有构成凸包的那些边其实在拓扑上讲都是首尾相连构成一个环状结构的</li><li>如果构造过程确实是一条一条边构造，那么如果我在某一个时刻构造出一条边，那么接下来我必然可以沿着它的某一个端点向后继续去找到下一条 extreme edge</li></ol><h4 id="Coherence"><a href="#Coherence" class="headerlink" title="Coherence"></a>Coherence</h4><p>该图可以说明如何在当前已有的这些极边基础上沿着下一个端点拓展出新的极边：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/pPWwjn.png"></p><p>当前节点称作 <code>k</code>，它的前驱我们称之为 <code>i</code>，下一个极边则是 <code>s</code>。根据刚才 Jarvis 的判断，这个 <code>s</code> 必然来自于其他尚未处理的那些点中的一员。</p><p>而 <code>s</code> 之所以可以脱颖而出，其资本在于它是所有这些拐角中的最小者。也许有同学已经跃跃欲试准备用三角函数和反三角函数操作了，但其实有一种基本的技术就可以解决我们的问题。</p><h4 id="To-Left-Test-1"><a href="#To-Left-Test-1" class="headerlink" title="To-Left Test"></a>To-Left Test</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/Qyx4n5.png"></p><h4 id="Lowest-Then-Leftmost"><a href="#Lowest-Then-Leftmost" class="headerlink" title="Lowest-Then-Leftmost"></a>Lowest-Then-Leftmost</h4><p>一个技术细节问题，也就是我们刚才说到的起点和第一条极边应该如何来找呢？</p><p>作为第一个点，它至少是极点。在这里针对于我们目前的算法需求，可以对问题进一步简化，也就是找到沿着 y 轴负方向最低的位置。这个点也就是所谓的 Lowest Point，在没有退化的情况下必然是 extreme point，所以我们可以以它为起点。</p><p>如果出现多个最低点的退化情况，则优先选择最左侧的点，也称为 Lowest-Then-Leftmost point。</p><h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/x8V0zb.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Jarvis</span><span class="params">(Point S[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        S[k].extreme = FALSE</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ltl = <span class="built_in">LTL</span>(S, n);</span><br><span class="line">    <span class="type">int</span> k = ltl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start with LTL</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        P[k].extreme = TRUE;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++)</span><br><span class="line">            <span class="keyword">if</span> (t != k &amp;&amp; t != s &amp;&amp; (s == <span class="number">-1</span> || !<span class="built_in">ToLeft</span>(P[k], P[s], P[t])))</span><br><span class="line">                s = t;</span><br><span class="line">        P[k].succ = s;</span><br><span class="line">        k = s;</span><br><span class="line">    } <span class="keyword">while</span>(ltl != k)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>初始化所有点都被视为非极点，接下来找到刚才所说的 Lowest-Then-Leftmost point 并且把它作为我们的第一个点 <code>k</code> 进入下面一个迭代循环。</p><p>每一个点当它进入这个循环的时候必为极点，第一个点如此，后面的点也一样。接下来我们则要找 <code>s</code> 是逐渐优化最终找到的极点，任何时候我们都未必知道它就是，需要遍历所有候选 <code>t</code>。 </p><p>当 <code>t</code> 通过 To-Left 测试时什么都不处理，<code>s</code> 依然为候选者；反过来 To-Left 测试失败意味着出现在右侧，需要更迭 <code>s</code> 为 <code>t</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/zpOE73.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LTL</span><span class="params">(Point S[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="type">int</span> ltl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">if</span> (P[k].y &lt; P[ltl].y || (P[k].y == P[ltl].y &amp;&amp; P[k].x &lt; P[ltl].x))</span><br><span class="line">            ltl = k;</span><br><span class="line">    <span class="keyword">return</span> ltl;        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Output-Sensitivity"><a href="#Output-Sensitivity" class="headerlink" title="Output Sensitivity"></a>Output Sensitivity</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/spDhK8.png"></p><h3 id="Lower-Bound"><a href="#Lower-Bound" class="headerlink" title="Lower Bound"></a>Lower Bound</h3><h4 id="Reduction"><a href="#Reduction" class="headerlink" title="Reduction"></a>Reduction</h4><p>在前面几节里我们围绕凸包的计算问题给了一系列的算法，从最开始的 n^4 极点算法一直到后面 n^3 极边的算法，再到 Jarvis march 以及 Incremental n^2，我们在沿着一条不断递减的路线在降低这个算法的复杂度。</p><p>但是如果计算模型是固定的话，必然有一个我们所说的 Low Bound 的概念：下界，也就是复杂度再低也不会低于某一个极限。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/dcT0rw.png"></p><h4 id="CAO-Chong’s-Methodology"><a href="#CAO-Chong’s-Methodology" class="headerlink" title="CAO Chong’s Methodology"></a>CAO Chong’s Methodology</h4><p>三国中曹操的儿子曹冲有个很著名的故事：曹冲称象。</p><p>我们需要度量一个东西的难度，曹冲是要称出一头象的重量，他去找中间参照物石头，通过石头的重量估算出象的重量，而 Reduction 关系就是曹冲的船和水。</p><h4 id="Transitivity"><a href="#Transitivity" class="headerlink" title="Transitivity"></a>Transitivity</h4><p>那么为什么这个问题可以像曹冲称象一样能够间接通过 A 问题的难度就得到 B 问题的难度呢？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/AZka7O.png"></p><p>对于 A 问题的任何一个输入，我们都可以曲径通幽式的先把它转化为 B 问题的输入，接下来调用 B 问题的任意算法得到输出，再转化为 A 的输出。</p><p>如果 A 问题确实存在某一个下界，而且这个下界是严格大于 n 的，那么我们说 B 问题的所有算法都不可能低于这个复杂度下界。</p><h4 id="Reduction-Input"><a href="#Reduction-Input" class="headerlink" title="Reduction: Input"></a>Reduction: Input</h4><p>首先要把我们未知的那个问题（也就是那头象）摆在右边，这里我们考虑二维的凸包 2-dimensional convex hull 这个问题。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/RHvnFP.png"></p><p>而石头则是 Sorting。也许初看这个问题可能会很迷茫，排序这个问题和凸包这个问题一个是纯粹的抽象计算问题，一个是具体的几何计算问题，二者之间怎么会有联系呢？</p><ol><li>证明可以在线性时间内将排序问题的任何一个输入转化为凸包问题的输入</li><li>证明凸包问题的结果线性时间内转换回到排序问题</li></ol><p>排序问题的输入可以理解为在数轴或者平面上 x 轴一系列的点，在图中我们只取了四个点。为了转换为凸包问题我们需要辅助线，以抛物线作为标尺将每一个点做提升变换，将 n 个数字转化为平面上的 n 个点。</p><h4 id="Reduction-Output"><a href="#Reduction-Output" class="headerlink" title="Reduction: Output"></a>Reduction: Output</h4><p>来自抛物线上有线个点的凸包都具有这样的一个特性：最左侧的那个点和最右侧的那个点会在上面连上一条纵跨的一条单调直线。</p><p>这样我们就完成了 Reduction 的第二步：将凸包问题转化为排序问题。输入是无序的，输出是有序的，这正是排序算法的要求。</p><p>(注：这里有一个疑惑就是如果是正五边形，那么这个左右边界又该如何去界定呢？边界的连线并不单调。)</p><h4 id="Sorting-lt-x3D-N-2d-CH"><a href="#Sorting-lt-x3D-N-2d-CH" class="headerlink" title="Sorting <=N 2d-CH"></a>Sorting &lt;=N 2d-CH</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/s350xy.png"></p><p>所以排序算法的下界是 nlogn，那么凸包问题也是如此，成为 Convex Hull 的下界。</p><h3 id="Graham-Scan-Algorithm"><a href="#Graham-Scan-Algorithm" class="headerlink" title="Graham Scan: Algorithm"></a>Graham Scan: Algorithm</h3><h4 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>那么我们来看一个下界意义上讲最优的算法：Graham Scan。</p><p>Graham Scan 首先要做的一件事情是一个预处理，一个排序。这个 presorting 其实就是要找到某一个特定的点，并且将其余所有的点按照这个点所对应的极坐标按极角来做一个排序。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/M8f8bt.png"></p><p>那么具体的这样第一个点应该找谁呢？</p><p>其实任何一个极点理论上都是可以的，同样为了简化算法的解释和实现，我们不妨依然采用前面所讲过的 Lowest-then-Leftmost point 为 1 号点。</p><p>接下来会有与 1 号成角度最小的 2 号点，这里不妨假设 1、2 号点为同一高度，并且没有三点共线的情况，接着按照 (1, 2) 极轴的夹角从小到大命名其他点。</p><p>Graham Scan 算法的数据结构也很简单，只需要两个栈 T 和 S。初始化时依次将 1、2 入栈 S 中，其他 n-2 个点自顶到底存入 T 栈。</p><p>而排序可以选用任意排序，只是对象变成了点，而比较器变为 To-Left Test。</p><h4 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h4><p>这个扫描过程中要关注三个东西：S 栈栈顶以及次栈顶、T 栈栈顶，我们可以用 <code>S[0]</code>、<code>S[1]</code>、<code>T[0]</code> 表示。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/YCf577.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!T.<span class="built_in">empty</span>()) {</span><br><span class="line">    <span class="comment">// test type of current turn</span></span><br><span class="line">    <span class="built_in">toLeft</span>(S[<span class="number">0</span>], S[<span class="number">1</span>], T[<span class="number">0</span>])?</span><br><span class="line">        <span class="comment">// step forward at a left turn</span></span><br><span class="line">        S.<span class="built_in">push</span>(T.<span class="built_in">pop</span>()):</span><br><span class="line">        <span class="comment">// or, backtrack</span></span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Graham-Scan-Correctness"><a href="#Graham-Scan-Correctness" class="headerlink" title="Graham Scan: Correctness"></a>Graham Scan: Correctness</h3><h4 id="Left-Turn"><a href="#Left-Turn" class="headerlink" title="Left Turn"></a>Left Turn</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/3oGYec.png"></p><h4 id="Right-Turn"><a href="#Right-Turn" class="headerlink" title="Right Turn"></a>Right Turn</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/Zw9WOM.png"></p><p>9 号点被包含在了某一个三角形(1-8-10)的内部，它应该被排除掉。</p><h3 id="Graham-Scan-Analysis"><a href="#Graham-Scan-Analysis" class="headerlink" title="Graham Scan: Analysis"></a>Graham Scan: Analysis</h3><h4 id="Backtracks"><a href="#Backtracks" class="headerlink" title="Backtracks"></a>Backtracks</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/fTPnpm.png"></p><h4 id="Planarity"><a href="#Planarity" class="headerlink" title="Planarity"></a>Planarity</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/i2ooE2.png"></p><p>根据欧拉公式，平面图中所有边的数量包括面数加在一起依然和顶点数目保持同阶，边数不会超过顶点数的三倍。</p><h4 id="Amortization"><a href="#Amortization" class="headerlink" title="Amortization"></a>Amortization</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/mAH8dL.png"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>: S.<span class="built_in">size</span>()++; T.<span class="built_in">size</span>()--;   <span class="comment">//  1 - 2</span></span><br><span class="line"><span class="keyword">else</span>: S.<span class="built_in">size</span>()++;               <span class="comment">// -1 + 0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Divide-And-Conquer-1"><a href="#Divide-And-Conquer-1" class="headerlink" title="Divide-And-Conquer (1)"></a>Divide-And-Conquer (1)</h3><h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/fbtL5x.png"></p><p>归并排序作为引子引出我们的算法。</p><p>Divide-And-Conquer 要求我们接近均匀切分 divide，接着我们把这些结果合并起来成为有序序列，变成最终结果。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/3p8soR.png"></p><p>凸包问题也是如此，把输入的点集分成大小规模接近的子集分别求出它们的凸包。问题实质就变成了我有两个凸包子集之后如何将它们合并得到更大的凸包。</p><h4 id="Common-Kernel"><a href="#Common-Kernel" class="headerlink" title="Common Kernel"></a>Common Kernel</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/tuDj5v.png"></p><p>找到一个公共核使得这两个待合并的子凸包能够同时关于这个点是角度有序的。</p><h4 id="Interior"><a href="#Interior" class="headerlink" title="Interior"></a>Interior</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/5IBdvu.png"></p><p>二路归并采用环形次序，然后 Graham Scan 即可。</p><h4 id="Exterior"><a href="#Exterior" class="headerlink" title="Exterior"></a>Exterior</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/ReaP65.png"></p><p>我们预选的那个来自第一个子凸包的 centroid point 不幸落在第二个子凸包的外面，在这种情况下我们应当如何完成二者的归并呢？</p><h3 id="Divide-And-Conquer-2"><a href="#Divide-And-Conquer-2" class="headerlink" title="Divide-And-Conquer (2)"></a>Divide-And-Conquer (2)</h3><h4 id="Preprocessing-1"><a href="#Preprocessing-1" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/jzuwYn.png"></p><p>不妨做一个假设，待合并的两个子凸包或者说它们对应的点集是沿着某个方向是可分割的，彼此独立。如果这样我们的合并任务就会变得更加简明、简单。</p><p>为了保证这一点，我们引入一个预处理：按 x 轴排序。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/HybE5r.png"></p><h4 id="Common-Tangents"><a href="#Common-Tangents" class="headerlink" title="Common Tangents"></a>Common Tangents</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/FGE9PW.png"></p><h4 id="Topmost-Bottommost"><a href="#Topmost-Bottommost" class="headerlink" title="Topmost + Bottommost?"></a>Topmost + Bottommost?</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/mhMYrp.png"></p><h4 id="Stitch"><a href="#Stitch" class="headerlink" title="Stitch"></a>Stitch</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/4F6fi4.png"></p><p>我们可以在最初构造一个子凸包的时候记下 leftmost 和 rightmost 各是哪两个顶点，剩下几乎不用花时间：把此前计算结果延续下来即可，而分摊到每一次合并常数时间就够了。</p><h4 id="Zig-Zag"><a href="#Zig-Zag" class="headerlink" title="Zig-Zag"></a>Zig-Zag</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/mTWeCG.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CG1/a3j4Rj.png"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://twitter.com/cyangmou/status/1571176793943457793&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CG1/qrXkrr.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本节我们将探索计算几何的核心问题：凸包问题。计算几何领域几乎所有的问题都可以“归约”为凸包问题，因此学习凸包问题对整个计算几何体系至关重要。&lt;/p&gt;</summary>
    
    
    
    <category term="计算几何 (Computational Geometry)" scheme="https://yousazoe.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-Computational-Geometry/"/>
    
    
    <category term="Computational Geometry" scheme="https://yousazoe.top/tags/Computational-Geometry/"/>
    
  </entry>
  
  <entry>
    <title>Introduction</title>
    <link href="https://yousazoe.top/archives/ed328fdc.html"/>
    <id>https://yousazoe.top/archives/ed328fdc.html</id>
    <published>2022-09-21T02:18:51.000Z</published>
    <updated>2023-01-24T07:20:37.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://twitter.com/m4ndrill/status/1570094225261301760"><img data-src="https://img.yousazoe.top/uPic/img/blog/CG0/Ofd9RT.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算几何的重要之处在于它是多门技术与学科的基础，例如图形学、CAD、GIS、路径规划等。这些技术的背后原理往往是基于计算几何的本质上。所以该门课程的学习对养成计算几何理论的总体认识很有帮助，这种认识将为学习者日后的研究工作提供几何的视角。</p><span id="more"></span><h4 id="What-can-we-learn-from-this-course"><a href="#What-can-we-learn-from-this-course" class="headerlink" title="What can we learn from this course?"></a>What can we learn from this course?</h4><blockquote><ul><li>Awareness of Computational Geometry theory that will help students incorporate Computational Geometry into their future research </li><li>Comprehensive understanding on fundamental paradigms/strategies for solving geometric problems, incremental construction, plane sweeping </li><li>Essential geometric structures and algorithms such as polygon decompositions, Voronoi diagrams, Delaunay triangulations</li></ul></blockquote><p>本课程的教学目标有三：</p><ul><li>对计算几何理论的总体认识，在日后的研究工作中，这种认识为你提供几何的视角</li><li>对几何问题求解范式及策略的全面领会，包括递增式构造、平面扫描、分而治之、分层化、近似以及随机化等</li><li>对基本几何结构及其算法的透彻掌握，包括凸包、多边形细分、Voronoi图、Delaunay三角剖分，以及几何求交、点定位、范围查找、截窗查询等</li></ul><h4 id="Are-you-qualified-for-learning-Computational-Geometry"><a href="#Are-you-qualified-for-learning-Computational-Geometry" class="headerlink" title="Are you qualified for learning Computational Geometry?"></a>Are you qualified for learning Computational Geometry?</h4><blockquote><p>Computational Geometry requires some skills of algorithm design and analysis as well as programming, but you don’t need to be an expert before learning this course. Actually, C/C++ programming experience and some basic knowledge of common data structures will be enough. To make sure whether you are qualified for learning this course, check the list below:</p><ul><li>C/C++ programming: variable, function, struct, class;</li><li>Algorithm design and analysis: complexity, amortized analysis, recursion, divide and conquer, linked list, binary search tree, priority queue.</li></ul></blockquote><p>计算几何这门课对数据结构和算法基础和编程基础有一定的要求，但这并不意味着你需要精通所有相关课程。实际上，你只需掌握一些常见数据结构，拥有一定的算法分析能力，以及C/C++语言编程的基本技巧。为确认自己是否适宜选修这门课程，不妨对照以下清单做一清点：</p><ul><li>C/C++语言程序设计基础：变量，函数，结构体，类</li><li>数据结构与算法分析：复杂度、摊还分析、递归、分治法、链表、栈、二叉搜索树、优先队列</li></ul><h3 id="History-of-This-Course"><a href="#History-of-This-Course" class="headerlink" title="History of This Course"></a>History of This Course</h3><p>这门课已经开设 18 年之久，虽然国外诸多著名高校都开设了这门课程，但国内做计算几何方面的学校和机构屈指可数。</p><h3 id="What’s-Computational-Geometry"><a href="#What’s-Computational-Geometry" class="headerlink" title="What’s Computational Geometry"></a>What’s Computational Geometry</h3><p>说到计算几何，我们要做一个名词辨析。</p><p>如果你第一次听到 Computational Geometry，首先注意到的肯定是几何，脑海中浮现的是曲线、曲面诸如此类。事实上我国数学家苏步青八十年代就曾出版过一本《计算几何》的书。 此计算几何非彼计算几何，这门课更加强调的是计算。现代计算几何人们公认诞生于 1978 年 Shamos 那篇著名的博士论文，所以这门学科到现在也不过区区四十年的发展历史。</p><p>当然计算几何之所以很重要，就是因为它是很多学科尤其是技术学科的基础，包括典型的图形学、CAD、GIS、路径规划等等……最后都会回到计算几何这些基本的问题。</p><p>在学习之前如果一言以蔽之概括一下的话，计算几何就是就是”算法设计与分析”的几何版，它所讨论的对象、问题的表面形式都是几何的，它求解这些问题的方法、策略高到上面的方法论其实也都是几何的。尽管从这个方面讲计算几何只是算法设计与分析的一个分支，但是正因为它融入了很多古典的一些离散几何学、组合几何学等等精华的结论和方法，所以它不仅仅是一个几何和计算两个问题的物理反应，而是很深入的化学反应。</p><h3 id="How-to-Learn-CG-Better"><a href="#How-to-Learn-CG-Better" class="headerlink" title="How to Learn CG Better"></a>How to Learn CG Better</h3><p>计算几何强调本质的东西就是要形象。</p><p>没有人喜欢复杂深奥的东西，所以这门课如果在学习过程中没办法很好理解推导和公式，不必拘泥于复杂深奥的泥潭，暂时放下它，将注意力放在图形和具体表现上。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://twitter.com/m4ndrill/status/1570094225261301760&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CG0/Ofd9RT.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;计算几何的重要之处在于它是多门技术与学科的基础，例如图形学、CAD、GIS、路径规划等。这些技术的背后原理往往是基于计算几何的本质上。所以该门课程的学习对养成计算几何理论的总体认识很有帮助，这种认识将为学习者日后的研究工作提供几何的视角。&lt;/p&gt;</summary>
    
    
    
    <category term="计算几何 (Computational Geometry)" scheme="https://yousazoe.top/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-Computational-Geometry/"/>
    
    
    <category term="Computational Geometry" scheme="https://yousazoe.top/tags/Computational-Geometry/"/>
    
  </entry>
  
  <entry>
    <title>基础算法</title>
    <link href="https://yousazoe.top/archives/ce5da845.html"/>
    <id>https://yousazoe.top/archives/ce5da845.html</id>
    <published>2022-09-20T13:04:37.000Z</published>
    <updated>2023-01-24T07:20:37.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/89559779/The-spirit"><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/DiUjjX.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>简单介绍一些基本算法，包括：搜索、贪心、二分查找与三分查找、序列分治以及排序。</p><span id="more"></span><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(3).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(4).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(5).PNG"></p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(6).PNG"></p><h4 id="什么是搜索"><a href="#什么是搜索" class="headerlink" title="什么是搜索"></a>什么是搜索</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(7).PNG"></p><h4 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(8).PNG"></p><ul><li>以起始状态为根，每个状态向其后继状态连有向边，可以得到一棵有根树<ul><li>终止状态对应这棵树的叶子</li></ul></li><li>搜索过程可以被抽象成遍历这棵搜索树的过程</li><li>如果需要遍历整棵搜索树，则复杂度至少正比于搜索树的结点数量</li><li>如果除叶结点外的结点都有至少两个叶结点，则可以用叶结点的数量估计有根树的大小<ul><li>为什么?</li></ul></li><li>如果除终止状态之外的状态都至少有两个后继状态，则可以用终止状态的数量估计搜索的复杂度</li><li>如果除终止状态之外的状态的后继状态数量是有下限的，则可以用层数估计终止状态的数量</li></ul><h4 id="搜索复杂度"><a href="#搜索复杂度" class="headerlink" title="搜索复杂度"></a>搜索复杂度</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(9).PNG"></p><h4 id="深度优先与广度优先"><a href="#深度优先与广度优先" class="headerlink" title="深度优先与广度优先"></a>深度优先与广度优先</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(10).PNG"></p><p>深度优先搜索(<strong>Depth-First Search</strong>)优先遍历一个后继结点的子树内所有结点</p><ul><li>先一条路走到黑，再返回上一个分岔点</li></ul><p>广度优先搜索(<strong>Breadth-First Search</strong>)先遍历所有后继结点，再遍历后继结点的后继</p><ul><li>在分岔点分身，最终每个终止结点都有一个分身</li></ul><h4 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 Depth-First Search"></a>深度优先搜索 Depth-First Search</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(11).PNG"></p><h4 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 Breadth-First Search"></a>广度优先搜索 Breadth-First Search</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(12).PNG"></p><h4 id="搜索策略的选择"><a href="#搜索策略的选择" class="headerlink" title="搜索策略的选择"></a>搜索策略的选择</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(13).PNG"></p><p><strong>深度优先搜索 DFS</strong></p><ul><li>只需储存从初始状态到当前状态的一条路径</li><li>当递归层数较深时可能会爆栈</li><li>需要考虑回溯撤销的问题，细节可能比较麻烦<ul><li>搜索层数不确定时可能会带来问题:无限拓展</li></ul></li><li>移动棋子，绕了一大圈返回起点</li><li>子树中结点编号是连续的</li></ul><p><strong>广度优先搜索 BFS</strong></p><ul><li>需要储存所有尚待拓展的状态，空间开销大</li><li>可以动态使用堆内存</li><li>状态单向拓展，实现较为简单</li><li>可以知道从初始状态到每个状态的最少步数<ul><li>适用于边权都为 1 的最短路</li></ul></li><li>同一层的结点编号是连续的</li></ul><h4 id="扩展阅读-迭代加深搜索"><a href="#扩展阅读-迭代加深搜索" class="headerlink" title="扩展阅读:迭代加深搜索"></a>扩展阅读:迭代加深搜索</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(14).PNG"></p><h4 id="搜索剪枝-Pruning"><a href="#搜索剪枝-Pruning" class="headerlink" title="搜索剪枝 Pruning"></a>搜索剪枝 Pruning</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(15).PNG"></p><p>果树剪枝是为了让树长得更好看，结出的水果质量更高</p><p>搜索树也可以剪枝，让搜索效率更高;注意不要把最优解给剪枝掉了</p><p>可行性剪枝</p><ul><li>如果当前状态已经不满足题目的要求，则不继续拓展</li><li>可以用于最优化问题，也可以用于统计解</li></ul><p>最优性剪枝</p><ul><li>只能用于最优化问题</li><li>如果从当前状态出发，可以得到的最优解一定不比已经得到的最优解优，则不继续拓展</li></ul><p>此外还有其它剪枝思路，例如在双人游戏中有 Alpha-beta 剪枝等，在这里不详细展开</p><h4 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h4><h5 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(16).PNG"></p><h5 id="埃及分数"><a href="#埃及分数" class="headerlink" title="埃及分数"></a>埃及分数</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(18).PNG"></p><h5 id="剪枝思路"><a href="#剪枝思路" class="headerlink" title="剪枝思路"></a>剪枝思路</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(19).PNG"></p><ul><li>放缩!</li><li>如果怎么救都救不回来，那就应该放弃<ul><li>如果后续状态一定不合法，则不继续深入搜索</li></ul></li><li>以最小化问题为例<ul><li>为当前状态的所有后继估计解的下界，如果下界大于(或大等于，取决于具体题目)当前最小值则剪枝</li></ul></li><li>扩展阅读:分支定界法求解</li></ul><h4 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(20).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(21).PNG"></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(26).PNG"></p><h4 id="贪心-Greedy-Algorithm"><a href="#贪心-Greedy-Algorithm" class="headerlink" title="贪心 Greedy Algorithm"></a>贪心 Greedy Algorithm</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(27).PNG"></p><h4 id="贪心与动态规划的区别"><a href="#贪心与动态规划的区别" class="headerlink" title="贪心与动态规划的区别"></a>贪心与动态规划的区别</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(28).PNG"></p><h4 id="找零钱问题"><a href="#找零钱问题" class="headerlink" title="找零钱问题"></a>找零钱问题</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(29).PNG"></p><ul><li>假设你有面值为 1 元，5 元，10 元，20 元，50 元和 100 元的纸币各若干张</li><li>用这些纸币表示出给定的正整数金额，使得用的纸币数量最少</li><li>贪心做法:每次选取不超过尚未被表示的金额的面值最大的纸币<ul><li>127 → 100 + 20 + 5 + 1 + 1</li><li>正确性?</li></ul></li><li>假设纸币的面值是 1 元，2 元，4 元，8 元，16 元，……，贪心做法还是正确的吗?</li><li>假设纸币的面值是 1 元，5 元，10 元，20 元和 25 元，贪心做法还是正确的吗?<ul><li>反例:40 → 25 + 10 + 5，但是 20 + 20 更优</li></ul></li></ul><h4 id="证明贪心正确性的常见思路"><a href="#证明贪心正确性的常见思路" class="headerlink" title="证明贪心正确性的常见思路"></a>证明贪心正确性的常见思路</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(30).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(31).PNG"></p><h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(32).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(33).PNG"></p><h3 id="二分与三分"><a href="#二分与三分" class="headerlink" title="二分与三分"></a>二分与三分</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(34).PNG"></p><h4 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 Binary Search"></a>二分查找 Binary Search</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(35).PNG"></p><h4 id="一个小故事"><a href="#一个小故事" class="headerlink" title="一个小故事"></a>一个小故事</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(36).PNG"></p><h4 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(48).PNG"></p><h3 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(50).PNG"></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(51).PNG"></p><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(52).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(53).PNG"></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(54).PNG"></p><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(55).PNG"></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(56).PNG"></p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(57).PNG"></p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(58).PNG"></p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(59).PNG"></p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA3/BasicAlgorithm%20(60).PNG"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/89559779/The-spirit&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/THUAA3/DiUjjX.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;简单介绍一些基本算法，包括：搜索、贪心、二分查找与三分查找、序列分治以及排序。&lt;/p&gt;</summary>
    
    
    
    <category term="清华大学算法协会 (Tsinghua University Algorithm Association)" scheme="https://yousazoe.top/categories/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E5%8D%8F%E4%BC%9A-Tsinghua-University-Algorithm-Association/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>《赛博朋克：边缘行者》与人文主义的反思</title>
    <link href="https://yousazoe.top/archives/dff9eab3.html"/>
    <id>https://yousazoe.top/archives/dff9eab3.html</id>
    <published>2022-09-19T02:03:09.000Z</published>
    <updated>2023-01-24T07:20:37.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/FQe8VN.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在贪墨成风的反乌托邦世界中，四处都是生化改造植入体。动画剧聚焦一个在街头长大的鲁莽天才少年努力想成为边缘行者：拿钱办事的法外之徒。</p><span id="more"></span><p>近些年里，游戏改编的影视作品越来越多，每一部都会宣称自己制作如何精良，但它们要么如《龙之血》《双城之战》那样摒弃了游戏玩法、着重于挖掘背景故事，要么如《神秘海域》或者《光环》，大幅改造甚至看不起原作剧情直接另起炉灶，没有任何一个能像《边缘行者》这样忠实地遵从原作的框架、同时还能讲好一个故事。它甚至还弥补了《2077》至今未能实现的缺憾：我们终于看到了单分子线在大杀四方的同时也能实现骇入，也终于看到了 NCART，其实是能坐人的。</p><p>《边缘行者》播出以来在各个评分网站上都收获了不错的口碑，这不仅证明了《2077》确实有着优秀的基础框架，可惜潜力没有被充分发挥出来；同时也是打了那些自大的好莱坞编剧们的脸：老老实实照着游戏内容拍，远比你们一拍脑门搞出来的那套东西更能讨好观众。</p><p>当然，出色的作画、讨喜的人设，还有以上说的种种，固然能够大幅提升玩家们的观感；但真正能够打动观众的，还是赛博朋克的内核。</p><h3 id="剧情梳理"><a href="#剧情梳理" class="headerlink" title="剧情梳理"></a>剧情梳理</h3><h4 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h4><p>本剧的主角，大卫·马丁内斯，在故事刚开始的时候，还是一个不谙世事的学生。他的母亲葛洛丽亚在市政部门工作，薪水微薄，日常工作是清理横死街头的赛博疯子和帮派分子。借着职务之便，能够接触到这些死人身上拆下来的义体，她便通过把义体倒卖给边缘行者们来赚取外快。而她这样辛辛苦苦、不惜违法地赚钱，目的就是供养自己的儿子在荒坂学院念书。</p><p>荒坂学院是荒坂公司附属的精英学术机构，费用高昂，但学员能够成功毕业，就有机会进入荒坂公司工作，再之后，就有机会一步一步爬到高层——这在葛洛丽亚看来，是普通人唯一能够改变命运的手段。</p><p>而对大卫来说，自己和学院里其他那些少爷终究不是一路人。尽管成绩优异，但连备用制服都买不起的贫寒家境让他处处遭到排挤。平时，他只能在黑超梦带来的感官刺激里麻醉自己，同时靠帮黑市的义体医生推销这些超梦来赚些零花钱。</p><p>本来，日子像这样平平常常地过去，也许大卫最终会成为荒坂公司的一颗螺丝钉，在无止境的工作和加班中被消磨殆尽；又或许时运眷顾，他真的会在企业里步步高升，最后出人头地呢。</p><p>但按部就班的生活因为一场车祸戛然而止。赶来救援的创伤小队把没有保险的母子二人留在原地等死，超级摩天楼里简陋医院的廉价急救套餐终于还是没能救回葛洛丽亚。</p><p>大卫把母亲火化——这是最便宜的丧葬方案——抱着母亲的骨灰回到了因为租金逾期未交而把他拒之门外的家。</p><p>他甚至没有哭泣。</p><p>在夜之城，死亡会让人麻木。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/UPABD8.jpg"></p><p>可他在母亲的遗物中发现了一件义体，他在黑超梦中见过它。斯安威斯坦，军用级义体，能够触发缓时。发动时，周围的一切仿佛静止，只有使用者能够移动自如。</p><p>到了2077年，斯安威斯坦已经发展到可以人手一件的程度，但在剧中故事发生时，装备这件义体还是一个禁忌。不只是因为它专供军用科技内部使用，外部难以获取；更是因为，普通人使用它，十有八九会发疯。</p><p>大卫没管这么多，他甚至在不知道什么是免疫抑制剂的情况下，去找那个相熟的义体大夫安装了斯安威斯坦。随后他直奔学院，在全班同学面前，把之前羞辱了自己和自己的母亲的田中痛打了一番。</p><p>在这之后又是无尽的空虚。他漫无目的地行走在那些曾经走过无数遍的道路上，不知道该做些什么。</p><p>而在这时他遇到了生命中的光。</p><h4 id="PART2"><a href="#PART2" class="headerlink" title="PART2"></a>PART2</h4><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Lucy，我偶尔，只是很偶尔的时候，会问自己，如果我没有见过你，我到现在的人生会不会不一样？没有成为边缘行者的我，没有遇到爱情的我，没有结实这么多同伴的我。我也许会给田中道歉、回到荒坂学院、成为义体实验对象，也许，有那么一丝的可能性，我能够进入公司的高层，能够实现妈妈的愿望。那样的什么都不知道的我，会不会也很快乐呢？ </p><p>但是再给我一次机会，我仍然不可能做出其他的选择。在那趟列车之前，在妈妈遇到车祸之前，在田中把我揍得体无完肤之前，我就见过你了。也许没有真的见过你，也许只是在梦里见过你。但那一头银发，是我黑暗中的光，我早已见过一次又一次，就算是在梦里我也不会认错。 </p><p>我的人生早已注定了。我注定会认识你。</p><p>而这是我遇到过的，最最最幸运的事。</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>他之前就遇到过好几次，一头璀璨耀眼的银发，但总是转瞬即逝，以至于他会以为是幻觉。不过，这次是在轻轨上，她无法再那么轻易地消失了。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/KbQWK1.jpg"></p><p>女孩名叫露西。他看到她在偷取别人的芯片，她发现了他窥伺的目光，冲突、解释、握手言和。他提出帮忙，三七分成。之后是一番奇遇，她把他邀请到家中，分享了自己隐秘的梦想——离开夜之城的牢笼，去月球生活。他们在超梦里登月，在虚拟的低重力下跳跃、欢笑。然后美梦醒来，一伙壮汉把大卫拉回现实。他们是赛博朋克，即是边缘行者。斯安威斯坦本是那伙人中的头领曼恩向葛洛丽亚订购的，如今后者杳无音信，露西按图索骥找到了大卫，现在他们要拿回自己的东西。大卫坚定地要为他们工作来偿还债务，思忖良久，曼恩答应了下来。</p><p>就这样大卫加入了这个小团体，认识了浑身装满义体的大块头曼恩 Maine、曼恩强壮的女友多利欧 Dorio、有着一双灵活手臂的技术狂皮拉 Pilar、皮拉的萝莉妹妹瑞贝卡 Rebecca、沉默寡言的黑客专家琦薇 Kiwi、以及老练可靠的司机法尔科 Falco。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/FQe8VN.jpg"></p><p>大卫在这里找到了家的感觉、和同伴们打成一片，也在一次次任务中逐渐成长为了优秀的边缘行者。他向 Lucy 吐露了自己的感情，答应要带着她去月球。Lucy 吻了过去，两颗心贴在了一起。</p><p>如果到此为止，不过是一系列热血番中常见的展开。主角团中有人死去、有人离开，但主角总是借着光环无法倒下。可赛博朋克的世界不是童话故事。一次任务中，大哥曼恩终于无法控制住自己日渐被义体所侵蚀的神经系统，失手攻击 Kiwi，打乱了行动计划，Lucy 作为备用黑客迫不得已加入任务；后面又因为失神造成了 Dorio 的死去。面对着 NCPD 和创伤小队的双重围堵，曼恩知道自己大限已至。面对前来试图营救自己的大卫，他只是淡然地说了一句：“这就是我的终点了。”</p><p>随后，便用烈火将自己和爱人焚尽。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/yNCjfh.jpg"></p><h4 id="PART3"><a href="#PART3" class="headerlink" title="PART3"></a>PART3</h4><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>他们都说，夜之城的传奇都在坟墓里。</p><p>这大概是真的吧。那么，曼恩大哥也算是一个传奇了吧。</p><p>但如果有选择的话，我宁愿不做那个传奇。毕竟，以前你们好多人和我说，说我老是为别人的梦想而活；而现在我也有自己的梦想了呢。我的梦想，就是我之前承诺过的，帮你实现你的梦想。你那时说你的梦想是去月球，我从来没有忘记过。月球的单程票是25万欧，当然，如果想要在那里生活，应该还需要更多的钱吧。如果完成了这最后一份差事，大概就足够了。如果能拿到赏金，如果能和你一起去月球，是不是也挺不错的呢？</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>此去经年，大卫成了小团体的新领袖，在圈子里的声望也越来越显赫。Rebecca 在和大卫搭档的过程中对他暗生情愫，可这份心思又怎么能够挑明呢？露西和他一起住进了漂亮的大公寓里，但不再参与组织的工作。当时，她在任务目标的大脑中发现，对方想要拿大卫作为荒坂的新产品“义体金刚”的实验对象。为了保护大卫，她删除了相关信息，没告诉任何人；在这几年中，她名义上拒绝参与团队工作，实际上却是在追杀任何了解实验计划的荒坂员工。</p><p>Lucy 的讳莫如深在大卫眼中看来是逐渐的疏远，可他自己又何尝没有改变呢？</p><p>当初，为了跑步时能够追上 Lucy，他给自己装上了斯安威斯坦外的第一个义体——一对人工肺。后来，曼恩嘱托他，为自己多装几个义体，变强，活下来。于是几年下来，大卫也变成了一个钢铁大块头，一个机械部分多于肉体的义体改造狂。他用的免疫抑制剂，药效也越来越猛、剂量也越来越多。他会时不时地抑制不住自己手臂的抖动，一如曼恩最后的那些日子。</p><p>明眼人都看得出来，大卫离赛博精神病不远了。</p><p>在《2077》里，也许是因为 Relix 芯片的特殊性，又或许仅仅是因为 CDPR 偷懒没有做出来，V 就算把自己浑身上下改装个遍，也感觉不到义体的副作用。可对普通人来说，你的身上不属于自己的部件越多，你的神经系统和肉体对它们的排异反应就会越大，最终，你的大脑会成为机械的奴隶，这就是赛博精神病。成为赛博疯子就是每个没在这之前就挂掉的义体改造狂最终的结局，而在终点等待着他们的，就是疯控小队。</p><p>大卫相信自己有某种天赋。这天赋从他还是十几岁的孩子、刚刚装上斯安威斯坦就能熟练掌控、随心所欲地运用就能看出端倪。要知道，就算是V，发动斯安威斯坦的效果都需要60秒游戏内时间的冷却。这天赋让他能装上一个又一个的义体，而不良反应比起其他人来说又是少之又少。这天赋让他觉得自己是“独特“的，让他觉得他能在夜之城里混出个名堂，让他觉得，带着露西去月球生活，也是有可能的。</p><p>所以说就算 Lucy 和 Rebecca 都劝说他，不要再改装自己了，拆卸下一些义体吧，他还是固执地为自己安装更多的功能模块。</p><p>在他看来，这是能让他赚到足够去月球的钱的，唯一的道路。</p><p>机会来了。一个大单子。拦截荒坂的一辆运输车，取到货，数百万欧，足够团队里每个人过上逍遥日子。当然，这自始至终都是诱饵，目的是让大卫穿上“义体金刚“、与军用科技斗个两败俱伤、最后由荒坂公司自己回收其中的实战数据。另一边，Lucy之前的行迹败露，又遭到Kiwi的出卖，被已成为荒坂哈巴狗的中间人法拉第扭送往荒坂。</p><p>计划如公司所料般进行，大卫一伙被军用科技包围，法拉第用合成的 Lucy 声音哄骗大卫穿上义体金刚，Kiwi跳反，偷袭法尔科后扬长而去。此后，按计划，大卫会发疯、与军用科技同归于尽——可 Lucy 在最后关头挣脱，向大卫发出了警告。这义体是把你赛博精神病的最后一根稻草，就算你没有疯，超量的免疫抑制剂也会让你的理智滑向边缘之外。求求你，千万别装。</p><p>可大卫有什么选择呢？穿了这义体，就不能陪你去月球；但不穿这义体，就不能救下你。这看似是两种选择，但对大卫来说，可能性只有一个。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/SkWYWR.jpg"></p><p>义体安装完成，Rebecca 帮他注入了一大瓶抑制剂。他启动机体，反重力装置和磁场发生装置风卷残云般摧毁了军用科技的包围圈。和荒坂料想中的不同，大卫还保持着清醒。下一步，他们向荒坂塔开去。</p><h4 id="PART4"><a href="#PART4" class="headerlink" title="PART4"></a>PART4</h4><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>可是我也许一开始就知道这是不可能的吧。大概从我安装上斯安威斯坦那天起，我就从它前主人的超梦中预见到了自己的结局。曼恩大哥那时对我说，那就是他的终点了。我当时不甘心，我当时觉得也许我再努力一点就能救下他了。但现在我知道了，当一个边缘行者的终点到来时，他会明白的。正如这就是我的终点了。</p><p>我没能救下妈妈，没能救下曼恩大哥，没能救下瑞贝卡，但我终于救下了你。</p><p>在月球好好生活吧。去感受地球六分之一的重力。去感受太阳的温度。</p><p>只是对不起，我们不能一起去了。</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>穿过荒坂和军用科技的重重围堵，一行人终于来到了最后的目的地。在荒坂塔前，大卫注射了最后一管免疫抑制剂，这其实就是他的死亡宣告：就算他最后战胜了重锤，也无法活着离开。更何况我们都心知肚明，他不可能打赢。</p><p>相比于 V 的轰轰烈烈，大卫的荒坂塔之旅，结束得既迅速又潦草。早在突围时大卫就开始在疯狂和清醒的边缘游走，越接近公司广场时更是越发难以稳定智识。恍惚中他登上了荒坂塔的顶端，在某种意义上完成了母亲的梦想。随后他冲进大楼，在这里遇到了亚当·重锤，一个他以为并非真实的人物。一个几乎只有大脑是原装的机械怪物。一个全无人性的梦魇。斯安威斯坦对重锤来说不过是初级的植入物，面对他，大卫毫无胜算。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/xrSssQ.jpg"></p><p>在此时的大卫身上我仿佛看到了自己。曾经自命不凡地以为自己是独特的那个，在现实日复一日的捶打下逐渐动摇了信心，开始怀疑自己，最后终于在某一刻发现，自己的“独特”在别人眼里可能只是个笑话。看到重锤，正是让大卫明白，自己的“独特”、“对于义体的天生钝感”，在这种公司培育出来的怪物面前，根本不值一提。</p><p>于是他释然了。就像当初的曼恩那样，大卫也明白了自己的结局。他选择了他能做到的最好的事：给法尔科和露西争取时间，让他们带着钱离开。让露西能够实现去月球的梦想。至于他自己呢？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/3qxDOb.jpg"></p><h3 id="绝望与无力"><a href="#绝望与无力" class="headerlink" title="绝望与无力"></a>绝望与无力</h3><p>从第一集开始大卫因为没有钱所以只能眼睁睁地看着本来有救的母亲去世，到最后站在荒坂大厦的顶端往下纵身一跃，他确实给垄断这个世界的大企业造成了一点小小的麻烦，但是归根结底，他都始终无法像传统的 TRIGGER 主角们那样用自己的意志去决定自己的命运。</p><p>恰巧相反，男主大卫从一开始接受移植手术到最后组装金刚机甲其实都是在接受一种看似自由选择的命运操弄，这种无论如何努力却依旧还是在既有框架体系之中的绝望和无力感，个人认为是对于 TRIGGER 传统的【钻破体系障碍】的逆反，但同时也是对于赛博朋克这一题材的绝佳诠释。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/OlIlVF.jpg"></p><p>在赛博朋克的世界里，一切的传统价值都被解构掉了，就连【相信】这个词也不能够被相信了，只有赤裸裸的能够被量化的金钱、身体机能改造或者成瘾品才能作为生存的意义，以至于大卫实际上只能够为了别人而活，为别人的梦想而活，他自己根本找不到自己为什么要活着的原因。</p><p>赛博朋克这个概念本来也就是作为一种现代化狂飙突进到极点之后的反乌托邦，因此大卫的迷茫其实也有其一定的现实意义。</p><h3 id="梦想与现实"><a href="#梦想与现实" class="headerlink" title="梦想与现实"></a>梦想与现实</h3><p>有批评者认为本作剧情不佳，觉得情节转折推进生硬、大卫行事动机薄弱，觉得露西明明可以和大卫解释清楚，觉得大卫明明可以拆下义体，觉得两个人明明可以靠着攒来的钱远走高飞，又何必走到最后那一步呢？</p><p>可我们别忘了，这里是夜之城，在这里，公司就是不坏的王权。</p><p>哪怕是当年强尼·银手和摩根·黑手把两颗战术核弹塞进了荒坂塔，把它夷为了平地，荒坂也能够在原地重新建造一座更气派的大楼。哪怕是后来无所不能的、最后成了城市之王的V，也不过是杀了几个西海岸的董事会成员、暂时阻止了荒坂三郎借尸还魂，荒坂在日本的根基并没有动摇、何况三郎的意识在别的分部可能也有备份。哪怕是荒坂就此一蹶不振，军用科技、康陶、夜氏集团也会立刻把它的份额瓜分殆尽。一切都不会有任何改变。</p><p>而大卫呢？大卫后来租住的公寓看上去相当豪华，但如果不接任务，他可能会连抑制剂都供养不起，更别提攒钱了；他的团队已经算是圈子里的顶尖队伍，在中间人法拉第眼中也不过是一批耗材；后者还幻想着一步登天进入公司，但在真正的公司人眼中也只是个逐利的小丑。在夜之城，哪怕你混成了来生的传奇，在公司眼里也是随时可以碾碎的蛆虫。大名鼎鼎、天赋异禀的大卫·马丁内斯，甚至都打不过亚当·重锤这条荒坂豢养的看门狗，更遑论撼动公司的一根汗毛。</p><p>在边缘行者们眼中，大卫最终迎来了一个壮烈的牺牲，一个传奇式的结局。</p><p>而在公司眼中，整个事件自始至终也没有惊动任何一个荒坂家族的成员，甚至可能董事会都对此漠不关心。</p><p>只是疯控小队又在公司广场上处决了一个赛博疯子，夜之城普普通通的一天而已。</p><p>对于在这样一个世界里的底层民众来说，只有梦想，只有那一点点对于未来的希望，才能支撑着人活下去。</p><p>人们总是对大卫说，你不要为了别人的梦想而活，但大卫根本不知道该梦想什么。在城市的边缘徘徊了那么久，他早已丧失里梦想的能力，哪怕最后对女主说出，“我的梦想就是完成你的梦想”，也依然没有跳出为别人梦想而活的桎梏。这其实也揭示了他注定的悲剧结局，因为直到最后，他也没有学会该怎样为自己而活。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/k6rWhY.jpg"></p><p>就算是那些有梦想的人，又能梦想到多远的地方呢？母亲的梦想是迎合，是儿子有朝一日能出人头地；曼恩的梦想是苟且，是靠不断变强的身体和同伴的支持走下去；露西的梦想是逃避，是逃往一个能够远离荒坂的触手的地方。而就连这些卑微的梦想，也会被公司一个接一个地毁灭。就算没有遇到车祸，葛洛丽亚的身体也会被不断累积的账单、债务和日夜的操劳压垮；就算任务没有出现差错，曼恩也会因为义体对神经系统的侵蚀而一步一步滑向彻底疯狂的深渊；而如果没有大卫，就算露西特意租了一间可以看到发射场的公寓，那一艘又一艘腾空而起的飞船里，也永远不会有她的身影；就算是现在，露西成功地来到了月球上，她又能躲得过荒坂的清算吗？</p><p>潘多拉因为好奇打开了众神留下的盒子，所有丑恶的东西一齐向人间四散飞去。在最后一刻她终于关上了盒子，留下了希望。有人说这是众神最后的怜悯，就算周围一片黑暗，希望仍存。</p><p>也有人说这是众神最大的恶意，因为每一个希望背后，总有绝望随行。</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>L’enfer est pavé de bonnes intentions. </p>            <i class="fa fa-quote-right"></i>          </blockquote><p>哦，还有爱情，这最后一点慰藉，最后一点美好的东西。</p><p>可夜之城的爱情，也不过是风中的烛火，轻轻一吹，就熄灭了。</p><h3 id="人文主义反思"><a href="#人文主义反思" class="headerlink" title="人文主义反思"></a>人文主义反思</h3><p>对未来的担忧往往会被人们以鲜明而极端的方式所表达出来。比如阿道司·赫胥黎的《美丽新世界》和乔治·奥威尔的《1984》等经典反乌托邦的末日预言，或者赫伯特·乔治·威尔斯的电影《先河》呈现出的未来世界完美或近乎完美的愿景。</p><p>而兴起于20世纪80年代由“控制论”和“朋克”两个概念组合而成的“赛博朋克”，正诞生于社会大变革下人们对未来的担忧的时代。于是，一场基于赛博朋克概念的文学运动逐渐蔓延，其所传达的精神文化通过各种形式的媒体传播，一种包罗万象、不断增长的亚文化随之流行。</p><p>赛博朋克展现了一种信息高度发达的未来人类社会图景，这种社会表面充满和平，内在却充斥着难以控制的阶级矛盾、资源紧缺等弊病。物质文明泛滥并高于精神文明，致使人类精神在高度发达的技术社会难以实现真正自由，从而具有明显的反乌托邦特性和悲观主义色彩。</p><p>从1984至今，科技迅速发展，新技术层出不穷，就在我们的世界随着现实时间的推进而更新的同时，赛博朋克下构建近未来世界的元素也大大增加。</p><p>尽管赛博朋克不是现实生活的完全映射，其狂想的架构更是塑造了许多个陌生的世界，以至于需要一定的接受度和反应时间。但赛博朋克作为一种基于时代环境的自我反思，揭示出了其中反映的数字时代的认知、认知局限与认知方式的转变，也持续地发人深省，供给科技伦理更多善意。</p><h4 id="赛博朋克的诞生"><a href="#赛博朋克的诞生" class="headerlink" title="赛博朋克的诞生"></a>赛博朋克的诞生</h4><p>二十世纪60年代，是一个社会大变革的年代。二战的滚滚硝烟与第三次科技革命的爆发，导致了这个黑暗压抑又有一丝光明前景的时代，未来近在眼前，历史还未走远。</p><p>一方面，曾经自由民主的国家无法抑制失业率上升或通货膨胀，国家干预也无法解决诸如种族主义或个人对意义和秩序的渴望等社会问题。超级大国利用游击队和傀儡政权作为他们争夺世界霸权的筹码。越来越多的经济学家和未来学家开始怀疑，冷战最终不过是日渐式微的西方世界的杂耍表演。</p><p>第三世界的主要国家正在崛起。日本比欧洲和美国更娴熟地玩着资本主义的游戏，中国和东南亚“七虎”在不受西方自由主义影响的情况下开始了自己的致富之路。而西方则无法与他们日益提高的生产效率和越来越多的劳动力相抗衡。</p><p>世界环境也在走向地狱，生物学家雷切尔·卡森早就在《寂静的春天》一书中对使用DDT和其他杀虫剂存在的危害发出了第一次警告，而这仅仅是个开始。事实证明，有毒废物造成的危害比任何人想象的都要多，公众的担忧似乎也无法阻止农药进入空气、土地和水中。</p><p>工厂和城市的有毒排放物不断地进入环境之中，持续的气候变化也迫在眉睫。1979年，世界气象协会（WMA）警告称，全球变冷已经持续了几十年，冰川期很可能即将来临。</p><p>另一方面，20世纪后期，控制论、信息论、计算机/网络、生物遗传工程等飞速地发展。尤其是80年代中期后，虚拟现实技术、人工智能技术，计算机图形学、仿真技术、多媒体技术、人工智能技术、计算机网络技术、并行处理技术和多传感技术的发展，人类生活水平前所未有地提高了。</p><p>现代性许诺了美好的前景和理想，诸如平等、自由和理性。人们在希望和绝望之间摇摆不定。终于，这种矛盾产生了科幻艺术创作的参考设定——赛博朋克。</p><p>事实上，赛博朋克所具备的元素在20世纪初的科幻小说中就可见端倪。在视觉文本出现以前，科幻小说是科幻领域的主要的表现形式。在整个十九世纪中，科幻创作经历了草创期以及从古典到现代的转型，工业革命引发了人类文明史上科技前所未有的大发展，这为作家们提供了用之不竭的创作激情。</p><p>进入二十世纪后，科幻领域开始出现变化，科幻电影、绘画、连环漫画、广播剧以及电视作品先后出现。梅里埃的《月球旅行记》成为了科幻电影的发端，也揭开了小说改编成电影的序幕。</p><p>1982年，世界上第一部赛博朋克电影《电子世界争霸战》在美国上映，《漫长的明天》将科幻小说和黑色电影相融合，《银翼杀手》则展现了一个雨后华丽的未来都市。</p><p>而真正开启了赛博朋克流派的发展则是1984年布鲁斯·贝斯克的《赛博朋克》和威廉·吉布森的《神经漫游者》问世。事实上，无论从哪方面来评价，《赛博朋克》和《神经漫游者》都是赛博朋克流派的权威之作。</p><p>《神经漫游者》的展望中，未来的两部分泾渭分明。一边是肮脏、充满犯罪的物质世界，一边是明亮的网络空间；一边是大街上为了生存抗争的人们，一边是绕地球环行的贵族努力找办法填补他们人为延长的寿命；一边是来自我们世界的老旧残迹——在故事早期，凯斯买了“一把50年前南美版瓦尔特PPK手枪的越南仿制品”——另一边则是能够让人们用新的肢体、眼睛和皮肤来强化身体的尖端科技，只要他们买得起。</p><p>于是，借助流行文化、科幻小说、戏剧和电影，这些基于既定事实又承载着超越想象力的故事，以《神经漫游者》为代表的赛博朋克作品从多个侧面描绘了一个关于未来的模糊信仰。</p><p>它既包含着对技术的依赖和恐惧、对未来浪漫而悲观的想象，又掺杂了身处技术爆炸时期的后人类对世界与自我的颠覆性认知。而这些杂陈的情绪以一种哲学化的方式被植入赛博空间的意象中，使它本身作为一个通信科学发展的产物，承载了更加值得深思的文化隐喻。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/KBIXfd.jpg"></p><h4 id="从浪潮到退潮"><a href="#从浪潮到退潮" class="headerlink" title="从浪潮到退潮"></a>从浪潮到退潮</h4><p>20世纪80年代明确了赛博朋克作为一种风格的界限，一并开启了赛博朋克流派作品的创作。</p><p>同时，在计算机领域突飞猛进的发展下，到了赛博朋克出现的八十年代，信息技术、生物工程、基因技术、网络、黑客等名词逐渐进入公众领域。人机联网，人工智能，虚拟空间等开始在现实生活中逐步实现。而在赛博朋克文学和电影诞生之初，赛博朋克就将这些先进技术与很多现实问题联系在一起。</p><p>其中，帕特·卡蒂甘的《合成人（1991）》构筑了一个由复杂的人机合作所掌控的世界，关注大脑改造技术的心理暗示；鲁迪·鲁克的Ware系列则延续了《神经漫游者》里有自我意识的人工智能这一思路，并得出了逻辑上的结论，即在此基础上产生的机械生命体是如何在其后代中进化的。</p><p>K.W.基特曾以《极度恐怖》而闻名，他推出的《玻璃锤》，则是一部结合了《硬线》风格的寓言故事——诺斯替主义邪教的超速者和走私者以及他们救赎世界的理念误入歧途的图景。</p><p>格雷格·贝尔则在《血音乐》一书中创造了一个复杂的未来，人类会被因基因改而拥有自我意识的细菌所破坏和改造。赛博朋克主题出现在他后来的一些作品中，尤其是以1990年的《天使女王》为开端的系列，书中的故事发生在洛杉矶，在那里纳米技术带来了根本性的变化。</p><p>布鲁斯·斯特林的作品，比如《网络岛》，对黑客这种亚文化开始特别关注。同时，斯特林是赛博朋克舞台上的一个标志，他编辑的《镜影：赛博朋克选集》是一本重要的短故事合集，包括吉布森、卡蒂甘和鲁克的作品。在这本书的前言中，斯特林写道：</p><p>“有些中心主题在赛博朋克中反复出现，比如身体入侵，包括假肢、植入电路、整容手术和基因突变。更重要的主题是心灵入侵：人脑-电脑交互，人工智能，神经化学——这都是从根本上重新定义了人性本质和自我本质的技术。”</p><p>于是，第一波浪潮中的赛博朋客作家继续他们的多元化发展，赛博朋克的思想和意象向四面八方扩散。赛博朋克的成功展示了一种思想在实现实体表达之前所具有的力量。正如乔治·奥威尔在《1984》中的构思已经成为了政治话语的一部分。因此，赛博朋克的存在也同时影响着现实世界中计算机和其他领域的发展。</p><p>然而，这并不意味着赛博朋克的发展就是一帆风顺的。事实上，在赛博朋克小说上发生的事情，同样发生在流行文化任何一个分支里的成功新事物上。布鲁斯·贝斯克说，“它从一个意料之外的、崭新的原创事物变成一股短暂的新潮，一个可重复的商业公式和一种老套的修辞。”</p><p>《神经漫游者》的主题变成了某种清单。疏离的独行者在镜影中做着毒品生意或飞快地入侵电脑，这样的故事很快成为标准内容。然而类似故事太多了，一些90年代最重要的赛博朋克故事，将这种公式推至具有讽刺意味的极端，使得赛博朋克终于在90年代走向了退潮。</p><h4 id="赛博朋克的重新出发"><a href="#赛博朋克的重新出发" class="headerlink" title="赛博朋克的重新出发"></a>赛博朋克的重新出发</h4><p>尽管看起来赛博朋克走向了消逝，但奇异的是，随着千禧年的结束，赛博朋克迎来了它最重要的时刻。它的影响力向外扩展，朝着许多不同方向突变，最终进入了主流文化。</p><p>究其根本，是因为赛博朋克本身的吸引力远不止于表面的皮革、铬合金和霓虹灯。风格显然很重要，但是赛博朋克更为重要的内核是：人们可以通过自我的表达充分说明所处的文化。</p><p>早期的赛博朋克作家们和他们的同龄人担心的很多事情都没有发生。冷战确实结束了，但不是通过核战争的形式。苏联解体了，即时它会因错位的怀旧情绪而复苏，但苏联式的共产主义对任何极端狂热分子来说都不再是未来的潮流。日本十年前陷入的经济困境依然深重，看不到真正复苏的希望。</p><p>上世纪70年代的许多大型企业要么倒闭，要么被其他企业吞并。冰川纪似乎不太可能在短时间内再次降临，人口这颗滴答作响的巨大炸弹正在缓慢而稳步地解除武装。</p><p>当然，新的恐惧总会取代旧的恐惧，全球变暖在许多人的脑海萦绕不去。曾经被认为已经解决的传染病问题又回来了，抗生素的滥用与自然进化相结合，制造出了越来越危险的微生物。</p><p>人们所担心的不再是苏联霸权，而是宗教狂热和恐怖主义。计算机化无时无刻不在给工作和娱乐的新领域带来革命，但也有代价，包括失业、数字鸿沟的扩大。精通技术的人和不具备使用高科技工具进行工作的能力的人之间的鸿沟，以及传统社区形成和维护方式的崩溃，网络互动无法(现在，也许永远)完全取代传统的社区。</p><p>社会构架偏向全球化，各个地域文化通过各种形式交融。人工智能发达，有强大的系统通过各种手段统治着所有人的生活。</p><p>在这样的背景下，赛博朋克再一次迸发出了新生的力量。当下大多数赛博朋克作品，都在二元对立下重新定义了“人”：机器人也可以为自己赋予人格，并成为新本体。《攻壳机动队》中，反抗政府过度化发展科技的群体被政府视为可弃之物，他们游走于城市边缘游行示威，最后却被政府抓走做义体人实验。生物组织通过无数次实验后，第一个真正意义上的义体人素子出现。素子竭力寻找自己的真实身份，自我觉醒让她重获新生。</p><p>《银翼杀手2049》中，复制人K的工作任务是追杀老式型号复制人。影片中，人类作为复制人的创造者，主宰复制人的生与死。</p><p>在游戏方面，《杀出重围》为CDPR创作《赛博朋克2077》奠定了基础。小岛秀夫在十年之前创作了《掠夺者》，也吸取了神经控制论和人工智能等元素，并将之运用在《合金装备》，获得了极大的成功。、</p><p>人类对世界的关注具有周期性。思想和风格会重新流行起来，故事也会不断重复。如果处理得当，旧的观念可以被打磨成新的、引人注目的东西，使人们对最原始的恐惧和希望产生强烈的共鸣。我们生活在赛博空间的临界点上，科学与人文问题和以往一样重要。</p><p>赛博朋克是我们这一代的流派。它是在计算机的体积和成本都非常巨大的时候被构想出来的，并预示了一个由微型处理器和超导体组成的世界。它赋予了黑色主题新的风格和复杂性，预示着对克隆和人类灭绝的恐惧，而这些正是今天社会关注的热点问题。</p><p>或许，这也是赛博朋克经久不衰的原因。赛博朋克作为一种具有思辨精神的基于美学的哲学，带有强烈的悲观主义色彩，却为浸淫在华丽的网络空间中逐渐模糊现实与虚幻的人类提供了一个自我审视的机会，以创造一个反乌托邦的未来世界的方式来警醒人们：任何一种进步都存在弊端，赛博朋克提出的问题都是人类在未来即将遇到且无法回避的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV14/xziLKI.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MV14/FQe8VN.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在贪墨成风的反乌托邦世界中，四处都是生化改造植入体。动画剧聚焦一个在街头长大的鲁莽天才少年努力想成为边缘行者：拿钱办事的法外之徒。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>Bézier Curves</title>
    <link href="https://yousazoe.top/archives/ca6f86db.html"/>
    <id>https://yousazoe.top/archives/ca6f86db.html</id>
    <published>2022-09-17T08:41:32.000Z</published>
    <updated>2023-01-24T07:20:37.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/119998367/Little-voxel-restaurant"><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-pa4/4tCecw.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>GAMES101现代图形学入门是由闫令琪老师教授。本次作业我们会通过 <strong>de Casteljau</strong> 算法来绘制由 4 个控制点表示的 Bézier 曲线。</p><span id="more"></span><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>Bézier 曲线是一种用于计算机图形学的参数曲线。在本次作业中，你需要实现 <strong>de Casteljau</strong> 算法来绘制由 4 个控制点表示的 Bézier 曲线 (当你正确实现该算法时，你可以支持绘制由更多点来控制的 Bézier 曲线)。</p><p>你需要修改的函数在提供的 main.cpp 文件中。</p><ul><li>bezier: 该函数实现绘制 Bézier 曲线的功能。它使用一个控制点序列和一个 <code>OpenCV::Mat</code> 对象作为输入，没有返回值。它会使 <code>t</code> 在 0 到 1 的范围内进行迭代，并在每次迭代中使 <code>t</code> 增加一个微小值。对于每个需要计算的 <code>t</code>，将调用另一个函数 <code>recursive_bezier</code>，然后该函数将返回在 Bézier 曲线上 <code>t</code> 处的点。最后，将返回的点绘制在 <code>OpenCV::Mat</code> 对象上。</li><li>recursive_bezier: 该函数使用一个控制点序列和一个浮点数 <code>t</code> 作为输入， 实现 <strong>de Casteljau</strong> 算法来返回 Bézier 曲线上对应点的坐标。</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>De Casteljau</strong> 算法说明如下:</p><ol><li>考虑一个 p0, p1, … pn 为控制点序列的 Bézier 曲线。首先，将相邻的点连接起来以形成线段。</li><li>用 t : (1 − t) 的比例细分每个线段，并找到该分割点。</li><li>得到的分割点作为新的控制点序列，新序列的长度会减少一。</li><li>如果序列只包含一个点，则返回该点并终止。否则，使用新的控制点序列并转到步骤 1。</li></ol><p>使用 [0,1] 中的多个不同的 t 来执行上述算法，你就能得到相应的 Bézier 曲线。</p><h3 id="开始编写"><a href="#开始编写" class="headerlink" title="开始编写"></a>开始编写</h3><p>在本次作业中，你会在一个新的代码框架上编写，它比以前的代码框架小很多。和之前作业相似的是，你可以选择在自己电脑的系统或者虚拟机上完成作业。 请下载项目的框架代码，并使用以下命令像以前一样构建项目:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></tbody></table></figure><p>之后，你可以通过使用以下命令运行给定代码 <code>./BezierCurve</code>。运行时，程序将打开一个黑色窗口。现在，你可以点击屏幕选择点来控制 Bézier 曲线。程 序将等待你在窗口中选择 4 个控制点，然后它将根据你选择的控制点来自动绘制 Bézier 曲线。代码框架中提供的实现通过使用多项式方程来计算 Bézier 曲线并绘制为红色。两张控制点对应的 Bézier 曲线如下所示:</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-pa4/Vkv71b.png"></p><p>在确保代码框架一切正常后，就可以开始完成你自己的实现了。注释掉 <code>main</code> 函数中 <code>while</code> 循环内调用 <code>naive_bezier</code> 函数的行，并取消对 <code>bezier</code> 函数的注释。要求你的实现将 Bézier 曲线绘制为<strong>绿色</strong>。</p><p>如果要确保实现正确，请同时调用 <code>naive_bezier</code> 和 <code>bezier</code> 函数，如果实现正确，则两者均应写入大致相同的像素，因此该曲线将表现为<strong>黄色</strong>。如果是这样，你可以确保实现正确。</p><p>你也可以尝试修改代码并使用不同数量的控制点，来查看不同的 Bézier 曲线。</p><h3 id="评分与提交"><a href="#评分与提交" class="headerlink" title="评分与提交"></a>评分与提交</h3><p>评分:</p><ul><li>[5 分] 提交的格式正确，包含所有必须的文件。代码可以编译和运行。</li><li>[20 分] De Casteljau 算法:<br>对于给定的控制点，你的代码能够产生正确的 Bézier 曲线。</li><li>[5 分] 奖励分数:<br>实现对 Bézier 曲线的反走样。(对于一个曲线上的点，不只把它对应于一个像素，你需要根据到像素中心的距离来考虑与它相邻的像素的颜色。)</li><li>[-2 分] 惩罚分数:<br>未删除 /build, /.vscode 和 assignment4.pdf。<br>未按格式建立 /images，缺少结果图片。<br>未提交或未按要求完成 README.md。<br>代码相关文件和 README 文件不在你提交的文件夹下的第一层。</li></ul><p>提交:</p><ul><li>当你完成作业后，<strong>请清理你的项目</strong>，记得在你的文件夹中包含 CMakeLists.txt 和所有的程序文件 (无论是否修改);</li><li>同时，请新建一个 /images 目录，将所有实验结果图片保存在该目录下;</li><li>再添加一个 README.md 文件写清楚自己完成了上述得分点中的哪几点 (如果完成了，也请同时在 images 目录下提交一份结果图片并注明)，并简要描述你在各个函数中实现的功能;</li><li>最后，将上述内容打包，并用“姓名 Homework4.zip”的命名方式提交到 SmartChair 平台。<br>平台链接:<a href="http://www.smartchair.org/GAMES101-Spring2021/">http://www.smartchair.org/GAMES101-Spring2021/</a> 。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;cv::Point2f&gt; control_points;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_handler</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span> *userdata)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (event == cv::EVENT_LBUTTONDOWN &amp;&amp; control_points.<span class="built_in">size</span>() &lt; <span class="number">4</span>) </span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Left button of the mouse is clicked - position ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span></span><br><span class="line">        &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        control_points.<span class="built_in">emplace_back</span>(x, y);</span><br><span class="line">    }     </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">naive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_0 = points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_1 = points[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_2 = points[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_3 = points[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> point = std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">3</span>) * p_0 + <span class="number">3</span> * t * std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">2</span>) * p_1 +</span><br><span class="line">                 <span class="number">3</span> * std::<span class="built_in">pow</span>(t, <span class="number">2</span>) * (<span class="number">1</span> - t) * p_2 + std::<span class="built_in">pow</span>(t, <span class="number">3</span>) * p_3;</span><br><span class="line"></span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau's algorithm</span></span><br><span class="line">    <span class="keyword">return</span> cv::<span class="built_in">Point2f</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cv::Mat window = cv::<span class="built_in">Mat</span>(<span class="number">700</span>, <span class="number">700</span>, CV_8UC3, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(window, window, cv::COLOR_BGR2RGB);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">"Bezier Curve"</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">setMouseCallback</span>(<span class="string">"Bezier Curve"</span>, mouse_handler, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (key != <span class="number">27</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;point : control_points) </span><br><span class="line">        {</span><br><span class="line">            cv::<span class="built_in">circle</span>(window, point, <span class="number">3</span>, {<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>}, <span class="number">3</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (control_points.<span class="built_in">size</span>() == <span class="number">4</span>) </span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">naive_bezier</span>(control_points, window);</span><br><span class="line">            <span class="comment">//   bezier(control_points, window);</span></span><br><span class="line"></span><br><span class="line">            cv::<span class="built_in">imshow</span>(<span class="string">"Bezier Curve"</span>, window);</span><br><span class="line">            cv::<span class="built_in">imwrite</span>(<span class="string">"my_bezier_curve.png"</span>, window);</span><br><span class="line">            key = cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">"Bezier Curve"</span>, window);</span><br><span class="line">        key = cv::<span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="De-Casteljau算法"><a href="#De-Casteljau算法" class="headerlink" title="De Casteljau算法"></a>De Casteljau算法</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/GAMES101_Lecture_11_page-0026.jpg"></p><p>$$<br>b^2_0(t) = (1 - t)^2b_0 + 2t(1 - t)b_1 + t^2b_2<br>$$</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/GAMES101_Lecture_11_page-0027.jpg"></p><p><code>bezier()</code> 函数则调用 <code>recursive_bezier()</code> 算法并将线段颜色设置为绿：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t += <span class="number">0.001f</span>) {</span><br><span class="line">        <span class="keyword">auto</span> point = <span class="built_in">recursive_bezier</span>(control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h5><p>由于给定的框架代码有四个控制点，所以我们可以向课程中那样依次推演：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau's algorithm</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> p_0 = control_points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> p_1 = control_points[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> p_2 = control_points[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> p_3 = control_points[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p_01 = (<span class="number">1</span> - t) * p_0 + t * p_1;</span><br><span class="line">    <span class="keyword">auto</span> p_12 = (<span class="number">1</span> - t) * p_1 + t * p_2;</span><br><span class="line">    <span class="keyword">auto</span> p_23 = (<span class="number">1</span> - t) * p_2 + t * p_3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p_012 = (<span class="number">1</span> - t) * p_01 + t * p_12;</span><br><span class="line">    <span class="keyword">auto</span> p_123 = (<span class="number">1</span> - t) * p_12 + t * p_23;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cv::<span class="built_in">Point2f</span>((<span class="number">1</span> - t) * p_012 + t * p_123);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h5><p>另一种递归方式则采用分而治之的策略，将问题不断分化：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau's algorithm</span></span><br><span class="line">    <span class="keyword">if</span> (control_points.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> control_points[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::Point2f&gt; lines;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; control_points.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        lines.<span class="built_in">emplace_back</span>((<span class="number">1</span> - t) * control_points[i] + t * control_points[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recursive_bezier</span>(lines, t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://games-cn.org/forums/topic/%E4%BD%9C%E4%B8%9A%E5%9B%9B%E5%BE%97%E5%88%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E8%A6%81%E6%B1%82%EF%BC%9F/">作业四得到这样的结果是否满足要求？</a></li><li><a href="https://zhuanlan.zhihu.com/p/344934774">从零开始学图形学：10分钟看懂贝塞尔曲线</a></li><li><a href="https://blog.csdn.net/qq_41835314/article/details/124882791">GAMES101作业4-贝塞尔曲线&amp;OpenCV图像处理</a></li><li><a href="https://blog.csdn.net/ycrsw/article/details/124117190">【GAMES101】作业4（提高）含Bazier曲线的反走样处理</a></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/119998367/Little-voxel-restaurant&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GAMES101-pa4/4tCecw.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;GAMES101现代图形学入门是由闫令琪老师教授。本次作业我们会通过 &lt;strong&gt;de Casteljau&lt;/strong&gt; 算法来绘制由 4 个控制点表示的 Bézier 曲线。&lt;/p&gt;</summary>
    
    
    
    <category term="现代图形学入门 (GAMES101-Introduction to Computer Graphics)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-GAMES101-Introduction-to-Computer-Graphics/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>STL&amp;基础数据结构</title>
    <link href="https://yousazoe.top/archives/558bb9a.html"/>
    <id>https://yousazoe.top/archives/558bb9a.html</id>
    <published>2022-09-15T12:31:48.000Z</published>
    <updated>2023-01-24T07:20:37.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/122046889/The-Traveler?tracking_source=project_owner_other_projects"><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/Hk2SRw.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>简单介绍 Vector 向量、List 链表、Queue 队列、Stack 栈、Priority_Queue 优先队列的原 理，以及 C++ STL 中这些数据结构的使用，以及笔试和面试的一些应用场景。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=514053762&amp;bvid=BV1Rg41117YB&amp;cid=791539408&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h3><h4 id="STL容器简介"><a href="#STL容器简介" class="headerlink" title="STL容器简介"></a>STL容器简介</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(5).PNG"></p><ul><li><p>容器(Containers)是用于保存一系列对象的对象。</p></li><li><p>例如，std::vector<int>, std::list<a href="std::string">std::string</a>, std::queue&lt;std::vector<double>&gt;;*</double></int></p></li><li><p>分类:</p><ul><li>Sequence container</li><li>Associative container</li><li>另外还有 Container adaptor 和 Almost container<br></li></ul></li><li><p>你也可以设计自己的容器，只要它满足通用的标准和接又</p></li></ul><blockquote><p>*注:在使用 C++98 标准编译时，需要在两个 &gt; 中间添加空格。</p></blockquote><h4 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(6).PNG"></p><ul><li>对指针的抽象。</li><li>因此需要重载 * 运算符。</li><li>指针的运算是基于使用连续的内存空间，但是对于一些容器来说并非如此。</li><li>基于能够进行的运算类型，迭代器可以分为下列几类:<ul><li>所有的迭代器都支持解引用运算符(*)和自增运算符(++)</li><li>Input iterator 在此基础上支持 ==, !=, 单次读取，-&gt;; Output Iterator 仅支持单次写入(课后:查阅 I/O 库相关内容，了解它们的使用场景)</li><li>Forward iterator 在 Input iterator 基础上支持重复访问及读写</li><li>Bidirectional iterator 在 Forward iterator 基础上支持自减运算符(–)</li><li>Random-access iterator 在 Bidirectional iterator 基础上支持 [], +, +=, −, −=, &lt;, &lt;=, &gt;, &gt;= 运算符(和普通指针功能相同)<br></li></ul></li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(7).PNG"></p><p>为了保证通用性，标准库中还提供了一些库函数</p><ul><li>#include <iterator></iterator></li><li>std::advance(iter, n) 迭代器 iter 自增 n 次</li><li>std::distance(iter1, iter2) 返回迭代器 iter1 和 iter2 间的距离</li><li>std::next(iter, n=1), std::prev(iter, n=1) 返回 “iter + n” 或 “iter – n” 对应的迭代器(c++11)</li><li>注意如果不是 Random-access iterator ，这些方法的复杂度可能是线性的，或者行为未定义，或者无法通过编 译。<br></li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(8).PNG"></p><p>容器的 begin() 和 end() 方法可以获得首尾迭代器</p><ul><li>for (auto it = c.begin(); it != c.end(); ++it)</li><li>for (auto &amp; x: c)</li><li>迭代器的类型为 ContainerType::iterator</li></ul><p>另外 cbegin() 和 cend() 方法可以返回首尾的常量迭代器(类似于常量指针)</p><ul><li>for (auto it = c.cbegin(); it != c.cend(); ++it)</li><li>for (const auto &amp;x: c)</li><li>迭代器的类型为 ContainerType::const_iterator</li></ul><p>课后:查询反向迭代器的相关资料，解释 rbegin(), rend(); crbegin(), crend() 的用法。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(9).PNG"></p><p>C++ 标准在设计的过程中，就有意地让这些标准容器共享接又，从而发挥模板多态的特性。</p><p>例如，常见的构造函数:</p><ul><li>ContainerType c(num)</li><li>ContainerType c(num, x)</li><li>ContainerType c(beg, end)</li></ul><p>容量相关的方法:</p><ul><li>int s = c.size(); bool b = c.empty();</li><li>c.resize(num); c.resize(num, x);</li><li>c.clear();</li></ul><blockquote><p>Reference: Bjarne Stroustrup. The C++ Programming Language, 4th edition. §31.3</p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(11).PNG"></p><h4 id="std-stack-lt-T-Container-gt"><a href="#std-stack-lt-T-Container-gt" class="headerlink" title="std::stack<T, Container>"></a>std::stack&lt;T, Container&gt;</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(12).PNG"></p><ul><li>属于 Container Adapter，需要基于某个 Sequence container</li><li>不能使用迭代器访问</li><li>push(x)</li><li>pop()</li><li>top()</li><li>课后:了解 initializer_list，理解 emplace() 方法的使用。</li></ul><h4 id="如何实现一个栈"><a href="#如何实现一个栈" class="headerlink" title="如何实现一个栈?"></a>如何实现一个栈?</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(13).PNG"></p><ul><li>方便起见，假设数据的总量为 N，数据类型为 int.</li><li>int stack[N], top; 数据存放在 [0, top) 区间内。</li></ul><p>一些基本操作:</p><ul><li>push: stack[top++] = x;</li><li>pop: int y = stack[–top];</li><li>size: return top;</li><li>empty: return top == 0;</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(14).PNG"></p><h4 id="Catalan数"><a href="#Catalan数" class="headerlink" title="Catalan数"></a>Catalan数</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(15).PNG"></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(17).PNG"></p><h4 id="如何实现一个队列"><a href="#如何实现一个队列" class="headerlink" title="如何实现一个队列"></a>如何实现一个队列</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(18).PNG"></p><p>int queue[N], head, tail; 其中元素存放在 [head, tail) 区间。</p><p>基本操作</p><ul><li>push: queue[tail++] = x;</li><li>pop: int y = queue[head++];</li><li>size: return tail – head;</li><li>empty: return head == tail;</li></ul><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(19).PNG"></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(20).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) { </span><br><span class="line">    <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())</span><br><span class="line">        stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>()), stack1.<span class="built_in">pop</span>(); }</span><br><span class="line">    <span class="keyword">return</span> stack2.<span class="built_in">top</span>();</span><br></pre></td></tr></tbody></table></figure><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(22).PNG"></p><ul><li>之前我们假设了数据量是已知的，那么当我们的数据量未知时?</li><li>不定长数组<ul><li>#include <vector> std::vector<t></t></vector></li><li>Sequence Container</li><li>Random-access iterator</li><li>随机访问: operator [], at(x), front(), back()</li><li>insert(iter, x), push_back(x)</li><li>erase(iter), pop_back()</li></ul></li></ul><h4 id="如何实现一个向量？"><a href="#如何实现一个向量？" class="headerlink" title="如何实现一个向量？"></a>如何实现一个向量？</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(23).PNG"></p><h4 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(24).PNG"></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(25).PNG"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(26).PNG"></p><h4 id="列表与链表"><a href="#列表与链表" class="headerlink" title="列表与链表"></a>列表与链表</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(27).PNG"></p><ul><li>另外一种实现动态性的方式是不采用数组，而是每增加一个元素，新开辟一块空间</li><li>但是我们依然需要保存一些额外信息来保存它们之间的顺序关系——指针!</li><li>这种链状的数据结构称为链表(linked list)。</li><li>例子:火车车厢</li><li>#include <list> std::list<t><ul><li>Sequence container, Bidirectional iterator</li><li>front(), back()</li><li>insert(iter, x), push_back(x), push_front(x),</li><li>erase(iter), pop_back(), pop_front()</li></ul></t></list></li></ul><h4 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a>链表的结构</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(28).PNG"></p><h4 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="哨兵节点"></a>哨兵节点</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(29).PNG"></p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(30).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node* pos, <span class="type">int</span> value)</span> </span>{</span><br><span class="line">    Node* n = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">    n-&gt;next = pos-&gt;next;</span><br><span class="line">    pos-&gt;next = n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(31).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node *pos, <span class="type">int</span> value)</span> </span>{ </span><br><span class="line">    Node *n = <span class="keyword">new</span> <span class="built_in">Node</span>(value); </span><br><span class="line">    n-&gt;next = pos-&gt;next;</span><br><span class="line">    n-&gt;prev = pos;</span><br><span class="line">    pos-&gt;next-&gt;prev = n; </span><br><span class="line">    pos-&gt;next = n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(32).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(Node *pos)</span> </span>{ </span><br><span class="line">    pos-&gt;prev-&gt;next = pos-&gt;next;</span><br><span class="line">    pos-&gt;next-&gt;prev = pos-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> pos;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(33).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase2</span><span class="params">(Node *pos)</span> </span>{</span><br><span class="line">    Node *tmp = pos-&gt;next;</span><br><span class="line">    pos-&gt;next = pos-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(34).PNG"></p><ul><li>for (Node* x = head-&gt;next; x != tail; x = x-&gt;next);</li><li>对比迭代器的 begin() 和 end()</li><li>“下标”访问?</li><li>单向链表查询上一个元素?</li><li>size()?</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(35).PNG"></p><h5 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(36).PNG"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(37).PNG"></p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(39).PNG"></p><h4 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a>std::priority_queue</h4><ul><li>Container Adaptor, 无迭代器</li><li>push(x), pop(), top()</li><li>std:priority_queue&lt;T, Container=std::vector<t>, Compare=std::less<t>&gt;<ul><li>the Compare parameter is defined such that it returns true if its first argument comes before its second argument in a weak ordering. But because the priority queue outputs largest elements first, the elements that “come before” are actually output last</li><li>需要定义小于号</li><li>std::greater<t> (需要定义大于号)</t></li></ul></t></t></li></ul><blockquote><p>Reference: std::priority_queue - cppreference.com</p></blockquote><h4 id="如何实现优先级队列-选讲"><a href="#如何实现优先级队列-选讲" class="headerlink" title="如何实现优先级队列?(选讲)"></a>如何实现优先级队列?(选讲)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(41).PNG"></p><ul><li>多种实现方式，最简单的一种——二叉堆</li><li>堆:满足父亲结点优先级不小于孩子结点的二叉树</li><li>为了方便实现，可以采用完全二叉树</li><li>向上调整过程 up, push()</li><li>向下调整过程 down, pop()</li></ul><h3 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h3><h4 id="单调栈-单调队列"><a href="#单调栈-单调队列" class="headerlink" title="单调栈 单调队列"></a>单调栈 单调队列</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(44).PNG"></p><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(45).PNG"></p><ul><li>为了简化问题，假设我们只有 + - * / () 这几种运算</li><li>观察:1+2<em>3 和 1</em>2+3。我们什么时候可以确定计算顺序?</li><li>第一个等式需要到最末尾，第二个等式在扫描到 + 的时候就发现可以计算前面的内容</li><li>无法判断的式子优先级大小递增</li><li>类似单调队列的单调栈。同时需要维护没有计算的数</li><li>括号?将括号也纳入优先级比较的范围，或者每遇到一层括号，括号内优先级增加一档</li></ul><h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA2/STL%20(46).PNG"></p><ul><li>(问题的最后一步)有一个长度为 n 的序列，进行 n – 1 次操作，每次将值最小的两个元素取出，再将它们的和放回序列。求每步操作取出的两个数是多少</li><li>对比优先队列的定义和接口</li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/122046889/The-Traveler?tracking_source=project_owner_other_projects&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/THUAA2/Hk2SRw.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;简单介绍 Vector 向量、List 链表、Queue 队列、Stack 栈、Priority_Queue 优先队列的原 理，以及 C++ STL 中这些数据结构的使用，以及笔试和面试的一些应用场景。&lt;/p&gt;</summary>
    
    
    
    <category term="清华大学算法协会 (Tsinghua University Algorithm Association)" scheme="https://yousazoe.top/categories/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E5%8D%8F%E4%BC%9A-Tsinghua-University-Algorithm-Association/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++梳理</title>
    <link href="https://yousazoe.top/archives/74ba873d.html"/>
    <id>https://yousazoe.top/archives/74ba873d.html</id>
    <published>2022-09-12T12:09:10.000Z</published>
    <updated>2023-01-24T07:20:37.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/132894291/The-Lovers?tracking_source=search_projects%7Clow%20poly"><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/AhZ5WD.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这一节课面向已经有一些 C++ 基础的同学(一个快速判断标准:是否知道构造函数和析构函数是什么，并自己写过构造函数和析构函数)， 复习串讲一些 OOP 中的知识点，以及介绍一些有趣的在面试中或者在写程序时用得到的 C++ 知识。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=386482748&amp;bvid=BV15d4y1U7HH&amp;cid=787484737&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="关于算协"><a href="#关于算协" class="headerlink" title="关于算协"></a>关于算协</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(3).PNG"></p><ul><li><p>2016年：清华大学计算机系学生算法与竞赛协会 </p><ul><li>举办过的活动：清华校赛（THUPC）</li></ul></li><li><p>2022年：清华大学学生算法协会</p><ul><li>成为校级社团 希望开展更广泛的活动</li></ul></li></ul><p>暑期培训：拓展业务的尝试，希望你在奋斗的路上少一些孤单。</p><ul><li>初衷：帮助大三升大四的同学复习编程和算法知识 </li><li>形式：多次相对独立的授课，提供回放 </li><li>建议：分析自身需求，有选择性地听课和完成作业</li></ul><h3 id="授课定位"><a href="#授课定位" class="headerlink" title="授课定位"></a>授课定位</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(7).PNG"></p><ul><li>C++ 相当庞大 不仅语言名字的字符数是 C 语言的三倍 标准的长度也相当于C语言的三倍多。</li><li>C++20 标准页数 1853 页 </li><li><a href="https://www.iso.org/standard/79358.html">ISO - ISO/IEC 14882:2020 - Programming languages — C++</a> </li><li>C11 标准页数 520 页 </li><li><a href="https://www.iso.org/standard/74528.html">ISO - ISO/IEC 9899:2018 - Information technology — Programming languages — C</a> </li><li>段子：21 天才能精通 C++ </li><li>本次课理想受众：至少上过一门 C++ 的课程/读过一本 C++ 的入门书籍</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(8).PNG"></p><ul><li>尝试带大家梳理一些语言特性，帮助大家“融会贯通” </li><li>最终希望大家能够尝试自己梳理更多的 C++ 语言特性、或用同样的思路学习其他语言。 </li><li>第一次做这种尝试，请大家在课后问卷中多多反馈</li><li>You can’t just look at C++ as a collection of features; some features make no sense in isolation. You can only use the sum of the parts if you are thinking about design, not simply coding. And to understand C++ this way, you must understand the problems with C and with programming in general.</li><li>– Bruce Eckel，Thinking in C++ </li><li>The C++ Programming Language 里，大量的交叉引用反映了语言特性之间的互动和联系</li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(10).PNG"></p><h4 id="内存是什么？"><a href="#内存是什么？" class="headerlink" title="内存是什么？"></a>内存是什么？</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(11).PNG"></p><ul><li>我们可以认为，程序处理的数据存储在内存（RAM）（忽略缓存和硬盘的使用）</li><li>现在常用的内存条，包含若干内存颗粒(半导体集成电路)</li><li>物理上，通过一些微小的元器件来表示 “0” “1” 状态</li><li>能存储的比特数取决于集成电路里的元器件数目</li><li>可以想象成一条非常非常长的纸带 每个格子可以填写 0-255 的一个状态（8 个 0/1 比特，一个字节）</li><li>例如 16G 的内存，一共能填写 16x1024x1024x1024 个字节</li><li>然后这根纸带卷啊卷，卷到了一根内存条这么大</li><li>这就是操作系统所拥有的内存资源，操作系统会将内存分配给正在执行的程序</li></ul><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(12).PNG"></p><ul><li>（分配内存的细节，和编译器、操作系统、运行时环境等等有关，具体细节需具体学习）</li><li>计算机上有多个程序同时运行，操作系统也预留了一部分内存，而内存是有限的</li><li>因此程序只能在操作系统分配给它的范围内使用内存</li><li>操作系统一开始就分配给程序一些内存，用来存储全局变量、局部变量、函数参数返回值、程序代码等数据。其中，全局变量、程序代码分配在static内存区域（从程序开始执行到结束，这些内存都被占用）。局部变量、函数参数返回值等，被分配在栈内存区域（函数调用栈）</li><li>函数每一次被调用时，在函数调用栈中分配一个大小合适的栈帧，存储这一次的局部变量、参数和返回值。从函数中返回时，释放栈帧的内存。（操作系统角度，整个函数调用栈还是在程序那里）</li><li>递归过深程序崩溃，是因为大量的栈帧未释放，占满了函数调用栈的内存。(stack overflow)</li><li>另外，程序在运行时，可以向操作系统动态地申请和释放一些内存（堆内存）</li></ul><h4 id="变量-x2F-指针-x2F-引用"><a href="#变量-x2F-指针-x2F-引用" class="headerlink" title="变量/指针/引用"></a>变量/指针/引用</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(13).PNG"></p><ul><li>变量：一块具有类型的内存（类型：数据的存储表示方式以及你可以对它进行的操作）</li><li>指针：一块内存的地址，指针的类型可能说明这个指针指向特定类型的变量。（void*）</li><li>引用：可以理解为指针的一种“语法糖”（左值引用/右值引用）</li><li>数组：内存中连续排列的多个同类型变量。数组名称可以用作指向第一个元素的指针</li><li>自定义的类型 (class/struct):一组成员变量在内存里的排列方式以及可以对它进行的操作</li><li>一个对象：按照特定排列方式存储在内存里的一组成员变量<br>+（课后练习：查阅资料，复习/学习 struct 中各个成员变量的 layout 规则）</li></ul><h4 id="一些类的示例"><a href="#一些类的示例" class="headerlink" title="一些类的示例"></a>一些类的示例</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(14).PNG"></p><p><code>Model2</code> 中一目了然的设计缺陷：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Triangle</span> {</span><br><span class="line">    Point A;</span><br><span class="line">    Point B;</span><br><span class="line">    Point C;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Model</span> {</span><br><span class="line">    Triangle many_triangles[<span class="number">100</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Model2</span> {</span><br><span class="line">    Triangle* triangles;</span><br><span class="line">    <span class="built_in">Model2</span>(<span class="type">int</span> n) {</span><br><span class="line">        triangles = <span class="keyword">new</span> Triangle[n];</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Model2</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] triangles;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Model3</span> {</span><br><span class="line">    std::vector&lt;Triangle&gt; triangles;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>Model2</code> 需要加一个成员变量表示拥有多少个三角形面片。</p><h4 id="构造函数-x2F-析构函数，new-x2F-delete"><a href="#构造函数-x2F-析构函数，new-x2F-delete" class="headerlink" title="构造函数/析构函数，new/delete"></a>构造函数/析构函数，new/delete</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(15).PNG"></p><ul><li>C++ 中两个运算符替代了C语言的 malloc/dealloc 库函数</li><li>通过 new/delete 动态分配或释放一个对象时会发生:</li><li>new：分配内存，然后调用对应的构造函数(递归调用各个成员变量的构造函数)</li><li>delete：调用对应的析构函数，然后释放内存</li></ul><p>动态内存管理的两种风格(不代表只有这两种风格）</p><ol><li>RAII （C++ 语言中可通过恰当实现构造/析构函数、恰当调用 new/delete 实现）</li><li>垃圾回收（C++ 语言中可通过智能指针实现）</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(16).PNG"></p><ul><li>将动态分配的资源的生命周期绑定到某个局部变量上，随着作用域的创建和消失完成分配和释放。</li><li>当希望创建一个动态数组时，不是在主函数里直接 new/delete</li><li>而是使用一个“包含动态数组的类”，作为局部变量定义，构造函数里 new，析构函数里 delete。</li><li>阅读 The C++ programming language 13.3 Resource Managerment，RAII 和异常处理。</li></ul><h4 id="智能指针-amp-垃圾回收"><a href="#智能指针-amp-垃圾回收" class="headerlink" title="智能指针&amp;垃圾回收"></a>智能指针&amp;垃圾回收</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(17).PNG"></p><p>如果计算机能够更加智能，意识到某块动态分配的内存目前没有任何一个活跃的指针会用到，就自动回收这一块内存，会怎么样？</p><p>这里介绍两种垃圾回收思路（并不止两种）：</p><ol><li>引用计数（C++ 中可以用智能指针实现，weak_ptr, shared_ptr, unique_ptr)<br>记录一下当前有多少个活跃的指针指向一块动态分配的内存 当这个计数变为 0 时，释放这块内存。</li><li>Mark &amp; sweep （最早的垃圾回收方法，在Lisp中被使用）<br>每隔一段时间 标记所有从当前程序执行到的位置出发，能够访问到的变量<br>然后将所有未标记的变量释放</li></ol><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(18).PNG"></p><p>时间所限，这里不细讲智能指针的具体语法。</p><p>有空可以看一下 “leak freedom in C++… by default by Herb Sutter”，CppCon的演讲</p><p>思考：</p><ul><li>引用计数和 Mark&amp;Sweep 带来的额外开销有什么区别？注重实时性的系统能否用垃圾回收？</li><li>C++ 中的智能指针常常会重载哪个运算符？(-&gt; 和 *)</li><li>尝试用智能指针实现一个双向链表，要求做到首尾节点释放后，中间的所有节点自动释放</li><li>使用 STL 的容器可以大大方便 C++ 中的一些内存管理，非必要不造轮子</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(19).PNG"></p><h4 id="减少函数调用：内联函数-vs-预处理宏"><a href="#减少函数调用：内联函数-vs-预处理宏" class="headerlink" title="减少函数调用：内联函数 vs 预处理宏"></a>减少函数调用：内联函数 vs 预处理宏</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(20).PNG"></p><ul><li><p>调用函数时，处理传参/返回值/栈帧的产生和销毁，会带来一定的开销。</p></li><li><p>对于简单的函数，将调用函数改为直接嵌入一段代码，可以节约一些计算开销。</p></li><li><p>C 语言：采用宏定义， #define min(a, b) ((a&lt;b)?a:b)</p></li><li><p>C++：使用 inline 关键字建议编译器进行内联（但并不代表编译器一定会这么做）</p></li><li><p>C++ 中，建议非必要不使用宏，如果一定要用，起一堆大写字母的丑陋名字</p><br></li><li><p>课后：查询如何用 C++11 中引入的 constexpr 关键字标识函数</p></li></ul><h4 id="传值-x2F-传引用"><a href="#传值-x2F-传引用" class="headerlink" title="传值/传引用"></a>传值/传引用</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(21).PNG"></p><p>定义函数</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(Type x){</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>函数 g 内有 Type 类型的局部变量 b，并调用了 f(b)</li><li>在函数 f 内修改 x，会不会导致 f 返回后，函数 g 中 b 的数值发生对应的改变？（传值/传引用）</li><li>f(int x), f(int &amp;x), f(int *x), f(int x[]), f(int &amp;&amp;x)</li></ul><p>思考题：举出一种实际应用情况，我们选择让函数返回一个引用（提示：从The C++ programming language 7.7.1 page 192中查找答案）</p><h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(22).PNG"></p><p>拷贝有两种情况可能发生：</p><ul><li>拷贝构造函数</li><li>重载赋值符号(A = B）<br></li><li>当一个类中包含动态分配的资源时，浅拷贝将不会分配第二份资源，使得拷贝后的对象和之前的对象指向相同的一份资源（如数组）。这很多时候是一个 bug，或者可以用 CoW/Move 来替代</li><li>默认的拷贝行为对所有成员函数逐个拷贝</li><li>合理的拷贝行为应当满足：等价性，独立性</li></ul><h4 id="拷贝-x2F-移动"><a href="#拷贝-x2F-移动" class="headerlink" title="拷贝/移动"></a>拷贝/移动</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(23).PNG"></p><p>有时并不需要进行拷贝，因为完成拷贝之后，旧的元素失去了使用的价值。</p><p>例如常见的交换函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type a, Type b)</span></span>{</span><br><span class="line">    Type tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以通过 move 来避免不必要的拷贝。（右值引用表示一个可以被销毁的临时值）</p><h4 id="swap函数"><a href="#swap函数" class="headerlink" title="swap函数"></a>swap函数</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(24).PNG"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type&amp; A, Type&amp; B)</span> </span>{</span><br><span class="line">    T tmp = std::<span class="built_in">move</span>(a);</span><br><span class="line">    a = std::<span class="built_in">move</span>(b);</span><br><span class="line">    b = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(25).PNG"></p><ul><li>通过函数指针，实现“以函数为参数”的函数, 或者说，传入一个“谓词”(predicate)</li><li>实质上是函数的代码所在的地址<br></li><li>例如可以定义遍历函数 iterate(数组A，函数B)，对数组中每个元素执行函数B (如都翻倍)</li><li>另一个常见例子：给排序函数传入一个比较函数的函数指针作为参数</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>{ <span class="keyword">return</span> <span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b); }</span><br><span class="line">std::<span class="built_in">sort</span>(array_A, array_A+n, cmp_func);</span><br></pre></td></tr></tbody></table></figure><ul><li>另一个用途: 设置回调函数, “发生某事件时调用该函数”</li></ul><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(26).PNG"></p><ul><li>函数对象是重载了函数调用运算符()的对象</li><li>在 C++ 中，应当倾向于使用函数对象 /lambda 表达式而非函数指针</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> a &lt; b; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(27).PNG"></p><ul><li>C++11 标准中引入的匿名函数，用于方便地定义一个匿名的函数对象</li><li>可以在 lambda 中“捕获”当前作用域的变量，定义参数列表，也可以有返回值</li><li>也可以将 lambda 表达式赋值给一个变量</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = (<span class="type">const</span> <span class="type">int</span> &amp;x, <span class="type">const</span> <span class="type">int</span> &amp;y){<span class="keyword">return</span> x&lt;y;}; <span class="comment">//这里没有捕获列表。</span></span><br></pre></td></tr></tbody></table></figure><br>+ 尝试分别用函数指针/函数对象/lambda表达式结合 std::sort( ) 写一个“按照绝对值排序整数的程序”+ 查阅文档：如何表示“捕获”一个变量时，捕获它的值/引用？<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(28).PNG"></p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(29).PNG"></p><ul><li>两类典型的继承：“实现继承”/ “接口继承”</li><li>如果没有继承语法，我们如何表示继承关系？</li><li>可以将基类作为子类的一个成员</li><li>如果一开始理解继承机制的时候有困难，可以认为基类就是子类的一种特殊成员变量</li><li>public/private 控制外部对成员变量的访问权限</li><li>通过 protected，特殊控制子类对基类的访问权限</li></ul><p>列个表：</p><ul><li>public/private/protected 继承，子类分别能否访问基类的public/private/protected成员变量？</li></ul><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(30).PNG"></p><ul><li>在成员函数前标注 virtual，允许子类重新实现这个函数，编译器和运行时环境通过虚表，保证调用正确版本的函数</li><li>纯虚函数要求子类必须重新实现这个函数</li><li>虚表可以认为是子类隐藏的一个成员数组，数组中标注每个虚函数具体指向哪一个实现版本（通常是继承关系上，“最近”的一个类所实现的版本，例如如果这个子类自身有实现，就调用自身实现的版本）（虚表中可能会保存指向一些函数实现的函数指针）</li><li>查阅文档: 用 final 或 override 关键字标注一个虚函数，分别会对子类提出什么样的要求？</li></ul><h4 id="运行时多态-runtime-polymorphism"><a href="#运行时多态-runtime-polymorphism" class="headerlink" title="运行时多态(runtime polymorphism)"></a>运行时多态(runtime polymorphism)</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(31).PNG"></p><ul><li>多态: 通过继承和虚函数，可以实现这样的行为: 某个变量的类型为基类的指针，它可以指向某个子类的对象，并正确调用子类对虚函数的具体实现。</li><li>（也可以通过引用来实现多态行为）</li><li>如果不用指针/引用而直接使用一个对象，可能会导致意外的切片(slicing), 从子类转换为基类，丢失了子类的数据。<br></li><li>尝试写一个会导致切片行为的简单程序</li><li>不同语言会用不同的方式来实现多态。查询文档：Java 中如何用 interface 实现多态？(rust 如何用 trait 实现多态？）</li></ul><h4 id="多态的应用：Visitor-pattern"><a href="#多态的应用：Visitor-pattern" class="headerlink" title="多态的应用：Visitor pattern"></a>多态的应用：Visitor pattern</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(32).PNG"></p><ul><li>这是一种在编译器中应用广泛的设计模式</li><li>在编译器中，常常需要多次遍历一个语法树的所有结点，第一轮遍历的时候进行符号收集，第二轮遍历的时候进行代码生成……</li><li>不同类型的节点有着不同的内部结构，但都对外提供构造函数、visit() 等接口</li><li>Visit() 可以接收一个函数对象作为参数，表示对节点进行的操作</li><li>这个函数对象我们称为 visitor，语法树节点的 visit() 接口接收一个基类 visitor 的函数对象作为参数</li><li>实际调用时，传入一个具体的继承 visitor（的指针/引用），对语法树中的节点进行遍历</li><li>如果大家去做一些编译原理课程的作业，看一下实验框架(通常是 toy compiler），或者看一些用 C++ 实现的开源编译器，常常会找到类似的结构。</li></ul><h4 id="模板的简介"><a href="#模板的简介" class="headerlink" title="模板的简介"></a>模板的简介</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/THUAA1/CPPOOP%20(33).PNG"></p><ul><li>函数：对于两段只有参数数值不同的代码，不用重复编写</li><li>模板：对于两个只有参数类型不同的函数，不用重复编写，编译器自动生成程序中用到的不同类型的函数。模板较多的代码往往编译起来非常慢<br></li><li>C++ 的 STL 容器中大量使用了模板，如我们可以定义保存任意类型的 std::vector，定义任意两个类型组成的 std::pair</li><li>可以通过模板来实现一些编译期计算(有个名词叫做“模板元编程”）</li></ul><h4 id="为什么模板类的函数声明和定义要放在一起？"><a href="#为什么模板类的函数声明和定义要放在一起？" class="headerlink" title="为什么模板类的函数声明和定义要放在一起？"></a>为什么模板类的函数声明和定义要放在一起？</h4><p>考虑模板代码生成的过程：</p><ul><li>从编译器的角度，模板函数本身并不是一个能直接拿来链接的函数，而是需要用它来生成一些其他的函数</li><li>将函数声明和定义拆开编写，其实是在链接阶段再去处理函数名称和函数实现的绑定</li><li>链接器通常没有办法在链接阶段再去处理模板参数的替换</li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/132894291/The-Lovers?tracking_source=search_projects%7Clow%20poly&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/THUAA1/AhZ5WD.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这一节课面向已经有一些 C++ 基础的同学(一个快速判断标准:是否知道构造函数和析构函数是什么，并自己写过构造函数和析构函数)， 复习串讲一些 OOP 中的知识点，以及介绍一些有趣的在面试中或者在写程序时用得到的 C++ 知识。&lt;/p&gt;</summary>
    
    
    
    <category term="清华大学算法协会 (Tsinghua University Algorithm Association)" scheme="https://yousazoe.top/categories/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95%E5%8D%8F%E4%BC%9A-Tsinghua-University-Algorithm-Association/"/>
    
    
    <category term="Cpp" scheme="https://yousazoe.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA Special Address at SIGGRAPH 2022</title>
    <link href="https://yousazoe.top/archives/5bc35f45.html"/>
    <id>https://yousazoe.top/archives/5bc35f45.html</id>
    <published>2022-09-07T08:27:19.000Z</published>
    <updated>2023-01-24T07:20:37.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><iframe src="//player.bilibili.com/player.html?aid=942855653&amp;bvid=BV1JW4y1B7iG&amp;cid=825831229&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机图像学 (Foundations of Computer Graphics)" scheme="https://yousazoe.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%83%8F%E5%AD%A6-Foundations-of-Computer-Graphics/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
    <category term="SIGGRAPH" scheme="https://yousazoe.top/tags/SIGGRAPH/"/>
    
  </entry>
  
  <entry>
    <title>把命运交还给时间和土地--电影《隐入尘烟》观后感</title>
    <link href="https://yousazoe.top/archives/7d09866f.html"/>
    <id>https://yousazoe.top/archives/7d09866f.html</id>
    <published>2022-09-01T11:45:59.000Z</published>
    <updated>2023-01-24T07:20:37.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/0eQBU8.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>影片讲述西北农村，两个被各自家庭抛弃的孤独个体，在日复一日的耕耘中相濡以沫的故事，武仁林与海清展现了一对底层农民夫妇从陌生到熟悉，从相知到相守的心路历程。</p><span id="more"></span><h3 id="作者自述"><a href="#作者自述" class="headerlink" title="作者自述"></a>作者自述</h3><p>我一直认为我做的工作就是在日常中提炼电影，然后在电影中去还原日常的工作。写作剧本、拍摄电影的过程就是发现生活，呈现生活和总结生活的过程，如何感知和捕捉日常中微妙诗意瞬间使之变成永恒的过程。2020年2月份，我陪海清老师随着电影的男主演去地里干活体验生活，我在田埂边的树桩修改剧本，看到眼前躺在田埂上休息的海清老师和在远处播撒种子的农人，瞬间让我对电影和种子有了新的认识和理解。农民在把种子撒进地里，在日复一日的全情陪伴中收获粮食，而电影剧本中的每一个字就像农民撒进地里的种子，它们最终在镜头中结出果来。以下是我和大家分享的在不同阶段感知到的一些诗意瞬间。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/kzoppi.jpg"></p><p>流云踩着墙头，躲进门窗的褶皱里，探听风的消息。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/2UUAhy.jpg"></p><h3 id="马有铁的个人魅力"><a href="#马有铁的个人魅力" class="headerlink" title="马有铁的个人魅力"></a>马有铁的个人魅力</h3><p>马有铁和大多数边远地区农村人一样，老实、木讷、敦厚，被无视，被边缘化，但却有着极强的生命力。只要给他的生活以希望，他就能在贫瘠的土地上开出花来。</p><p>电影中，一年的时间，他凭自己的双手，借蛋养了一窝属于自己的鸡，还养了一口小猪，收获了属于自己的粮食，盖起了属于自己的房子。他的脸上有了笑容，甚至憧憬着，明年为妻子买一台电视。</p><p>这一切，都是因为贵英。</p><p>这个被别人当累赘丢掉的女人，使他看到了希望，为他沉重、灰暗的生活掀开了一条缝，透进了一点微光，让他粗糙的大手有了力气，让他布满皱纹的脸变得柔和。</p><p>他高贵的灵魂，也得以在这粗粝的黄土地中绽放。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/u2tGZE.jpg"></p><p>他看到了希望，得到了希望，蓬勃的生命力，便从身体的每一道褶皱中迸发出来。借几个鸡蛋抚育新生命，在女人的手上印一朵花，说出最美最质朴的情话，一天做几百个土坯而不觉得辛苦……</p><p>他依然被抽血、被驱赶、被嘲讽、被压榨，但他不在乎，心中有希望，生活的小苦难就变得不值一提，脸上的皱纹都会不自觉地舒展开。</p><p>可是，最后，贵英死了，他的希望破灭了。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV13/XDwBJI.jpg"></p><p>他的生活，看似是一个新的开始，其实却回不去了。他吃了一个鸡蛋，因为贵英去找他的时候，拿着一个鸡蛋，贵英生病的时候，他也给她煮了一个鸡蛋，那是他们一起养的鸡娃子下的蛋，是他们自己辛劳所得。</p><p>他还了所有的欠债，想一了百了，让生命如尘般来，如烟般去。</p><p>干净、纯洁、高贵、厚重，却沉默无言，来去无影，隐入世间，什么都留不下。</p><h3 id="苍凉而残酷的底色"><a href="#苍凉而残酷的底色" class="headerlink" title="苍凉而残酷的底色"></a>苍凉而残酷的底色</h3><p>本片仅从抒情的角度看，它是精明且有效的。全片事无巨细地展现农村生活，却能牢牢锚定“土”（耕种的地和建筑的泥）的核心意象，将情感增厚，为羁绊赋形，做到形散神不散：穷人的命运就是扎根土地，风吹雨打，仍在默默隐忍中开出自己的麦花。但从一个了解电影语境的中国观众角度出发，这种将逆来顺受浪漫化的温吞做法背后，又有多少结构性的顽疾被草草略过？这片土地有太多值得且亟需被讲述的故事，它们绝不该隐入尘烟。</p><p>马有铁和曹贵英一辈子卑微、沉默，如蝼蚁般在泥土的缝隙里挣扎求生，面对命运，他们没有选择权，没有话语权，甚至连和别人平等对话的机会都没有。那么浅的一条灌溉水渠，那么多人看着，贵英掉下去，却没有人愿意伸出援手。</p><p><strong>资本家靠吸穷人的血活下来，勤劳能干的边缘人，失声、丢命，拼尽全力，却连一点希望都抓不住、一点痕迹都留不下，两条生命，还不如世间的一粒微尘。</strong></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MV13/0eQBU8.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;影片讲述西北农村，两个被各自家庭抛弃的孤独个体，在日复一日的耕耘中相濡以沫的故事，武仁林与海清展现了一对底层农民夫妇从陌生到熟悉，从相知到相守的心路历程。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>极圈以南，承诺埋葬冰川之下--South of the Circle</title>
    <link href="https://yousazoe.top/archives/6c20c24c.html"/>
    <id>https://yousazoe.top/archives/6c20c24c.html</id>
    <published>2022-08-29T12:39:55.000Z</published>
    <updated>2023-01-24T07:20:37.111Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/WI2ABK.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>《极圈以南》是一款动人心弦的叙事游戏，探索两位被卷入政治冲突的剑桥学者披得与克拉拉之间的情感关系。当过去被迫做出的选择已成幻影，我们又该如何坚守职业生涯与真爱的承诺。</p><span id="more"></span><p><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.akamai.steamstatic.com/steam/apps/1811040/ss_1b0d785bc5288a160d458252861a093463427b61.600x338.jpg?t=1661510536">       <source id="mp4" src="https://cdn.akamai.steamstatic.com/steam/apps/256899096/movie480_vp9.webm?t=1659529552" type="video/mp4">       </video></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p>《极圈以南》将以多层次的电影化叙事手段来讲述一段动人心弦的故事。游戏的主要故事将向人生选择之重抛出疑问，并从过去与未来的双重视角探讨对职业生涯与真爱的影响。玩家将扮演在冷战时期的南极遭遇飞机失事事件的剑桥学者披得。在寻求帮助的道路上，他将回忆起自己的过去，并思考权利的威压与个人的野心是怎么将自己一步步带入这个必须逃脱的困境。随着披得与自己的同事克拉拉之间爱意萌生，他渐渐意识到了当初许下诺言的承重。就像是儿时的回忆，不经意间的承诺也将陪伴我们一生。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/1811040/extras/SotC_TRAIN_D.gif?t=1661510536"></p><p><strong>匠心打造，电影味十足</strong></p><p>由揽获英国电影和电视艺术学院（BAFTA）大奖的工作室 State of Play 创作，《极圈以南》中唯美的画面与细致入微的文笔将在电影化的镜头语言中娓娓道来，除此以外还有来自多位知名演员的倾情演出：Gwilym Lee（波西米亚狂想曲），Olivia Vinall（白衣女人），Richard Goulding（王冠），Anton Lesser（权利的游戏），Adrian Rawlins（切尔诺贝利）以及Michael Fox（唐顿庄园）。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/1811040/extras/SotC_CAR_D.gif?t=1661510536"></p><p><strong>特色</strong></p><ul><li>在独特时代与地点背景下引人入胜的沉浸式叙事体验</li><li>细致入微而且深入肺腑的选择</li><li>完美演绎情绪波动的真人动作捕捉演出</li><li>设定在真实冷战年代的细腻背景</li><li>与故事本身交织融合的环境叙事手法</li><li>出类拔萃的美术风格</li><li>由制作出荣获BAFTA大奖的 Lumino City、BAFTA提名KAMI 2以及荣获苹果设计大奖（Apple Design Award）的INKS等多款游戏的State of Play Games倾情打造，玩家们将在游戏中见证诸多感人肺腑的动情时刻</li></ul><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/1811040/extras/SotC_footer_karta_steam_616x136__copy.png?t=1661510536"></p><h3 id="游戏实况"><a href="#游戏实况" class="headerlink" title="游戏实况"></a>游戏实况</h3><iframe src="//player.bilibili.com/player.html?aid=259995007&amp;bvid=BV1aa411R71s&amp;cid=816529436&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="极具特色的画面张力"><a href="#极具特色的画面张力" class="headerlink" title="极具特色的画面张力"></a>极具特色的画面张力</h4><p><strong>简约化</strong></p><p>与漫漫长夜极为相似的印象派画风让本作的美术风格给人一种独树一帜的感觉，非常的简约，并没有着重勾勒面部、建筑、场景的细节，而是着重于色彩对比、阴影处理等烘托氛围的表现方式，把简约化模型作为画面的主要表现形式，让玩家专注于剧情发展。</p><p><strong>噪点</strong></p><p>将游戏画面做旧，这种复古的画面设计把冷战时期那种不清晰的质感拔高，呈现出一种“时过境迁”的年代感。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/2xjQDV.jpg"></p><p><strong>色彩</strong></p><p>本作画面张力的另一处体现。本作的色彩较为鲜艳，虽然在噪点的影响下看上去饱和度不算太高，但产生的色彩对比让本作极具直观的视觉冲击力。</p><p><strong>阴影</strong></p><p>本作处理阴影的手法也非常巧妙，大量的特殊镜头与光线关系，将玩家包裹在了有限的回旋空间里，特别是在房间里，聚光灯式的打光方式，圆形画面外的阴影令人恐惧，而在狭隘的空间中聚焦到一处的视觉表现，非常地压抑。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/1t7qoI.jpg"></p><h4 id="电影叙事与蒙太奇手法"><a href="#电影叙事与蒙太奇手法" class="headerlink" title="电影叙事与蒙太奇手法"></a>电影叙事与蒙太奇手法</h4><p>State of Play 把游戏做成了一部冗长的电影，在电影里运用蒙太奇式的插叙叙事手法将 “过去/剑桥” 和 “现在/南极” 两条不同时间线的故事糅合到一起，风雪与细雨，雪原与街道，铀矿场与游乐园、南极站与办公室……过往的故事仿佛梦境一般插在南极冒险的中间，时空的错位感构筑出截然不同的两种氛围环境，同时产生一些只可意会的暗喻内涵，拔高了整个作品的层次感和节奏感。</p><p>与之相对的，游戏电影化非常考验制作人的手法：在叙事性与游戏性间平衡。显然本作并没有达到完美的平衡，游戏中要求文章联名只存在于 Peter 的自我幻想，无论前面做出什么决定玩家都不会改变结果，这会给人非常强的负反馈与挫败感，单线式剧情和存在感弱的选项使游戏缺乏交互感，也是许多玩家给予差评的原因之一。</p><h4 id="富有争议的讨论与思考"><a href="#富有争议的讨论与思考" class="headerlink" title="富有争议的讨论与思考"></a>富有争议的讨论与思考</h4><p>虽然游戏只有短短的三个小时流程，但其包含了两个饱受争议的对立议题：女性独立与平权、意识形态与冷战思维。</p><h5 id="冷战思维与意识形态"><a href="#冷战思维与意识形态" class="headerlink" title="冷战思维与意识形态"></a>冷战思维与意识形态</h5><p>在游戏中的 “现在/南极” 时间线是关于冷战思维的部分。</p><p><strong>学校政治运动</strong></p><p>游戏涉及了大量史实，比如剑桥的教授曾对 Peter 提及剑桥四人组，并暗示军方对所有剑桥的研究学者都有所怀疑；以及政府对同性恋、女权主义近乎宗教审判式的迫害。</p><p>历史上真实存在的是剑桥五杰，他们是上世纪30年代就读于剑桥大学的五位高材生，认为资本主义无法拯救欧洲大陆的命运，对苏联新起的社会主义充满兴趣，后来都成为了坚定的共产主义信徒。毕业之后的五人分别在英国的外交、情报甚至间谍机构工作，而苏联的间谍组织克格勃也开始秘密与他们接触。五人后来相继成为了苏联的间谍，为苏联不断提供英方政府的情报。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/nEntlP.jpg"></p><p><strong>南极条约</strong></p><p>尽管历史上1959年包括美苏在内的许多国家已经签署并加入确保各国在南极和平发展的《南极条约》，但美苏冷战的范围早已不可避免地波及这片地球的处女地，甚至相继在南极洲附近展开核武器实验，时至今日南极洲的冰层上仍可检测出大量残存的放射性氯元素。</p><p><strong>苏联工程师</strong></p><p>在 Peter 与飞行员交流的过程中，玩家可以明显感受到西方世界对于苏联的偏见，事实上在玩游戏前我以为制作方可能会与大部分欧美人一样以抹黑苏联作为一种政治正确。</p><p>但是制作组还是打了我的脸。最后飞行员放下了心中的偏见，也把问题抛给了玩家：对于大多数人而言，时代就像一股莫之能御的洪流。整个冷战期间各个国家的人都彼此满怀恶意，而在极地圈中三人相依为命，机长给工程师递烟，敬威士忌，而工程师也与他敞开心扉，聊的酣畅淋漓，不由得让玩家们在极地的寒冷中感受到了一丝暖意。这也是在生命的最后时期中，体现出的一丝人性的良知面，这种感情，并不是国与国之前能限制的，而是人与人一辈子的生死至交。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/wessdX.jpg"></p><h5 id="妇女运动与女性独立"><a href="#妇女运动与女性独立" class="headerlink" title="妇女运动与女性独立"></a>妇女运动与女性独立</h5><p>在游戏中的 “过去/剑桥” 时间线是关于女性独立的部分。</p><p>其实关于女性独立的话题我一直不想涉及，因为这个话题涉及到太多的争议，而我之前也被朋友以”女权”之名中伤过，现在想想那位可能怎么也想不到我会为这样的游戏宣传。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/Q4QMEi.jpg"></p><p>但本作的精妙之处在于，即使玩家选择了所有支持克拉拉的选项，结果依然是背叛。其实许多暗线都指向了背叛，首先本作开头 Peter 出现在南极，就说明他最终选择了向名利妥协没有在论文中联名；其次当 Peter 多次选择联名论文选项时，给出的说辞是模棱两可的，也就侧面印证了”幻想说”：许多场景都是 Peter 自己的臆想，其实他选择的是背叛和食言，只是负罪感迫使他去逃避这段现实，捏造了虚构的情景（也就是玩家选择的场景）。</p><p>换句话说，其实玩家是站在一种比较虚伪的角度去协助克拉拉，以强者的怜悯姿态而非平等的尊重，也是很多人会犯的本质错误。当最后真相大白时，玩家的选择被一个个的否定，其实也就是制作组告诉你之前的一切只是幻想罢了，这段是给我非常大震撼的一段剧情。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/FAxZn0.jpg"></p><p>不仅如此，除了故事的主线，大量支线也在隐喻妇女运动，例如 Peter 小时候父母吵架暗示了父权社会的主导地位、Peter 在剑桥路上闲聊中发现克拉拉对于自己教授资格非常敏感暗示了职场中女性的不平等地位…… </p><p>《极圈以南》提供了一个从男性的视角去体验变化的过程，看着父权如何运作，主角是如何从童年开始被建构成“男人”的，通过画面明暗的隐喻，“男人群体”间的玩笑，“以父之名”的规训，男主被压抑的想法，以及厌女的社会氛围如何形成，并且在这样一个环境中男主角有何感受，经过了怎样的事情被迫妥协，甚至是合作反抗的故事，这是让我觉得最难能可贵的地方；并且这种与个人命运相关的叙事反复穿插在极难环境的求生过程中，并与求生的主题相互呼应，随着事态的变化高低起伏，铺满悬念，以至于被剥夺一切之后，那种极端环境下的绝望和最后觉醒的冲击力不言而喻，而游戏的配乐、画面运镜在不遗余力渲染这种情绪高潮的到来。结局里男主角从克拉拉的女性他者的幻象中走了出来，看清了何为真实，伸手与过去作别，最终向着深邃幽蓝的天空远去。这个意味深长的结局或许是象征着男主角从男性建构中挣扎并最终挣脱的过程，不只是与现实的他一起离开了南极圈的险境，更是代表着离开了思想的“险境”，完成了对于他自身的蜕变。</p><p>作为一款从男性视角看待女性主义的作品，我是非常推荐去尝试的。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><p>从南极冻土挟着冰霜而来的凛冽狂风在世人心中呼啸，自冷战至今，从未止息。</p></blockquote><p>《极圈以南》的结局可以看作是开放性的，彼得和同伴们在最后一刻成功是否脱险，并没有明确交待给玩家，留下了想象和回味的空间。游戏通过在现在与过去之间闪回式的插叙展现了男主角彼得的人生，表达出冷战大背景下个人命运的些许无奈，但同时也歌颂了热爱和平的反战精神。游戏的艺术性很强，思想性也可圈可点，如果你不是很在意游戏性，而是想体验一个沉浸式的故事，那么本作非常值得推荐。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT16/KQwQkE.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GT16/WI2ABK.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;《极圈以南》是一款动人心弦的叙事游戏，探索两位被卷入政治冲突的剑桥学者披得与克拉拉之间的情感关系。当过去被迫做出的选择已成幻影，我们又该如何坚守职业生涯与真爱的承诺。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>一花一叶，毕其一生--Gorogoa</title>
    <link href="https://yousazoe.top/archives/9a8c63ec.html"/>
    <id>https://yousazoe.top/archives/9a8c63ec.html</id>
    <published>2022-08-23T02:15:46.000Z</published>
    <updated>2023-01-24T07:20:37.111Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/rvrEea.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Gorogoa 是一款独具特色的解谜游戏，其故事情节采用由 Jason Roberts 设计和作画的精美手绘插画展开。</p><span id="more"></span><p><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.akamai.steamstatic.com/steam/apps/557600/ss_aa212d776cb3cd25316b3932c218c08f4843f4dd.600x338.jpg?t=1660851691">       <source id="mp4" src="https://cdn.akamai.steamstatic.com/steam/apps/256717596/movie480.webm?t=1527026591" type="video/mp4">       </video></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/557600/extras/Gorogoa_1S.png?t=1660851691"></p><p><strong>充满独特想象力的谜团</strong></p><p>Gorogoa 的情节设计均为原创，游戏中有多个细节丰富的插画格子，玩家可按照自己的想法通过移动和组合插画格子来解谜。操作极为简单，内容却复杂有趣。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/557600/extras/Gorogoa_2S.png?t=1660851691"></p><p><strong>精美的手绘游戏情节</strong></p><p>Jason Roberts 精心制作了数千张极为精细的插画，构成极为丰富的 Gorogoa 特色游戏情节。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/557600/extras/Gorogoa_3S.png?t=1660851691"></p><p><strong>全新的叙述方式</strong></p><p>Gorogoa 不仅是一款游戏，还是一件艺术品，它用充满情感、极富魅力的插画和构思奇妙的解谜机制诉说着自己的故事。</p><p><img data-src="https://cdn.akamai.steamstatic.com/steam/apps/557600/extras/Gorogoa_4S.png?t=1660851691"></p><h3 id="游戏实况"><a href="#游戏实况" class="headerlink" title="游戏实况"></a>游戏实况</h3><iframe src="//player.bilibili.com/player.html?aid=344859158&amp;bvid=BV1Hd4y1A7e6&amp;cid=811487520&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="近乎绚烂的美术风格"><a href="#近乎绚烂的美术风格" class="headerlink" title="近乎绚烂的美术风格"></a>近乎绚烂的美术风格</h4><iframe src="//player.bilibili.com/player.html?aid=32718176&amp;bvid=BV1qW411S7X2&amp;cid=57247688&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="突破思维定势的交互体验"><a href="#突破思维定势的交互体验" class="headerlink" title="突破思维定势的交互体验"></a>突破思维定势的交互体验</h4><p>笔者从来都没玩过像 Gorogoa 这样的解谜游戏。它安静而引人深思：四个可拖动的方块就像是一扇扇窗户，通向美丽梦幻的手绘世界。当你滚动、覆盖、拼接或放大缩小每一块画面时，你会发现每一个小方块中都蕴藏着一个神秘庞大的世界。静态的场景会随着画面的移动焕发生机，你可以通过改变方框的位置来激活场景的互动，探索隐藏在其中的双重世界（神秘、悲伤还有一点吓人）。一旦你找到了正确的拼接方法，你就会感到无比兴奋和满足。游戏的故事只需要短短两个小时就可以通关，但游戏独具的魅力和充满神秘感的故事会在你的脑海里停留很长一段时间。</p><p>见到这款游戏的第一眼，你可能会以为这些图片只是从儿童故事书上撕下来的插画，毫无联系可言。游戏的奥秘往往隐藏在一个平凡的小物件上：枝头的一个苹果、书架上的一盏灯、一个指南针、一张地图和一幅照片。还有一些场景需要将两幅图片拼到一起，形成一个更大的场景，然后你可以点击进入场景或将场景放大，以揭示隐藏在原来的图像中的新世界：一座废弃的城市、瓦砾堆里坏掉的玩具和寺庙上的滚动陨石。它们之间的联系是分散而神秘的，每个谜题的场景都像是梦境，讲述了一个深奥的故事。这是一种难以抗拒的魅力。</p><p>你在这几幅画框之间探索、排列和堆叠，有时甚至从一张画框中分离出两个图层，这些四散在画框中的杂乱线索会以一种不可思议的方式组合在一起。在一幅场景里，笔者从天上偷了一颗星星来点亮台灯。在另一幅场景里，笔者通过重叠门的图案、旋转古代遗迹并将转动的瓷盘当成齿轮，来指引主角在几张老照片中穿梭。在这些谜题中，时间和空间不受物理定律约束，可以自由的组合切换，同时出现在一幅场景中。笔者发现自己回到了过去或是到了遥远的土地上，在那片土地上的一举一动竟然会影响现在。这是一种非常巧妙的机制，它能激励玩家去发掘每个场景背后新颖神奇的联系，在这个过程中跟随故事一起回想过去与得失。</p><h4 id="记忆碎片背后的叙事艺术"><a href="#记忆碎片背后的叙事艺术" class="headerlink" title="记忆碎片背后的叙事艺术"></a>记忆碎片背后的叙事艺术</h4><blockquote><p>该部分主要参考了以下两个游戏资料</p><ul><li><a href="https://www.gcores.com/radios/95810/timelines?pi=1">机核</a></li><li><a href="https://www.bilibili.com/video/BV1tC4y1a7bG">制作人演讲</a></li></ul></blockquote><h5 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h5><p>游戏制作人 Jason Roberts 原本是个软件工程师，37 岁那年他辞去工作，开始独立制作这款游戏。不断推翻重来的制作过程花光了他所有的钱，但也让他想象中的游戏成为了现实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/j7DIbP.jpg"></p><p>游戏本名 Gorogoa，是他在小时候给自己想象中的生物起的名字，它听起来像是雷声或是从地下传来的轰隆声，古老而强大。而它的出现也成了游戏的序章，巨龙游过街头如同神迹降临，心怀好奇的男孩从此开始冒险。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/iuZytz.jpg"></p><p>当他集齐五色果实想召唤神龙时，神龙却闭上了眼，他也从云端坠落…</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/j2VVwe.jpg"></p><p>从此，破解神龙的秘密成为了他一生的追求。通过拼图，玩家跟着游戏中的男孩一步步展开冒险。</p><p>男孩在寻找神龙的旅程中度过了一生，这个游戏就像他所有的回忆。它们并不遵照时间顺序重演，而是不断折叠、编织，构成了一个时空交错的寓言。大部分玩家在游玩过程中专注于解谜的过程，其蕴含的剧情故事却被忽略，而这恰恰是开发者最想要传达的故事，只不过以一种比较隐晦的方式表达出来。</p><h5 id="剧情梳理"><a href="#剧情梳理" class="headerlink" title="剧情梳理"></a>剧情梳理</h5><p>童年时期男孩看见巨龙从街头经过，他查阅书籍发现了一个古老的仪式，集齐五色果实就可以召唤神龙，于是男孩踏上了寻找果实的冒险之旅。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/DCfBug.jpg"></p><p>旅程的开端十分顺利，一只乌鸦振翅而飞，他就获得了从枝头掉落的红色果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/SD1BYa.jpg"></p><p>随后他通过一扇画中之门进入花园，从女神像手中得到绿色果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/tRyWdx.jpg"></p><p>在另外几尊塑像的指引下，他来到一片墓地，时间由黄昏进入深夜，一颗星辰成为了黄色果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/xNDt5W.jpg"></p><p>此后昼夜流转，在经历了一些神秘的建筑遗迹后他来到一处祭坛，取走了蓝色果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/D7Cmmp.jpg"></p><p>最后他搭乘列车来到紫色塔楼，登上高塔，摘下了紫色果实。可当他为神龙献上五色果实后，神龙却闭上了眼，他也因此从云端坠落。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/XcVoWo.jpg"></p><p>受了重伤的男孩缠上了绷带，需要借助轮椅移动。养伤期间，他回到了自己曾获得果实的地方，想起自己过去的经历，心中充满了困惑。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/bcpQjx.jpg"></p><p>这场伤病持续了很久，男孩已长成少年，但仍需要拄着双拐行动。此时城市因为某种原因成为废墟，有关神龙的资料也被烧毁了一部分。在一幅寓言画中，失明的人在沙漠中进入一片绿洲，得到女神赐予他的眼睛，从此得到了光明。</p><p>与之对应的，现实中的男孩身处断壁残垣之间，就像失明者看不清方向。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/RIHBr9.jpg"></p><p>得到神龙之眼意为他得到了启示，开始真正认识这个世界。</p><p>在家中翻阅古籍后，男孩了解了”神的起源”，人们对神的想象经历了漫长的演变，并由此创造了神的象征图案以及它所对应的马鱼星座。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/bU32pn.jpg"></p><p>研究古籍的日子一直持续到青年时期，男孩在书中看到了”神的惩戒”，人对神的召唤并未得到应允，反会引来陨石的坠落，是他让这座城市遭受了天灾。</p><p>愧疚之下他更渴望破解神龙的奥秘，开始学习占星术。房间里的书架和书桌边都散落着大量书籍，他每天研读资料至深夜。确认了马鱼星会在何时出现后，他来到野外进行观测。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/wtI2LH.jpg"></p><p>当它如预想中的一样出现在夜空时，他的求知之树已然结出了果实。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/ioPN83.jpg"></p><p>读完万卷书后，进入中年时期的他开始行万里路。地图上标注了他参与不同教派进行三次修行的路径。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/fqAv8N.jpg"></p><p>第一次修行，他在沙漠中徒步摇铃，齿轮中的图案呈现了这一教派的四种仪式：</p><ul><li>日出时献祭孔雀</li><li>白天在沙漠摇铃</li><li>日落时放走飞蛾</li><li>夜晚握着蓝色念珠对着马首鱼身神像做礼拜</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/mLujm5.jpg"></p><p>第二次修行，他在森林中供奉烛火。</p><p>花窗中的图案表明火焰是这一教派信仰的象征，他们高举火焰以示崇拜，并在教徒间传递火焰留存火种。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/TC36HF.jpg"></p><p>第三次修行，他攀登雪山为自己洗礼。 瓷盘中的图案也呈现了四种仪式：</p><ul><li>为自己洗礼</li><li>在蛋上绘画</li><li>供奉烛火</li><li>马鱼祭祀</li></ul><p>这三次苦修磨砺了他的身心，但他始终没有追寻到神龙的踪迹。看着自己曾用过的法器，他又回想起了当初的梦魇，不由地感到失望而沮丧，但他始终没有放弃。</p><p>当他年近花甲时，开始回顾自己一生的研究，希望能从中找到有用的线索。当他理清思绪后，他再次搭乘火车来到紫色塔楼。</p><p>曾被摧毁的高塔在重建后已恢复了原貌，他登上高塔开始回溯过去的经历。</p><h5 id="果实隐喻"><a href="#果实隐喻" class="headerlink" title="果实隐喻"></a>果实隐喻</h5><p>童年时期，那本记录了神龙的书其实早已揭示了后果：献祭果实失败后，他将从云端跌落。血一般的红色果实，象征的是他渴望追寻理想的热血和甘愿为之牺牲的勇气。</p><p>少年时期，在现实和内心都是一片荒芜的时刻，绿色果实象征者神的启示降临。他怀揣希望，开始寻找前行的路。</p><p>青年时期，在钻研知识的道路上，他经历了漫长而孤独的黑夜，黄色果实象征着他从未熄灭的求知欲。通过研究与实践，他正一步步解开神龙的秘密。</p><p>中年时期，他云游四海，在沙漠、森林与雪山中完成了艰苦的修行，蓝色果实象征着他的决心与毅力。肉体与精神上的锤炼让他变得更加坚韧。</p><p>老年时期，他在精神世界重走了一遍人生路，从事物的表象到达了意识的深处，则色果实意味着他实现了顿悟。</p><p>当他参透了所有果实的含义后，他的灵魂也就此升华。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT15/Ptilrl.jpg"></p><h4 id="开发者的朝圣修行之旅"><a href="#开发者的朝圣修行之旅" class="headerlink" title="开发者的朝圣修行之旅"></a>开发者的朝圣修行之旅</h4><iframe src="//player.bilibili.com/player.html?aid=795979987&amp;bvid=BV1tC4y1a7bG&amp;cid=198333711&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>玩家在游戏中用了90分钟追梦，作者在创作中用了七年追梦，而男孩在画中用了一生追梦。</p><p><strong>追寻并不一定有结果，即使达到了终点也不一定是你想要的，但这追寻的过程，便是那可以令人生而无憾的宝物。</strong></p><blockquote><p>有生之年，得偿所愿。</p><p>画中世界，怪龙隐现。</p><p>小小男孩，四处追寻。</p><p>众人身影，仿佛曾见。</p><p>乌鸦振翅，眼珠游动。</p><p>飞蛾扑火，青花旋转。</p><p>列车出站，楼高危险。</p><p>瓷碗破碎，眼前一黑。</p><p>鲜血红艳，枝桠绿翠。</p><p>挂毯紫绣，鳞羽燃星。</p><p>痴人前行，不舍昼夜。</p><p>摇铃叩门，天光重开。</p><p>兽尾深潜，层层叠叠。</p><p>黄粱一梦，已历半生。</p><p>轮椅仍在，男孩又见。</p><p>不知谁人，泪流满面。</p></blockquote><p>如果你和游戏中的他一样，也在为了一个遥不可及的梦忍受失败和孤独，那么祝愿你终有一天也能触碰到那个奇异而美丽的龙。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GT15/rvrEea.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Gorogoa 是一款独具特色的解谜游戏，其故事情节采用由 Jason Roberts 设计和作画的精美手绘插画展开。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>简明 VIM 教程</title>
    <link href="https://yousazoe.top/archives/a10f3033.html"/>
    <id>https://yousazoe.top/archives/a10f3033.html</id>
    <published>2022-08-16T02:25:53.000Z</published>
    <updated>2023-01-24T07:20:37.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/VIM1/NRflHC.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>You want to teach yourself vim (the best text editor known to human kind) in the fastest way possible. This is my way of doing it. You start by learning the minimal to survive, then you integrate all the tricks slowly.</p><span id="more"></span><blockquote><ul><li>原文 <a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">Learn Vim Progressively</a></li><li>译文 <a href="https://coolshell.cn/articles/5426.html">简明 VIM 练级攻略</a></li></ul></blockquote><p>你想以最快的速度学习人类史上最好的文本编辑器 VIM 吗？你先得懂得如何在 VIM 幸存下来，然后一点一点地学习各种戏法。</p><p><a href="https://www.vim.org/">Vim</a> the Six Billion Dollar editor</p><blockquote><p>Better, Stronger, Faster.</p></blockquote><p>学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。</p><p>我建议下面这四个步骤：</p><ol><li>Survive</li><li>Feel comfortable</li><li>Feel Better, Stronger, Faster</li><li>Use superpowers of vim</li></ol><p>在开始学习以前，我需要给你一些警告：</p><ul><li>学习vim在开始时是痛苦的</li><li>需要时间</li><li>需要不断地练习，就像你学习一个乐器一样</li><li>不要期望你能在3天内把vim练得比别的编辑器更有效率</li><li>事实上，你需要2周时间的苦练，而不是3天</li></ul><h3 id="1st-Level-Survive"><a href="#1st-Level-Survive" class="headerlink" title="1st Level-Survive"></a>1st Level-Survive</h3><ol><li>安装 vim</li><li>启动 vim</li><li>什么也别干！请先阅读</li></ol><p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p><ul><li>启动 Vim 后，vim 在<code> Normal</code> 模式下</li><li>让我们进入 <code>Insert</code> 模式，请按下键 <code>i</code> 。(陈皓注：你会看到 vim 左下角有一个–insert–字样，表示，你可以以插入的方式输入了)</li><li>此时，你可以输入文本了，就像你用“记事本”一样</li><li>如果你想返回 <code>Normal</code> 模式，请按 <code>ESC</code> 键</li></ul><p>现在，你知道如何在 <code>Insert</code> 和 <code>Normal</code> 模式下切换了。下面是一些命令，可以让你在 <code>Normal</code> 模式下幸存下来：</p><blockquote><ul><li><code>i</code> → <code>Insert</code> 模式，按 <code>ESC</code> 回到 <code>Normal</code> 模式</li><li><code>x</code> → 删当前光标所在的一个字符</li><li><code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)   （陈皓注：<code>:w</code> 后可以跟文件名）</li><li><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li><li><code>p</code> → 粘贴剪贴板</li></ul><p><strong>推荐</strong>:</p><ul><li><code>hjkl</code> (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</li><li><code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（陈皓注：退出帮助需要输入 <code>:q</code>）</li></ul></blockquote><p>你能在 vim 幸存下来只需要上述的那 5 个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p><p>当是，在你进入第二级时，需要再说一下 <code>Normal</code> 模式。在一般的编辑器下，当你需要 copy 一段文字的时候，你需要使用 <code>Ctrl</code> 键，比如：<code>Ctrl-C</code>。也就是说，<code>Ctrl</code> 键就好像功能键一样，当你按下了功能键 <code>Ctrl</code> 后，C就不在是C了，而且就是一个命令或是一个快键键了，在 VIM 的 <code>Normal</code> 模式下，所有的键就是功能键了。这个你需要知道。</p><ul><li>下面的文字中，如果是 <code>Ctrl-λ</code> 我会写成 <code>&lt;C-λ&gt;</code></li><li>以 <code>:</code> 开始的命令你需要输入 <code>&lt;enter&gt;</code> 回车，例如 — 如果我写成 <code>:q</code> 也就是说你要输入 <code>:q&lt;enter&gt;</code></li></ul><h3 id="2nd-Level-–-Feel-comfortable"><a href="#2nd-Level-–-Feel-comfortable" class="headerlink" title="2nd Level – Feel comfortable"></a>2nd Level – Feel comfortable</h3><p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在 <code>Normal</code> 模式下使用，如果你不知道现在在什么样的模式，你就狂按几次 <code>ESC</code> 键）</p><ol><li>各种插入模式</li></ol><blockquote><ul><li><code>a</code> → 在光标后插入</li><li><code>o</code> → 在当前行后插入一个新行</li><li><code>O</code> → 在当前行前插入一个新行</li><li><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li></ul></blockquote><ol start="2"><li>简单的移动光标</li></ol><blockquote><ul><li><code>0</code> → 数字零，到行头</li><li><code>^</code> → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</li><li><code>$</code> → 到本行行尾</li><li><code>g_</code> → 到本行最后一个不是blank字符的位置</li><li><code>/pattern</code> → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）</li></ul></blockquote><ol start="3"><li>拷贝/粘贴 （陈皓注：<code>p</code>/<code>P</code> 都可以，<code>p</code> 是表示在当前位置之后，<code>P</code> 表示在当前位置之前）</li></ol><blockquote><ul><li><code>P</code> → 粘贴</li><li><code>yy</code> → 拷贝当前行当行于 <code>ddP</code></li></ul></blockquote><ol start="4"><li>Undo/Redo</li></ol><blockquote><ul><li><code>u</code> → undo</li><li><code>&lt;C-r&gt;</code> → redo</li></ul></blockquote><ol start="5"><li>打开/保存/退出/改变文件(Buffer)</li></ol><blockquote><ul><li><code>:e &lt;path/to/file&gt;</code> → 打开一个文件</li><li><code>:w</code> → 存盘</li><li><code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code></li><li><code>:x</code>，<code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，<code>ZZ</code> 不需要输入冒号并回车)</li><li><code>:q!</code> → 退出不保存 `:qa!`` 强行退出所有的正在编辑的文件，就算别的文件有更改</li><li><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件（陈皓注：我喜欢使用 <code>:n</code> 到下一个文件）</li></ul></blockquote><p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用 vim 还是有点笨拙，不过没关系，你可以进阶到第三级了。</p><h3 id="3rd-Level-–-Better-Stronger-Faster"><a href="#3rd-Level-–-Better-Stronger-Faster" class="headerlink" title="3rd Level – Better. Stronger. Faster."></a>3rd Level – Better. Stronger. Faster.</h3><p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和 vi 可以兼容的命令。</p><h4 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h4><p>下面，让我们看一下vim是怎么重复自己的：</p><ol><li><code>.</code> → (小数点) 可以重复上一次的命令</li><li><code>N&lt;command&gt;</code> → 重复某个命令 N 次</li></ol><p>下面是一个示例，找开一个文件你可以试试下面的命令：</p><blockquote><ul><li><code>2dd</code> → 删除2行 </li><li><code>3p</code> → 粘贴文本3次 </li><li><code>100idesu [ESC]</code> → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “ </li><li><code>.</code> → 重复上一个命令—— 100 “desu “. </li><li><code>3.</code> → 重复 3 次 “desu” (注意：不是 300，你看，VIM 多聪明啊).</li></ul></blockquote><h4 id="Stronger"><a href="#Stronger" class="headerlink" title="Stronger"></a>Stronger</h4><p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。</p><ol><li>N<code>G</code> → 到第 N 行 （陈皓注：注意命令中的 <code>G</code> 是大写的，另我一般使用 <code>:N</code> 到第 N 行，如 <code>:137</code> 到第 137 行） </li><li><code>gg</code> → 到第一行。（陈皓注：相当于 <code>1G</code>，或 <code>:1</code>）</li><li><code>G</code> → 到最后一行</li><li>按单词移动：<blockquote><ol><li><code>w</code> → 到下一个单词的开头</li><li><code>e</code> → 到下一个单词的结尾</li></ol><ul><li>如果你认为单词是由默认方式，那么就用小写的 e 和 w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）</li><li>如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）<br><img data-src="https://img.yousazoe.top/uPic/img/blog/VIM1/U0ZGqV.jpg"></li></ul></blockquote></li></ol><p>下面，让我来说说最强的光标移动：</p><blockquote><ul><li><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>{</code>, <code>[</code>. （陈皓注：你需要把光标先移到括号上）</li><li><code>*</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li></ul></blockquote><p>相信我，上面这三个命令对程序员来说是相当强大的。</p><h4 id="Faster"><a href="#Faster" class="headerlink" title="Faster"></a>Faster</h4><p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p><p><code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code></p><p>例如 <code>0y$</code> 命令意味着：</p><ul><li><code>0</code> → 先到行头 </li><li><code>y</code> → 从这里开始拷贝 </li><li><code>$</code> → 拷贝到本行最后一个字符</li></ul><p>你可可以输入 <code>ye</code>，从当前位置拷贝到本单词的最后一个字符。</p><p>你也可以输入 <code>y2/foo</code> 来拷贝2个 “foo” 之间的字符串。</p><p>还有很多时间并不一定你就一定要按 <code>y</code> 才会拷贝，下面的命令也会被拷贝：</p><ul><li><code>d</code> (删除 )</li><li><code>v</code> (可视化的选择)</li><li><code>gU</code> (变大写)</li><li><code>gu</code> (变小写)</li><li>等等<br>(陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等)</li></ul><h3 id="4th-Level-–-Vim-Superpowers"><a href="#4th-Level-–-Vim-Superpowers" class="headerlink" title="4th Level – Vim Superpowers"></a>4th Level – Vim Superpowers</h3><p>你只需要掌握前面的命令，你就可以很舒服的使用 VIM 了。但是，现在，我们向你介绍的是 VIM 杀手级的功能。下面这些功能是我只用 vim 的原因。</p><h4 id="Move-on-current-line-0-g-f-F-t-T"><a href="#Move-on-current-line-0-g-f-F-t-T" class="headerlink" title="Move on current line: 0 ^ $ g_ f F t T , ;"></a>Move on current line: <code>0</code> <code>^</code> <code>$</code> <code>g_</code> <code>f</code> <code>F</code> <code>t</code> <code>T</code> <code>,</code> <code>;</code></h4><blockquote><ul><li><code>0</code> → 到行头 </li><li><code>^</code> → 到本行的第一个非blank字符 </li><li><code>$</code> → 到行尾 </li><li><code>g_</code> → 到本行最后一个不是blank字符的位置</li><li><code>fa</code> → 到下一个为a的字符处，你也可以fs到下一个为s的字符</li><li><code>t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符</li><li><code>3fa</code> → 在当前行查找第三个出现的a</li><li><code>F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向<br><img data-src="https://img.yousazoe.top/uPic/img/blog/VIM1/0JOfOm.jpg"></li></ul></blockquote><p>还有一个很有用的命令是 <code>dt"</code> → 删除所有的内容，直到遇到双引号—— <code>"</code>。</p><h4 id="Zone-selection-lt-action-gt-a-lt-object-gt-or-lt-action-gt-i-lt-object-gt"><a href="#Zone-selection-lt-action-gt-a-lt-object-gt-or-lt-action-gt-i-lt-object-gt" class="headerlink" title="Zone selection <action>a<object> or <action>i<object>"></a>Zone selection <code>&lt;action&gt;a&lt;object&gt;</code> or <code>&lt;action&gt;i&lt;object&gt;</code></h4><p>在 visual 模式下，这些命令很强大，其命令格式为</p><p><code>&lt;action&gt;a&lt;object&gt;</code> 和 <code>&lt;action&gt;i&lt;object&gt;</code></p><ul><li>action可以是任何的命令，如 <code>d</code> (删除), <code>y</code> (拷贝), <code>v</code> (可以视模式选择)</li><li>object 可能是： <code>w</code> 一个单词， <code>W</code> 一个以空格为分隔的单词， <code>s</code> 一个句字， <code>p</code> 一个段落。也可以是一个特别的字符：<code>"</code>、 <code>'</code>、 <code>)</code>、 <code>}</code>、 <code>]</code>。</li></ul><p>假设你有一个字符串 <code>(map (+) ("foo"))</code>.而光标键在第一个 <code>o</code> 的位置。</p><blockquote><ul><li><code>vi"</code> → 会选择 foo. </li><li><code>va"</code> → 会选择 “foo”. </li><li><code>vi)</code> → 会选择 “foo”. </li><li><code>va)</code> → 会选择(“foo”). </li><li><code>v2i)</code> → 会选择 map (+) (“foo”)</li><li><code>v2a)</code> → 会选择 (map (+) (“foo”))</li></ul></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/VIM1/O2wN7U.jpg"></p><h4 id="Select-rectangular-blocks-lt-C-v-gt"><a href="#Select-rectangular-blocks-lt-C-v-gt" class="headerlink" title="Select rectangular blocks: <C-v>."></a>Select rectangular blocks: <code>&lt;C-v&gt;</code>.</h4><p>块操作，典型的操作： <code>0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC]</code></p><ul><li><code>^</code> → 到行头</li><li><code>&lt;C-v&gt;</code> → 开始块操作</li><li><code>&lt;C-d&gt;</code> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)</li><li><code>I-- [ESC]</code> → <code>I</code> 是插入，插入“–”，按 <code>ESC</code> 键来为每一行生效。</li></ul><p><img data-src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/rectangular-blocks.gif"></p><p>在 Windows 下的 vim，你需要使用 <code>&lt;C-q&gt;</code> 而不是 <code>&lt;C-v&gt;</code>，<code>&lt;C-v&gt;</code> 是拷贝剪贴板。</p><h4 id="Completion-lt-C-n-gt-and-lt-C-p-gt"><a href="#Completion-lt-C-n-gt-and-lt-C-p-gt" class="headerlink" title="Completion: <C-n> and <C-p>."></a>Completion: <code>&lt;C-n&gt;</code> and <code>&lt;C-p&gt;</code>.</h4><p>在 Insert 模式下，你可以输入一个词的开头，然后按 <code>&lt;C-p&gt;</code> 或是 <code>&lt;C-n&gt;</code>，自动补齐功能就出现了……</p><p><img data-src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/completion.gif"></p><h4 id="Macros-qa-do-something-q-a"><a href="#Macros-qa-do-something-q-a" class="headerlink" title="Macros : qa do something q, @a, @@"></a>Macros : <code>qa</code> do something <code>q</code>, <code>@a</code>, <code>@@</code></h4><ul><li><code>qa</code> 把你的操作记录在寄存器 <code>a</code></li><li>于是 <code>@a</code> 会 replay 被录制的宏</li><li><code>@@</code> 是一个快捷键用来 replay 最新录制的宏。</li></ul><blockquote><p><strong>示例</strong></p><p>在一个只有一行且这一行只有“1”的文本中，键入如下命令：</p><ul><li><code>qaYp&lt;C-a&gt;q</code>→ <ul><li><code>qa</code> 开始录制 </li><li><code>Yp</code> 复制行</li><li><code>&lt;C-a&gt;</code> 增加 1 </li><li><code>q</code> 停止录制</li></ul></li><li><code>@a</code> → 在 1 下面写下 2</li><li><code>@@</code> → 在 2 正面写下 3 </li><li>现在做 <code>100@@</code> 会创建新的 100 行，并把数据增加到 103.</li></ul></blockquote><p><img data-src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/macros.gif"></p><h4 id="Visual-selection-v-V-lt-C-v-gt"><a href="#Visual-selection-v-V-lt-C-v-gt" class="headerlink" title="Visual selection: v,V,<C-v>"></a>Visual selection: <code>v</code>,<code>V</code>,<code>&lt;C-v&gt;</code></h4><p>前面，我们看到了 <code>&lt;C-v&gt;</code> 的示例 （在 Windows 下应该是 <code>&lt;C-q&gt;</code>），我们可以使用 <code>v</code> 和 <code>V</code>。一但被选好了，你可以做下面的事：</p><ul><li><code>J</code> → 把所有的行连接起来（变成一行）</li><li><code>&lt;</code> 或 <code>&gt;</code> → 左右缩进</li><li><code>=</code> → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）</li></ul><p><img data-src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/autoindent.gif"></p><p>在所有被选择的行后加上点东西：</p><ul><li><code>&lt;C-v&gt;</code></li><li>选中相关的行 (可使用 <code>j</code> 或 <code>&lt;C-d&gt;</code> 或是 <code>/pattern</code> 或是 <code>%</code> 等……)</li><li><code>$</code> 到行最后 </li><li><code>A</code>, 输入字符串，按 <code>ESC</code></li></ul><p><img data-src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/append-to-many-lines.gif"></p><h4 id="Splits-split-and-vsplit"><a href="#Splits-split-and-vsplit" class="headerlink" title="Splits: :split and vsplit."></a>Splits: <code>:split</code> and <code>vsplit</code>.</h4><p>下面是主要的命令，你可以使用 VIM 的帮助 <code>:help split</code>。</p><blockquote><ul><li><code>:split</code> → 创建分屏 (<code>:vsplit</code> 创建垂直分屏)</li><li><code>&lt;C-w&gt;&lt;dir&gt;</code> : dir就是方向，可以是 <code>hjkl</code> 或是 ←↓↑→ 中的一个，其用来切换分屏。</li><li><code>&lt;C-w&gt;_</code> (或 <code>&lt;C-w&gt;|</code>) : 最大化尺寸 (<code>&lt;C-w&gt;|</code> 垂直分屏)</li><li><code>&lt;C-w&gt;+</code> (或 <code>&lt;C-w&gt;-</code>) : 增加尺寸</li></ul></blockquote><p><img data-src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/split.gif"></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>上面是作者最常用的 90% 的命令，我建议你每天都学 1 到 2 个新的命令。在两到三周后，你会感到 vim 的强大的。</p><p>有时候，学习 VIM 就像是在死背一些东西，幸运的是，vim 有很多很不错的工具和优秀的文档。运行 <code>vimtutor</code> 直到你熟悉了那些基本命令，其在线帮助文档中你应该要仔细阅读的是 <code>:help usr_02.txt</code>。</p><p>你会学习到诸如 <code>!</code>， 目录，寄存器，插件等很多其它的功能。学习 vim 就像学弹钢琴一样，一旦学会，受益无穷。</p><blockquote><p>If you liked this article, there is a follow up: <a href="http://yannesposito.com/Scratch/en/blog/Vim-as-IDE/">Vim as IDE</a></p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/VIM1/NRflHC.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;You want to teach yourself vim (the best text editor known to human kind) in the fastest way possible. This is my way of doing it. You start by learning the minimal to survive, then you integrate all the tricks slowly.&lt;/p&gt;</summary>
    
    
    
    <category term="写作技巧 (Write Skill)" scheme="https://yousazoe.top/categories/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7-Write-Skill/"/>
    
    
    <category term="Write" scheme="https://yousazoe.top/tags/Write/"/>
    
  </entry>
  
  <entry>
    <title>用镜头捕捉每个可爱的瞬间--TOEM</title>
    <link href="https://yousazoe.top/archives/58c9c2ab.html"/>
    <id>https://yousazoe.top/archives/58c9c2ab.html</id>
    <published>2022-08-07T12:24:35.000Z</published>
    <updated>2023-01-24T07:20:37.111Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/jPglR3.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在这款手绘冒险游戏中，踏上愉快的探索之旅，用镜头发掘神奇的TOEM世界。与怪诞有趣的人物聊天，通过拍摄优美的照片来解决他们的问题，并一路观赏令人身心放松的景观！</p><span id="more"></span><p><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.akamai.steamstatic.com/steam/apps/1307580/ss_452053e6976add5d6690c6f5dc227d3fd4bda26d.600x338.jpg?t=1659101774">       <source id="mp4" src="https://cdn.akamai.steamstatic.com/steam/apps/256851407/movie480_vp9.webm?t=1631968502" type="video/mp4">       </video></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p>在这款手绘冒险游戏中，踏上愉快的探索之旅，用镜头发掘神奇的TOEM世界。与怪诞有趣的人物聊天，通过拍摄优美的照片来解决他们的问题，并一路观赏令人身心放松的景观！</p><p>用相机拍照，解开拼图并帮助别人！</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/hUo01c.jpg"></p><p>聆听放松心情的音乐，尽情观赏四周风景！</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/QApNK5.jpg"></p><p>认识怪诞有趣的人物，帮助他们解决问题！</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/Yd8gU3.jpg"></p><h3 id="游戏实况"><a href="#游戏实况" class="headerlink" title="游戏实况"></a>游戏实况</h3><iframe src="//player.bilibili.com/player.html?aid=386780948&amp;bvid=BV1Ad4y1m7JB&amp;cid=796742565&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="这就出发"><a href="#这就出发" class="headerlink" title="这就出发"></a>这就出发</h4><p>在游戏的开始，你被奶奶打发去旅行，带着一部老式相机上路。出发前，奶奶给你看了一眼，只有一眼，闪闪发光的“Toem”照片，那是她年轻时出去旅行拍的，“Toem”是她的“宇宙之眼”。自始至终，她都没说“Toem”到底是个啥，反正现在你将踏上类似的旅程，在终点你将亲眼看到它。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/iiJGTD.jpg"></p><p>通过助人为乐，为社区里形形色色的角色（包括人、动物，还有幽灵、气球、雪人啥的）解决麻烦，在“社区卡”上收集印章，你能获得免费坐巴士到下一个区域的通行证，一站又一站的前进。这些麻烦大多数能通过相机解决，也不知为何，不过有些还需要你出卖劳力，比如跟一个幽灵约会、把走失的狗狗找回来啥的。</p><p>每个区域内有数个任务，但获得通行证并不需要帮助所有人，只需大概二分之一的人给你盖章，就能去坐车了。游戏还有一些其他的收集要素，换装和小动物图鉴，换装通过任务获得，小动物则藏在地图的各个角落，等你用镜头发现它们。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/KijeBa.jpg"></p><p>这就把游戏的全部都讲清楚了，从系统上来说，《Toem》就是这么简单。</p><h4 id="简单意味着更多"><a href="#简单意味着更多" class="headerlink" title="简单意味着更多"></a>简单意味着更多</h4><p>在 EUROGAMER 的一篇<a href="https://www.eurogamer.net/articles/2022-01-19-on-the-growing-appeal-of-photography-games">文章</a>中，《Toem》的主创谈了他们的创作理念。不同于其他主打拍照的游戏，或是游戏自带的拍照模式，《Toem》将照片视为个人的珍宝，而不带技术上或是艺术上的考量，对于人们来说，最重要的是照片记录下的那个“时刻”，以及当时的心情。</p><p>在这样的前提下，复杂的拍照功能是完全没有必要的。制作组在游戏开发中有不断的反思，“XX 设计是否在游戏中增加了不必要的东西？”最后的结果是，游戏中的老相机只有变焦、翻转两样功能，配件也仅有一副三脚架和一只吵死人的喇叭。游戏里只有黑白灰的色调，所有的贴图也都糊糊的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/SwQzHM.jpg"></p><p>简约意味着更多，在没有复杂系统、丰富叙事的情况下，《Toem》需要有一个更为生机勃勃、妙趣横生的世界。正巧，这就是制作组所想要的。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/u-3826655691001aJg.gif"></p><h4 id="神奇草图所定基调"><a href="#神奇草图所定基调" class="headerlink" title="神奇草图所定基调"></a>神奇草图所定基调</h4><p>还有一篇刊载于 Game Developer 的<a href="https://www.gamedeveloper.com/production/postmortem-toem">回忆录</a>，详细叙述了《Toem》的前世今生。从立项之初，它就是一个追求“舒适”的项目，即便它已经经过多次推到重来，已至面目全非。</p><p>2018 年，碍于学业繁重，Niklas Mikkelson 和 Lucas Gullbo 长谈了一次，商议是否应该放弃游戏开发的兴趣。而作为长谈的结果，一张画有古怪人物和小岛的草图诞生了。当时还不知道，这张草图将贯穿他们今后四年的人生。</p><p>用他们的话讲，这张草图带有一种有趣、奇妙的美学，他们始终想通过电子游戏来将这种美予以复现，那应该是一场愉快的冒险，自由、纯粹的冒险。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/BqGriz.jpg"></p><h4 id="“这不是我们想要的”"><a href="#“这不是我们想要的”" class="headerlink" title="“这不是我们想要的”"></a>“这不是我们想要的”</h4><p>几周后，他们参加了在瑞典当地参加了一场游戏设计比赛。让这张草图变成了第一版《Toem》的游戏原型，这给他们带回了 50000 克朗的奖金（约合人民币 33000 余元），旗开得胜。当时的《Toem》还只是一个比较粗糙的冒险解谜游戏，根本和拍照没有半毛钱关系。</p><p>然而事情并未一帆风顺，改变谜题、设计交互、新增机制……在做了各种尝试后，他们始终没能逼近他们的理念半分，这游戏根本不有趣，必须找到更加适当的玩法作为载体。在花大量时间来反思，翻找游戏中真正让人愉快的事物后，最早原型玩法之一的望远镜给予了灵感。</p><p>随后，带着相机旅行、乘坐巴士移动、遇见有趣的角色，还有盒式磁带。一步又一步，《Toem》经历了一次重生，事情终于开始明朗。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/ls5Wh5.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/u-3826655691145ONX.gif"></p><h4 id="2-分正经-8-分扯淡"><a href="#2-分正经-8-分扯淡" class="headerlink" title="2 分正经 8 分扯淡"></a>2 分正经 8 分扯淡</h4><p>大量既有趣、又蠢蠢、还可爱的内容，让《Toem》变得丰满，最终给予了它灵魂。而这些内容几乎全部来自开发组的集思广益、头脑风暴。除了两名主创，而后声音设计、配乐、发行等其他成员陆续加入，他们组成了一个临时团队（音效和发行来自于各自的公司）深度参与了游戏制作，在各司其职的同时，也为游戏提供了源源不断的灵感。</p><p>每周一例会，除了用 20%的时间来说正事，沟通彼此的进展，剩下 80%的时间全用来闲聊，聊彼此，聊琐事，聊自己的脑洞，聊蠢蠢的想法。为了把那些蠢蠢的想法更好地加以理解、审视，并且想办法做进游戏，负责美术的 Lucas 会把他们全部画成草图。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/Vis1Fd.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/SXJexf.jpg"></p><h4 id="一篇散文"><a href="#一篇散文" class="headerlink" title="一篇散文"></a>一篇散文</h4><p>成品的《Toem》如此松散，如此漫不经心，没有宏大的网状叙事，没有顶尖的画面表现，一切炫酷、复杂的东西都被排除在外，正如前面所说，那是一个缀满各种蠢蠢、可爱又奇妙东西的世界。</p><p>你旅行，结识人们，了解他们的难处，寻找每一个地方。任务是一点动因、一点指引，相机是另一个视角、一件神器，由此你终于有了仔细观察这个世界的机会，一草一木、飞鸟走兽、蚂蚁高楼，这是件平时你基本不会去做的事情，哪怕是游戏中。</p><p>没有经验奖励、没有任务道具，照片是唯一的收获，里面拍的全是那些互不相干、零零碎碎的生活细节，一个个“时刻”，它们共同组成了每个人的冒险，让每个人会收获每个人自己的宝藏，里面铭刻美好的情感、奔涌奇妙的灵性。</p><p>我喜欢挂在晾衣绳上的猫猫、我喜欢背着妈妈出来蹦迪的熊弟、我喜欢海底成群游弋的鱼儿、我喜欢毛茸茸的雪怪……</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/3EPFyc.jpg"></p><p><strong>我还喜欢获得到道具的瞬间</strong>：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/u-3826655691369N0M.gif"></p><p><strong>喜欢盒式磁带</strong>：</p><p>首先《Toem》有极其好听的原声。</p><p>然后，换磁带咔咔的仪式感、随时看心情切歌的自由自在、特殊磁带上寄宿的美好回忆……我爱盒式磁带的设计。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/zbO6PI.jpg"></p><h4 id="烦恼消灭者，就在你身边"><a href="#烦恼消灭者，就在你身边" class="headerlink" title="烦恼消灭者，就在你身边"></a>烦恼消灭者，就在你身边</h4><p>那些任务，它们可能有点蠢，但也很可爱，里面的烦恼，或许你也会遇到：灵感枯竭，需要启发；耗子成精，招摇过市；发现可疑人物，八卦心理作祟；狗狗跑丢了，帮忙找找呗；对未来有点迷茫，不晓得第一步如何迈出……</p><p>那么，是时候让有求必应的烦恼消灭者——相机小天使出手，帮他们排忧解难啦！办法也再简单的不过，咔嚓一声，快门一按，照片一张，烦恼消散。</p><p>其实也不是相机小天使有多厉害，它只是一双不一样眼睛。面对这些个可大可小、奇奇怪怪、到处滋生的烦恼，please，别光顾着苦恼！就在人们的眼皮子底下，烦恼的“天敌”也静静存在着，有着这让大多数问题迎刃而解的力量，请快去发现它们吧！</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/u-3826655691840chO.gif"></p><h4 id="游戏能是什么呢？"><a href="#游戏能是什么呢？" class="headerlink" title="游戏能是什么呢？"></a>游戏能是什么呢？</h4><p>我在《Toem》里再一次找到了宽慰。现在，当说起好游戏时，我们共同的印象是：思路明确、设计集中、严丝合缝、处处打磨，怎么摔都摔不坏，随便拿个点出来就够分析一个钟，让人深受震撼、倍受启迪。但《Toem》并不是那种好游戏，当然你也可以觉得它不好。它天生“摆烂”，不追求玩法的变革、情感的巅峰或是技术的极致，<strong>它就是一个舒适的游戏</strong>。</p><p>它真诚坦然姿态，让我反思，游戏能是什么呢？我能做什么呢？</p><h4 id="It’s-just-“something-we-made”"><a href="#It’s-just-“something-we-made”" class="headerlink" title="It’s just “something we made”"></a>It’s just “something we made”</h4><p>之前故意都没讲，Niklas 和 Lucas 将他们自己的小工作室命名为“something we made”，以下是他们放在官网最醒目处的一句话：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/s3o3YV.jpg"></p><h4 id="假设一下……不，事实如此：生活是美好的"><a href="#假设一下……不，事实如此：生活是美好的" class="headerlink" title="假设一下……不，事实如此：生活是美好的"></a>假设一下……不，事实如此：生活是美好的</h4><p>或许还可以回答上上段的问题的是，有另一种感情，自《Toem》传递而来，它使我重燃对于生活的向往，让被心灵鸡汤用烂的朴素哲理重新拥有了生机。</p><p>让我也有了些许冲动，也许也可以整一台二手老相机，漫无目的地出门瞎溜达，来一场小小的冒险，去遇见一个个“时刻”，里面铭刻着美好、奔涌着灵性，是生活里的无价之宝。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT14/u-3826655692035z8R.gif"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><p>我抚摸过宇宙鹿的毛 也摸过走失的小狗 在暴风雪的群山背面见过巨怪 给一家三口气球人和气球小狗庆祝过生日 为音乐家拍下了一段旋律 我知道蜗牛的壳和陨石一样光滑坚硬 见过海底的沉船和水母 也乘巴士去过能看到绚丽极光的山巅<br>真的好像一场现实中会发生的旅行 我徒步看过了那么多不可思议的奇迹 在回家的车上才不住地流下泪来 </p><p>从一开始为了寻找任务而举起相机 到后来不由自主地用镜头捕捉每个可爱的瞬间 </p><p>就像这个故事里很多角色都并非人甚至生物 </p><p>原来生命是被想要看见美的眼睛赋予的</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GT14/jPglR3.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在这款手绘冒险游戏中，踏上愉快的探索之旅，用镜头发掘神奇的TOEM世界。与怪诞有趣的人物聊天，通过拍摄优美的照片来解决他们的问题，并一路观赏令人身心放松的景观！&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>批判二舅视频的小资叙事--作为客体的无言二舅他者与无产阶级生存境况</title>
    <link href="https://yousazoe.top/archives/292f6dd9.html"/>
    <id>https://yousazoe.top/archives/292f6dd9.html</id>
    <published>2022-08-07T12:17:16.000Z</published>
    <updated>2023-01-24T07:20:37.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV12/faon6O.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们都知道他们在凝视着什么，但问题恰恰在于：他们站在何处凝视？</p><span id="more"></span><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><iframe src="//player.bilibili.com/player.html?aid=898762590&amp;bvid=BV1MN4y177PB&amp;cid=783037295&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="批判"><a href="#批判" class="headerlink" title="批判"></a>批判</h3><iframe src="//player.bilibili.com/player.html?aid=814199810&amp;bvid=BV1RG4y1v7hk&amp;cid=796198439&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>前几日，哔站一篇以小资产阶级情调为新自由主义意识形态摇旗呐喊的视频《回村三天，二舅治好了我的精神内耗》突然爆火，视频up主“衣戈猜想”拿鞭炮吓野猪的搞笑娱乐景观遮蔽留守儿童与老人的具体生存境况，以小资产阶级审美意趣的你侬我侬掩埋工人夫妻死亡的实在性创伤，用他自己强加给二舅的乐观面对生活的岁月静好式话语覆盖了残疾的成因和残疾证办不下来的苦难现实，反观祥林嫂和骆驼祥子同样热爱生活，但在他们那里，苦难只是苦难本身，可对某些人来说，苦难的本己性一定要被抹杀掉，只有这样，他们才能把苦难（有时候是他人的苦难）当作某种了不得的好事兴高采烈地接受下来（有时候是让他人接受下来），然后再将这苦难娱乐化、审美化、崇高化，可以说该视频的内容里到处都充斥着这种斯德哥尔摩式性变态的无意识欲望结构和小资产阶级茶余饭后对他者苦难津津有味的咀嚼。</p><p>其次从形式上讲，《二舅》又在以小资产阶级的叙事陈述无产阶级的故事，如果说二舅不能以自己的话语为中介使得自身的存在得以展现，那么视频中无产阶级的声音必然遭遇全方位地抹杀排除，才能让小资岁月静好的审美情调全方位地重构灌注，留守的老人和儿童没有话语、死去的工人夫妇也没有话语，乃至于那个作为“主角”却从始至终一句自己的声音都没有被允许存在的纯粹被小资叙事当作陈列展品一般罗列着展示苦难一生的二舅甚至连一句属于自己的台词都没有，他们生存在视频之内的诗意小资视界里是一副喑哑无声的被拔除了话语的脸孔，而他们生存在视频之外的现实世界里同样也是被他者化与被客体化的纯对象，在这里，视频内外无产阶级被剥夺了主体性对自身生命进行阐解的权力的生存境遇竟然吊诡地联合在了一起——二舅的苦难显然不是他自己的财富，但小资叙事替他高声赞美苦难却可以创造财富，比如去创造up主衣戈猜想的财富，抑或是去创造占有更多被《二舅》打了鸡血的年轻生命剩余价值的老板的财富。</p><p>最后，《二舅》本质是一部为新自由主义意识形态摇旗呐喊的备书视频，正如它的题目“精神内耗”这四个字所表达的含义那样，这个说法不承认外部卷翻天的现实秩序和系统性压迫的存在，而将青年的精神困境说成是和外界完全无关的纯个人的不愿意努力奋斗的问题，这当然最大限度地体现了新自由主义的逻辑基底。再看视频内容，如果说《二舅》整体上还算得上是一部小资产阶级美化和品鉴苦难的“蠢”的作品，那么到了结尾，它邀请其受众一起卷的“坏”就真可谓图穷匕见原形毕露了——“我四肢健全，上过大学，又生在一个充满机遇的时代，我理应度过一个比二舅更为饱满的人生。”</p><p>鼓吹个人奋斗改变命运的新自由主义确实只能依靠凝视/观看他人的苦难来反证出自己的幸福来，这点无可厚非，但这里真正的矛盾之处在于，一个奋斗者理应期待周围更多人以摆烂躺平的姿态从这个卷翻天的竞争体系里彻底退出，这样他自己才会获得更多升职加薪的机会，所以新自由为什么会在精神上需要《二舅》这样的作品将自己的同类更多地召唤出来一起卷呢？原来，那是因为新自由主义者的欲望只是大他者欲望的支流，新自由主义者的思想也只是大他者以最廉价最不消耗产能的形式复制粘贴出来的最简单的单线程思维节点，他们最担心的其实不是自己在竞争中落败，而是这种他们疯狂追求几十年的整个生存都维系其上的权力竞争根本就是一场毫无意义被大他者生生编造出来的荒唐谎言，因此就需要同化一切他者以遮蔽真理的显现，被他们欲望生产出来的《二舅》虽然不符合他们的逻辑，但却很符合他们的道理，因为新自由越是提倡个人奋斗、越是对抗“精神内耗”、越是通过否认外部的不合理来肯定自身意识形态的合理，就越是没有办法在他者那找到任何对其行动价值的承认的合法性凭依，便只能不断从别人的苦难里见证出自己的奋斗的意义，这才是《二舅》在我们今天这个时代能够火起来的真正原因。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MV12/faon6O.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;我们都知道他们在凝视着什么，但问题恰恰在于：他们站在何处凝视？&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>ShaderToy简明教程</title>
    <link href="https://yousazoe.top/archives/e6443aed.html"/>
    <id>https://yousazoe.top/archives/e6443aed.html</id>
    <published>2022-08-05T08:59:48.000Z</published>
    <updated>2022-08-07T08:02:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.behance.net/gallery/73818109/Blego-Blender-Shader"><img data-src="https://img.yousazoe.top/uPic/img/blog/SHADER/pFVZN0.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Shadertoy.com is an online community and tool for creating and sharing shaders through WebGL, used for both learning and teaching 3D computer graphics in a web browser.</p><span id="more"></span><h3 id="简介以及坐标操作"><a href="#简介以及坐标操作" class="headerlink" title="简介以及坐标操作"></a>简介以及坐标操作</h3><iframe src="https://player.bilibili.com/player.html?aid=209900301&amp;bvid=BV1ua411k7DY&amp;cid=463034474&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">{</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">  </span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">1.</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">{</span><br><span class="line">    <span class="type">vec2</span> uv = (fragCoord - <span class="number">0.5</span> * iResolution.xy) / iResolution.xx;</span><br><span class="line">  </span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.</span>;</span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.3</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">length</span>(uv) &lt; r)</span><br><span class="line">    {</span><br><span class="line">        c = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="坐标系统绘制与fwidh函数"><a href="#坐标系统绘制与fwidh函数" class="headerlink" title="坐标系统绘制与fwidh函数"></a>坐标系统绘制与fwidh函数</h3><iframe src="https://player.bilibili.com/player.html?aid=677459040&amp;bvid=BV1Xm4y1X7qU&amp;cid=464337810&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> NumberPlane(<span class="type">vec2</span> uv)</span><br><span class="line">{</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec2</span> cell = <span class="built_in">fract</span>(uv);</span><br><span class="line">    <span class="keyword">if</span>(cell.x &lt; <span class="built_in">fwidth</span>(uv.x))</span><br><span class="line">    {</span><br><span class="line">        color = <span class="type">vec3</span>(<span class="number">1.</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(cell.y &lt; <span class="built_in">fwidth</span>(uv.y))</span><br><span class="line">    {</span><br><span class="line">        color = <span class="type">vec3</span>(<span class="number">1.</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(uv.y) &lt; <span class="built_in">fwidth</span>(uv.y))</span><br><span class="line">    {</span><br><span class="line">        color = <span class="type">vec3</span>(<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(uv.x) &lt; <span class="built_in">fwidth</span>(uv.x))</span><br><span class="line">    {</span><br><span class="line">        color = <span class="type">vec3</span>(<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">{</span><br><span class="line">    <span class="type">vec2</span> uv = (<span class="number">2.</span> * fragCoord - iResolution.xy) / <span class="built_in">min</span>(iResolution.x, iResolution.y);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    fragColor = <span class="type">vec4</span>(NumberPlane(uv), <span class="number">1.</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="线段绘制、clamp与mix函数"><a href="#线段绘制、clamp与mix函数" class="headerlink" title="线段绘制、clamp与mix函数"></a>线段绘制、clamp与mix函数</h3><iframe src="https://player.bilibili.com/player.html?aid=592528307&amp;bvid=BV1oq4y1271G&amp;cid=465667453&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="smoothstep函数"><a href="#smoothstep函数" class="headerlink" title="smoothstep函数"></a>smoothstep函数</h3><iframe src="https://player.bilibili.com/player.html?aid=295068556&amp;bvid=BV1EF411B7Mo&amp;cid=467779233&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="函数绘制的优化、mod与超采样"><a href="#函数绘制的优化、mod与超采样" class="headerlink" title="函数绘制的优化、mod与超采样"></a>函数绘制的优化、mod与超采样</h3><iframe src="https://player.bilibili.com/player.html?aid=210186263&amp;bvid=BV1Ka411r7yK&amp;cid=469271756&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="2D符号距离函数"><a href="#2D符号距离函数" class="headerlink" title="2D符号距离函数"></a>2D符号距离函数</h3><iframe src="https://player.bilibili.com/player.html?aid=550355531&amp;bvid=BV1Ci4y1X7EG&amp;cid=475729129&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="Ray-Marching"><a href="#Ray-Marching" class="headerlink" title="Ray Marching"></a>Ray Marching</h3><iframe src="https://player.bilibili.com/player.html?aid=592966932&amp;bvid=BV18q4y1271t&amp;cid=476598275&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="3D摄像机设置"><a href="#3D摄像机设置" class="headerlink" title="3D摄像机设置"></a>3D摄像机设置</h3><iframe src="https://player.bilibili.com/player.html?aid=680555987&amp;bvid=BV1PS4y1j7Xg&amp;cid=479847858&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="矩阵的SDF函数"><a href="#矩阵的SDF函数" class="headerlink" title="矩阵的SDF函数"></a>矩阵的SDF函数</h3><iframe src="https://player.bilibili.com/player.html?aid=680806558&amp;bvid=BV1zS4y157de&amp;cid=489094915&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="多物体与阴影"><a href="#多物体与阴影" class="headerlink" title="多物体与阴影"></a>多物体与阴影</h3><iframe src="https://player.bilibili.com/player.html?aid=465967653&amp;bvid=BV1HL411F74d&amp;cid=493087903&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="软阴影的实现原理"><a href="#软阴影的实现原理" class="headerlink" title="软阴影的实现原理"></a>软阴影的实现原理</h3><iframe src="https://player.bilibili.com/player.html?aid=678390849&amp;bvid=BV1sm4y1S7Kh&amp;cid=493592768&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="多物体着色与棋盘贴图"><a href="#多物体着色与棋盘贴图" class="headerlink" title="多物体着色与棋盘贴图"></a>多物体着色与棋盘贴图</h3><iframe src="https://player.bilibili.com/player.html?aid=678587219&amp;bvid=BV1bm4y1f7B5&amp;cid=494480968&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><iframe src="https://player.bilibili.com/player.html?aid=852079009&amp;bvid=BV1pL4y1u7Cz&amp;cid=543142885&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="Smooth-Minimum"><a href="#Smooth-Minimum" class="headerlink" title="Smooth Minimum"></a>Smooth Minimum</h3><iframe src="https://player.bilibili.com/player.html?aid=595609612&amp;bvid=BV1CB4y1m7V8&amp;cid=573847748&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="环境光遮蔽"><a href="#环境光遮蔽" class="headerlink" title="环境光遮蔽"></a>环境光遮蔽</h3><iframe src="https://player.bilibili.com/player.html?aid=853610688&amp;bvid=BV1KL4y1c79A&amp;cid=587623240&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h3><iframe src="https://player.bilibili.com/player.html?aid=469271198&amp;bvid=BV1T5411X7dR&amp;cid=726569034&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="2D分形绘制"><a href="#2D分形绘制" class="headerlink" title="2D分形绘制"></a>2D分形绘制</h3><iframe src="https://player.bilibili.com/player.html?aid=983275371&amp;bvid=BV12t4y1b79q&amp;cid=770922515&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.behance.net/gallery/73818109/Blego-Blender-Shader&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/SHADER/pFVZN0.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Shadertoy.com is an online community and tool for creating and sharing shaders through WebGL, used for both learning and teaching 3D computer graphics in a web browser.&lt;/p&gt;</summary>
    
    
    
    <category term="ShaderToy简明教程 (ShaderToy Simple Tutorial)" scheme="https://yousazoe.top/categories/ShaderToy%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B-ShaderToy-Simple-Tutorial/"/>
    
    
    <category term="Shader" scheme="https://yousazoe.top/tags/Shader/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fl0w3r</title>
  
  <subtitle>carpe diem</subtitle>
  <link href="https://yousazoe.top/atom.xml" rel="self"/>
  
  <link href="https://yousazoe.top/"/>
  <updated>2022-07-28T14:03:06.000Z</updated>
  <id>https://yousazoe.top/</id>
  
  <author>
    <name>Yousazoe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Open Yale Courses--Death</title>
    <link href="https://yousazoe.top/archives/b4f250e7.html"/>
    <id>https://yousazoe.top/archives/b4f250e7.html</id>
    <published>2022-07-28T02:16:29.000Z</published>
    <updated>2022-07-28T14:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/DEATH/PoxbFP.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最受欢迎的国际名校公开课之一《哲学：死亡》中，谢利卡根教授挑战了对于死亡，许多我们习以为常或未经深思的观点，邀请学生系统反思死亡的哲学之谜，以更清晰的概念探讨死亡的意义为何，从形而上学到价值观，认真、理性地思考生命和死亡的真相。有了对死亡的深刻意识，才会有对生命价值的深刻了解。</p><span id="more"></span><h3 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430043964&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>这是一本关于死亡的书。但它是一部哲学著作，这就意味着，我们将要讨论的主题有别于其他关于死亡的书可能涵盖的主题。所以，我想做的第一件事情就是，谈谈我们不会讨论哪些话题。你也许期待或希望一本关于死亡的书会讨论这些话题，这很合理，但是我不会去讨论它们，所以你马上就能意识到这是不是你要找的书。<br>说到我们不会讨论的话题，我主要想到的是关于死亡的本质或现象的心理学、社会学问题。比如，一本关于死亡的书可能会详细地讨论死亡的过程，或人们慢慢接受自己终有一死这一事实。我们不会谈论这些。类似地，我们也不会谈论悲伤或丧亲之痛的过程。我们不会讨论美国的殡葬业，或我们对待死亡的恼人态度，或我们如何倾向于避免面对死亡。这些话题都很重要，但是在这本书中我们不会去讨论它们。<br>那么，我们将讨论什么呢？我们将讨论开始思考死亡的本质时出现的哲学问题，诸如：我们死亡时发生了什么？不过，为了着手谈论这一问题，我们首先要思考：我们是什么？人是怎样的一种实体（entity）？尤其是，我们有灵魂（soul）吗？<br>在一开始，我还要解释一下，在本书中我把“灵魂”当作一个哲学术语来使用。我用“灵魂”一词指某种非物质的（immaterial）、完全不同于我们肉体（body）的东西。所以，我们要问的一个问题是，我们有非物质的灵魂，即某种在我们的肉体死亡后会存活下来（survive the death of the body）的东西吗？如果没有，这对死亡的本质来说意味着什么？我们死亡时发生了什么？<br>我们还会问：我死后仍存活下来（survive my death）需要哪些条件？事实上，我们要问，普遍说来，对我来说活着到底是什么意思？比如，对我来说活着，好比说今晚活着是什么意思？这大体上就是我问这个问题的意思。在明天下午的某个时候，某个人会坐在我的电脑前写这本书，我当然会假定（并且希望！）那就是我。但是，如果说那个明天坐在这里打字的人，跟今天坐在这里打字的人正是同一个人，这到底是什么样的状况？这是人在时间中的同一性（personal identity）问题。显然，我们如果要恰当地思考死亡和存活，以及我死后继续存在的可能性，首先要弄清个人同一性的本质。<br>本书的前半部分将用大部分篇幅来讨论灵魂的存在、死亡的本质以及死后存活的可能性等问题，然后我们会回到价值问题上。如果死亡真的是终点，那么死亡会很糟糕吗？当然，大部分人很有可能会立刻认为死亡是很糟糕的。但死亡为何会那么糟糕，这其中有哲学之谜。<br>现在，我要试着让你马上感受一下死亡的一个难解之处。假设我死后就不存在了，如果你想一想，你很难看出死亡为何对我来说会是一件坏事。毕竟，当我死了之后，死亡对我来说好像不可能是坏事：对于某种根本就不存在的东西，怎么会发生任何坏事？如果我死后，死亡对我来说不是坏事，那么它对我来说怎么会是坏事呢？毕竟，现在我还活着的时候，看上去死亡对我肯定不会是坏事！</p><p>别担心，我不会努力劝服你，说死亡不是坏事。但是我们将会看到，要准确地厘清死亡到底坏在哪里，以便看到死亡怎么可能是一件坏事，这是要下点儿功夫的。（还有个问题值得一问：是否不止一点使死亡成了坏事。）现在，如果死亡真的是一件坏事，那么你可能会问，永生不朽（immortality）会不会是一件好事？这是我们将要思考的另一个问题。普遍来说，我们要问的是：我将会死掉这一事实将怎么影响我活着的方式？对我会死掉这一事实，我应该持何种态度？比如，我该不该害怕死亡？我该不该对终有一死这一事实感到绝望？<br>最后，我们会转向自杀问题。许多人认为，鉴于生命很有价值、很珍贵，我们永远都没有道理去自杀。毕竟，那是在放弃你所能拥有的唯一的生命。所以，在本书的最后，我们会考察自杀的理性和道德（或者，也许应该说是自杀的非理性和不道德）。<br>上述这些是我们要讨论的问题。对于熟悉相关哲学术语的人，可以粗略地说，本书的前半部分是形而上学，后半部分是价值理论。<br>现在有两种不同的撰写哲学著作的方式，尤其是这样的导论读物。在第一种方式中，你只是简单地列出各种可选立场，从正反两方面辩论，而你尽量保持中立。你不会一开始就公开站在某一边，而是避免暴露你接受的特定立场。这是第一条道路。但你也可以采取一种非常不同的道路。要提醒你的是，在本书中我将采取第二条道路。在第二条道路中，你会告诉读者你所接受的观点，并为这些观点争辩，竭尽全力地为它们辩护。这更接近于我接下来的做法。我将形成一种特定的思想路线，并为之做出辩护。也就是说，关于我将讨论的问题，我持有一套观点，而我在本书中将努力说服你认为这些观点就是正确的。<br>为了帮你迅速弄清这些观点，我首先要描述一下跟它不同的另一套观点，那是许多其他人所接受的观点。这种常见观点包含了许多逻辑清晰的主张。从逻辑上说，你可以相信这套主张中的一些而非全部，也有许多人确实全盘接受，由此我估摸着你也很有可能相信至少其中的一些主张。<br>这套常见的观点是这样的。首先，我们拥有灵魂。也就是说，我们不只有肉体，我们不只是一块块肉和骨头。相反，我们还有一部分，也许正是那核心的部分，某种不只是物理的（physical）东西，它是我们精神的、非物质的部分。如我所说，在这本书中我将称它为灵魂。大部分人都相信有灵魂，或许你也相信。大部分美国人都相信存在着某种非物质的灵魂。这种常见的观点接着认为，由于这种非物质的灵魂存在，我们很有可能死后仍然活着。死亡是我们肉身的灭失，但是我们的灵魂是非物质的，所以在我们死后会继续存在。当然，关于死亡有许多我们无法了解的东西，死亡是终极之谜。但是，不管你是否相信有灵魂，你可能至少会希望存在灵魂，因为那样你就很有可能死后仍活着。毕竟，死亡不仅是坏事，还可怕到令我们希望永远活着。永生会是多么美妙。如果有了灵魂，至少就有永生的可能。无论如何，我们希望如此——我们是不朽的灵魂——不管我们是否知道实情。如果没有灵魂，如果死亡真的是终点，那事情真是坏透了，以致我们显而易见的、恰当的、普遍的反应，就是带着恐惧和绝望面对死亡的前景。最后，鉴于死亡是这么可怕，生命是这么美好，放弃你的生命就永远都是没有道理的。因此，一方面，自杀总是非理性的；另一方面，它总是不道德的。<br>我刚才说了，这些是关于死亡的本质的常见观点。接下来我要做的，就是在这本书中证明，这套观点是相当错误的。我要试着让你相信，没有什么灵魂；我要试着让你相信，永生不会是一件好事；畏惧死亡实际上不是对死亡的恰当反应；死亡并非特别神秘；自杀在某些情况下，可能既理性又合乎道德。我认为常见的对死亡的想象是相当错误的，而我的目标是，让你们也相信这一点。<br>很自然地，我希望到这本书的最后你会同意我的观点。毕竟，我认为自己为之辩护的观点是正确的，我非常希望你最后相信这一事实。<br>但是我还要说，对你来说，关键不是最终同意我的观点，而是要为自己思考。归根结底，我要做的最重要的事情是邀请你严肃、认真地思考死亡，以一种大部分人从未采用过的方式去面对它、思考它。如果在这本书的最后，你没有同意我的某个主张，那就随它去吧，我已经很满足了。好吧，我不会完全感到满足，但是至少我会感到很大的满足，只要你真的思考过了这许多问题正反两方面的论证。<br>在开始之前，我要再说一两点。首先，我已经解释过，这是一部哲学著作。基本上，这意味着，我们将试着用自己的推理能力来仔细思考，关于死亡我们能知道什么，或者能弄清楚什么。我们将从理性的角度来思考死亡。<br>所以，我需要说清楚，有一种证据和论证我们不会在本书中使用，那就是诉诸宗教权威。当然，你可能已经相信来世的存在，可能相信你死后将继续存活，可能相信永生。当然，你可以相信所有这些东西，因为你的教堂就是这么教你的。没关系。我的目标和意图不是让你脱离你的宗教信仰，或者反对你的宗教信仰。但是我确实希望先说清楚，在本书中我不会诉诸宗教论证，不管是天启，还是《圣经》的权威，还是你信奉的什么。<br>如果你愿意，你可以把这本书当作一个巨大的假说。如果我们不得不从世俗的视角来思考，那么关于死亡的本质我们将得出怎样的结论呢？相对于神圣启示给出的权威答案，只使用我们自己的推理思考能力，我们会得出怎样的结论？如果你刚好相信神圣启示，不妨换个时间再讨论，我们只是不会在这里争论它。<br>最后，我要解释一下“这是一部导论性哲学著作”是什么意思：这意味着本书没有在话题中预设任何背景，但这也并不等于说它好懂。实际上，其中一些材料是很难懂的，有些思想可能很难一下子就把握住。事实上，如果你有时间的话，把某些部分读个两遍会很有帮助。当然，我不是真的指望你这样做，但要提醒你：哲学是很难懂的。<br>我还要强调，“这是一部导论性著作”有其第二层含义，即我们将要讨论的每个话题都可以延展开来。它们都可以用长得多的篇幅加以追问，超出我们将要考虑的论证之外，总是有更深入的论证。许多这样的论证很快都会变得极其复杂，复杂到无法在这样的著作中加以讨论。对于我们将要考察的每个话题来说，确实都是这样的。<br>所以读完之后，不要以为关于这些话题我的意见都已经是定论了。其实，它们更像是初步观点（first words）。但是，当然了，初步观点会是很好的起点。</p><h3 id="人的本质：二元论与物理主义"><a href="#人的本质：二元论与物理主义" class="headerlink" title="人的本质：二元论与物理主义"></a>人的本质：二元论与物理主义</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430044989&amp;page=2&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>提问<br>我们要讨论的第一个问题跟死后存活的可能性有关。死掉之后还有生命吗？我死后至少还有仍然存在（exist）的可能吗？<br>表面看来，要回答这个问题，我们至少需要弄清楚两个基本的问题。第一，我到底是什么？我到底是何物？或普遍来说，因为我不仅想知道我自己死后的存活机会，还想知道所有人的，所以会问：人到底是何物？我们是由什么构成的？我们有哪些组成部分？<br>顺理成章地，在回答“我能存活下来吗”之前，我们需要了解自己是如何构成的，所以首先要做的是花点儿时间弄清人的基本“构件”。我们需要确定人是什么。<br>第二，我们要弄清：到底何谓存活（survive）？如果我们想知道死后存活的可能性，最好先弄清“存活”这一概念。那个将来作为我存在的到底是什么？<br>现在，关于存活的本质，即在时间中持续存在这一问题，可以用非常通俗的术语来讨论。我们可以讨论椅子、桌子、树木，或者任何东西的存活。我们可以问：同一个东西在时间中持续存在是怎么回事？或者，更抽象地说，在时间中持续的同一性（persistence of identity）的本质是什么？<br>但我们特别感兴趣的是像我们这样的存在——人类。我们尤其感兴趣的是弄清一个人在时间中持续存在需要具备什么条件。哲学家们称这个问题为“个人的同一性”（personal identity），也就是人在时间跨度中的同一性问题（同一个人在两个不同的时间中）。比如说，下周会有好几个人住在我家，我非常希望他们其中一人是我。但是，如果说其中一人下周正好是我，就是此刻坐在桌子前的这个人，这是什么意思？是什么使得那个人跟这个人一样？简单来说，就是个人同一性的本质是什么？或者，如果我们用存活的语境来提问：一个人的存活需要具备什么条件？<br>所以，从表面看来，为了弄清我死后是否活了下来，或可能存活，我们至少需要知道人是什么，我们需要弄清存活的本质，或者（更具体的话）个人在时间中的同一性。毫无疑问，我们将用几章来仔细地研究这些问题。<br>但是在开始之前，我们要考虑对这一整体计划的一个反驳。我们要花许多时间来讨论这个问题：死后有生命吗？或者死后可能有生命吗？我死后能不能存活？然而，根据我脑中的这一反驳，整个复杂的研究都是一种误解，它基于一种混淆。这种反驳意见说，一旦我们看出这一混淆，就能看出我们提问的确凿答案。我死后还能不能活着？当然不能！<br>如果这是对的，我们的讨论就简单多了。但它对不对呢？这种反驳是这样说的(1)：<br>对于我们发问的这个问题，一种陈述方式是：死后有没有生命？但这个问题是什么意思？假如我们一开始问，一个人死了（has died）是什么意思，那么“死亡”（death）一个很自然的定义是，它类似于“生命的终止”。但如果真是这样，那么问“死后有没有生命”，就像在问：“生命终止之后有没有生命？”对此的回答应该很明显，答案是没有。问死后有没有生命，就像稀里糊涂地问你的生命耗尽了之后还有没有生命。哦，咄！当然没有！这就好比问：我吃光了盘子里的食物之后，盘子里还有没有食物剩下？或者，电影结束了之后电影会怎样？这是愚蠢的问题，因为一旦你明白了你问的是什么，答案就包含于其中了。答案不言而喻。<br>所以，这种反驳意见接着说，虽然很久以来人们觉得“死后有没有生命”是一个巨大的谜，是重大的哲学问题之一，但这真的只是一种错觉。实际上，一旦你思考它，你就能看出答案必然是：没有。死后不可能有生命，生命结束之后不可能有生命。<br>或者，假如我们以稍微不同的方式来问：我能从我的死亡中存活下来吗？那么，“存活下来”一词是什么意思？我们说某人从某件事中存活了下来，比如有一次意外或者一场病，他没有死，他还活着。比如，发生了车祸，你可能会说某位先生去世了，某位女士存活了下来，而说她存活了下来就等于说她还活着。所以，问“我能不能从我的死亡中存活下来”，就好比问“我死后还能活着吗”。而死亡是什么？死亡是生命的终结。所以，问能不能从自己的死亡中存活下来，其实是问：我停止生存之后还能不能活着？我是不是一个死的时候没有死去的人？答案又是：咄！当然不能！鉴于存活的定义，你不可能从你的死亡中存活下来。<br>这一反驳总会让我想起小时候的一则笑话。你可能听过这个笑话，7岁的时候它会让你抓狂。它听上去就像一个谜语：“一架飞机在加拿大和美国边境坠机。人们该把幸存者埋到哪里？加拿大还是美国？”7岁的时候，你会想，“我不知道他们会把幸存者埋在哪里，会埋在加拿大吗？还是会埋在美国？”但答案当然是：你不会把幸存者埋起来！幸存者是还没有死的人！所以问“我能不能从我死亡中存活下来”，就像问“我死后是不是还没有死”，答案当然是：不是！如果你死了，那么显然你没有存活下来，这一问题根本无从谈起；它实际上不是一个开放的问题。至少这个反驳是这么说的。<br>在这里，我不想彻底拒绝考虑这一反驳，所以才用好几段话来详细地说明它，但我认为有一种回应它的办法。我们需要做的是，搞清楚我们想问的到底是什么，那么接下来我会试着把这个问题提得更准确些。关键是，使它成为一个真正开放的问题，一个我们可以合理地提出的问题。<br>我将在本书中多次提醒大家，我是一位哲学家。这意味着：我所知的事实并非包罗万象。所以，对于我即将给你讲的故事，有些地方我希望自己知道那些事实，但是我不知道。因此，为了讲好这个故事，我应该邀请一位客座作者，一位杰出的生理学家来给我们提供我不知道的事实。但我并没有，我只是假装这样做。我会说“之类之类”，然后在应该请出我们的客座生理学家时，我会捏造相关的细节。没关系，对我们的目的来说，细节没有那么重要。<br>请想一下一具肉体死亡时发生了什么。无疑，你可以用各种方式杀死一个人。你可以毒死他，你可以勒死他，你可以向他的心脏开枪。他可以死于自然原因，比如心脏病突发，或者中风，或者癌症。导致死亡的也许是不同的起因，但是假定这些原因殊途同归，你最终都要经历一系列事件。这是些什么事件？这正是我不知道细节的地方，但是我会按照下面的情况来理解。不论何种原初的致死缘由，最终血液不再循环，氧气无法在肉体里流通，导致大脑开始缺氧。由于细胞逐渐缺氧，无法继续开展各种代谢过程，它们便无法按需修复自身遭到的各种损害，或者生产它们所需的氨基酸和蛋白质。随之细胞开始衰败，细胞结构开始崩溃，无法照常修复。最后，关键的细胞结构毁掉了，然后轰的一声，肉体死了。如我所说，我不知道自己描述的是否准确。我刚才讲的是一个粗略的故事，但是类似的故事大体上是真的。<br>我已经给你勾勒出了这个故事。这就是肉体死去时体内所发生的事件，尽管我并不真的知道其细节。我们可以称这些事件为B1，B2，B3，直到Bn（B代表body，肉体）。在B1开始前，你的肉体还在运行，按照肉体的方式正常地工作着，呼吸、繁殖细胞，等等。在这一过程的最后，即Bn，就是肉体的死亡。从B1到Bn，就是死亡的过程。至少，这是肉体之死（death of the body）。医学院的人士、生物学家或生理学家会这样向我们描述。<br>假定我们把这一过程称为“肉体之死”，把这一序列最后发生的事件称为“肉体之死”。现在我们仍可以问，或至少看起来可以问：我还能不能，或者我是否，在我的肉体死后仍然存在着？我能不能在肉体死亡后仍然存在着？我的意思不是说我们已经知道这个问题的答案，但至少看上去我们可以顺理成章地这么提问。问我的肉体死后我还能不能存在，这里并没有明显的荒唐之处。答案可能会是“不能”，但至少不是“显然不能”，这需要持续的论证才能以这种或那种方式下定论。从我们目前知道的来判断，答案最后可能是肯定的。这只是把我们带回了这一想法：我的肉体死后我是否能够存在，好像取决于我是什么。所以，我们马上要讨论这个问题。<br>但老是问“我的肉体死后，我能不能继续存在”有些累赘不便。在澄清了要问的问题之后，我们可以换一种方式来重新表达它，不是坚持问“我的肉体死后，我是否能够继续存在”，而是有时用这样的问法来代替：我能从我的肉体之死中存活下来吗？这么问也无妨。或者，我们甚至可以这样问：我死后能继续存在吗？这实质上也并无不妥。实际上，我们可以规定，当我们在这类问题的背景下谈论“我的死亡”时，我们要谈论的是我“肉体的死亡”。所以问“我死后能继续存在吗”，不过是“我的肉体死后，我能存活吗”的简略形式，这样做没什么妨碍。即使我们问“死后有生命吗”，也没有关系。我们可以安全地假定，当我们这样问的时候，只是在问，“即使在我的肉体死亡后，我是否还依然存在”。这确实像是一个非常合理的问题。让我们试着来回答它。<br>两种观点<br>如我已经提出的，如果我们想回答“我的肉体死后，我是否能够继续存在”这一问题，我们首先要搞清我是谁。毕竟，一个人能否从肉体之死中存活下来应该取决于（至少部分地取决于）他是怎样构成的——他是由什么组成的，又有哪些部分。我们需要知道人是什么。用哲学术语来说，这是一个关于人的形而上学的问题。<br>我来简述一下关于这个问题的两种基本立场。我想，这两种立场你都很熟悉，我们要做的是选择其中之一。确实，关于人的形而上学，这两种立场并非仅有的可能立场，但我认为它们是两种最突出的立场，而且对于我们的目的来说，它们肯定是最值得去探索的立场。<br>第一种可能的立场是这样的：人是肉体和另一种东西——心灵（mind）——结合而成的。但这第一种观点的关键之处是，心灵被认为是一种独立于、区别于肉体的东西。用一个常见的词来说，它是灵魂。所以人是，或者人有，或者人包含着，肉体和灵魂。如我所说，灵魂是某种区别于肉体的东西。<br>现在，假定我们都很熟悉肉体的概念。以我为例，我的肉体是一团肌肤、骨头和肌肉，它正坐在我的电脑屏幕前，我每天拖着它到处走动。你也有一个肉体，你也拖着它四处走动。对于这种东西，我们可以放在秤上称重、用棍子戳、生物学家可以去研究，它由各种分子、原子等组成。所以，肉体是人们拥有的一种东西。但是照第一种观点看来，我们还有一种不是肉体的东西，一种非物质的对象，它不是由分子和原子组成的。它是灵魂，它是意识、思维，或许还是人格的居所、所在地和基础。无论是以上哪种情形，关键的是，要想从形而上学的角度恰当地理解心灵，就要用非肉体、非物质的术语来谈论它，即把它当作灵魂。<br>我们可以把这第一种观点称为二元论（dualism），因为它设定人有两种基本的组成成分，肉体和灵魂。接下来我们将把“灵魂”一词留给这种二元论观点，根据这种观点，灵魂是一种非物质的、非肉体的东西，它跟肉体相反。肉体是物质实体，灵魂是非物质实体。这是二元论观点。<br>这便是第一种基本观点。稍后我会接着谈它，先让我来简述一下另一种基本观点。<br>我们要考虑的另一种观点不是二元论，而是一元论。它说，组成人的只有一种基本的东西：肉体。那什么是人呢？人只是一种物质对象，只是一具肉体。由于这第二体的死亡”。所以问“我死后能继续存在吗”，不过是“我的肉体死后，我能存活吗”的简略形式，这样做没什么妨碍。即使我们问“死后有生命吗”，也没有关系。我们可以安全地假定，当我们这样问的时候，只是在问，“即使在我的肉体死亡后，我是否还依然存在”。这确实像是一个非常合理的问题。让我们试着来回答它。<br>两种观点<br>如我已经提出的，如果我们想回答“我的肉体死后，我是否能够继续存在”这一问题，我们首先要搞清我是谁。毕竟，一个人能否从肉体之死中存活下来应该取决于（至少部分地取决于）他是怎样构成的——他是由什么组成的，又有哪些部分。我们需要知道人是什么。用哲学术语来说，这是一个关于人的形而上学的问题。<br>我来简述一下关于这个问题的两种基本立场。我想，这两种立场你都很熟悉，我们要做的是选择其中之一。确实，关于人的形而上学，这两种立场并非仅有的可能立场，但我认为它们是两种最突出的立场，而且对于我们的目的来说，它们肯定是最值得去探索的立场。<br>第一种可能的立场是这样的：人是肉体和另一种东西——心灵（mind）——结合而成的。但这第一种观点的关键之处是，心灵被认为是一种独立于、区别于肉体的东西。用一个常见的词来说，它是灵魂。所以人是，或者人有，或者人包含着，肉体和灵魂。如我所说，灵魂是某种区别于肉体的东西。<br>现在，假定我们都很熟悉肉体的概念。以我为例，我的肉体是一团肌肤、骨头和肌肉，它正坐在我的电脑屏幕前，我每天拖着它到处走动。你也有一个肉体，你也拖着它四处走动。对于这种东西，我们可以放在秤上称重、用棍子戳、生物学家可以去研究，它由各种分子、原子等组成。所以，肉体是人们拥有的一种东西。但是照第一种观点看来，我们还有一种不是肉体的东西，一种非物质的对象，它不是由分子和原子组成的。它是灵魂，它是意识、思维，或许还是人格的居所、所在地和基础。无论是以上哪种情形，关键的是，要想从形而上学的角度恰当地理解心灵，就要用非肉体、非物质的术语来谈论它，即把它当作灵魂。<br>我们可以把这第一种观点称为二元论（dualism），因为它设定人有两种基本的组成成分，肉体和灵魂。接下来我们将把“灵魂”一词留给这种二元论观点，根据这种观点，灵魂是一种非物质的、非肉体的东西，它跟肉体相反。肉体是物质实体，灵魂是非物质实体。这是二元论观点。<br>这便是第一种基本观点。稍后我会接着谈它，先让我来简述一下另一种基本观点。<br>我们要考虑的另一种观点不是二元论，而是一元论。它说，组成人的只有一种基本的东西：肉体。那什么是人呢？人只是一种物质对象，只是一具肉体。由于这第二种观点仅仅将人视为一种特殊的物理对象（physical object），我们把它称为物理主义（physicalism）。<br>在这第二种观点看来，人只是物质对象，即一种物理的东西。当然，人是一种非常神奇的物质对象。实际上，人这种物质对象令人称奇。毕竟，按照这第二种观点，人这种物理对象能够做大部分其他物理对象不能做的事情。我们能说话，我们能思考，我们能歌唱，我们能写诗，我们能恋爱，我们能害怕，我们能制订计划，我们可以认识宇宙。根据这种物理主义观点，人只是能做所有这些事情的肉体：思考、理性、沟通、制订计划、恋爱、写诗。这是物理主义的观点。<br>这样我们就有了两种基本立场。有二元论的观点，认为人有肉体和灵魂；还有物理主义的观点，认为不存在灵魂，我们没有那样的非物质对象，我们只有肉体，虽然像我们肉体这样正常运行的肉体（据物理主义者们所说）能做一些委实神奇的事情。二元论和物理主义是我们将考察的两种基本观点。<br>从逻辑的角度来看，我假定你还有第三种可能的观点。既然有认为人只有肉体没有灵魂的一元论者，你也可以想到有人说存在灵魂但是没有肉体！比如，可能有一种形而上学观点，认为存在心灵（实际上是非物质的心灵：灵魂），但是根本没有任何物质对象，存在的只有灵魂以及它们的观念。搞不好我们是为了比较方便地谈论心灵拥有的观念，才谈什么物理对象。从物质的角度来思考物理对象，可能只是一种我们很容易就会陷入的幻觉，一种形而上学的错误。在哲学上，这种观点叫唯心主义。<br>实际上，唯心主义在哲学上有着悠久、卓越的历史。在更加彻底地研究形而上学时，我们值得花时间更细致地讨论它。但就我们的目的而言，我认为它不是一个竞争者。所以，我将把它暂且放下。<br>还有其他可能的观点。比如，有一种观点认为，谈论心灵和肉体只是两种看待同一潜在现实的不同方法，背后的现实从根本上既不是物理的，也不是精神的。这种观点——中立一元论——可能在形而上学著作中值得讨论，但就我们的目的而言，我提一下之后也要把它撇开不谈。<br>在本书中，我们不会考虑在讨论人的形而上学本质时才会关心的各种奇异的哲学立场。相反，我们将集中关注我认为是最有力的两个竞争者，物理主义和二元论。要指出的是，这两种观点都接受肉体的存在，就像在我的设定中你的观点一样，它们的区别只在于我们是否也需要接受非物质的灵魂的存在。二元论者说“是”：人有灵魂，或者人是肉体也是灵魂。物理主义者说“不是”：我们只有，或只是肉体。<br>二元论<br>让我再谈谈二元论的立场。首先也是最重要的，二元论者认为，心灵是非物质实体。我们可以用不同的名字来称呼这一实体。实际上，如果我们就叫它“心灵”，也并无不妥。但是在讨论二元论时，我通常会谈论灵魂，以此来标示出二元论观点的关键之处，即认为心灵基于或心灵就是某种非物理、非物质的东西。<br>其次，二元论者认为，肉体和灵魂相互作用。一方面，灵魂可以指挥和命令肉体。比如，就在现在，我的肉体在键盘上打字。二元论者认为，它这么做是由于我的灵魂的命令。我的灵魂可以让我的肉体起立、坐下，或在房间里四处走动。所以，灵魂可以以各种方式作用于肉体。但另一方面，灵魂也会受到肉体的反作用，肉体发出的输入指令最终会被灵魂感知或感觉到。如果你拿起一个大头针，刺破我肉体上的肉，我的灵魂、我的心灵会感到疼痛。所以，作用是相互的：肉体会影响灵魂，灵魂也会影响肉体。当然，如哲学中常有的情形一样，在更为复杂的二元论版本中，交互作用不是双向的，但让我们限制在传统的、双向交互作用的二元论上。我的灵魂控制着我的肉体，我的肉体也会影响我的灵魂。当然，虽然能够相互作用，肉体和灵魂还是相互独立的。不过，通常在各种事件上，它们都存在着非常紧密的联系。<br>虽然“灵魂的处所”这个问题对我们的目的来说并不是非常关键，但还是值得花点儿时间来谈谈。如果存在着灵魂，它们在哪里？实际上，灵魂会有处所吗？我认为答案并不是显而易见的。一方面，我们言谈间好像灵魂是有处所的，我们说灵魂在肉体中。当然，这并不是说我们认为如果你打开肉体，就会发现灵魂所处的某个地方。但好像很自然地，我们认为灵魂至少有一个大致的处所。毕竟，我从这里观看世界，就像你在从另一个不同的地方观看世界一样。所以，也许你的灵魂多多少少正处于你的肉体附近。<br>只要你的肉体在正常运行，这也许就是真的。说不定死亡时，灵魂就会从肉体获得解放，更加自由地四处游荡。实际上，没准我们活着的时候有时都会发生这种事情。有人就记录过灵魂出窍的经历，它们好像抛开肉体，四处游荡。在这样不同寻常的时刻，灵魂也许离开了肉体，后来又返回来。当然，即使这都是真的，灵魂出窍是可能的，然而在既定的时间，灵魂仍处在某个地方，哪怕它不一定就在肉体所在的地方。<br>另一方面，也许这都是幻觉，也许灵魂根本没有任何处所，也许我有一个处所的感受，实际上只是我从我的肉体获得的所有感觉输入形成的幻觉。想象一下，一个人被锁在纽黑文的一个房间里，他能看到的只有设在芝加哥的一个远程摄像头拍到的图像，他能听到的只有放在芝加哥的远程麦克风录下的声音，诸如此类。如果他经历的只是这些，你就会明白，为何他会误以为自己置身于芝加哥，因为所有的感官输入都源自芝加哥。说不定灵魂就是这样运作的，我们被骗了，以为我们处于我们的肉体所在的地方，但也许这只是形而上学的幻觉：搞不好灵魂根本没有处所。<br>说实话，对于非物质对象应该如何运作，我所知甚少（非物质实体竟能有处所吗？我不知道）。如我已经解释的，我自己不相信灵魂，我不认为二元论立场是正确的。我会把“灵魂是否在空间上有一个处所”这一问题丢给那些相信灵魂的人。好在对于我们的目的来说，我认为这个问题无关紧要。如果你想说灵魂有一个处所，也许你会满足于说，它们（通常）差不多跟与之相应的肉体处于同一个地方。但是，如果你更倾向于说，相反，灵魂根本没有自己的处所，这也不成问题。<br>就我们的目的来说，重要的是二元论的这一主张：存在着灵魂，它通常与它相互联系的肉体不同，它是非物质的实体。如果存在着肉体，也存在着灵魂，而且灵魂是非物质的，那么即使肉体死了，灵魂也可能继续存在！<br>这是某个人活着的肉体，令人难过的是，它生病了。我们经历了从B1到Bn的过程，到了最后的Bn，肉体停止自我修复。肉体开始衰败，肉体死亡了。我们都知道这个悲伤的故事：蛆虫钻进来，蛆虫爬出去。一天过去了——好吧，也许不只一天——肉体分解了。是的，这都证明了肉体的终结。但如果灵魂是一种非物质、非物理的东西，那么它可以继续存在，哪怕肉体已经坏了。这是二元论吸引人的地方之一。相信灵魂的存在，给了你一种你的肉体终结之后会继续存在的东西。<br>那么死亡是什么？好吧，如果我的灵魂和肉体之间有着紧密的联系，死亡可能会切断这种联系。肉体坏了，再不能给心灵传去输入指令；灵魂再不能够控制肉体，让它四处走动。但即使如此，灵魂也可能继续存在。至少，有这种可能。如果我是二元论者，那么我死后继续存在的可能性就值得斟酌。<br>但是仍有一种怀疑。二元论认为，人是肉体和灵魂的联合：一种肉体和灵魂的三明治。如果人是一种联合，如果人是成对的——灵魂加上肉体——那么当你毁掉肉体之后，你不就毁掉了这个人？毕竟，当你毁掉了成对的东西中的一部分，这一对就不再存在了，那这个人也就不再存在了！这是不是意味着，我最终不能从我的肉体死亡中真的存活下来，哪怕我们假定二元论是真的？<br>然而，幸运的是，二元论者至少会给出两种可能的回答。一种可能性是，二元论者坚持认为，严格说来，一个人不是一个灵魂加一个肉体；严格说来，人只是灵魂。照此说来，我只是我的灵魂，再也没有别的。显然，按这种观点来说，我肉体的毁灭并不会真正涉及我哪怕是一部分的毁灭。当然，我跟我的肉体有着密切的联系，但是毁掉肉体根本不会毁掉我的一部分。（这里有一个类比：我跟我住的房子有着特别紧密的联系，但是毁掉我的房子并没有毁掉我的一部分。）<br>这是二元论者可能提出的一个立场：严格说来，人只是灵魂。灵魂跟肉体有着紧密的联系，但是人不是灵魂和肉体，人只是灵魂。哪怕这种紧密的联系被破坏了，但是人，那个灵魂，还可以继续存在。<br>而这只是二元论者可以采取的路线，他不一定要走这条路。相反，二元论者可以坚持说，虽然我的肉体真的是我的一部分，它不是我的核心部分。相反，若我要继续活下去，肉体是可以失去的。毕竟，事物一直在失去其某些部分，并不必然会因为这些失去而整个毁了。比如，我汽车的右前轮以前有一个轮毂，但现在没有了。那个轮毂当然是我汽车的一部分，但即使如此，在轮毂失去和坏掉之后，我的汽车仍继续存在着：那个轮毂是我汽车的一部分，但不是核心部分。（实际上，即使没有换新的轮毂，我的汽车仍继续存在着！）类似地，虽然一个人在他还活着的时候由肉体和灵魂组成，但是在肉体毁掉之后这个人也许仍能继续存在下去。肉体是这个人的一部分，但不是核心部分。<br>我不会做出决定说在这两个答案中，二元论者采取哪个更好。不妨说，这两个答案好像都可以接受。那么，不管采取哪个答案，我认为二元论者都可以坚持说，在我的肉体死亡和毁灭之后，我至少仍有存活的可能性。<br>我要强调一下，二元论者只是坚持死后存活的可能性，因为只是非物质的灵魂的存在并不能完全、自然而然地保证在肉体死后灵魂真的可以存活下来。也许尽管存在着灵魂，但是当肉体死亡时它也死了！<br>所以，这里引起我们兴趣的是两个不同的问题。第一个问题是：非物质的灵魂是否存在？真的可以用非物质实体这样的术语来理解心灵吗？真的存在两种不同的事物，也就是肉体和灵魂吗？这是第一个问题。第二个问题是：我们还想知道，假如灵魂存在，它能否从肉体的毁灭中存活下来。毕竟，灵魂可能是跟肉体分离的，但即使如此，它也可能在肉体被毁掉时遭到毁灭。<br>因此我在说明，如果存在灵魂，至少为我死后存活的可能性打开了大门。但这没有保证，因为没有进一步的论证，就不能保证灵魂会从肉体的死亡中存活下来。哪怕它是分离的，它也可能在肉体被毁掉的同时遭到毁灭。要知道，我们考察的毕竟是交互作用式二元论。肉体和灵魂之间有着紧密的因果关系。当你刺我的肉体时，这一肉体上的过程会在我的灵魂中引发各种事件——痛感！那么，类似地，当我的肉体死亡时，也就是发生从B1到Bn的物理事件时，它们会在我的灵魂中引发一个并行的过程，可称之为从S1到Sn，这些过程会导致（或构成）我灵魂的毁灭。所以当我肉体死亡时，我的灵魂也死了！<br>这是我脑海中的图景，它跟我们之前表现肉体之死的图类似，但现在我补充了这一个观点：当肉体死亡时，它会同步造成灵魂的死亡。（当然，我不清楚如何画出灵魂，所以就画了一个带光环的脸。）<br>但这时，有人可能想提出反驳。在我们讨论的灵魂观里，灵魂是一种非物质实体，它不是由普通的、原子般的物质组成的。但是，如果灵魂是非物质的，那是否就可以自动地、毫不费力地推断出，灵魂不可能被一个物质的过程毁灭？肉体之死，从B1到Bn，显然是一个物理过程，而非物质的灵魂不可能被物质、物理的过程毁灭，这不是显而易见的吗？<br>悲哀的是，我认为这事实上并不是显而易见的。如我提醒过的那样，我们在这里考察的是交互作用式二元论，它认为肉体能够以各种方式影响灵魂。现在，各种波长的光反射到我的眼睛上，由此我的灵魂有了与我眼前各种对象有关的视觉体验——电脑、桌子、电话。现在，各种强度的声波反射到我耳中，由此我的灵魂有了对隔壁屋里的家人的各种声觉体验。现在，胃液在我的胃里累积，由此我的灵魂有了饥饿的感受。简单来说，我的肉体中发生着各种物理过程，它们引发了我灵魂中的各种变化。但是一旦我们承认，在这种二元论图景中，物质的肉体能影响非物质的灵魂中发生的事件，那么我们好像就没有理由否认，从B1到Bn的肉体过程有可能引起从S1到Sn这一可怕的灵魂过程，并最终导致灵魂的毁灭。这肯定是有可能的，不过它需要进一步的论证来加以排除。<br>简而言之，哪怕我们认为灵魂是存在的，这并没有保证我们能从肉体之死中存活下来。这是更进一步的主张，需要进一步论证的支持。<br>但实际上，我们还有第三个想问的问题：假如肉体死后灵魂还活着，它能存活多久？它会永远存在下去吗？我们是永生的吗？<br>大部分人肯定希望这是真的。我们希望存在着这样的灵魂，这样我们就能永生。因此，我们不仅要问灵魂是否不同于肉体，肉体死后它能不能存活下来，还要问它能不能永远存在下去。这最后一个关于灵魂不朽的问题，是柏拉图特别感兴趣的问题，我们将在第五章涉及他的一些论证。但是，我们首先需要决定，是否应该相信灵魂的存在。<br>物理主义<br>根据关于人的本质的第一种观点，也就是二元论，一个人有或者是非物质的灵魂。我认为这是一种人们都很熟悉的观点，可能你自己也相信灵魂。哪怕你不相信，你可能也受到了这种信念的吸引。无论如何，我可以肯定，至少你认识一些相信这种观点的人。尽管这是一种大家很熟悉的情景，但我们要问自己的问题是：它是真的吗？有理由相信它是正确的吗？<br>在回答这一问题之前，让我们仔细探究下物理主义，即关于人的本质的第二种观点。根据这种观点，人只是一个肉体，只是物质对象，是生物学家们摆弄和研究的事物。<br>搞清楚这里说的是什么，自然很关键。当物理主义者说人只是肉体，只是物理对象时，他们的主张肯定不是说人只是随便什么肉体！不是说不同的物理对象之间好像没有重大的差异。要知道，有些物理对象能做出比其他物理对象有趣得多的事情。<br>我桌子上有一支铅笔，它只是某种物理对象。它能做什么？好吧，做不了多少事情：我可以用它在纸上写字；我可以把它掰成两截；如果我拿起它，再松开它，它会落下。铅笔不是一种很有趣的物理对象。我还有一部手机，它也只是一个物理对象，它也不是世界上最有趣的物理对象，但比铅笔可有趣多了。它能做铅笔做不了的各种事情。<br>如果物理主义者是对的，那么这里还有一个物理对象——谢利·卡根。我是一个令人难忘的物理对象。这样说可能有些傲慢，我的意思不是说，我比你更令人难忘。按照物理主义者的看法，我们每一个人都只是一个能做一些奇妙之事的肉体。我们是能够思考的肉体，我们是能够制订计划的肉体，我们是能够推理的肉体，我们是能够感知的肉体，我们是会害怕、创意十足、有梦想、有抱负的肉体，我们是能够相互沟通的肉体。这里有一句话：我们是人这样的肉体（we are bodies that are people）。但物理主义者认为，人只不过是肉体，再没别的了。<br>那么，按照物理主义的理论，人是拥有特定能力的肉体，是能做一系列活动的肉体。人是能够思考、沟通、推理、制订计划（感受事物、创意十足、有爱和梦想）诸如此类的肉体。<br>如果我们愿意，我们可以争辩这些能力中哪些是最厉害的，但就我们的目的来说，我认为这并不重要。所以，虽然我有时会谈到这一系列能力，但我不会试着去列一个权威的清单。我只把它当作人拥有的一系列能力，我们能做的事情是其他物理对象，如铅笔、收音机、汽车做不了的。我们可以把这些称作使人之为人的能力。为引入一个术语，我们不妨称这些能力为“P功能”（P代表person，人）。那么，按照物理主义者的看法，人只是拥有各种P功能的肉体。同样，我们可以说，按照物理主义者的看法，人只是有能力实现各种P功能（推理、思考、感受、交往、爱，等等）的肉体。那么，我们可以说，人是执行P功能的肉体。<br>再一次要强调的是，我们要看到，这种观点是说，虽然人只是肉体，但不只是随便哪种肉体。实际上，它不只是随便什么样的人的肉体。毕竟，如果你拔出枪，朝我的心脏射击，我会流血而死，在你面前的仍是一个人的肉体，但它不是一个能执行P功能的肉体。它不是一个能思考的肉体，一个能制订计划、能沟通、能创造、有目标的肉体。所以，要成为人，关键是要有一个能够执行P功能的肉体。<br>那么在这种观点中，心灵到底是什么？在物理主义者看来，谈论心灵仍然是合理的，但是从物理主义的视角来说，心灵不过是表达肉体各种精神能力的便捷方式。当我们说到心灵时，我们是把这些能力名词化，用名词“心灵”来谈论这些能力。总而言之，心灵只是对肉体正常运行时拥有的独特能力的一种说法。<br>类似地，说到微笑，我们都相信存在着微笑，但什么是微笑？微笑只是对肉体做某件事的能力的一种说法——我们能做出如此独特的事情，卷起嘴唇，露出牙齿，等等。但微笑并不是肉体额外的一部分。如果你把肉体的各个部分列出来，你会列出牙齿，你会列出嘴唇，你会列出牙龈，你会列出舌头，但是你不会列出微笑。<br>那么，我们该不该接受某种二元论？我们可不可以得出结论说，微笑是额外的、非物质的东西，它跟肉体有特别密切的关系？你大可以这么来想，但这是一种很愚蠢的观点。更好的办法是，将微笑看成表达肉体微笑能力的一种说法。没有额外的事物——微笑。<br>确实，我们有一个名词“微笑”，如果你不小心的话，这一事实可能会哄骗你以为一定存在着微笑这种事物，然后各种形而上学的难题就接踵而至。微笑处于何处？它好像处于嘴巴附近。但是微笑不是嘴唇，也不是牙齿。那它肯定是某种非物质的东西！<br>但是我说过，这将是一种愚蠢的思考微笑的方式。我们谈论微笑只是表达肉体具有笑的能力，能够形成一个微笑。这是我们拥有的一种能力，或者说，是我们的肉体拥有的能力。<br>类似地，在物理主义者看来，谈论心灵只是表达我们肉体做各种事情的能力的一种说法，只是因为这样便于我们谈论我们的肉体能够思考、能够沟通、能够制订计划、能够权衡、能够创造、能够写诗、能够恋爱这些事实。关于这些能力的说法，就是我们所指的“心灵”，但是并没有心灵这一额外的事物，存在于肉体之上或之外。<br>这是物理主义者的观点。物理主义者不否认存在心灵，就像我们不否认存在着微笑，但是谈论心灵就像谈论微笑，只是因为这样来谈论肉体能做的事情比较方便。<br>那么，从物理主义者的观点来说，心灵不是大脑这一点就特别重要了。你可能会想：“瞧，根据物理主义者的观点，心灵只是大脑。”我要承认，这并不是一个可怕的误导，因为根据目前最先进的科学，大脑是肉体中赋予我们各种能力的底层结构，那些P功能是我们凭借大脑才拥有的功能。所以，这可能会误使你认为，在物理主义者看来，心灵只是大脑。<br>但我们也许不能这样说。毕竟，假如你杀了我。我的尸体躺在地板上，我的大脑也在那里（咱们别说得过于可怕了，就假设它还在我的脑壳里）。大脑仍然在那里，但即使如此，显然心灵已经被毁灭了。所以，我认为我们不该说大脑就是心灵。至少，在需要严谨时，我们应该说，谈论心灵是谈论肉体的P功能的一种方式。大家公认的是，我们最先进的科学已表明，一个运行良好的肉体须凭借大脑的正常运行，才能够思考、制订计划、恋爱。严格地说，谈论心灵真的只是表达P功能的一种方式。这是物理主义者的心灵观。<br>物理主义者的死亡观是怎样的呢？在二元论者看来，死亡是心灵——非物质的灵魂——和肉体的永久分离，因为肉体毁掉了。但是对物理主义者来说，没有灵魂这一额外的、在肉体死亡后可能或不能存活的实体，心灵只是肉体的P功能。所以，当肉体各项运作能力被破坏后，心灵也就毁掉了。粗略地说，死亡就是种种功能的终结。<br>我说了，这是粗略的说法。在第十一章中我们还会花时间来梳理这种看法，使它变得更准确。但是，其基本看法没有任何神秘之处。从物理主义者的观点来看，死亡没有什么特别神秘的地方。<br>这就好比我有一套音响。假如我为你举着我的扬声器，它正在播放音乐，这是它能做的一件事。但我把它丢到地上，摔碎它。它摔坏了之后就不能正常运行了，这一点儿也不神秘。从物理主义者的观点来看，死亡基本上就是这样的，它是肉体的停工，以致肉体再也不能正常运行。<br>还有一点值得强调。我已经解释过了，物理主义者不否认存在着心灵（就像我们不否认存在着微笑一样），但谈论我们的心灵只是表达我们的肉体能做之事的一种方式，表示它能思考、能恋爱、能制订计划这一事实。这并不是说，物理主义者的观点认为，我们只是有一些误以为自己能思考的肉体。不是的，我们是真的能思考、能恋爱、能制订计划的肉体，所以的确存在着心灵。如果我们愿意的话，可以称这些心灵为灵魂，哪怕是站在物理主义者的角度。<br>毕竟，从物理主义者的观点来说，谈论心灵没有什么不对的，谈论灵魂也没有什么不对的。通常，在谈论灵魂时，我们不是在搞形而上学，不是在假定一种特殊的形而上学立场。我是一位物理主义者，但在大部分语境中，我能坦然地谈论一个人的灵魂：“他有一颗善良的灵魂”，“她是一个很坏的灵魂”，“当一个人阅读莎士比亚时，他的灵魂在飞升”。<br>“灵魂”这个说法并不会令人心烦或感到不合适，哪怕是站在物理主义者的角度来说。这是一种很恰当的表达方式。但我已经说过，在本书中，为了避免混淆，我将把“灵魂”一词留给谈论二元论立场时。<br>或许我可以这么说，我们将中立地使用“心灵”一词，用它并不表示我们以这种或那种方式肯定了心灵是什么。这样，我们就能同意，人们拥有心灵——我们的思想和人格的居所或所在地。但是，我们还有一个难题没有回答：什么是心灵？二元论者的立场当然是，心灵是灵魂，灵魂是非物质对象。在本书中，当我使用“灵魂”一词时，我会把它留给这种特别的形而上学观点，它认为灵魂是非物质的。反之，我们还有物理主义者的观点。物理主义者也相信心灵，但是他们认为，心灵只是一种谈论肉体能力的方式。物理主义者当然不相信二元论者信奉的非物质的灵魂。所以为了区分清楚，我将说物理主义者根本不相信灵魂。他们相信心灵，但是不相信灵魂。<br>我们接下来的问题就是：我们该相信谁，二元论者还是物理主义者？灵魂存在还是不存在？</p><h3 id="灵魂存在与否的论证"><a href="#灵魂存在与否的论证" class="headerlink" title="灵魂存在与否的论证"></a>灵魂存在与否的论证</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430047074&amp;page=3&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430045875&amp;page=4&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="自由意志与濒死体验"><a href="#自由意志与濒死体验" class="headerlink" title="自由意志与濒死体验"></a>自由意志与濒死体验</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048775&amp;page=5&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=6&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="柏拉图的论证"><a href="#柏拉图的论证" class="headerlink" title="柏拉图的论证"></a>柏拉图的论证</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=7&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=8&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=9&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="人格同一性"><a href="#人格同一性" class="headerlink" title="人格同一性"></a>人格同一性</h3><h4 id="跨越时间的同一性和灵魂理论"><a href="#跨越时间的同一性和灵魂理论" class="headerlink" title="跨越时间的同一性和灵魂理论"></a>跨越时间的同一性和灵魂理论</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=10&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="肉体理论及人格理论"><a href="#肉体理论及人格理论" class="headerlink" title="肉体理论及人格理论"></a>肉体理论及人格理论</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=11&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="人格理论的异议"><a href="#人格理论的异议" class="headerlink" title="人格理论的异议"></a>人格理论的异议</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=12&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="本质因素何在"><a href="#本质因素何在" class="headerlink" title="本质因素何在"></a>本质因素何在</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=13&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="死亡的本质"><a href="#死亡的本质" class="headerlink" title="死亡的本质"></a>死亡的本质</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=14&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=15&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="死亡之害"><a href="#死亡之害" class="headerlink" title="死亡之害"></a>死亡之害</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=16&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=17&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=18&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="不朽性"><a href="#不朽性" class="headerlink" title="不朽性"></a>不朽性</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=19&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="生命的价值"><a href="#生命的价值" class="headerlink" title="生命的价值"></a>生命的价值</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430048074&amp;page=20&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="死亡的其他特征"><a href="#死亡的其他特征" class="headerlink" title="死亡的其他特征"></a>死亡的其他特征</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430096595&amp;page=21&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>根据剥夺解释理论，死亡剥夺了我们本该拥有的美好事物。因此，当它对我们有害时，这是它的主要坏处。当然，我最初提出这个想法时说的是，死亡剥夺了我们生命中的美好事物。但是，现在我发现有些人可能希望略微修正一下这种说法，因为还有另外一种可能性，即生命本身也可以是美好的。不过，抛开这些细节，我们可以将这种理论的基本思想概括为：死亡的主要坏处在于，（当它降临的时候）它剥夺了我那值得一活的生命。<br>不过，虽然我一直极力在说，剥夺是死亡主要的或者说根本的坏处，但我想我们还是可以说，这不是死亡的唯一坏处。就算我们继续耗在“死亡是如何对会死之人产生不利的”问题上，也不能说剥夺是死亡唯一的坏处。就像我们体验到的一样，除了涉及剥夺之外，死亡还有其他的特性，与剥夺截然分开。那么我们就必须问一个问题，这些进一步的特性会增加死亡的坏处吗？与此相对应的，可以想到，这些特性中的某些可能会起缓和的作用，或者说，以这样或那样的方式消除它的坏处。<br>我们来看一个例子。“你将会死去”，这当然是一个关于你的不争事实。但是不止于此，你将会死去，而且你必然会死，这件事避无可避。让我们就死亡的必然性（inevitability）做个对比，就拿你在读这本书来说吧。毫无疑问，你现在读着这本书，但这不是必然的。在读书这件事上，你有得选；但是死亡不一样，不管你怎么选择，你都避不开死亡。所以“我们都将死去”不仅仅是一个事实，更是一个必然真理。于是，我们可能会问，死亡的必然性意味着什么？它会使事情变得更糟吗？这里，我想区分两种情况：个人的情况（你必然将会死去）和普遍的情况（我们都必然将会死去）。<br>让我们先思考一个事实，即你不可避免地将会死去。死亡的不可避免是让事情变得更糟了，还是变得更好了？有趣的是，我认为这个问题两种可能的答案都很有道理。一方面，你可以想到有个人在说：“你看，我将要死去已经够糟了，但是我却对此无能为力，这就更糟了。我在死亡面前无力回天，这就像在伤口上撒盐。我无论如何也无法逃脱死神的追捕，在生死存亡面前我们完全软弱无能，这让事情变得更糟了。”<br>可是，相反，也有人会说死亡的必然性减少了死亡的坏处。想要明白这种立场，只要想一下习语“不要为打翻的牛奶哭泣”背后的观点即可。木已成舟，覆水难收，你不能改变它了。显然，这种观点想要说明的是，一旦你注意到你无法改变某事这个事实，你无力改变的事就不再那么让你沮丧了。如果这个说法成立的话，当我们发现自己对于“我将要死去”这件事无能为力时，也许这个发现带来的刺痛也就消除了一些。<br>有一个简单易懂的例子可以说明这个观点：请试着为“2+2=4”这个你无力改变的事实感到沮丧。假设你希望2+2=5，在这件事上你会感到愤怒、遗憾和恐慌吗？我想你不会。在如此明显不可改变的事物面前，你无法激发起那些情绪。<br>哲学家斯宾诺莎认为，生命中发生的每件事都是必然的，只要我们承认这个事实（至少他认为这是一个事实），就能与生命中发生的事拉开某种情感距离，它们将不再使我们沮丧。我们将不再为事物失望，因为对一件事失望的前提是这件事可以有其他不同的结果。斯宾诺莎认为，一旦你意识到某件事不能有其他结果，就无法对这件事感到难过。既然如此，那么如果我们明白了我们的死亡是必然的，并且从内心接受了这一事实，这也许就可以减少死亡的坏处。<br>没准这是对的，但我不确定。也许你读过陀思妥耶夫斯基的短篇小说《地下室手记》（Notes from Underground）。地下室里的人对“2×2＝4”这件事感到沮丧。或者更确切地说，他对此完全无能为力，正是这个事实让他倍感沮丧。他不能改变2×2＝4，这种无能为力让他感到愤恨。类似地，当笛卡尔思考上帝之无所不能时，他指出，如果上帝不能改变数学法则，那么他是不够完美的。笛卡尔认为，如果上帝被迫接受那些他不能改变的必然性，那将是上帝软弱的象征。所以笛卡尔声称，上帝本可以使得2＋2＝5变成真理，只是他选择了不那么做。实际上，陀思妥耶夫斯基采纳了这个想法并使用了它。他的地下室里的人说，事物发生的必然性并没有实际的帮助，它反而让情况变得更糟。就像我说的，这两种观点对我来说都很有道理。在不同的心境下，我会偏向不同的立场。<br>事实上，不仅我必然将会死去，而且我们都必然将会死去。死亡的普遍性（universality）增加了还是减少了死亡的坏处呢？同样地，我在两种答案间摇摆不定。一方面，我想说，我将要死去真是糟糕，但我不是一个不死的怪物。然而，知道其他人也必然死去甚至让我感觉更糟。又或许，根据我们关于永生的讨论，我应该说真正令人伤心的是我们（或者至少我们中的大部分）都死得太早。这增加了死亡的坏处。<br>另一方面，说句实话，我们都知道“难中喜相伴”这个说法。发现这种不受欢迎的事不仅仅发生在我身上，多少有些令人安慰，不是吗？就好像上天并没有单独把我拎出来受伤害，让我早些死，它几乎对所有人都是这么做的。也许从这个事实当中，我们可以得到一些慰藉。<br>这里有一个关于死亡的特征值得思考，即死亡的差异性（variability）。毕竟，事情并不是“我们都会死去”这么简单，在我们能够活多久这个问题上，人和人之间存在着很大的差别。我们中的有些人可以活到80岁、90岁、100岁，甚至更高龄。而另一些人在20岁，或者15岁，或者10岁，甚至更年幼的时候就夭折了。<br>即使死亡是不可避免的，生命也并不一定要以不同的长度出现。毕竟，死亡好像并不一定要涉及差异性。我们可以设想有这样一个世界，在这个世界中每个人都在相同的年龄死去，也许这个统一年龄是100岁。那么，生命长度的差异性是使事情变糟还是变好了呢？<br>从道德的角度来看，我想，可以直接认为这种差异性让事情变得更糟了。毕竟，我们大多数人都倾向于认为，人们很难从道德上接受不平等。很不幸，尽管这不是他们自己的错，但有些人生来就很穷，而另一些人却生来就富有。如果不平等在道德上是不能接受的，那我们很可能会认为，在能活多久这件事上存在如此严重的不平等，有些人年仅5岁就夭折，另一些人却可以活到90岁，这是道德上的灾难。然而，为了总体集中讨论关于死亡的坏处，我想把道德问题放在一边，转而思考死亡的差异性对我来说有多好或有多坏。<br>我们可以从两个基本的角度来看待这个问题：寿命不足平均值的人和寿命超过平均值的人。从不足平均寿命的人的角度来看，这显然是一件坏事。我这么早就要死去已经够糟糕的了，但更糟的是，我连平均寿命都活不到，真是雪上加霜。随后我们可能会猜想，那些寿命超过平均值的人怎么想呢？假设我们可以找到一个寿命的中位数，即一个精确的生命长度，使50％的人活得比这个值少，另外50％的人活得比这个值多。对于每个寿命比中位数短的人来说，都有一个对应的寿命比中位数长的人存在。那么后者会说：“虽然我这么快就会死去有些遗憾，但至少我已经活得比平均寿命长了，看起来我还算是赚了。”<br>这个等式的两边也许可以互相抵消，即有一些人因为他们活得比平均寿命短而受损，另一些人因为活得比平均寿命长而获益。说不定就死亡对个人的坏处来说，这是一句废话（that’s a wash），可能是这样吧。但是据我所知，还有一个相关的更深层的人类心理现象是：相比于过度补偿（overcompensated），（用我们常说的话就是）我们更在乎被亏待（shortchanged）。我认为，平均水平以下的人们，他们受到伤害要大于平均水平以上的人们的获益。如果这个说法是正确的——事实看来是这样的，尤其是对死亡这样的事而言——那么差异性就带来了额外的坏处，一些人由于寿命少于平均值而受到的危害，大于那些寿命多于平均值的人获得的好处。<br>死亡还有另一个重要特征。我们已经考虑过了必然性，探讨过了差异性，那么不可预测性（unpredictability）又是怎样的呢？关于死亡，不仅“你将会死去”是必然的，也不仅一些人活得比另一些人长，还有一个事实是，你不知道你还能再活多少时日。<br>如果你认为我们在考虑差异性时已经引入了不可预测性的概念，那也可以谅解，但事实并不是那样的。从逻辑上来说，尽管差异性是不可预测性的必要条件，但不是其充分条件。事实上，你可以在存有差异性的情况下，具备全面的预测性。比如，试想一下，假如每一个婴儿出生的时候手腕上天生都有一个胎记，这个胎记准确无误地指出他们将要死去的年、月、日以及时刻。我们完全能够设想这样的一个世界：死亡仍是必然的，每个人的手腕上都标有一个死亡日期；更重要的是，死亡仍可以具有差异性，有些人活了80岁，有些人活了57岁，另一些人仅仅活了20岁。但是，这里就没有了不可预测性。因为胎记的存在，每个人都会准确地知道他们还能够活多久。<br>当然，我们的世界里没有那样的胎记。在现实世界里，死亡不仅存在差异性，还具有不可预测性。这会使事情变得更好，还是变得更糟？预先得知你什么时候死去会更好吗？<br>不可预测性有潜在的可能让事情变得更糟，其中一种方式就是：我们不知道自己还有多少时间可活，所以很难做出规划安排。当然，你可以基于统计数据做出一个猜测，你还可以计算平均寿命。假设现在美国的平均寿命是79年。那就意味着，如果你现在快30岁了，那么平均来说你还有50年的时间可活。但是正如我们前面所说的，平均水平掩盖了许多潜在的差异性。比如，很可能出现这样的情况：你一边忙着计算这些，一边过马路，然后被一辆卡车撞了，你死了。这种情况是有可能发生的，对吧？因为不可预测性的存在，你不能真正确定将会发生什么。因为你不能真正确定将会发生什么，所以你很难做出合理的规划安排。<br>尤其是，我们很难知道该以什么样的步调走完一生。假如你决定去医学院，成为一名医生，那么你不仅要花时间读大学，还要花时间去医学院，更要花时间住院实习，甚至要花时间做实习医生。这需要非常庞大的投入，是一个长期规划。如果你在20岁出头就生病去世，那这个规划就砸了。当然，这个例子相当戏剧化，但从原则上来说，这类事情可能发生在我们任何人身上。你制订了一个人生规划，弄明白了你一生中想实现的成就，然后，“啪”，毫无预兆地，你死了，也就搞砸了你的规划。如果你能知道你只有20年而不是50年可以活，你会为你自己选一个完全不同的人生。所以说，不可预测性让事情变得糟糕。<br>还有另一种不那么常见的情况。你做了一个人生规划，很好地执行了它，然后每当临近你推测的死期时，可以想见，你都没有死。你继续在世间逗留徘徊，然后你就会觉得自己的人生虎头蛇尾了。你的人生太早到达了巅峰。你以为自己会像演员詹姆斯·迪恩一样，“放纵过活，英年早逝”（burn out fast and die young），但你错了。如果你能知道自己还有70年可活，知道你不会这么年轻就去世（你活到94岁高龄），就会选择一个截然不同的人生。<br>实际上，通过思考这些问题，我想说明的是，你生命的总体价值可以被一些我们未曾讨论的特征所影响。我们可以这么说：你人生的整体形态（shape）极为重要。稍微换一个说法就是：你人生的“叙事弧线”（the narrative arc）影响了其总体价值。<br>让我用一些非常简单的图表来解释这个观点。这些图表并不一定切合实际，却可以让你有个基本概念。19世纪美国作家霍雷肖·阿尔杰曾写过一些故事，都是关于出身贫穷的人通过自己的力量（辛勤工作、奉献、努力）成为富人和成功人士的故事。麻雀变凤凰，那真是一个美妙而令人鼓舞的人生。<br>让我们来为那样的人生画一个图（见图13.1）。Y轴代表幸福，即在既定时刻你的处境有多好，X轴代表时间。在图13.1中的第一个图里，你开始时一无所有，最后生活美满。这个很棒的人生，就是霍雷肖·阿尔杰型。</p><p>现在来看另一个不同的故事。这次与前面相反，一个人从富裕落入贫穷。他一开始什么都有，最后却变得一无所有，凤凰变麻雀。这是阿尔杰·霍雷肖型的人生。当然，这是第一个故事的颠倒版本。在图13.1中，为右侧的图。<br>我不相信有人真的对人生模式漠不关心，觉得这两种生活中无论选哪种都无关紧要。我想，绝大多数人都会选择第一种人生。(1)但需要注意的是，如果只从生命内容的角度来看，至少是从片面的（local）内容来看，很难看出为什么要在意我们过的是哪种人生。这两种人生都经历了等量的苦难和成功。显然，这两个图互为镜像，这就意味着在一个图中有多少美好时光，在另一个图中就会有一段完全相似的美好时光；每一段苦难时期，在另一幅图中都能找到一段相应的苦难时期。概括且直观地说，这两种人生中的生命内容是一样的。（从数学的角度来说，两幅图中斜线和两条轴围成区域的面积是一样的。）就算我们接受有价容器理论，认为活着本身也是有价值的，这也不能成为我们偏爱其中一种人生的理由。因为这两种人生持续了相同的时间，两者都会增加等量的额外价值。<br>如果我们对这两种人生的看法并不一样，那么这似乎说明除了各种“片面的”幸福（不同时期你有多么幸福或不幸）之外，人生的总体形态也会影响生命的价值，即叙事弧线也很关键。我们都希望“从坏变好”的故事发生在自己身上，而不愿“从好变坏”的故事成为现实。<br>这就引出了一个很有意思的问题：我们为什么要在意这些？当然，这又会使我们想起卢克莱修之惑：为什么相对于过去的不存在，我们更在意未来的不存在？答案还不是很明显，但事实仍是，和即将来临的坏事相比，已经过去的坏事显得不那么令人困扰。相似地，如果坏事一定要发生的话，似乎我们更愿意坏事早一些而不是晚一些发生。（回想一下德里克·帕菲特关于痛苦手术的故事。对于将痛苦放在过去还是放在未来，我们是有偏好的。）不论关于这个问题的确切解释是什么，一个很简单的事实就是，我们会关心人生的整体形态和轨迹。<br>既然讨论到这个案例，我们不得不考虑一种可能性：由于死亡不可预测，也许当生命终结时，我们人生的整体形态并不是那么理想。思考一下如图13.2中所示的人生。这里的问题是，这个人过早到达了人生巅峰。我们到达了巅峰，但是随后，在高潮过后我们活得太久了。我想，很多人可能会因为拥有这样的人生而不快。请把你的人生想象成一本小说，你的人生图景就像一个伟大故事中的情节。人生不像我们想的那样，大结局必须出现在小说的最后一页，大结局之后还是可以有一些情节的。但是，如果小说的高潮在第二章就出现了，而这之后还有67章的情节等着你，你可能就会觉得这部小说的结构不合理。</p><p>由于我们关心人生的整体形态，我们可能会担心从整体上来看自己的人生是否拥有完美的形态。你想在什么时候、在哪个时间点，让你的人生成就达到巅峰呢？这个问题对我们来说当然很重要，但问题是，鉴于有不可预测性，你就不知道该把这个巅峰放在哪里。如果你追求大器晚成，有可能你活不到那个时候；如果你趁早达到巅峰，在那之后，你活着的时间可能就会太长。这一切都表明，死亡的不可预测性增加了死亡的坏处。它让我们难以规划人生，不知道该如何用最好的方式度过一生。从这个角度来看，好像能够知道我们还剩下多少时日会比较好。<br>但是，我们又不得不问，知道了真的比较好吗？你真的想要确切地知道自己还能活多久吗？假设我们生来就有我刚才提前的那种胎记，你从来都知晓死前还剩多少时间。如果你拥有那样的胎记，那么你一生都将背负着心中有数的包袱：我还有50年可活，我还有49年可活，还有48年可活，还有47年……我想，我们中的很多人会视它为负担，就像有什么东西一直萦绕心头，影响了我们享受生活的能力。<br>让我们稍微修改一下故事的内容。假设我们有的不是那种可见、可解读的胎记，而是某种基因标记，只有通过特定的检测才能够知道。如果你想要知道，可以把自己的DNA拿去检测，然后就能知道自己究竟还能活多少时间。你会想要去做那个检测吗？当然，这是一个科幻故事，而且我推测它也一直会是个科幻故事。但事实上，随着我们对致病基因的了解越来越多，我们中越来越多的人将面对要不要去检测自己是否携带了这些基因的问题。<br>假设有一种可怕的遗传缺陷，它会在携带者40岁的时候发作并致死。假设你已经20岁了，而且你已经知道自己有50％的可能性带有这个遗传缺陷（你父母中一人有这种遗传缺陷，并且已经英年早逝），但是你还不确定自己是否有这个遗传缺陷。如果你有这个遗传缺陷，你将会在20年后死去。你会想要去检测吗？你会想要知道真相吗？<br>这就带来一个密切相关的问题：如果你知道自己还有多少时间可活，你的行为和现在的表现会有所不同吗？知道还能活多久会使你重新调整，并将注意力放到那些对你来说最重要的事上吗？思考这些问题可以有效地辨别在生命中你最看重什么。问问你自己，如果你只有一年可活了，你会选择做什么呢？如果还有五年可活，还有十年可活呢？《周六夜现场》曾经有一个老段子，讲的是有位演员在一名医生的办公室里，而医生告诉了他一个非常糟糕的消息，他的生命只剩下两分钟了。这个男人说：“我要把一生可以享受的都在这两分钟里享受完。”可以想见，这个滑稽短剧的笑点在于，他按了向下的电梯按钮，在他等电梯的时候，一分半钟过去了。<br>如果你知道自己还有一年或者两年可以活，你会用那段时间来做什么呢？你会去学校吗？你会去旅行吗？你会花更多的时间跟朋友在一起吗？就在耶鲁大学死亡课的课堂上，我抛出这个问题，并碰到一个非常感人的真实例子。几年前，在那个班上，有一个学生快要死了，他也知道自己时日不多。在大学一年级的时候，他被确诊患有癌症。他的医生告诉他几乎没有康复的可能，事实上他只能活几年时间。知道这个事之后，他必须问自己：“在剩下来的几年中，我该做什么呢？”<br>他决定完成耶鲁的学业，拿到学位。他给自己设定的目标是在死去之前从学校毕业。然后，他就在大学四年级的第二个学期选修了我的死亡课程。（得知有一个像他那样处境的人决定修这门死亡课，我感到很羞愧，而我每次起床去上课，周复一周地大谈没有灵魂，没有来生，我们都将死去是一件好事……）他就在那里，一直到放春假，都来上我的课。放春假的时候，他的病已经非常严重了，医生告诉他不能再去学校了，他必须回家。事实上，医生告诉他可以回家等死了。他回家之后，病情急剧恶化。<br>在那个学期给他上过课的多位老师都要面对学校行政部门提出的一个问题：到目前为止，基于那个学期里他所完成的课程，我们打算给他整个学期打一个什么样的分数呢？当然，他能否毕业取决于他通过或没通过哪些课程。结果是，他做得非常好。非常值得赞扬的是，耶鲁派了一位行政人员到他的病榻前，在他临终前授予了他学位。<br>这是一个不同寻常的感人故事。我不知道我们中有多少人会认定，当只剩下几年生命的时候，我们最想做的事是在大学里度过这些时光。不过，你想去做的事会是什么呢？你会选择什么呢？回到我们最初的问题，知道你还有多少生命，会让你接纳新的选择，从而以最有意义的方式过完一生吗？还是说，它会变成一种负担呢？当想到通常情况下我们不知道自己还剩下多少时间时，我们必须面对这类问题。它会增加死亡的坏处，还是会减少一些呢？<br>除了必然性、差异性和不可预测性之外，死亡还有另一种特性。关于死亡的这个真相，我喜欢称它为无所不在（ubiquitous）。我不仅仅是指我们周围的所有人都正在死去，更多的是指我们自己可能在任何时候死去。你永远都无法摆脱你现在就会死的可能性。即使我们已经知道了死亡具有不可预测性，但也未必意识到死亡会以这种方式无处不在。我想说的是：即使在你认为自己绝对安全的时候，你也有可能会死于中风，或者死于心脏病突发。即使是一个年轻力壮的人，也可能会死于动脉瘤。<br>或者，用一个我最喜欢的例子来说明。你可能正坐在客厅里，突然一架飞机撞进了你的房子，把你杀死了。我们偶尔会在报纸上读到这样的报道：你以为自己很安全，正在看电视重播；下一分钟，你已经死了。这就超出了不可预测性的范畴。你不知道你何时会死这个事实，还不足以推出你可能在任何时刻死去这个结论。但事实上，这对我们所有人都成立。<br>还有另外一个例子，也深得我心。某一次我在高速公路上开车，有一辆车连看都没看就变换车道，开到我所在的车道上来，直接撞上了我的车，导致我的车方向失控，转着圈穿过三个车道。整个过程只持续了很短的时间，但是我记得自己当时头脑极为清醒地想着：“我要死了。”幸运的是，我没死。我离开了事故现场，我的车损也微乎其微。但是，事情也可能会像我想的那样。<br>死亡——死亡的可能性——是无所不在的，它普遍存在。所以我们需要问问自己，这让事情变得更糟了吗？在我看来，这给人感觉当然是死亡的又一个坏处。如果能够喘口气不去想死亡的事，当然是很好的。如果你愿意的话，不妨想象一下，有这么一些地方，比如一些度假胜地，只要你在那里，你就不会死。能够去这样一个地方待那么一小会儿，自思自忖道，“现在我不用去担心它了，这个念头甚至都不会闪过我的大脑”，这样不是很好吗？<br>当然，如果有这样的死亡免疫（death-free）地区，一定会人满为患。所以，也许我们应该换一个例子。想象一下，存在死亡免疫时间段，而不是死亡免疫地区。假设不管出于什么原因，没有人会在中午12点到下午1点之间死去，这段时间里你就可以把死亡抛到脑后去。那样会不会很美好？诚然，在1点整的时候，你将重拾那个思想包袱。但是，如果每天能有这么一段时间，死亡不过是一种遥远的可能，那不是很美好吗？或者，假设存在一些特定的死亡免疫活动。也许读哲学就是一种，只要你在读哲学，你就不会死；或者是祈祷，只要你在祈祷，你就不会死。那样不是很美好吗？<br>或者，不妨把整个事情反过来看。假设大多数时间和大多数活动都是死亡免疫的，但一些特定的活动有导致死亡的可能性。所以，除非你从事这些活动，否则你就不会死。你可以永远活着，但不会被迫活到永远，从这个意义来说，你有可能永生。有一些活动，比如对着你的头开枪，可以结束你的生命。所以，即使永生是一件坏事，你还是有办法终结它。不过，除了这些保证致死的活动之外，设想一下还有其他的活动，这些活动仅仅具有导致死亡的风险（也就是说，它们具有的风险水平和它们在现实世界中的风险水平是一样的）：当你做这些事情的时候，就失去了免于死亡的保证。问问你自己，哪些活动是即使知道它们存在致死的风险，但你仍然愿意去从事的。<br>有什么事情重要到你愿意冒着生命危险去做的呢？你也许喜欢艺术。你准备去欣赏一幅杰作，得知在这个过程中自己可能会死，但是不去的话就没事，那么艺术有没有重要到你在知晓这件事的情况下，还是决定去呢？性爱有没有美妙到你愿意在做爱的时候冒着死亡的风险呢？问问自己，有没有什么活动是如此重要，即使你知道从事这些活动有所谓的招致死亡的风险，不去做就没风险，但你还是愿意去做。那么，从中就可以发现，什么是我们认为最有价值的。<br>我以这种方式提问，就在假定有些事情是你会不顾死亡风险去做的。我想，这里还有一个进一步的问题：有没有这样一些事，人们认为它值得去做，恰恰是因为它们包含了致死的几率呢？诚然，这个新的观点听起来相当怪诞。至少，抛开“我们已经活了10万年，对生活所能给予的一切已经感到厌倦”这个可能性的话，这个新观点听起来很是离奇。令人难以置信的是，当生活还能够给予我们更多的时候，我们却可能正因为某样活动有可能致死而去那么做。然而，在我看来，的确存在这样的活动——即使不是很多，至少还是有一些——人们正是因为它们有死亡的几率才参与其中。<br>让我来举一个例子，你们肯定会吃惊。你们知道有些人会从飞机上跳下去吗？诚然，当他们跳出去的时候，带有那么一小块布，这块布给了他们相当大的存活机会。但这些保险措施有时也会失效，你时不时地会在报纸上读到，有些人的降落伞没有打开，然后他们死了。我问自己，这是为什么呢？是什么驱使这些人就这么跳下飞机，让自己和死亡之间只隔着几块布呢？我觉得最合理的解释是：正是很有可能致死这个事实，解释了人们为什么会这么做。<br>当然，如果你和这些跳伞者讨论这个问题，他们会说：“哦，不是，不是。这是因为景色实在太优美了。”或者一些类似的话。但是，我认为这种说法很难让人信服，因为你只用登上飞机俯视，就可以在飞机里安全地看到那些美景。在我看来，这么做之所以令人兴奋，部分原因必然是这增大了死亡的风险。死亡这种可能性是驱使某些人跳下飞机的部分动力。<br>但是，如果这是真的，那么也许我之前关于“拥有死亡免疫时间段或死亡免疫地区或死亡免疫活动真好”的说法就错了。也许当我说“死亡无处不在，它普遍存在，这令人难以忍受”的时候，也就错了。如果死亡的几率能够带来某种兴奋，那么死亡的无所不在也许是一件好事，而不是坏事。<br>然而，我倾向于认为这种说法是不对的，即使对那些确实被风险吸引去跳伞的人来说，也无法成立。我是这么想的，对于这些人来说，死亡的无所不在更像是一种背景里持续的不被注意的嗡嗡声。对他们来说，有一些死亡风险还不足够，必须是比平常大得多的死亡风险才行。跳下飞机之所以这么吸引人，就是因为它让死亡的风险达到巅值。如果这种说法是正确的，那么即使对那些寻求死亡刺激的人来说，死亡无所不在也不是一件特别好的事情，而这恰恰是因为死亡普遍存在。死亡风险的无处不在使它本身没入背景之中。<br>我还想审视一下死亡的另一个特征，即生而后有死（death follows life）。可以说，这是关于人类境况的基本事实。它不仅是指我们活着，或在某一个时间点不复存在，而是指我们活着并随后死亡，对人类来说，这是事实。我想问的是，我们该如何看待这一现实呢？毕竟，这是一种形而上学的组合，是一种生与死的特定结合。我们需要探寻的不只是生命的整体价值或死亡的整体价值，还有生死作为一个组合的整体价值。<br>一种合乎常理的想法是，当我们想要弄清楚一种组合物的价值时，只需要简单地弄清它各个组成部分的价值，然后把这些价值相加即可。相应地，如果想要明白人类境况，即生而后有死的整体价值，我们首先需要算出生命的价值，然后算出死亡的坏处，接着把两者相加即可。换句话说，我们只需要找到这两个组成部分的价值，然后看它们的总和即可。<br>当然，就算给定这样的策略，人们还是会对价值的总和意见不一。乐观主义者大概会认为总和是正数。“是的，”他们会说，“死亡是不好，但生命是美好的，美好到可以抵消‘我们将会死去’这个事实所带来的坏处。两相权衡后，能够来到这世上还是一件好事。”而悲观主义者大概会坚持说总和是负数。“两相抵消后，”他们会争辩，“死亡的坏处大于生命的美好（如果生命中有任何美好的话）！”温和派可能会认为，答案取决于每个人的具体情况。<br>但我认为，仅仅计算价值的总和并不够。从整体上评估人类境况，需要做的不只是将生命的美好与死亡的坏处相加。事实上，情况要复杂得多，因为一个组合的整体价值常常不等同于孤立地考虑每个组成部分，再将不同部分的价值相加得到的总和。这种简单地通过“做加法”来得到总体价值的方式并不总是正确的。<br>有一个例子可以说明这个观点。我最喜欢的两样食物是比萨和巧克力。我曾跟你们提过我对巧克力的喜爱，但是好像没有说过我也爱吃比萨。现在我有两样喜欢的食物了。比萨——美味！巧克力——美味！现在把这两样美味的食物放在一起，做成一个涂满巧克力的比萨——恶心！对我来说这个东西听起来就很恶心，完全没有食欲。(2)我希望你们像我一样，觉得这个主意令人作呕。如果将两者分开，单独考虑比萨的价值和巧克力的价值，你可能不会留意到这种恶心感。所以，巧克力比萨的价值，不是仅仅将巧克力的价值和比萨的价值相加就可以得到的。你需要考虑到所谓的“交互作用”（interaction effects）。<br>所以，我们不禁要问，在考虑人类境况，即生而后有死这个事实时，有没有哪些交互作用是我们需要考虑的？想来有两种主要的可能性。如果真的有交互作用的话，那么它们可能是负面的，从而降低了整个组合的价值；或者相反，它们也可能是正面的。<br>我先简单介绍一个可能是正面交互作用的例子。考虑到你将会死去这个事实，不言自明，这意味着你的生命将是有限的。生命是一种稀缺资源，它很宝贵。我们可能被这样的观点吸引，因为生命很珍贵，所以它的价值得到了提升。毕竟，如果一样东西脆弱易损或稀有少见，它的价值就会更大，这是一种很普遍的想法。说不定正是生命珍贵而易逝这个事实，实际上增加了它的价值。<br>科幻作家奥森·斯科特·卡德写过一个短篇故事，大意是说：在宇宙所有形式的生命中，只有地球上的我们终有一死。(3)正是这个原因，我们成了宇宙中所有其他生命羡慕的对象。这并不是说永生不吸引人，或者很无聊。永生固然美好，但是宇宙中的其他生命体还是嫉妒我们有限的寿命。因为我们拥有而他们无法拥有的，是对每个人来说都弥足珍贵的事物，我们只能短暂拥有它，唯有倍加珍视。我不知道自己是否同意这种观点，但我看到了这种观点的吸引力。如果这种说法是对的，那么我们命定的死亡和我们的生命发生了交互作用，就使得生命更显脆弱、更为短暂，于是变得更有价值。<br>不管是否有人认同第一种正面交互作用的观点，负面的交互作用仍有可能存在着。以下有两种关于负面交互作用的想法，我常认为它们比较有说服力。第一种想法，我命名为“尝一口，就一口”（A Taste Is Just a Taste）。这个想法是从生活中观察而来的。我们存活在世上一段时间，感受到了生活可以提供的所有美好事物，然后就在片刻过后，所有这一切便都从我们手中被夺走了。从某种程度上来说，我们浅尝辄止，这就像雪上加霜。好比说，有人在一个饿汉面前摆了一顿美味的大餐，允许他看有多好看，允许他闻有多香，可能还会给他一小勺尝尝，就为了让他知道这顿大餐有多色香味俱全。然后，所有的东西就被拿走了。<br>如果有人说，宁可不吃，也不要这样尝了一口之后却不被允许吃下整份大餐，这是可以理解的。然而，如果你只专注于品尝的本质的话，也许完全不会注意到这个负面特征。毕竟，品尝一口美味大餐的体验还是正面的。类似地，如果你只注意不能吃到大餐的本质，可能也不会留心到这个负面特征。毕竟，不吃一顿美食只是缺失了一种特定经历。而剥夺是一种相对的坏事，它并不包含任何坏事，它本身也不是一件坏事。在给你品尝一口却又不让你吃完整顿大餐这件事中，如果你想要厘清到底什么是最令人难以忍受的，就需要把两件事结合起来考虑，这就是一种交互作用。同样地，我们可能会想，人类境况的坏处之一就是，在生命被夺走之前我们已品尝到了它的甜头，但也仅仅是一些甜头而已，无法吃到更多。这是一种可能的负面交互作用。<br>我提到的第二种可能的负面交互作用叫作“从高贵到卑微”（How the Noble Have Fallen）。关于你我，有一个无比神奇的事实，那就是我们是人类。据我们所知，在宇宙中人类是非常罕见和独特的。当然，我们无法自信满满地说出在地球之外有什么形式的生命体存在，但是至少在地球上，我们可能是唯一的人类。（谁知道呢，也许从哲学意义上来说，海豚或者其他类人猿也是人类。不过，无论如何，人类俱乐部的会员都是经过精挑细选的。）当然，按照物理主义的观点，人就是某种机器。不过我已经解释了，我们可不是任何随随便便的机器，我们是很神奇的机器。我们能够相爱；我们能够写诗；我们可以思考宇宙最远可抵达之处，并思考我们在宇宙中所处的位置。人类真的很不可思议。尽管如此，我们最终都会变成尸体，直至腐烂。对很多人来说，这是一个令人恐惧的想法：如此神奇的人类，如此高贵而珍贵的存在，最后居然变得像一块腐烂的肉一样低微，一样无足轻重。<br>每每想到这种想法，我的脑海中就会出现一幅影像：一位被废黜的国王在纽约以在餐厅当服务员为生。你可能认为，以服务员为生计并不是这个世界上最悲惨的事情，这么想也是合情合理的。但同时，这个故事有一处额外的转折，雪上加霜的是，这位服务员会一直记得他曾经是一位统治者，他曾多么不凡。需要注意的是，如果你只考虑统治者的生活，把它作为整体的一部分独立讨论的话，它看起来相当不错。即使是当一辈子服务员，如果单独来看的话，也不太坏。所以，如果你想知道这种命运究竟有什么问题，想了解潜在的额外的负面特征是什么，就必须认清一个事实，那就是现在要评估的是一整个组合。毕竟，从国王变成服务员，这肯定让人倍感屈辱。而那种命运或者更糟的命运，在等着我们所有人。这是关于人类境况的一个事实：我们这种了不起的造物不会一直了不起，我们会变成一块块腐烂的、腐败的肉。<br>所以，当评估人类境况时，至少有三种潜在的交互作用值得我们思考。一方面，“就尝一口”的人生可能是一种特殊形式的折磨，由人沦为一具尸体也让人恐惧，这些可能会产生负面作用。另一方面，同时也可能由生命的十足珍贵带来正面作用。在不同的心境下，我倾向于接受不同的观点，有时三种都赞同。除此之外，如果这三种交互作用真的存在的话，我不清楚哪一种的影响会更大。<br>对于这个问题，人们可能持有不同的意见。乐观主义者会说即使引入负面的交互作用，人类境况的总体本质还是正面的。所以，尽管我们有生必有死，能够在世上活过还是一件美好的事。相反，悲观主义者会说生命的负面实在是太多了，尤其是引入负面交互作用之后；与其这样，还不如从未出生过。实际上，悲观主义者认为“我们将会死去”这个事实渗透并荼毒了生命的本质，或者说荼毒了“生而后有死”这个组合的本质。两相权衡，他们坚持认为，生命整体是消极的。最好什么都不要，生也好，死也罢，宁可从未出生，也不要有像这样生而后有死的组合。（那么，对于第十章出现过的拉里，也就是那个可能存在却从未出生的人，我们说不定应该感到嫉妒而不是遗憾。）<br>就个人而言，我足够乐观，认为生命可以相当精彩。尽管从严格意义上来讲，我并不是一位乐观主义者，而是一位温和派。我们不应该给人类境况设置一个单一的总体价值，否则我们就可以貌似有理地评价说，每个人的出生都是幸运的，或者最好所有人从未出生过。遗憾的是，这得取决于既定个人的人生是怎样的。不过，在我看来，多数人还是获得了非常值得活下去的人生。即使在某些情况下，我倾向于认为我们不要忘了考虑一种或另一种负面交互作用，但我还是觉得，对多数人来说，或者对绝大多数人来说，我们的处境权衡下来还是好的。我认为，尽管有生必定有死，但对于那些有幸品尝到生活之美好的人来说，能够出生还是比从未出生要更好。<br>虽然如此，我还是要强调一下，即使我们接受悲观主义者的观点，认为从未出生会更好，也不能得出结论说，对这个认识的合理反应是自杀。我们还需要进一步论证。<br>当然，从另一方面来说，这样的想法是很容易产生的。也就是说，如果我们认为从未出生更好，不费周折就可以推出应对这种境况的合理反应是自杀。但事实上，至少从逻辑上来讲，根本不能推出这样的结论。如果你再想想，就会发现自杀并不能改变人类境况“生而后有死”的基本本质。并不是说如果你杀了自己，你就没来过这世界了。举个例子，如果品尝一小口美味是可怕的事，那你杀了自己并不能改变这一事实，你所得到的还是品尝到的那一小口。事实上，如果你选择了自杀，仅仅是将那一小口变成了更小的一小口。类似地，如果说由人沦为一具尸体是堕落的话，那自杀也不能改变这个基本事实，它只不过是让这份屈辱来得更快一些罢了。<br>所以，即使我们接受悲观主义者的观点，认为我们从未出生更好，我们还是要说（套用一个老笑话），请从一千个人里找出这样一个幸运儿！我们都已经在这世上了，由这个事实，如果我们同意这是事实的话，即从未出生更好，不能简单地得出自杀是合理反应的结论。<br>当然，这些都不能表明，自杀不是应对某人所处情形的一个合理反应。这是我们将在倒数第二章里讨论的话题。我们先缓一缓，到时再讨论它。首先，我认为，我们需要提出一个更为广泛的问题：基于之前所列出的关于死亡的种种事实，一个人究竟该如何活着？事实上，我们还需要问：死亡到底该不该影响我们的生活方式呢？</p><h3 id="对死亡的恐惧"><a href="#对死亡的恐惧" class="headerlink" title="对死亡的恐惧"></a>对死亡的恐惧</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430099291&amp;page=22&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="如何面对死亡"><a href="#如何面对死亡" class="headerlink" title="如何面对死亡"></a>如何面对死亡</h3><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430100085&amp;page=23&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>无视这些事实<br>我们很自然就会认为，我们都将死去的事实会显著地影响我们的生活方式，但真实情况也许并非如此。那么，我们首先要问的或许是：我们真的应该思考所有这些问题吗？<br>当然，亲爱的读者，对你来说，现在问这个已经太晚了。这本书你都读到这里了，再问起初花费如此多的时间思考死亡是不是一个好主意，已经太迟了。饶是如此，至少我们作为理论家，对“应对死亡的正确方式，可能就是完全不去考虑它”这种理论上的可能性，仍可以保持兴趣。<br>原则上来说，应对任何一个事实，我们都可以有三种不同的可能反应：你可以否认它们；你可以回应它们；或者，你可以无视他们。我想要进一步深入讨论的就是最后一种反应。<br>在前面的章节中，我已经就死亡的本质给出了许多的观点。当然，我特别提到了，我们只是物理对象，当这种对象以一定的方式垮掉时，我们就不复存在了。很显然，对我所说的这一切有一种可能反应，就是完全不同意我说的事实。搞不好你认为灵魂是存在的，或者你认为尽管我们只是一些肉体，但这些肉体在死后某一天可能会被复活，所以死亡也不是终结。如果你在这些观点上确实不同意我，我自然会认为你弄错了。我会以为你在否认事实，把它们弄错了。但是，就死亡本质而言，关于为什么别人该持有我认为他们该持有的观点这一点，毫无疑问，我已经没有什么可多说的了。所以，就让我们把这第一种反应放到一边不谈吧。<br>等一下我会稍微谈及另一种不同的可能反应，即承认事实的存在，然后采取相应的行动去生活，也就是以恰当地活着来回应这些事实。当然，我们还没有问过自己，认识到并愿意考虑死亡的真相后，又该如何生活。这是稍后要涉及的问题。但是，还有一种中间的可能性也值得考虑：有些人可能既不会错误地否认事实，也不会接受它们并对生活做出相应的行动，他们仅仅是决定不去想它们。说不定应对死亡本质的最好回应就是把它抛诸脑后，压根不去想它。<br>有人也许会抱怨说，这不可能是一种恰当的回应。这种抱怨是可以理解的。无视关于任何研究对象的事实，并把它们抛诸脑后，这怎么可能会是恰当的呢？但是，上面这种看起来高贵的、高尚的立场必定是错的。不去思虑我们在某一时刻得知的各种事实，这种做法并没有什么不可接受的，也没有什么不恰当的，或者说错误的。<br>我很喜欢举的一个例子是小时候我被逼着去学一些很傻的知识，比如说各州的首府分别是哪些城市。在人生旅途中，我已经走了很远，据我所知，我从来就不需要回忆起那50个州的首府。所以，我就不用去想它。事实上，我一年就想起这些首府一次，还是因为要用这个例子来说明“不用去想”这个观点。然后我扪心自问，这些州的首府我还记得多少？答案是，真的记不起那么多了。我曾经一度知道所有的首府，但事实是，不去思虑它们也是可以接受的。<br>那么，假设我们都同意生与死的事实跟我描述的完全一样，在我们进一步讨论之前，实际上我们并不确定，对待这些事实是否不应该只是注意到，记下来，然后忘记它们，就如同对待那些州首府一样。<br>这看起来像是一个奇怪的提议；事实上，它看起来像是搞错了。但是，为什么呢？关于生死的事实有什么特别的吗？为什么我们把有关生与死的事实搁到一边，不管不顾，这样的想法就像是错误的呢？大概是因为，无论死亡的事实指的是什么，我们都倾向于认为这些事实会影响我们如何生活。我们都将会死去、我们不会永远活着这个事实，塑造了或至少部分塑造了恰当的生活方式。如果这种说法是正确的，那么简单地无视这些事实好像就显得有些不理性、不恰当了。<br>当然，决定无视这些事实也有可能是可以理解的。想象一下，有人这么说：“一想到死亡的本质，想到在地球上我只能生活50年、80年或者90年，那真是太沉重了。那对我来说是毁灭性的，我可能无法继续生活了。”人们常常发出如此的感慨，他们会争辩说，正是由于这个原因，所以正确的做法是不要去想死亡。回想一下托尔斯泰的《伊万·伊里奇之死》，这个故事中的人们似乎把终有一死这个事实抛到了脑后。为什么呢？也许因为他们觉得这个事实太具有毁灭性、太沉重了。所以，他们的应对方式就是简单地无视这些事实，试着不去考虑死亡。<br>但是，这种反应中似乎总有些不对劲的地方，那正是托尔斯泰想要我们明白的意思。不管应对死亡的恰当反应可能是怎样的，如果不去面对我们必然死亡的事实并采取相应行动去生活，总有些不太对头，或者说总有些不真实。无视这些特别的事实有点怪异和不妥。与有关各州首府的事实不同，关于死亡的真相是重要的。<br>这里有两个故事，可以让我们感受到无视重要事实的那种怪异。这两个故事都不涉及死亡本身。首先，假设你要和佩吉·苏（Peggy Sue）出去火热约会［这取决于你的性偏好，你可能更希望我讲一个有关比利·鲍勃（Billy Bob）的故事］。想象一下你的室友拿着一个信封说：“这封信上写了一些关于佩吉·苏的事。我不会亲口告诉你写的是什么，它们就在信封里。但我会把这封信给你，你可以打开来看。不过我要告诉你，如果你打开看了，如果你考虑一下这些事，如果你知道了信里写的内容，你就不会想要和佩吉·苏约会了，肯定是这样的。”<br>然后，想象一下你相信了你的室友。你不知道信里写的是什么，但不管写的是什么，你确实相信它是真的。你并不认为是你的室友编造了一切，它们都是谎言或诽谤。你确信里面写的事都是真的。更重要的是，你知道如果看了信里的内容，你就会改变主意，再也不想和佩吉·苏约会了。假设事情就是这样的，你却对室友说：“不要让我看这封信。”这就显得很奇怪了，这么做看起来很不合理。如果有一些事实会让你改变关于如何行事的想法，而且你知道这些事实会改变你的想法，那么无视这些事实怎么可能是理性的呢？<br>这里还有一个故事。你正打算喝奶昔，但你的室友突然冲进来说：“我这里有份实验报告。我对这个奶昔有点儿不放心，就取了样本，送到实验室化验。现在实验结果出来了。”你正要喝掉奶昔，那是一个大热天，而且你本身很爱喝奶昔，但是你的室友说：“这个信封里有关于这个奶昔的报告，我保证，一旦你知道这些实情，就再也不会喝奶昔了，肯定是这样的。”然后你说：“哦，谢天谢地，别打开那个信封。”于是，你无视那些事实，喝了奶昔。这看起来也不合理。<br>要是我们正视终有一死的事实，就会选择一种和现在相当不同的生活。假设这个说法是真的，那我们无视这些事实怎么会是合理的呢？这样做看起来既欠妥当，也不理性。<br>这一切也许都说明，选择无视死亡的事实并不真的那么明智。我们也许只能要么选择否认关于死亡本质的主张，要么问自己，假设那些主张是正确的，那么根据这些主张，我们该如何生活。也许，无视这些事实根本就不是一个在理性上可以接受的选项。<br>但我想，这么下结论也许有些为时过早了，因为实际上，事实可以通过两种不同的方式来影响我们的行为。尽管我认为这两种方式间的区别很重要，但是如果我们不够谨慎的话，就会忽略这两者间的区别。这两种方式如下所述：第一种可能性是，有某些特定的事实，仅仅知道这些事实本身就会导致你改变自己的行为，而不需要给你改变行为的理由；第二种可能性是，这些事实通过给你一个改变行为的理由，从而让你的行为发生改变。<br>先讲第一种可能性。我认为，在假定“无视关于死亡的事实完全没有道理”的时候，我们可能会忽略这种可能性，所以我将举一个例子来说明。假设你正在亲吻佩吉·苏，然后你的室友突然出现了，说：“我这个信封里有一些事实，如果你考虑一下这些内容，就再也不会想吻她了。”现在让我来告诉你，你室友的信封里装着什么。信里讲的是佩吉·苏的消化系统。她已经吃了晚饭，当你们坐在那里亲热的时候，食物正沿着佩吉·苏的消化道下行，然后变成了粪便。最终，它们将被排泄出来。如果你开始在脑海里描绘佩吉·苏消化道里的排泄物，并想象她最终把这些排泄物从屁股上擦掉的场景，你可能就很难跟她继续亲热下去了。<br>这只是一些事实，不是吗？我并没有编造任何东西。但我可以想象，就算只是这样粗略的描述，已经让你觉得很恶心了。所以，我们当然可以相信，只要你看了你室友的信封里装着的那些详尽且引人联想的描述，并且想象到那里面描述的事实，的确会失去亲吻佩吉·苏的欲望。<br>这些关于消化系统的事实会让亲吻一个人变得不合理吗？当然不会！尽管如此，想起这些事实还是会让人很难继续享受亲吻一个人的过程。所以，关于消化道有一些特定的事实，一旦想到它们你就不会再做一些事情，比如亲吻佩吉·苏，但这不是因为你找到了充分的不亲吻她的理由。想到人类的消化过程，可能导致你改变自己的行为，而不需要提供任何改变你行为的理由。<br>所以，当你的室友跑进来，拿着信封说：“在这个信封里有一些事实，如果你看了并且想到它们，你就会停止亲吻佩吉·苏。”这时，你该向室友提出的问题是：“这些事实是仅仅导致我改变正在做的事，还是会给我充分的理由去改变正在做的事呢？”如果这些事实是关于佩吉·苏是如何大嘴巴的，搞不好她会告诉朋友谁是接吻高手，谁的技巧很烂，那么，这也许就给了你一个不继续和她接吻的理由。不过，如果我们只知道那些事实会改变你的行为，这并不能告诉我们这些事实是否提供了改变行为的理由。如果它们仅仅导致你去改变，而不是给你理由去改变，那么无视它们也许完全没有关系。如果你的室友跑进来，想告诉你关于人类消化系统的事实，你可以合理地说：“现在不行。”无视事实有时候是一种明智的行为。<br>那么，关于死亡的事实呢？无视这些事实是妥当的吗？持有大胆观点的人们可能会给出肯定的回答。也许当我想到死亡的事实的时候，它们会改变我的行为，不过那不是因为它们给了我改变的理由，仅仅是它们直接影响了我的行为。如果是这样的话，我们可能会得出这样的结论：说不定不去想它们更好。在这个问题上得出这样的结论是很大胆的。<br>举例来说，假定面对死亡，正确的生活方式是充实地生活并享受生活。但是，假如你想到死亡时变得太消沉，就不能享受生活了。死亡并没有给你待在房间里生闷气的理由，但它导致你待在房间里生闷气。如果是这样的话，那么无视这些事实，或者始终无视这些事实，可能就是一个恰当的反应。这的确是一个相当大胆的断言。我不倾向于认为这个大胆断言是正确的。<br>所以，我们是否可以得出另一个结论，即你应该始终想着死亡的本质？不，我认为这种立场可能也是错误的。最后拿你举一次例子，你在和佩吉·苏亲热，你的室友进来了，告诉你人类变成尸体后是如何腐烂的。当他告诉你这个故事的时候，你的脑海中描绘出佩吉·苏变成一具正在腐烂的尸体的画面。突然，你感觉再也不想亲她了。这和那个消化道的例子类似。据我所知，她会变成尸体这个事实并没有给你提供任何不亲她的理由。只不过是想到她将会变成尸体这个事实，导致你不想去亲她，它让你不再享受亲吻她的过程。<br>我倾向于认为正确的立场应该是一个中立的立场。你有一些时间和场合可以用来思考死亡，但当你在亲吻一个人时，就不是思考这个问题的合适时间和场合。如果有人说，你应该始终在心里想着自己终有一死这个事实，我会认为他们错了。不过，类似地，如果有人说你永远不用思考必死的命运和死亡的本质，我认为他们也错了。实际上，在有些时间和场合是可以思考死亡的。<br>但是那样的话，我们仍然有一个问题。让我们假设此时此地是思考死亡的恰当时间和地点。（毕竟，如果的确有一个时间和地点，可以用来思考死亡以及它如何影响我们生活的话，那就是现在，就在这里，当你在读一本关于死亡的书时。）所以，我们仍然要问：你该如何生活？对于关于生与死的真相的恰当反应是什么？<br>恐惧死亡<br>认为“我们将会死去”这个事实会影响到我们的生活方式，这么想是很自然的。的确，大多数人都会被这样的想法所吸引，即死亡是我们存在的核心，它会对我们如何生活产生重大而普遍的影响。比如，卡夫卡说过：“生命的意义在于它终将结束。”（The meaning of life is that it ends.）这个暗藏玄机的说法很妙，很典型的卡夫卡风格，但它的含义我想是很平常的：我将会死去，我的生命终将走到尽头，这些都是关于生命的深刻而根本的真相，这些事实会对我如何生活产生重要影响。这就是那句话的想法。但是，那些影响到底会是什么呢？认识到自己终将死去这个事实，会如何影响我生活呢？<br>思考这些问题时，仅仅注意到“意识到我们终有一死”这件事的确会影响我们，这还不够。借用一下托尔斯泰的话，事情可能会这样：一想到你必死的事实，你将无休止地尖叫，直到死去的那一刻为止。但这事如果真的发生的话，并不能说明这种做法就是恰当的反应，也许它仅仅是出于我们的本能。确切地说，我想问的是，怎样才是恰当的反应？做出一种行为而不是另一种行为的理由是什么？<br>严格来说，我想让大家思考的第一种“行为”并不是一种行为，而是我们反应的情绪方面，在我看来，对死亡最常见的反应之一是害怕死亡。实际上，在很多情况下，“害怕”可能不足以表达这种情绪。我认为，一种极为强烈的害怕，即恐惧，是面对死亡时十分常见的情绪反应。所以，我们要问：对死亡的恐惧是一种理性的恰当的反应吗？<br>这里的关键词是“恰当的”。不可否认，我的人生经验告诉我，很多人都害怕死亡。这种反应有多么常见以及这种恐惧有多么强烈，那是心理学家或者社会学家研究的课题，我不感兴趣。我同意对死亡的恐惧是很常见的，但我想知道的是，对死亡的恐惧是否为一种恰当的反应，是否为一种合理的情绪。<br>很显然，提出这个问题时，我已经预设了一个更大的哲学命题，即探讨情绪是否合理是有意义的。我们不仅可以探讨一个人会有什么情绪，还可以探讨一个人应该有什么情绪。然而，这一观点似乎不那么显而易见，在我们讨论对死亡的恐惧之前，也许要先花些时间思考一下。<br>让我们从不同于恐惧的另一种情绪开始说起，比如说自豪。自豪当然是一种情绪。但我想我们都同意，只有在相关条件成立的情况下，对某样事物感到自豪才是合乎情理的。什么条件呢？我想到了两个。首先，你感到自豪的事必须是某种成就。如果你现在对我说：“我真为自己在呼吸而感到自豪。”我可能会很不解地看着你，因为无论从任何角度来看，呼吸都没有困难到足以称之为成就，所以我无法理解你怎么会，或者说你为什么会为自己在呼吸这个事实而自豪。当然，如果你出过意外，为了能够重新用肺呼吸经历过极其痛苦的物理治疗，那么我们或许就能理解，为何自然而寻常的呼吸会成为一种成就，一件值得自豪的事。但是，对于我们其他人来说，呼吸无论如何都不是一种成就，为它感到自豪是不恰当的。<br>即使我们取得了一些成就，那也是不够的。如果要让你对某样事物感到自豪这件事站得住脚，那么它必须是能够充分显现出你的成就。当然，最直接明了的例子就是你自己的成就，你为之自豪是合乎情理的，因为你正是那个攻克难关的人。如果你的哲学论文得了一个A，你告诉我你很自豪，我可以理解；哲学论文得A是一项成就，而且那正是你写的，所以我理解你为什么自豪。当然，如果你做的只是在互联网上找到那类网站，付钱请人帮你写了一篇论文并得到A，那我可以理解那些人也许为写了一篇很棒的哲学论文而自豪，但是我看不出这件事显示了你的什么积极面。所以，恰当的自豪必须满足第二个条件：你感到自豪的事物、活动或者特征，必须能以某种方式充分地显现你自己。<br>这种成就不一定非要是你的成就，即使从简单的狭义上来说。比如，为你孩子的成就感到自豪是合乎情理的，因为在你和你孩子之间存在着一种紧密的联系。从某种意义上来说，他们的成就是和你联系在一起的。在其他情况下，也许我们要考虑这种联系是否足够紧密，或者这种联系的本质到底是什么。作为一个美国人，当美国运动员在奥运会项目上夺冠的时候，你也许会感到自豪，你会对自己说：“我没有参加比赛，尽管如此，我是个美国人，美国队赢了，我就会感到自豪。”这是合情合理的，我们可以理解你为何认为这份联系足够紧密。另一方面，如果你说：“德国人在奥运会上夺冠了，我真的很自豪。”我就会问你，你是德国人吗？你有德国血统吗？你出资赞助了德国奥运会运动队吗？如果这些问题的回答都是否定的，那就不符合恰当性条件，这时你感到自豪就说不通了。<br>我们可以花更多的时间去探讨，使自豪这个情绪合乎情理需要满足什么精确条件，但那当然不是我的目的。我引入这个讨论是为了说明“情绪确实需要满足一定的要求”这个说法是合理的。要注意的是，并不是只要满足了这些条件就必然能感受到某种情绪，那是另一个问题了。不如这样说，只有满足了这些条件，你拥有某种情绪才说得通，你感受到这种情绪才是理性的、合理的，因为这种情绪才是对你周遭环境及情形的恰当反应。<br>那么，让我们来想一下，恐惧需要什么恰当性条件呢？了解了这些相关条件，就可以进一步思考，对死亡感到恐惧是否恰当呢？但是首先，我们需要知道这些相关条件是什么。当我思考这个问题时，想到了三个条件。第一个条件是：要使感到恐惧合乎情理，你害怕的事必须是一件坏事。<br>我想，第一个条件应该是没有争议的。如果有人过来跟我说：“下班后有人要送给我一个圆筒冰激凌，我感到很害怕。”我同样会很不解地看着他问：“你为什么要害怕？这件事怎么会让你害怕呢？”当然，这不是说他完全没有说得通的答案。如果他告诉我：“我正在减肥，但是我意志力太弱，如果他们给我一个圆筒冰激凌，我一定会吃掉的，那我这周就白节食了。”那我就能理解了。从一个节食者的角度来看，圆筒冰激凌可能是一种不好的东西，这样的话，就满足了恰当的恐惧需要的第一个条件。但是如果你没有一个那样的理由，如果你和我们大多数人大多数时候一样，那圆筒冰激凌是个很好的东西，它是一种稍纵即逝但让人由衷快乐的源泉，由此我就不明白你有什么理由害怕得到一个圆筒冰激凌。这说不通。<br>要让害怕某事看起来合理，这件事必须是一件坏事。这也是有时候我们对有各种恐惧症（害怕蜘蛛、灰尘或者兔子）的人另眼相看的原因之一。我们会想，这怎么可能呢？可爱的小兔子一点儿也不危险，对兔子感到恐惧是不合理的；有些蜘蛛确实是有毒的，但我们在康涅狄格州郊区碰到的蜘蛛一般是无毒的，所以害怕蜘蛛也说不通。（当然，如果你住在澳大利亚的话，情况又不一样了，在那里毒蜘蛛更常见。）再次申明，这并不是说人们不能对蜘蛛或者兔子有这种情绪反应，只是它们看起来不合理。<br>所以，要使恐惧合理的第一个条件是：你的恐惧对象必须是不好的。如果我是偏头痛患者，我对偏头痛感到恐惧是合理的；而我对欣赏美丽的夕阳带来的快乐感到恐惧，就是不合理的。<br>第二个条件是，这件坏事发生的几率，即坏事降临到你身上的几率，必须是不可忽视的。只有逻辑上的可能性，不足以说明恐惧是一种合理的反应。比如，你有可能被一只西伯利亚虎撕成碎片，与死亡不期而遇，这在逻辑上看来并没有前后矛盾或不连贯一致。但这不是说这件事有什么前后不一致的地方，只是它发生的几率太小了，小到可以忽略不计。如果你告诉我，你实在害怕自己会以这样的方式死去，那我只能说这种恐惧根本说不通，它是不合理的。<br>话又说回来，我们可以举出一些特殊情况，在这些情况下，恐惧可能是合理的。假设你告诉我，在你不读关于死亡的哲学书时，你是一个野生动物训练员，或者你打算去一个马戏团工作，在那里你要训练老虎，那我当然会改变自己的说法。在这些情况下，你的确有可能被老虎伤害并杀死，这种几率是不容忽略的。我理解这种恐惧，它说得通。但对于我们其他人来说，我认为，被老虎杀死的几率几乎等于零，可以忽略不计。所以，害怕被老虎吃掉或者害怕被老虎咬成重伤而死是不合情理的。<br>一旦你明白了这一点，就很容易举出许多例子。假设我害怕被来自半人马座阿尔法星的太空生物绑架，他们把我带回实验室，捅我戳我，然后将我活体解剖。我承认，这件事有发生的可能性，逻辑上它不是不可能的。但是同样地，这件事发生的几率小到可以忽略不计。如果我真的害怕这件事发生，你大可准确无误地向我指明，这种恐惧是不恰当的。它是不理性的。<br>因此，如果要使恐惧变得恰当，相应的坏事真实发生的几率就要足够大。当然，就这种几率要多大才算数这个问题，还有很大的讨论空间，但至少我们可以同意：当这种几率小到可以忽略不计时，感到恐惧是不合理的。这就是第二个条件。<br>第三个条件，我想，从某种角度上来说是有争议的，尽管如此，我还是认为它是对的。这个条件就是：关于坏事是否会发生，必须有一定的不确定性，这样你感到恐惧才是合理的。虽然我们还不清楚到底需要多大的不确定性，但是关于坏事是否真的会发生或会坏到什么程度，至少需要有某种不确定性。要弄明白第三个条件，我们需要想象一个情形：一件坏事将会发生；而且，实际上这件事百分之百会发生；同时，你也很确切地知道这件事会有多坏。我希望你同意，在这样的情况下，尽管已经满足了前两个条件，恐惧仍然不是一种恰当的情绪反应。<br>假设事情是这样的，每天你都会带一份午餐去上班，并把它放在办公室的冰箱里。和午餐一起你还带了甜点，假设是一块曲奇。每天中午1点，你把午餐从冰箱里拿出来时，朝袋子里看，发现有人偷了你的曲奇！这是一件坏事。诚然，它不是这个世界上最糟糕的事，但有人偷了你的曲奇确实也是一件坏事。而且，明天你的曲奇也有不容忽视的几率会被偷。所以，现在前两个条件已经满足了。实际上，明天你的曲奇不只是有不容忽视的几率会再次被偷，而且这几乎是可以肯定的事，它会日复一日地发生。也就是说，这件坏事肯定会发生，而且你知道它究竟有多糟糕（因为除了你的曲奇之外，没有其他什么东西丢失）。那么我认为，在这样的情形中，恐惧是不合理的。<br>请你注意，在这种时候，一些其他的负面情绪，比如愤怒和怨恨，可能是合情合理的。不管这个小偷是谁，他或她以为自己是谁啊，竟然敢偷你的曲奇？他们没有权利那么做！你可以生气，可以愤恨，还可以因为你没有甜点吃而伤心，如此日复一日。但你不应该感到害怕，因为没什么理由让你感到害怕。当你知道坏事肯定会来临，而且知道它究竟有多坏的时候，害怕就说不通了。<br>相反，如果这个小偷随机作案，在每周的不同时间、从不同的袋子里偷不同人的甜点，你永远不知道他或她下一次将要去偷谁，那么你有理由害怕成为明天那个甜点被偷的人。说不定你觉得这个饼干小偷的例子太幼稚了，那么想象一下有人闯进隔壁公寓，偷走了笔记本电脑。在这里，恐惧也是说得通的，你有理由害怕他们下一次来偷你的电脑。此时，所有的三个条件都满足了；有一个令人恐惧的坏事，有一个不可忽视的坏事会发生的几率，而且这个几率还达不到成为一种确定性的程度。<br>另一方面，假设事情就像你在电影里经常看到的情节一样。这个窃贼是一位神偷，他为自己的“伟业”感到骄傲，并且会宣布他的行窃计划。比如，他可能会在《纽约时报》上登一则公告说：“4月27日，星期三，我会从××的公寓里偷走电脑。”而且，不管采取了什么防护措施，总是会有疏漏，被指定的这个人的电脑总是会被偷走。如果下周的行窃名单上写的是你的公寓，那么理所当然地，你可以生气，可以不爽，可以恼怒，可以为不知道如何采取充分的防护措施而觉得自己很蠢。但是，当你的名字和将要被盗的时间出现在公告上的时候，当这个窃贼全年都按照预示过的计划盗窃且从未失手的时候，我希望你同意说，此时的恐惧是不合情理的，一旦你确切地知道将要受到多大伤害，并且知道那个伤害将会发生，恐惧就不再恰当了。<br>假设我有一台小型拷问机，一台小型疼痛产生仪。我把你的手放进去，连上电极，转动手柄，打开开关，然后你感受到了一次电击。如果每次电击的强度都不一样，你担心下一次受到的电击有多难受是说得通的。但是，如果这台机器只有一种设置，开和关，每次电击的感受都完全一样，而且我已经电击过你很多次了，所以你确切地知道那是什么样的感受，而且你确切地知道还要被电击三次。（也许有人付钱请你参加一个诡异的心理学实验。）那么，我认为这时恐惧就是不合情理的。当你确切地知道将会发生什么，并且确切地知道那是什么样的感受时，你当然可能会反感将要发生在你身上的事，但这时恐惧不是合理的情绪。<br>现在实验结束了。你因为参与实验得到了10美元报酬，但我不让你走。我说：“我还要再做一次这个实验，不会比前面那次更疼。”显然，你可能不相信我，说不定最后这一次电击真的会比其他几次要疼。这就引出了不确定性这个因素，这时恐惧也许就变得合理了。但是，如果你完全相信我说的，认为只需要再痛一次，而且和你之前感受过的一模一样，那么愤怒可能是合理的（你拒绝再来一次！），怨恨可能是合理的，因为又要再疼一次而感到沮丧也是合理的，但恐惧是不合理的。<br>所以我认为，恐惧要成为恰当的情绪，一定要满足三个条件：你恐惧的对象必须是不好的，坏事将要发生的几率必须是不可忽视的，而且你不确定这件坏事将要发生。如果你确定这件坏事的性质，而且确定它一定会发生，那么恐惧就说不通了。<br>另一个值得一提的观点是，即使表现出恐惧是合理的，切记还有一个适度（proportionality）的问题。即使伤害发生的几率不容忽视（并且这个几率达不到成为确定性的程度），并且感到某种恐惧也被认为是合理的，但如果发生的几率很小却恐惧得要死，那这时恐惧的程度仍可能是不合理的。当风险很小的时候，轻微的担心是恰当的。类似地，恐惧的程度应该与事情的糟糕程度相符。比如，在饼干小偷的例子中，你不确定自己会不会成为下一个受害者，难免有一些害怕，不过这种害怕应当是轻微的。这时候，任何超出轻微程度的恐惧都是不恰当的反应。<br>了解这些观点以后，我们现在可以讨论对死亡的恐惧是否合适了。然而，首先我们需要澄清一些重要的事：当我们害怕死亡的时候，我们究竟在害怕什么？我们害怕的具体对象到底是什么？碰巧，我认为可以从几个不同的角度来回答这个问题；而恐惧是否合理，取决于我们所考虑的东西究竟是什么。<br>你担心的事情可能是死亡的过程。有些人发现当他们生命终结的时候，那个现实过程充满痛苦，令人不快。我已经提到被老虎撕咬吃掉的可能性，可以想见那当然是一种很不愉快的死亡方式。由此，你会痛苦地死去的几率不可忽视，并且看来它给恐惧留出了空间。当然，我们会问，你会痛苦地死去的几率有多大？正如我已经指出的，对我们中的大多数人来说，被老虎撕咬致死的可能性微乎其微。因此，我认为对这种特殊死亡形式的恐惧是不恰当的。同样，如果担心被半人马座阿尔法星人抓去，在痛苦的手术中死去，这种恐惧也是不合适的。<br>尽管如此，令人悲伤的是，在这个世界上的确有人在死去时饱受痛苦，特别是因为在晚期时给人带来痛苦的一些疾病。令人不快的是，我们发现很多医院在病人生命晚期并不为他们提供足够的止痛药。为什么呢？那是一个很复杂的问题，但是我认为，如果有人跟我说鉴于这个事实，他们很怕这种事情会发生在自己身上，我完全可以理解他们的这种反应。尽管如此，恐惧最好还是要适度。如果你告诉我，因为害怕这件事发生在自己身上，你夜不成寐，那我会大吃一惊，觉得那种量级的恐惧是不合适的。<br>尽管对有些人来说，当他们说害怕死亡时指的是害怕死亡的过程，但是不管怎么说，我想这并不是多数人说到害怕死亡时脑中所想的事。我认为多数人指的是他们害怕死亡本身——害怕处于死亡的状态。他们感到害怕，不知道死了会是什么样的。关于这一点，我想说它并不满足恐惧是否恰当的相关条件。<br>我们脑中要谨记，死亡什么感觉也没有，即死亡的状态不涉及任何性质的体验。当然，这是我们在第九章中已经讨论过的观点。这并不是说当一个人死了，他就会有某种体验，一种不同寻常的、难以想象的体验，像是一个令人困扰的谜团。不，这里根本没有什么谜团：死亡的状态仅仅就是不涉及任何体验。<br>但那就意味着，事实上，死了“是什么样的”（“what is it”to be dead）其本质上不是坏的，也不包含坏的事物，这恰恰是因为死了什么感觉都没有。所以，如果我们害怕死亡，其实是害怕不知道死了会怎样，那么这种恐惧就是不恰当的。在这里，就不符合恰当的恐惧需要的第一个条件，因为我们恐惧的对象——“死了是什么样的”——事实上，一点儿也不坏。<br>显然，这种观点以死亡的本质为前提，而我在本书的前半部分为这些本质辩称过。如果你相信来世，或者至少相信有显著的可能性存在来生，你的看法就会很不一样。比如，你担心自己可能会下地狱。从那种角度来看，担心死了是什么样的显然就说得通了。（当然，除非你确定自己会下地狱，而且知道将会遭受多少惩罚。但是那样的话，不符合恰当的恐惧需要的第三个条件，所以恐惧还是不恰当的。）但是，如果你和我一样相信，死亡仅仅是体验的终结，那么在我看来，这就不符合恰当的恐惧需要的第一个条件。因为死了什么感觉都没有，也就没有什么坏的感觉，所以对死了是什么样的感到恐惧就说不通了。<br>当然，我并不是主张死亡什么坏处也没有。尽管我坚持认为对死了是什么样的感到恐惧并不恰当，因为死了就没有坏的了，但我没有否认死亡是坏事。相反，我认同剥夺解释理论。根据剥夺解释理论，从死亡剥夺了人们生命中享有的美好事物这个事实来看，死亡是一件坏事（当它产生坏处的时候）。简而言之，死亡之所以是一件坏事，并不是因为死了是什么样子，而是因为死亡涉及剥夺。<br>但如果这种观点是对的，那么我们也许可以明确一个恰当的恐惧对象。没准我们只需要单纯地恐惧死亡所涉及的剥夺，而不是恐惧死了是什么样的。诚然，剥夺本质上并不是一件坏事。但是正如我们所见，它看来是一种相比较而言的坏事。因此，似乎对死亡所涉及的剥夺感到恐惧，满足了恰当的恐惧需要的第一个条件，即恐惧的事物必须是不好的。那么，也许只要弄清楚我们恐惧的是死亡带来的剥夺，而不是死亡的体验，那么对死亡的恐惧就是恰当的了。<br>但这也不太对。首先，事实上我已经论证过，永生对我们来说不是好事；被宣判永远活着是一种惩罚，而不是赐福。如果在这点上我是对的，那么我们终有一死的事实，即我们最终会被剥夺生命的事实，就完全不是什么坏事，而是好事。那么，对死亡涉及的剥夺感到恐惧是不恰当的。更确切地说，如果我们害怕的是不可避免地失去生命，那么我们的恐惧对象并不是坏事，反而是好事，所以恐惧是说不通的。<br>当然，也许你还没有被“永生将是坏事”这个观点所说服，也许你认为永远活着会是件好事，那样的话，我们终有一死的事实，因为包含了不可避免失去生命，将会是一件坏事而不是好事。根据这个观点，我们是不是至少可以同意，如果永生是好事而不是坏事，我们恐惧的对象就是不好的，所以恐惧死亡是合理的？<br>然而，需要注意的是，即使我认为“永生是一件坏事”这个观点错了，也不能推出对死亡的恐惧是合理的。因为我们已经讨论过，要使恐惧合理，关于所畏惧的事物是否到来就需要具有不确定性。而对于我终究会被剥夺生命这个事实而言，没有不确定性。我知道这件相对的坏事（为了讨论之便，假设死亡的确是件坏事）正在降临，我知道我将会死去。所以，恐惧就变得不适宜了。<br>假设我给你一个圆筒冰激凌，你很喜欢它，希望自己可以再吃第二个，但我没有第二个圆筒冰激凌可以给你。所以，你知道吃完第一个圆筒冰激凌后，自己不会得到第二个。那很遗憾，因为没有足够的冰激凌。这时你告诉我：“我害怕，我害怕吃完第一个圆筒冰激凌之后，一段时间里我得不到第二个。我害怕，因为冰激凌被剥夺就带来了坏处。”很显然，在这个思路里恐惧是讲不通的。既然你知道不会有第二个圆筒冰激凌，那对这个缺失感到恐惧就是不恰当的。类似地，即使死亡意味着在某一刻你再也不能从生活中获益，使得死亡本身是件坏事；但是，既然你知道生命必然会终结，那么对这种必然会有的缺失感到恐惧同样是不恰当的。<br>但是现在一种不同的可能性不言自明。我刚刚辩称，正是因为死亡是确定无疑的，所以对死亡的恐惧是不恰当的。但是，关于死亡也有完全不确定之处，那就是我们什么时候会死。或许，我们应该害怕的不是失去生命本身，而是我们可能会早死的可能性。<br>让我们来考虑一个类比。假设你在一个派对上，而那是一个很棒的派对，你希望可以一直待下去，但这是发生在高中时期的事，接下来会发生的是，在某一个时间点，你妈妈会打来电话，告诉你是时候回家了。让我们假设待在家里并没有什么不好，本质上来说它是中性的。你只是希望你可以待在派对上，但是你知道你不能。最后，假设你知道那个电话百分之百会在午夜打来，可以打包票，完全不存在早些或晚些打来的可能性。那么，这件事的确没有什么可害怕的。你也许会对妈妈在午夜给你打电话感到怨恨，可能会因为她不让你像其他朋友一样待到1点钟而恼怒，但这件事并没有什么可害怕的。如果11点的时候，你说：“我很怕电话会在午夜打来，因为她总是在那个时候打电话过来。”那么，很简单的一个事实就是，你的恐惧站不住脚。你并没有相应程度的不确定性。因为你确切地知道要发生的事，而且你确信它会发生，所以这时恐惧不是恰当的情绪。<br>相反，假设你只知道你妈妈将会在11点到1点之间的某个时刻打电话过来，那么有一些担心是合理的。在大多数时候，她会在12点或12点半打来电话，有时候她到1点才打过来，但偶尔她会在11点就打电话。这时，在我看来，恰当的恐惧需要的各种条件都满足了。有了一件坏事——可能要更早（而不是更晚）离开派对；坏事将要发生有不可忽视的几率（她有时候的确很早就打电话过来）；同时，坏事是否会发生有不确定性（因为她有时候会晚打电话，而不是早打）。那么，在这种情况下，一定程度的恐惧是合理的。（会有多么恐惧？这取决于电话会早些打来的可能性有多大。）<br>也许这就和我们对死亡的恐惧类似。也许正是“死亡会更早到来”这种可能性使恐惧这种情绪变得合理了。顺便提一下，这种类型的恐惧巧妙地回避了永生对我们来说是不是坏事这个问题。即使永生将是坏事，对我们大多数人，或者说对我们所有人而言，死亡仍然可能来得太快。如果是这样的话，我们可以合情合理地担心死亡会来得太早。<br>同样需要注意的是，死亡的不可预测性是一个决定性因素，这使得死亡这件事可以让我们合理地感到害怕。事实上，在我看来，如果不是因为死亡的不可预测性，对死亡的恐惧就不可能站得住脚。就像我说明的，对死亡状态本身感到害怕并不是一种合理的情绪。在我看来，死亡的不可预测性才是我们可以合理地对死亡感到恐惧的唯一理由。<br>即使是这样，进一步的区分也有助于我们理解这个观点。我害怕自己死得太早，是因为“如果我能再多活一会儿，我的人生两相权衡后仍将是美好的”吗？或者担心我会很快死去，是从“就我有望再活多少年的数字范围来说，死亡会早些到来而不是晚些到来”这个意义上说的？又或者是针对第三种可能性，即我是在害怕自己会英年早逝，比其他人死得更早？这三种细分潜在恐惧的准确对象的方式，有许多重要的区别，包括如果感到恐惧的话，那什么程度、什么时候才是恰当的，因为你的恐惧需要和相应的可能性成比例。<br>以对英年早逝的恐惧为例。很显然，如果一个人已到中年，对英年早逝感到恐惧就完全是不理性的，因为他已经没有英年早逝的可能性了。（我自己已经快要60岁了，就我这个年纪来说，要想英年早逝已经来不及了！）但是，即使是对年轻人来说，虽然存在英年早逝的可能性，但实际发生的几率微乎其微。比如，对于一个身体健康的20岁美国人来说，在未来5年、10年甚至20年内死去的几率几乎可以忽略不计，这个几率太小了，为此如果有大量的恐惧情绪，看起来就很不合理。当然，随着我们的年龄越来越大，在既定时间段里死亡的可能性也会稳步上升，不过即使是这样，对于很快死去的恐惧也很容易并不适度。即使是一位80岁的老太太，她也有超过90％的几率再活至少一年。<br>显然，得了重病的人和年迈的人对死亡快要来临感到恐惧是合理的。但是，对于我们其他人而言，我认为这种情绪是不恰当的。如果你自己非常健康，但你却对我说：“死亡真是令人喘不过气来，我太害怕死亡了。”我只能回应说，我相信你，但是尽管如此，这种对死亡的畏惧不是一种恰当的情绪。基于已有的事实，这种畏惧不合情理。<br>当然，即使我这种看法是正确的，而且对死亡的恐惧在大部分时候是不恰当的，但仍然存在别的可能性，即一些其他的负面情绪是恰当的。我已经提到了，有时候即使恐惧是不合理的，但感到愤怒、悲伤和悔恨却是恰当的。所以，我们仍然要问，想到死亡的时候，这些负面情绪中是否有哪一种是恰当的呢？<br>有一点是毋庸置疑的，基于我关于永生的看法，我终究会死这个事实本身不是坏事，也不包含任何坏事。死亡本身不是一件坏事，而是一件好事。因此，我认为对死亡本身，即我将会死去这个事实表现出负面态度是站不住脚的。但是，我们可以关注“我们可能会死得太早”这个可能性，也就是说，当生活给予我的总体来说（在两相权衡后）还是美好的事物时，我可能就得死去。死得太早的可能性显然是一件坏事。在这种情形下，如果有某些负面情绪是合理的反应，那会是什么情绪呢？<br>一个显而易见的答案是愤怒。即使恐惧不是面对死亡的恰当的反应，但愤怒有可能是，持这个想法看起来是很自然的事。我一部分意识里想对宇宙挥拳，咒骂它只给了我60年或70年或100年的寿命，而世界又是如此丰富多彩、不可思议，需要花上几百年、几千年或者更长的时间才能享尽它的奉送。面对我可能会死得太早这个事实，愤怒难道不是恰当的反应吗？<br>然而，事实上，答案并不是那么确定无疑的。和其他情绪一样，恰当的愤怒本身需要满足一定的条件，这些条件是否已经被满足，在这里还不清楚。无可否认，恰当的愤怒需要的第一个条件——有坏事发生在你身上（或可能发生在你身上）——事实上已经被满足了，因为我有可能很早就会死，这对我来说是一件坏事。但是，要使愤怒合理，还需要一些附加条件，而这些附加条件可能没有被满足。<br>比如，只有在指向某个人，即指向施事者，也就是那些有能力决定如何对待你的对象时，愤怒才是合理的。如果在办公室里，尽管你以前告诉过同事要更小心一点儿，但还是有人将咖啡洒到了你的电脑上，弄坏了硬盘，那么愤怒是合理的。愤怒直指你的同事，一个对自己的行为有控制力的人。类似地，如果你因为在工作中得到的评价低而对老板倍感愤怒的话，那么最起码满足了一个特定条件：你的愤怒直指一个施事者，一个对于如何对待你有部分控制权的人。<br>当然，有时候我们会对无生命的物体生气。你要提交的工作报告截止日期就要到了，你正要把它打出来赶紧交上，这时你的电脑崩溃了。你会对你的电脑感到愤怒。到底发生了什么事？你把电脑人格化了：你把它视为一个人，认为它故意选择在这个时候坏掉，再次让你失望。我当然理解这种行为，我也做过这种事。但是，你当然也可以退一步思考。至少，一旦你的愤怒平息之后，就可以退一步思考，并意识到对你的电脑生气毫无意义。为什么没有意义呢？因为你的电脑不是一个人，它不是一个施事者，它没有选择权和控制权。<br>我想，另一个合理愤怒需要满足的条件是：只有当施事者错待了你，对你做了不合乎道德的事时，愤怒才是合理的。如果你理应从老板那里得到一个不好的评价，那么他并没有做错什么，你的愤怒就是不合理的。但是，如果他给你一个差的评价是为了报复你在壁球场上赢了他，那么他就做错了，你的愤怒就不再不合理了。当你对某人感到愤怒的时候，你透露的事实是你认为他们错待了你，他们不该这么对待你。<br>这两个附加条件可能不是进一步满足合理的愤怒仅需的条件，但是就我们的目的来说，这已经足够了。让我们想一想，对于我们有可能会死得太早这个事实而感到愤怒，真的站得住脚吗？<br>答案可能很大程度上取决于你认为谁，或者说什么，该为我们死得太早负责。为什么我们只有60年、70年、80年可以活？这里有两种基本的答案。一方面，你可能认同一种经典的宗教学观点，认为是上帝统治着宇宙并且决定着我们的命运。也许上帝判了我们死刑，让我们中的大多数人死得过早。这是我们在《创世纪》中看到的，比如，上帝将亚当和夏娃贬为凡人，惩罚他们。另一方面，你可能会相信存在一个完全非人格化的宇宙。从这种观点看来，宇宙只是原子在太空中盘旋，通过各种结合方式聚合到一起而形成的，没有人在幕后操纵这一切。我们会死亡，这是因为生命碰巧是如此发展的。<br>让我们来考虑这两种可能性，从有神论的宇宙观开始。在这种情况下，至少满足了恰当的愤怒需要的两个附加条件中的第一个。既然上帝是一个人，那么对上帝感到愤怒是恰当的，因为他惩罚我们，给了我们如此短暂的生命，相比之下，世界又是如此丰富多彩。但是，第二个附加条件呢？上帝错待我们了吗？他给我们50年，或者80年，或者100年，是错待我们了吗？上帝对我们做了什么不道德的事情了吗？如果不是的话，那么对上帝的愤怒和怨恨就说不通了。<br>假设一位同事有一盒糖，她给了你一颗，你很喜欢。然后她又给了你第二颗，你也很喜欢。然后她又给了你第三颗，你还是很喜欢。假设你问她要第四颗糖的时候，她没有给你，她这样做错待你了吗？她这么对你是不道德的吗？她欠你更多的糖吗？目前还说不好。但是，如果答案是否定的话，那么你感到气愤就并不恰当了。当然，如果你感到气愤，我能理解，只因为这是一种很常见的反应。但是，当你的同事给了你一些好东西，之后却不给你更多的，这时愤怒是你该有的合理反应吗？不好确定。在我看来，恰当的反应不是愤怒，而应该是感激。你的同事并不欠你一丁点糖果，但是她给了你三颗。你也许希望自己可以得到更多，可能因为不能得到更多而伤感，但是愤怒的情绪并不恰当。类似地，对上帝感到愤怒也是不恰当的。在我看来，上帝并不欠我们的，并不需要给我们比我们已有的更多的生命。<br>假设你赞同的是第二种基本立场，相信存在一个完全非人格化的宇宙。在这种情况下，甚至连第一个附加条件都没有满足。对宇宙感到愤怒不是一种理性的恰当的行为，恰恰是因为宇宙不是一个人，不是一个施事者，它对它的所作所为没有选择权和控制权。诚然，我可以挥舞拳头，诅咒宇宙，但是我这样做就是将宇宙人格化了，把它当作一个故意决定让我们过早死去的人。但是不管这种反应有多么常见，如果宇宙并不是一个人，只是原子在太空中旋转形成的各种各样的聚合，那么理性来讲，这种反应就是不恰当的。从这种观点来看，对我可能会死得太早这件事感到愤怒就说不通了。<br>那么，如果感到悲伤呢？我应该为自己可能会很早就死去感到伤心吗？事实上，在我看来，按照上面讨论的，某些情绪是合理的。世界是一个如此美妙的地方，如果能够更多地从这个世界提供的精彩事物中获益，那该多好。因此，我为我不能得到更多而感到伤心。我认为，这种伤心是合理的。<br>但在这样想的时候，我发现自己马上有了另外一个想法。尽管不能得到更多，令人遗憾；但是能够得到这么多，我已经无比幸运了。在我看来，宇宙只是一堆旋转的原子，聚合成一群群各种各样的东西，然后这些原子群消融或者分解。这些原子大多数根本就没有生命，它们不能成为人类，不能相爱，不能欣赏落日，不能吃冰激凌。能够有幸成为被选中的少数（原子），对我们来说是无上幸运的。<br>让我分享一段话，这是我最钟意的表达了这个观点的话。这段话来自库尔特·冯内古特的《猫的摇篮》（Cat’s Cradle）。冯内古特设想了一段人们在病榻上可能会吟诵的临终祷告（以下翻译来自刘珠还译本，特此感谢。——编者注）：<br>上帝创造泥土。<br>上帝感到有点孤独。<br>于是上帝对一些泥土说：“坐起来！”<br>“看看我创造的一切，”上帝说，“山峦，海洋，天空，星辰。”<br>我就是那些坐起来环视四周的泥土。<br>幸运的我，幸运的泥土。<br>我，泥土，坐起来，见到了上帝完成的伟业。<br>干得好，上帝！<br>唯有你才能胜任这一切，上帝！我肯定力不能及。<br>跟你比我不足挂齿。<br>只有在想到那些甚至都没有坐起来环视四周的泥土时，我才产生些许的自尊。<br>我收获如此丰厚，而大多数的泥土却收获如此微薄。<br>谢谢您赐予我荣耀！<br>现在泥土再次躺下，入睡。<br>泥土有多美好的记忆啊！<br>我遇见多么有趣的其他坐起来的泥土啊！<br>我喜欢所见到的一切！(1)<br>在我看来正确的情绪反应不是恐惧，不是愤怒，而是感激，感激我们可以拥有生命。（感激应该像愤怒一样，只能指向一个人吗？如果是的话，如果人们相信非人格化的宇宙，那么严格来说，恰当的情绪也不是感激，或许那是一种感到无比走运或幸运的感觉。）<br>小心谨慎<br>到目前为止，我们一直在讨论面对死亡的反应的情绪方面。那么行为方面呢？鉴于我们都将会死去，我们应该如何活着？有个答案一下子就跳进了我的脑海，它看起来就像是一个笑话。我想说，我们应该小心谨慎地活着。<br>曾有一档警察类电视节目叫《山街蓝调》（Hill Street Blues）。每天这个节目开头，都由一位警长评点最近发生的案件以及正在进行的调查，最后他派出警员，并叮嘱说：“在外面要小心。”总是以此结尾。<br>你当然要小心，不然的话，你可能会死于那些本可以避开的致死因素。如果你不够小心，你不会注意到有一辆卡车正向你撞来。这看起来似乎显而易见，但是除了这种琐碎的观察之外，除了必须注意那些可能提前结束我们生命的危险外，“我们将会死去”这个事实还需要进一步的特别关照：你必须留意你在拿自己的生命干什么。就像人们有时候说的，你只能到世间走一遭，没有再来一次的机会。我们终有一死，我们的生命是有限的，这要求我们意识到：我们有可能把生命搞砸，我们可能会过着一种错误的生活。<br>吹毛求疵的那部分我想指出一点，不是终有一死的命运本身包含了这样的暗示。即使我们可以永远活着，我们还是可能过着错误的生活。毕竟，即使拥有无限长的生命，你还是会拥有一些特定的行动模式，从事一些特定的活动，而这种特定模式仍可能不是你可以拥有的最佳模式。所以无论是否拥有终有一死的命运，搞砸生命的可能性、过着一种错误的生活的可能性，对我们所有人来说都是存在的。要明白这一点，请看下面这个极为简单的例子。假设我们可以永远活着，想象一个人用他一生的时间来数整数：1、2、3、4、5、6……相对于做更复杂的数学研究来说，这可能是一种不怎么有价值的度过永生的方式。所以，即使是永生的人也可能浪费掉他们的生命。<br>话虽如此，但如果我们必然死去，而没有不朽的生命，就增加了额外的风险，即额外的搞砸它的危险。毕竟，如果你真的可以活到永远，那么即使你已经花了100万年或者10亿年数整数，只要你发现这是一件了无意义的事，你总是可以重新开始。你有大把的时间可以开始做更加深奥的、更有价值的数学研究。永生给了你重新开始的机会，给了你重来一遍的可能性。<br>因此，我们是不是可以推断，终有一死的命运剥夺了我们重新开始的机会，这是它特别的烦人之处？但是，这也不是非常正确。即使你不能活到永远，事实上，即使你只能活60年、70年或80年，那么在20岁、30岁或50岁的时候，你也有机会可以重新审视你的生活，并决定是否需要改变。所以，并不完全是终有一死的命运导致我们失去了重来一遍的可能性。然而，死亡来得很快这个事实，的确意味着必须特别小心谨慎，因为我们只有这么一小段时间可以重新来过，只有那么一点儿宝贵的时间可以去纠正我们的错误。<br>我们可能会犯两种错误。我们可能会发现，一方面，在“目标是什么”这个问题上，我们做出了错误的选择。另一方面，我们可能会发现，即使我们设定了正确的目标，但在达成目标的过程中，我们却把它搞砸了。所以，我们确实需要重新开始，再来一次。因此我们需要注意两个方面：我们必须在目标的选择上非常小心，也必须在执行目标的过程中保持谨慎，因为我们有且只有极其有限的时间来把事情做对。<br>挑剔的那个我要再次指出：严格来说，我们的生命相对短暂（通常少于100年）并不必然推导出我们需要特别谨慎。一个从绝对值上来说短暂的生命本身并不意味着我们必须非常小心。毕竟，可能没有那么多事情，或者这些值得做的事情都不难做好。假设只有5件值得做的事，而且即使你不是每一件事都能一次性做对，但最多试两三次就可以，每次尝试最多花一两个小时。显然，如果这个世界只能提供这么多的话，那它该多么贫瘠。但是，如果这真的是世界运转的方式，而我们有100年可以活，就不用为需要小心而担心了。我们有足够的时间致力于这5件值得做的事，有足够的时间去把每一件事都做好，根本不需要100年的时间，20年的生命可能都嫌多！我们根本不需要小心谨慎。<br>所以，不是因为我们终有一死，也不是因为从绝对量上来说我们只能存活很短的一段时间，我们才要小心谨慎。而是相对于有那么多值得追求的目标，以及达成这些目标又那么复杂困难而言，我们的时间太有限了。有那么多事可以做，而要把它们做好又是那么难，所以我们必须非常谨慎。我们没有时间到处乱晃，试一试这个，试一试那个。<br>正如我所说的，这里存在两种危险。首先，我们可能最终发现以之为目标的事物并不真的是最佳选择。顺便说一下，需要注意的是，最大的风险不是发现我们试着完成的目标根本不是真正值得做的，而是发现我们在这些事上浪费了时间，与我们可能会为自己设立的其他目标相比，这些事的价值要小得多得多。如果想要试着完成每一件值得做的事，我们拥有的时间就太少了。鉴于我们只有相对有限的一段时间，就需要决定哪些事情是最值得追求的，这就成了一个额外的负担。我们都有可能在最终回顾人生时发现，我们在制定目标时没有做出明智的选择。所以，这是死亡使得我们只能小心谨慎的一种方式。除此之外，当然还有第二种方式，无论我们的目标是什么，我们仍然需要考虑如何来完成目标。生活可能会给你足够的时间，让你偶尔能够重来一次，但是显然，你没有那么多时间把所有的事情都重来一遍。所以，这是死亡使我们变得小心谨慎的另一种方式。<br>打一个比方，想象你是一位音乐家，走进一个录音棚，打算录一张专辑。如果你有足够多的时间，比如说可以在录音棚里待一个月，那么你就不用特别小心翼翼了。你可以从你的曲目里选一些歌，然后看看效果。也许这些不是最适合录成专辑的歌曲？没关系，我们先试一试，然后就会知道适不适合了。一首歌第一次没有录好？不成问题，我们可以再录一次。我们甚至再录第三次或者第四次，或者可以尝试一首完全不一样的歌。如果你有足够的时间，清楚地知道哪些歌是要录的，就不是那么重要了；一次或者最多两次就要把这些歌录好，也不是那么重要了。<br>不过，如果你没有一个月时间可以泡在录音棚里，而是只有一周的时间待在里面，或者只有一天的时间，突然间所有的事都变得更加紧迫了，时间变得宝贵了。你必须尽早决定哪些歌是值得录的。当然，你还有其他的歌可以录，但是这些歌看起来像是更好的选择。当你开始录制它们的时候，你不能像只是把它们录完那样漫不经心和随随便便。你必须尽量一次录好，最坏的情况下也必须录两次就得成功。<br>在我看来，这就和我们自身的处境一样，我们所处的世界是如此丰富多彩，能够给我们提供这么多东西，在值得追求的事物上我们有那么多目标，而要达成这些又是那么困难。诚然，生命足够长，无论是改变自己的目标，还是为了达成目标做出两三次尝试，我们确实都有一些可以重来的机会。但事实是，我们没有那么多机会，我们根本没有那么多时间。所以我们必须留心，必须非常谨慎。<br>当然，说到这里，我们马上就会问：我应该拿我的生活怎么办？我在，故我专注，我尽量小心。但是我该怎么做？我该怎样度过我的人生？我该以什么为目标？<br>我必须告诉你，我不打算回答这些问题。问“生命中什么东西是真正值得追求的”，这个问题几乎等于在问“生命的意义是什么”。什么样的目标、什么样的意图、什么样的目的才是最有价值的、最有回报的、最有意义的呢？这显然是一个很重要的问题，事实上可能是唯一重要的问题。但是我认为，这是另一本书该讨论的问题。所以，触及这个问题后，现在我要放弃它。<br>对策<br>既然我终将死去，那么我该怎么生活呢？一个自然而然的想法是：我们的时间不多，所以应该尽可能多地去体验，在还能这么做的时候，让生命包含尽可能多的内容。<br>这是一个再普通不过的想法。但是我想，至少有两种不同的广泛性策略来把这个想法付诸实践。第一种策略强调目标太过远大时有失败的风险，它会建议我们选择那些肯定会达成的目标取而代之。它告诉我们选择食物、伴侣和性爱所带来的欢愉。“吃喝玩乐吧，因为明天我们就死了。”这就是第一种策略。明天我们可能就死了，所以当我们还活着的时候，应该去追寻那些更有机会实际得到的东西，通过这种方式让生命尽可能丰满充实。<br>第二种策略觉得，如果那正是你所想要追求的，你当然有很大的机会可以成功，这样也未尝不可。但第一种策略存在一个问题，那就是：如果你只追求那些确定的事物，那么你能取得的成就往往很小。一般来说，它们都是一些微不足道的小事。第二种策略提醒我们，生命中有一些最有价值的东西，不是你确定可以轻易得到的。你可能想要写一本小说，创作一曲交响乐，或者是结婚养家。这些更有雄心壮志的事情，是生命可以提供的最有价值的事。有一些人生被吃喝玩乐这种容易获得却稍纵即逝的快乐所填满，相比而言，一个充满了雄伟目标和不确定性的人生是更有价值的。<br>假设上帝对你说：“你想要哪种人生？一个充满了美食佳酿和转瞬即逝的快乐的人生，还是一个充满持久成就的人生？我向你保证，无论选择哪一种人生，你都会非常成功。”我想，大多数人都会认为一个有着真正成就的人生更有价值。问题是，在现实生活中，这种人生，即以重大成就为目标的人生，也有更大的失败风险。你想写一部伟大的美国小说，10年后你还没有完成。20年后，你觉得自己不具备写出伟大的美国小说的天赋。这时，对于已经逝去的生命，你有什么成就可展示的呢？又或者你试着去创业，想开创一个蒸蒸日上的事业，但在一年又一年的艰苦奋斗和挣扎之后，还是破产了。<br>那么，哪一种才是我们应该采用的正确策略呢？我想很多人都会倾向于认为，实际上还有第三种策略，而这第三种策略才是我们应该采用的，即把大目标和小目标恰当组合起来。一方面，我们应该追求某种重大成就，这样，一旦你实现这些目标，你的人生就会更有价值；与此同时，另一方面，你也需要搭配一些小目标，这样，至少可以保证你从生命中得到一些东西。<br>当然，即使我们赞同这种混合策略，认为这是最合理的，我们还是想要知道怎样的组合才是合适的。但我也不打算回答这个问题。我想问的是，我们该不该接受这三种不同策略背后所隐藏的共同观点，即往生命里装进尽可能多的东西呢？不论我们是在讨论大成就还是小追求，或是两者的组合，是不是往生命中添加的东西越多，生命的价值就越大？真的是这样吗？我们假定越多越好，这是正确的吗？<br>我已经论证过，永生实际上并不是一件好事。虽然世界丰富多彩，充满了不可思议，但最终每个人生命中的美好事物都会耗尽；永生将会变得糟糕透顶。但大多数人都离“即将耗尽生命中所有美好事物”还太远，我们大多数人都死得太早了。比如，如果你在30岁去世，对你来说能够活到40岁本来会更好。如果你在40岁去世，那么活到50岁、60岁、70岁或者80岁本来会更好。所以，我们大多数人都倾向于同意一个观点，那就是，在其他条件相同的情况下，你活的时间越长越好。<br>让我们来比较图14.1中的两种生活。图中四边形的宽代表生命的长度，高代表在给定时刻生活的幸福水平。图中所示的两种生活过得一样好。为了有一个具体的概念，我们可以假设这两种生活在每一刻都有100分的幸福值，同时假设这是一个非常高的幸福水平。我想，大多数人都偏好右侧的这种生活。我们都会同意在这个幸福水平上，能活100年的人生就比只能活50年的人生要好。在其他条件相同的情况下（这里我已经规定了，其他条件相同），生命的长度或持续时间越长越好。</p><p>但与此同时，我想我们都同意生命的长度不是唯一重要的因素，生活的质量也很重要。举例来说，假设你必须在两种生活中二选一：一种是长度为50年，“质量分”为100分的人生；另一种是长度为50年，质量分为130分的人生（见图14.2）。估计你会选择第二种人生。所以，生命的长度并不是我们唯一关心的要素，我们也注重生命的质量。</p><p>从数学角度来考虑，我们会说幸福总量是生命持续时间和质量的二元函数。更准确地说，我们可以说幸福总量就是图中四边形所围起来的面积值，也就是将生命持续时间和质量相乘之后得到的数值。所以，在图14.2中，第一种人生的幸福总量为5000（50×100=5000）个单位的幸福，第二种人生的幸福总量为6500（50×130=6500）。当然，我们不必认为这些数值能如此精确，重要的是其背后所包含的想法，即四边形的面积代表了你在50年的生命中所能获得的幸福总量。<br>（如果我们接受有价容器理论的观点，而不是中性容器理论的观点，就需要一个更复杂的公式。将生命持续时间和质量相乘，得到的仅仅是生命内容的价值。如果活着本身也具有价值，那么我们需要增加一个额外的量来得到整体总和，以反映生命所包含的以及生命本身的价值。可以假定，这个额外的量是生命持续时间的一元函数。为了简便起见，我就不采用这种复杂的计算方式了。同样地，为了简便起见，我也将第十三章中提到那类观点放到一边，即不考虑人生的总体价值将受到人生整体形态的影响。）<br>如果幸福是生命持续时间和质量的二元函数，那么我们可能就不得不面对二选一的情况。见图14.3所示，图中第二种人生持续的时间要比第一种人生长得多（100年，而不是50年），但是它的生活质量水平要低一些（90分质量分，而不是100分）。我们要问，在生命持续时间上的增量是否足以弥补在质量上的落差，从而使得第二种人生比第一种人生更好呢？如果我们诉诸幸福总量的概念，就会做出肯定的回答，因为第二个四边形的总面积要大于第一个四边形的总面积（9000单位∶5000单位）。</p><p>显然，当幸福总量被定义为生命质量和生命长度的乘积时，考虑幸福总量就是考虑生命质量重要性的一种方式。但是，这是正确的方法吗？这种方式给了生命质量足够的重视吗？<br>结论目前尚不明确，不过可以想一想另外两种人生之间的选择。在图14.4中，第一种人生可以幸福地生活很长时间，比如说100年，而且生命质量在一个极其高的水平上，有150分的质量分。假设地球上目前为止有过的最好人生其生命质量水平是125分，所以150分好得不可思议。你拥有了这样的人生，而且可以活100年！现在用这种人生和图中所示的第二种人生对比一下。在第二种人生里，生命质量非常不高，只有1分。需要提醒一下，这仍是值得一活的人生，因为1依然是一个正数。不过在任何时间点，这样的人生都只是勉强让人值得拥有罢了。（得分为0的人生虽然并不比不存在要差，但是不值得一过；负分的人生比从未活过还要糟糕。）尽管如此，虽然生命的质量很低，但是这个人生持续了很长很长的时间。它持续的时间太长了，以至于我都无法按比例把它画出来了。（这就是我在线条中间标上了省略号的原因。）假设这段人生持续了30000年。</p><p>再问问你自己，这两种人生你更喜欢哪一种，是第一种还是第二种呢？我想，大多数人还是偏好第一种而不是第二种。不可否认，第二种人生比第一种人生要长得多，但是除此之外，在任何时间点，它都只是勉强值得拥有。与此相对的是，第一种人生虽然短得多，但是生活质量却相当高。面对这样的选择，我想大多数人都会认为，在第二种人生里，额外的生命长度并不足以弥补在生命质量水平上显著的落差。<br>需要注意的是，如果我们不得不根据两种人生所包含的幸福量来二选一的话，我们不得不说第二种人生比第一种人生更好。毕竟，第二个四边形的面积是第一个的两倍（30000∶15000），也就是说，第二种人生所包含的美好事物的总量是第一种人生的两倍。所以，这个选择告诉我们，尽管知道第一种人生的幸福总量更少，你还是认为事实上第一种人生更优越，那就表示幸福总量并不说明全部问题。稍换一种说法就是，尽管幸福总量将生命质量考虑在内，但这种方式可能是错误的，它没有赋予生命质量足够的权重。(2)<br>当比较两种生活时，很自然的一个想法是：尽管第一种人生更短暂，但是它达到了生命质量的巅峰水平，而这种水平没有在第二种人生中的任何一个时刻出现过。在评估和选择时，我们也许不能只看美好事物的数量，还必须特别注意其高度和峰值。当考虑人生时，不仅要问从总量上来说，你的人生得到了多少东西，还要问在这一生中你所取得的最大成就或得到的最好事物是什么，后两个问题十分重要。简而言之，也许质量可以胜过数量。<br>要想将这种观点付诸实践，可以采取很多不同的方式。至少，我们可以给生命质量一个额外的权重，这样，有时候（但不总是）生命质量就可以在重要性上超过数量。这种观点一个比较大胆的版本认为，生命质量总是比数量重要，但这并不是说数量不重要。如果让我们在两个取得同样伟大成就的人生中选择，一个拥有更长的生命，一个更短，我们可能还是会认为更长的人生更好。所以，当我们认可质量最重要时，数量也重要。<br>还有一个更大胆的理论版本说，事实上，生命质量是唯一重要的。我们只应该关心那些巅峰。不管怎么说，这至少是弗里德里希·荷尔德林在他的诗歌《献给命运女神们（致命运）》［To the Parcae（to the Fates）］中所表达的立场（译文采用钱春绮译本，特此感谢！——编者注）：<br>万能的女神们！请假我一个夏季，<br>一个秋季，让我的诗歌成熟，<br>那么，我的心儿，满足于<br>这甘美的游戏，就乐愿死去。<br>这颗心灵，在生时不能获得它那<br>高贵的权利，死后也不会安宁；<br>可是，有一天，这神圣的事业，<br>深藏在我心中的诗歌获得完成，<br>那么，冥府的沉寂，欢迎你来吧！<br>我将会满足，即使我的乐器<br>没有伴我同住；我只要有一天<br>过着神的生活，我就更无他求。(3)<br>荷尔德林说的是，他完全不在乎数量。如果他可以取得一些重大的成就，如果他可以写出伟大的诗歌，登上巅峰，那就足够了。只要曾经像诸神一般生活过，就别无他求。<br>所以，当我们思考该如何生活时，仅仅思考什么是值得拥有的还不够，我们必须解决质量和数量的问题。质量中涵盖了数量，所以数量是重要的，但实际上真正重要的仅仅是质量，是这样吗？还是数量本身就很重要，本身就值得追求，即使那意味着值得拥有的事物其质量更低呢？如果质量很重要，那数量也重要吗？还是说质量是唯一重要的呢？当荷尔德林说“只要有一天过着神的生活，我就更无他求”的时候，他是正确的吗？<br>我猜想，荷尔德林能够信心满满地说“更无他求”的部分原因是，他认为自己的诗歌可以做出持久的贡献。通常，当我们认为自己完成了一些了不起的事业时，就会感觉自己好像获得了某种程度上的永生。比如，我们会通过自己的作品活下去。所以，接下来在探讨面对死亡而生活的策略时，我想要问，这类永生是否值得追求。当然，我强调“类”这个字，是因为严格来说，如果你通过自己的作品或通过你的孩子活在世上，诸如此类，那不同于你真正地活着。这最多是半永生（semi-immortality）或者准永生（quasi-immortality）。我想那些不相信这类永生价值的人会称之为伪永生（pseudo-immortality）。（就像伍迪·艾伦所说：“我不想通过我的作品变得不朽，我想要通过不死来活着。”）<br>在我看来，对“半永生”价值的这种追求一般分为两种主要形式。有时候人们会说，尽管你没有真的继续活着，但是你的一部分还继续活着，这和你自己继续活着非常相似。比如，如果我有孩子，那么我的一部分就在我的孩子体内。我的一个细胞在别人身上延续。如果我的孩子还有孩子，那么，他们的细胞将在他们的孩子身上延续，他们孩子的细胞将在他们孩子的孩子身上延续，以此类推。请想象一下一只阿米巴虫不停地分裂，分裂，分裂，再分裂，原始的那个阿米巴虫的一部分可以在很多很多代上延续。从字面上讲，我们的一部分会继续存活，有些人从这种说法上找到了安慰。即使我从来没有过孩子，至少我的原子可以循环再利用。最终，我被宇宙吸收回去，但是我并没有完全消失。有一些人从这种想法上得到了慰藉。<br>德国哲学家叔本华认为这可以减少几分死亡的痛苦。他说：“但是有人还是会问，‘微不足道的尘埃和天然粗糙的原材，怎么能当成我们万物之灵的延续呢？’”他回答说：<br>哦！那么你了解这尘埃吗？你知道它是什么，它可以做什么吗？在你鄙视它之前，请试着了解它。这地上的尘土，当它溶解在水里，很快就会结晶；它像金属一样闪耀；它会释放电火花……它会自然地形成植物和动物；在它那神秘的子宫里，它会孕育出生命。在你那狭隘的思想里，失去这生命让你如此紧张与焦虑。(4)<br>这的确是一段激动人心的文字，但是我不得不说，我不买账。当我想到自己的原子将仍然存在于世，在其他东西里被再次使用时，并不能从这个想法中得到一丝安慰。所以，这第一种类型的半永生，这种从字面上“你的一部分还会继续存在”的想法中找安慰的行为，在我看来，就像绝望地抓住救命稻草一样。“哦，我就快要死了，但是也没有那么糟糕，至少我的原子还在。”如果叔本华是这么想的，我认为他只是在自欺欺人罢了。无论如何，这对我没用。<br>如果“你的一部分会在死后延续”这种想法并不怎么能给你安慰的话，那还有第二种获得半永生的方法，就是“你的成就会在死后继续存在”。荷尔德林写的诗，200年后我们还在阅读。你可以写一部小说，被世人传诵20年、50年、100年或者更久；你可以为数学、哲学或者科学做出贡献，50年或100年后，人们可能还会讨论你的那些哲学论点或者数学结论。<br>当然，还有很多其他的持久成就。比如，你参与建造的建筑物，在你过世之后依然还在。我读过关于石匠的采访。他们认为，在自己去世很久以后，那些他们参与建造的建筑物还会矗立世间，这让他们感到骄傲和宽慰。或者你可以试着创立一家公司，在你死后仍继续存在。或者，你可以从养育家庭的成就中得到愉悦和欣慰。这并不是说你的一些细胞在后代体内延续，而是说将另一个正直的人抚养长大是一项了不起的成就，那是生活中值得去做的事，并且这份成就在你死后依然存在。<br>我们该如何看待这第二种类型的半永生呢？必须承认，我有些拿不定主意。如果你认为自己的组成部分在死后仍然存在是令人欣慰的，我会认为你是在自欺欺人，但这第二种类型的半永生不同于尘埃和原子的说法，我倾向于认为它含有一些真正的价值。创造一些能够持续一段时间的有意义的东西是很有价值的，这种想法对我来说有说服力。即使我的生命终究是短暂的，但是如果我完成的一些事业得以延续，那么我的人生也就因此更有价值。我估摸着，这就是荷尔德林的想法，这也是一种对我个人来说很有吸引力的想法。这种说法部分解释了为什么我也要写哲学书。我希望自己写下的东西，在我死后20年或者50年，或者如果我够幸运的话，100年后，还有人在读。<br>所以一般情况下，也许是大部分情况下，我认可这种想法，但是我必须承认，在另一些时候，我对它也有质疑。我提醒自己想一想叔本华写的文字，他的“尘埃颂”，接着我就觉得我在欺骗自己，就像叔本华欺骗他自己一样。叔本华太绝望了，以至于他自欺欺人地想：“哦，我就要变成尘埃了，这没有关系。尘埃真的真的很重要。”类似地，当我认为取得能够超越自己而存在的成就是伟大的、有意义的、有价值的时候，我会担心，也许我也只是在欺骗自己。至少，当我心情消沉的时候，我认为自己只是在自欺欺人。<br>但那只是在特定的情绪下才会有的想法。在大部分时候，我还是认同荷尔德林的观点。不过，我不同意他关于数量完全不重要的说法。荷尔德林认为写出一部伟大的作品就够了，那就意味着再写出其他伟大的作品都是多余的，在我看来，这有点儿太极端了。我认为，数量也是很重要的。但在这一点上他是对的：完成一些持续的有意义的事，在我看来，确实可以增加自己生命的价值和意义。<br>让我快速阐述一下最后一种面对死亡的方法。我将用很短的篇幅来介绍最后一种策略，但它当然也值得关注。到目前为止，我们提及过的所有策略，都有一个共同的潜在信念：生活是或者可以是美好的，所以让你的人生变得尽可能地有价值，这就说得通了。尽管不同的策略在细节上各有不同，但在有一点上却是一致的，那就是对于失去生命我们无能为力，所以正确的应对方式是，尽量让我们拥有的生命更有价值。也就是说，在我们还拥有它的时候，去发现（并提升）它的价值。<br>但是，有人可能会采用另一种完全不同的方式来面对死亡。持这种观点的人会说：是的，我们将会失去生命，这看起来很可怕。但是，只有当失去生命真的是一件坏事的时候，它才是真正可怕的。如果我们认为生命不是一件珍贵的礼物，不值得拥有，没有什么潜在的价值，那么失去生命根本就不能算是一种损失。这种观点其实和我们之前探讨过的一种观点有很紧密的联系。根据剥夺解释理论，死亡的主要坏处在于它剥夺了我们本值得一活的一段生命。当然，这就意味着，如果悲观主义者是对的，即生命并不值得拥有，那么，失去生命根本就不是一件坏事，反而是一件好事。所以，这里的关键就不在于尽量生活得有价值，而在于意识到权衡下来生活是负面的，而不是正面的。<br>我将要说的简单得像《经典名著漫画》一样，而且非常一概而论，但是也许我们可以笼统地说，第一种基本观点是西方的观点。根据这种观点，生命是美好的，所以失去生命是一件坏事，而应对它的方法就是在我们还拥有生命的时候，充分利用它。类似地，如果笼统地来说，第二种基本观点也可以说是东方的观点。根据这种观点，生命并不像我们通常以为的那样美好，所以根本不用将失去生命看作是一件坏事。当然，把这种观点叫作“东方的观点”是过分简单化了，但至少这种观点更多地出现在东方思想中，而不是西方思想中。<br>在一些特定的佛教流派中，我们可以找到第二种观点的典型例子。佛教宣扬“四圣谛”，而第一种圣谛就是“人生是苦”（life is suffering）。佛教徒相信（或者至少是某些佛教徒相信），如果你认真思考生命的内在本质，你便会发现遗失和苦难无处不在。(5)生命中有苦难，有疾病，有死亡，有痛苦。诚然，生命中也有我们希望拥有的东西，如果足够幸运，我们就可以得到它们；但是，随后我们又会失去它们，而这又增加了苦难、痛苦和不幸。两相权衡后，生活不是美好的。基于这种判断，佛教徒试着将你从对这些事物的执着中解脱出来，这样当你失去它们时，损失就能最小化。实际上，佛教徒希望将你从他们所说的自我幻象中解放出来。不存在自我，就没有什么可以失去。<br>我担心死亡是自我的消亡（dissolution of myself），所以死亡令人恐惧。但是如果没有自我，就没有可以消亡的对象了。<br>我要说的是，我极为尊敬佛教。假设人生是苦，这很能说得通。但我是在西方文化中长大的，不管这是好还是坏，我都是读着《创世纪》长大的，书中说上帝看着这个世界，并判定这是个美好的世界。至少对我来说，通过承认生活是消极的来使损失最小化，不是我可以接受的方式。那么，对我来说，或许对我们大多数人来说，应该在我们已经讨论过的几种更为乐观的策略之间做出选择。我们要问的是：如何让我们的生活变得更有价值呢？有什么事我们做成之后，可以像荷尔德林那样说，“只要有一天过着神的生活”呢？</p><h3 id="自杀"><a href="#自杀" class="headerlink" title="自杀"></a>自杀</h3><h4 id="自杀的合理性"><a href="#自杀的合理性" class="headerlink" title="自杀的合理性"></a>自杀的合理性</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430100982&amp;page=24&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="犹豫不决的决定"><a href="#犹豫不决的决定" class="headerlink" title="犹豫不决的决定"></a>犹豫不决的决定</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430098362&amp;page=25&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="自杀的道德批判"><a href="#自杀的道德批判" class="headerlink" title="自杀的道德批判"></a>自杀的道德批判</h4><iframe src="https://player.bilibili.com/player.html?aid=421331895&amp;bvid=BV1V3411k7Q1&amp;cid=430097476&amp;page=26&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/DEATH/PoxbFP.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;最受欢迎的国际名校公开课之一《哲学：死亡》中，谢利卡根教授挑战了对于死亡，许多我们习以为常或未经深思的观点，邀请学生系统反思死亡的哲学之谜，以更清晰的概念探讨死亡的意义为何，从形而上学到价值观，认真、理性地思考生命和死亡的真相。有了对死亡的深刻意识，才会有对生命价值的深刻了解。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo Netlify CMS 静态博客管理与写作</title>
    <link href="https://yousazoe.top/archives/62b1072e.html"/>
    <id>https://yousazoe.top/archives/62b1072e.html</id>
    <published>2022-07-14T08:50:38.000Z</published>
    <updated>2022-07-29T03:00:04.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG12/AXeW7R.jpg"></p><span id="more"></span><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们都知道，Hexo 是一个静态部署博客的框架，优点在于速度快，成本低（无需服务器），缺点在于繁琐，你每次更新文章都需要去改代码，再部署推送，修改配置也是如此，你不能像WordPress一样直接在后台修改配置并使它生效。</p><p>不过有很多教程可以让你无需繁琐的部署，只管推送代码，通过GitHub Actions，travis-ci，Vercel，Netlify 等都可以便捷的进行博客的部署，只管写代码然后推送就好，类似的教程有非常多，在此就不再重复介绍。那么，我们是否可以在此基础上，更加便捷的进行静态博客的写作和管理？答案是可以的。</p><p>我们可以通过将博客部署到 Netlify，并使用 Netlify cms 来做到这一点。</p><p>首先，我们来了解一下配置完之后可以做到哪些事情？</p><ul><li>在线新建，编辑，预览，删除博客文章</li><li>支持文章草稿，工作流</li><li>支持对博客图片的管理</li><li>支持在线修改博客配置，例如对首页顶部图的修改，友链的修改</li></ul><h4 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h4><h4 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h4><p>为了更加直观，原作者做了一个已经配置完毕的博客，你可以在线体验上述功能 👉<a href="https://qwqmiao.cf/admin/">点我查看</a></p><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p>下面我将会以 Hexo + NexT 主题做演示，并配置 Fluid 主题 的友链功能，达到在线编辑预览友链的目的，但此方法不仅仅只适用于 Fluid 主题 的友链功能，其他各类主题也可以通过此方法达到在线修改配置的目的，只要你配置完成，几乎可以修改所有配置项。包括但不限于以下类型的文件yml、yaml、toml、json、md、markdown、html具体请查看 👉Netlify cms 文档。</p><h3 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h3><p>Netlify cms 使用的前提条件是你必须将博客部署到 Netlify 上。因为网上有很多部署教程，这里不再重复。</p><blockquote><p>可以部署到其他托管网站上，但需要自行修改</p></blockquote><p>具体可以查看：</p><ul><li><a href="https://guanqr.com/tech/website/deploy-blog-to-netlify/">博客通过 Netlify 实现持续集成</a></li><li><a href="https://io-oi.me/tech/deploy-static-site-to-netlify/">将 Hexo 静态博客部署到 Netlify</a></li></ul><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在部署完成后，你需要开启 <code>Identity</code>：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG12/sg5uDS.jpg"></p><p>进入设置中：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG12/fTM5np.png"></p><p>将 <code>Registration preferences</code> 修改为 <code>Invite only</code> 此项为是否开启注册，默认是开启注册。修改为 <code>Invite only</code> 后表示仅受邀请的用户可以注册，当然此项你可以在自己注册完毕之后再行修改。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG12/3O86cR.png"></p><p>下滑找到 <code>Git Gateway</code> 并开启。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG12/sojOqj.png"></p><p>至此准备工作完成。</p><h4 id="修改博客配置"><a href="#修改博客配置" class="headerlink" title="修改博客配置"></a>修改博客配置</h4><blockquote><p>在博客根目录中找到 <code>_config.yml</code> 并修改，这一步是跳过文件夹渲染，不然后面会出错： </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">skip_render: admin/*</span><br></pre></td></tr></tbody></table></figure></blockquote><p>在博客 <code>source</code> 文件夹中，创建 <code>admin</code> 文件夹，并新建两个文件 <code>index.html</code> 和 <code>config.yml</code>：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG12/Pc34XA.png"></p><p>在 <code>index.html</code> 中添加以下内容：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=Edge"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"white"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://identity.netlify.com/v1/netlify-identity-widget.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Fl0w3r<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">"true"</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/netlify-cms@2/dist/netlify-cms.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>因为涉及到 Jsdelivr 加速，所以我选择把两个 js 源文件下载到 <code>theme\next\source\js</code> 中：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset="utf-8" /&gt;</span><br><span class="line">        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;</span><br><span class="line">        &lt;meta http-equiv="x-UA-Compatible" content="IE=Edge"&gt;</span><br><span class="line">        &lt;meta name="apple-mobile-web-app-status-bar-style" content="white" /&gt;</span><br><span class="line"><span class="deletion">-       &lt;script type="text/javascript" src="https://identity.netlify.com/v1/netlify-identity-widget.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+       &lt;script type="text/javascript" src="js/netlify-identity-widget.js"&gt;&lt;/script&gt;</span></span><br><span class="line">        &lt;title&gt;Fl0w3r&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;body&gt;</span><br><span class="line"><span class="deletion">-       &lt;script defer="true" src="https://cdn.jsdelivr.net/npm/netlify-cms@2/dist/netlify-cms.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+       &lt;script defer="true" src="js/netlify-cms.js"&gt;&lt;/script&gt;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG12/PWgH0X.png"></p><p>在 <code>config.yml</code> 中添加以下折叠内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">backend:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">git-gateway</span> <span class="comment"># https://github.com/netlify/netlify-cms</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span> <span class="comment"># 要更新的分支(可选；默认为主分支)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line should *not* be indented</span></span><br><span class="line"><span class="attr">publish_mode:</span> <span class="string">editorial_workflow</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line should *not* be indented</span></span><br><span class="line"><span class="attr">media_folder:</span> <span class="string">"source/images/uploads"</span> <span class="comment"># 媒体文件将存储在图片/上载下的Repo中。</span></span><br><span class="line"><span class="attr">public_folder:</span> <span class="string">"/images/uploads"</span> <span class="comment"># 上传的媒体的src属性将以/images/uploads开头。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">site_url:</span> <span class="string">https://www.myql.xyz</span> <span class="comment"># 网站网址</span></span><br><span class="line"><span class="attr">display_url:</span> <span class="string">https://www.myql.xyz</span> <span class="comment"># 显示网址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">locale:</span> <span class="string">"zh_Hans"</span> <span class="comment"># 语言环境 https://github.com/netlify/netlify-cms/tree/master/packages/netlify-cms-locales/src</span></span><br><span class="line"></span><br><span class="line"><span class="attr">collections:</span> <span class="comment"># https://www.netlifycms.org/docs/configuration-options/#collections</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"posts"</span> <span class="comment"># 在路由中使用，例如：/admin/collections/blog。</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">"Post"</span> <span class="comment"># 在用户界面中使用</span></span><br><span class="line">    <span class="attr">folder:</span> <span class="string">"source/_posts"</span> <span class="comment"># 存储文件的文件夹的路径。</span></span><br><span class="line">    <span class="attr">create:</span> <span class="literal">true</span> <span class="comment"># 允许用户在这个集合中创建新的文件。</span></span><br><span class="line">    <span class="attr">fields:</span> <span class="comment"># 每份文件的字段，通常是前面的内容。</span></span><br><span class="line">      <span class="bullet">-</span> {</span><br><span class="line">          <span class="attr">label:</span> <span class="string">"顶部图"</span>,</span><br><span class="line">          <span class="attr">name:</span> <span class="string">"banner_img"</span>,</span><br><span class="line">          <span class="attr">widget:</span> <span class="string">"image"</span>,</span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span>,</span><br><span class="line">        }</span><br><span class="line">      <span class="bullet">-</span> {</span><br><span class="line">          <span class="attr">label:</span> <span class="string">"文章封面"</span>,</span><br><span class="line">          <span class="attr">name:</span> <span class="string">"index_img"</span>,</span><br><span class="line">          <span class="attr">widget:</span> <span class="string">"image"</span>,</span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span>,</span><br><span class="line">        }</span><br><span class="line">      <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"文章排序"</span>, <span class="attr">name:</span> <span class="string">"sticky"</span>, <span class="attr">widget:</span> <span class="string">"number"</span>, <span class="attr">required:</span> <span class="literal">false</span> }</span><br><span class="line">      <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"标题"</span>, <span class="attr">name:</span> <span class="string">"title"</span>, <span class="attr">widget:</span> <span class="string">"string"</span> }</span><br><span class="line">      <span class="bullet">-</span> {</span><br><span class="line">          <span class="attr">label:</span> <span class="string">"发布日期"</span>,</span><br><span class="line">          <span class="attr">name:</span> <span class="string">"date"</span>,</span><br><span class="line">          <span class="attr">widget:</span> <span class="string">"datetime"</span>,</span><br><span class="line">          <span class="attr">format:</span> <span class="string">"YYYY-MM-DD HH:mm:ss"</span>,</span><br><span class="line">          <span class="attr">dateFormat:</span> <span class="string">"YYYY-MM-DD"</span>,</span><br><span class="line">          <span class="attr">timeFormat:</span> <span class="string">"HH:mm:ss"</span>,</span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span>,</span><br><span class="line">        }</span><br><span class="line">      <span class="bullet">-</span> {</span><br><span class="line">          <span class="attr">label:</span> <span class="string">"更新日期"</span>,</span><br><span class="line">          <span class="attr">name:</span> <span class="string">"updated"</span>,</span><br><span class="line">          <span class="attr">widget:</span> <span class="string">"datetime"</span>,</span><br><span class="line">          <span class="attr">format:</span> <span class="string">"YYYY-MM-DD HH:mm:ss"</span>,</span><br><span class="line">          <span class="attr">dateFormat:</span> <span class="string">"YYYY-MM-DD"</span>,</span><br><span class="line">          <span class="attr">timeFormat:</span> <span class="string">"HH:mm:ss"</span>,</span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span>,</span><br><span class="line">        }</span><br><span class="line">      <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"标签"</span>, <span class="attr">name:</span> <span class="string">"tags"</span>, <span class="attr">widget:</span> <span class="string">"list"</span>, <span class="attr">required:</span> <span class="literal">false</span> }</span><br><span class="line">      <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"分类"</span>, <span class="attr">name:</span> <span class="string">"categories"</span>, <span class="attr">widget:</span> <span class="string">"list"</span>, <span class="attr">required:</span> <span class="literal">false</span> }</span><br><span class="line">      <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"关键词"</span>, <span class="attr">name:</span> <span class="string">"keywords"</span>, <span class="attr">widget:</span> <span class="string">"list"</span>, <span class="attr">required:</span> <span class="literal">false</span> }</span><br><span class="line">      <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"摘要"</span>, <span class="attr">name:</span> <span class="string">"excerpt"</span>, <span class="attr">widget:</span> <span class="string">"list"</span>, <span class="attr">required:</span> <span class="literal">false</span> }</span><br><span class="line">      <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"内容"</span>, <span class="attr">name:</span> <span class="string">"body"</span>, <span class="attr">widget:</span> <span class="string">"markdown"</span>, <span class="attr">required:</span> <span class="literal">false</span> }</span><br><span class="line">      <span class="bullet">-</span> {</span><br><span class="line">          <span class="attr">label:</span> <span class="string">"永久链接"</span>,</span><br><span class="line">          <span class="attr">name:</span> <span class="string">"permalink"</span>,</span><br><span class="line">          <span class="attr">widget:</span> <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span>,</span><br><span class="line">        }</span><br><span class="line">      <span class="bullet">-</span> {</span><br><span class="line">          <span class="attr">label:</span> <span class="string">"评论"</span>,</span><br><span class="line">          <span class="attr">name:</span> <span class="string">"comments"</span>,</span><br><span class="line">          <span class="attr">widget:</span> <span class="string">"boolean"</span>,</span><br><span class="line">          <span class="attr">default:</span> <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span>,</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"pages"</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">"Pages"</span></span><br><span class="line">    <span class="attr">files:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">file:</span> <span class="string">"source/about/index.md"</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">"about"</span></span><br><span class="line">        <span class="attr">label:</span> <span class="string">"关于"</span></span><br><span class="line">        <span class="attr">fields:</span></span><br><span class="line">          <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"标题"</span>, <span class="attr">name:</span> <span class="string">"title"</span>, <span class="attr">widget:</span> <span class="string">"string"</span> }</span><br><span class="line">          <span class="bullet">-</span> { <span class="attr">label:</span> <span class="string">"内容"</span>, <span class="attr">name:</span> <span class="string">"body"</span>, <span class="attr">widget:</span> <span class="string">"markdown"</span>, <span class="attr">required:</span> <span class="literal">false</span> }</span><br><span class="line">          <span class="bullet">-</span> {</span><br><span class="line">              <span class="attr">label:</span> <span class="string">"评论"</span>,</span><br><span class="line">              <span class="attr">name:</span> <span class="string">"comments"</span>,</span><br><span class="line">              <span class="attr">widget:</span> <span class="string">"boolean"</span>,</span><br><span class="line">              <span class="attr">default:</span> <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">required:</span> <span class="literal">false</span>,</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果你不是fluid主题，请删除以下配置，或者对文件路径及字段进行修改</span></span><br><span class="line"><span class="comment">#  - name: "settings"</span></span><br><span class="line"><span class="comment">#    label: "settings"</span></span><br><span class="line"><span class="comment">#    files:</span></span><br><span class="line"><span class="comment">#      - file: "source/_data/fluid_config.yml"</span></span><br><span class="line"><span class="comment">#        name: "fluid"</span></span><br><span class="line"><span class="comment">#        label: "fluid主题配置"</span></span><br><span class="line"><span class="comment">#        editor:</span></span><br><span class="line"><span class="comment">#          preview: true # 是否开启编辑预览</span></span><br><span class="line"><span class="comment">#        fields:</span></span><br><span class="line"><span class="comment">#          - label: "首页"</span></span><br><span class="line"><span class="comment">#            name: "index"</span></span><br><span class="line"><span class="comment">#            widget: "object"</span></span><br><span class="line"><span class="comment">#            collapsed: true # 是否折叠显示</span></span><br><span class="line"><span class="comment">#            fields:</span></span><br><span class="line"><span class="comment">#              - label: "顶部图"</span></span><br><span class="line"><span class="comment">#                name: "banner_img"</span></span><br><span class="line"><span class="comment">#                widget: "image"</span></span><br><span class="line"><span class="comment">#              - label: "高度"</span></span><br><span class="line"><span class="comment">#                name: "banner_img_height"</span></span><br><span class="line"><span class="comment">#                widget: "number"</span></span><br><span class="line"><span class="comment">#          - label: "文章页"</span></span><br><span class="line"><span class="comment">#            name: "post"</span></span><br><span class="line"><span class="comment">#            widget: "object"</span></span><br><span class="line"><span class="comment">#            collapsed: true</span></span><br><span class="line"><span class="comment">#            fields:</span></span><br><span class="line"><span class="comment">#              - label: "顶部图(默认)"</span></span><br><span class="line"><span class="comment">#                name: "banner_img"</span></span><br><span class="line"><span class="comment">#                widget: "image"</span></span><br><span class="line"><span class="comment">#              - label: "高度"</span></span><br><span class="line"><span class="comment">#                name: "banner_img_height"</span></span><br><span class="line"><span class="comment">#                widget: "number"</span></span><br><span class="line"><span class="comment">#              - label: "文章封面图(默认)"</span></span><br><span class="line"><span class="comment">#                name: "default_index_img"</span></span><br><span class="line"><span class="comment">#                widget: "image"</span></span><br><span class="line"><span class="comment">#          - label: "归档页"</span></span><br><span class="line"><span class="comment">#            name: "archive"</span></span><br><span class="line"><span class="comment">#            widget: "object"</span></span><br><span class="line"><span class="comment">#            collapsed: true</span></span><br><span class="line"><span class="comment">#            fields:</span></span><br><span class="line"><span class="comment">#              - label: "顶部图"</span></span><br><span class="line"><span class="comment">#                name: "banner_img"</span></span><br><span class="line"><span class="comment">#                widget: "image"</span></span><br><span class="line"><span class="comment">#              - label: "高度"</span></span><br><span class="line"><span class="comment">#                name: "banner_img_height"</span></span><br><span class="line"><span class="comment">#                widget: "number"</span></span><br><span class="line"><span class="comment">#          - label: "分类页"</span></span><br><span class="line"><span class="comment">#            name: "category"</span></span><br><span class="line"><span class="comment">#            widget: "object"</span></span><br><span class="line"><span class="comment">#            collapsed: true</span></span><br><span class="line"><span class="comment">#            fields:</span></span><br><span class="line"><span class="comment">#              - label: "顶部图"</span></span><br><span class="line"><span class="comment">#                name: "banner_img"</span></span><br><span class="line"><span class="comment">#                widget: "image"</span></span><br><span class="line"><span class="comment">#              - label: "高度"</span></span><br><span class="line"><span class="comment">#                name: "banner_img_height"</span></span><br><span class="line"><span class="comment">#                widget: "number"</span></span><br><span class="line"><span class="comment">#          - label: "标签页"</span></span><br><span class="line"><span class="comment">#            name: "tag"</span></span><br><span class="line"><span class="comment">#            widget: "object"</span></span><br><span class="line"><span class="comment">#            collapsed: true</span></span><br><span class="line"><span class="comment">#            fields:</span></span><br><span class="line"><span class="comment">#              - label: "顶部图"</span></span><br><span class="line"><span class="comment">#                name: "banner_img"</span></span><br><span class="line"><span class="comment">#                widget: "image"</span></span><br><span class="line"><span class="comment">#              - label: "高度"</span></span><br><span class="line"><span class="comment">#                name: "banner_img_height"</span></span><br><span class="line"><span class="comment">#                widget: "number"</span></span><br><span class="line"><span class="comment">#          - label: "关于页"</span></span><br><span class="line"><span class="comment">#            name: "about"</span></span><br><span class="line"><span class="comment">#            widget: "object"</span></span><br><span class="line"><span class="comment">#            collapsed: true</span></span><br><span class="line"><span class="comment">#            fields:</span></span><br><span class="line"><span class="comment">#              - label: "顶部图"</span></span><br><span class="line"><span class="comment">#                name: "banner_img"</span></span><br><span class="line"><span class="comment">#                widget: "image"</span></span><br><span class="line"><span class="comment">#              - label: "高度"</span></span><br><span class="line"><span class="comment">#                name: "banner_img_height"</span></span><br><span class="line"><span class="comment">#                widget: "number"</span></span><br><span class="line"><span class="comment">#          - label: "友链页面"</span></span><br><span class="line"><span class="comment">#            name: "links"</span></span><br><span class="line"><span class="comment">#            widget: "object"</span></span><br><span class="line"><span class="comment">#            collapsed: true</span></span><br><span class="line"><span class="comment">#            fields:</span></span><br><span class="line"><span class="comment">#              - label: "顶部图"</span></span><br><span class="line"><span class="comment">#                name: "banner_img"</span></span><br><span class="line"><span class="comment">#                widget: "image"</span></span><br><span class="line"><span class="comment">#              - label: "高度"</span></span><br><span class="line"><span class="comment">#                name: "banner_img_height"</span></span><br><span class="line"><span class="comment">#                widget: "number"</span></span><br><span class="line"><span class="comment">#              - label: "项目"</span></span><br><span class="line"><span class="comment">#                name: "items"</span></span><br><span class="line"><span class="comment">#                widget: "list"</span></span><br><span class="line"><span class="comment">#                fields:</span></span><br><span class="line"><span class="comment">#                  - {</span></span><br><span class="line"><span class="comment">#                      label: "网站名称",</span></span><br><span class="line"><span class="comment">#                      name: "title",</span></span><br><span class="line"><span class="comment">#                      widget: "string",</span></span><br><span class="line"><span class="comment">#                      required: false,</span></span><br><span class="line"><span class="comment">#                    }</span></span><br><span class="line"><span class="comment">#                  - {</span></span><br><span class="line"><span class="comment">#                      label: "网址描述",</span></span><br><span class="line"><span class="comment">#                      name: "intro",</span></span><br><span class="line"><span class="comment">#                      widget: "string",</span></span><br><span class="line"><span class="comment">#                      required: false,</span></span><br><span class="line"><span class="comment">#                    }</span></span><br><span class="line"><span class="comment">#                  - {</span></span><br><span class="line"><span class="comment">#                      label: "网站地址",</span></span><br><span class="line"><span class="comment">#                      name: "link",</span></span><br><span class="line"><span class="comment">#                      widget: "string",</span></span><br><span class="line"><span class="comment">#                      required: false,</span></span><br><span class="line"><span class="comment">#                    }</span></span><br><span class="line"><span class="comment">#                  - {</span></span><br><span class="line"><span class="comment">#                      label: "网站图片",</span></span><br><span class="line"><span class="comment">#                      name: "avatar",</span></span><br><span class="line"><span class="comment">#                      widget: "image",</span></span><br><span class="line"><span class="comment">#                      required: false,</span></span><br><span class="line"><span class="comment">#                    }</span></span><br></pre></td></tr></tbody></table></figure><p>请注意，这里我对 Fluid 主题进行了配置，例如 <code>banner_img</code>、<code>index_img</code> 等项目，不能正常使用请删除。如果你不是 Fluid 主题，请根据实际情况对 <code>source\admin\config.yml</code> 配置进行修改。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.myql.xyz/post/e00ab0f6/">Hexo Netlify CMS</a></li><li><a href="https://hexo.fluid-dev.com/posts/hexo-netlify/">Hexo Netlify CMS 在线编辑博客</a></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/BLOG12/AXeW7R.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建 (Blog Building)" scheme="https://yousazoe.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Blog-Building/"/>
    
    
    <category term="Blog" scheme="https://yousazoe.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>纯粹形式家庭的构建--对动画《间谍过家家》的简单分析</title>
    <link href="https://yousazoe.top/archives/e3f93243.html"/>
    <id>https://yousazoe.top/archives/e3f93243.html</id>
    <published>2022-07-11T12:27:00.000Z</published>
    <updated>2022-07-29T03:00:04.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><a href="https://www.pixiv.net/artworks/97517830"><img data-src="https://img.yousazoe.top/uPic/img/blog/MV11/4cSL0y.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>虚假的共同体是否能构成所谓的“真正家庭”？从希区柯克的《史密斯夫妇》、以及福克斯的翻拍版本，再到今天的流行动画《间谍过家家》，我们似乎可以绘出一条探究婚姻维度底线之线。</p><span id="more"></span><p>间谍与杀手和他们领养的儿童因各自不同的需求伪装成的虚假家庭，这在外人视角下已然同普通家庭没有任何区别，但想要玩好“过家家”这一游戏，关键点在于“扮演”的角色是否真实。我们所好奇的是：由扮演者虚构而成的家庭是否还存在某种“真实”之维？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV11/iiMS9O.jpg"></p><h3 id="镜像理论"><a href="#镜像理论" class="headerlink" title="镜像理论"></a>镜像理论</h3><p>在此之前我们需要知道我们在“扮演”谁。在拉康的镜像理论中，婴儿通过将镜中的形象内化成为自己，将一个“他人”的形象误认为是自己，从而确立了“自我”这一形象。但婴儿是如何扮演好“自我”的？此时，符号性阉割出场了。通过作为母亲的欲望对象，婴儿以符合母亲预期的行为来获取母亲的认可，以这种方式在符号层面接受阉割，婴儿必须扮演好符合母亲价值观的形象，由此，婴儿得以确立自己的理想自我。例如，某人的梦想是当一名演员，但他是从何处建构这一理想自我的？换句话来说，是站在何处凝视“演员”这一形象，才让他将其判定为有价值的？而在这之后通过不断地扮演，不断地如同水中捞月般向这一形象靠近，主体得以跨入符号界。同动画中的剧情一样“单身女人容易被怀疑成间谍”，<strong>主体也通过扮演，通过掩饰自身的空洞性在符号界获得一席之地。</strong></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV11/IefLfs.jpg"></p><p>一个家庭的基本构成是一对情侣，儿童则是可选项。阿尼亚的形象是极为真实的儿童形象，她不仅敏感且希望作为父母欲望的客体，作为旁观者，并带有明确的理想自我——间谍。另一方面，在意识形态领域，阿尼亚的形象则是作为主体的再现——具有读心术的超能力者。这恰恰和每个意识形态的信徒处于了相同的地位：我知道他人怎么想。在此我们借用齐泽克的南斯拉夫笑话来描述这一机制：在南斯拉夫，市场上有充足的手纸。但突然间，一个出人意料的谣言大肆传播——手纸短缺。而因为这一谣言的传播，人们开始疯狂抢购，最终导致的结果当然是真的出现了手纸短缺。初看上去，这似乎很简单，即所谓的“预言自我实现”机制，但它运作的有效方式有些复杂。其中每个参与者都是这样推理的：“我不天真，也不愚蠢，我的心里一清二楚，商店里的手纸绰绰有余；但或许有些人，他们既天真，又愚蠢，对这些谣言信以为真，并据之行事，于是他们开始疯狂抢购，到最后，必定真的造成短缺；所以，即使我一清二楚，手纸充裕，但快去商店，多买一些，总不失为明智之举！”而至关重要的是，这个我们假定天真地相信谣言的人甚至不必真的存在：要在现实中产生这样的结果，只要假定他存在就够了。那个到最后两手空空的，正是坚持真理的人。他自言自语道，“我知道这只是谣言，我知道手纸充裕”，并据此行事……</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV11/pf6ZFE.jpg"></p><p>同样，在意识形态领域，难道我们每个人不都在扮演某种角色吗？我们都有“猜中他人想法”的“超能力”，同时我们又要小心翼翼的扮演着自己“理应是的形象”，并进行着“知晓之假定”的运动。如果将东国与西国带入到这一家庭中，我们会发现该家庭作为整个国家的征兆已然显现——东西国的矛盾将被调停，就如同间谍父亲与杀手母亲通过女儿调停而组织的家庭一般。尽管原作还在连载中，我们依然能够这样简单地尝试猜测最终剧情的走向。</p><p><a href="https://mobile.twitter.com/3RbK7HS51MdRjF1/status/1544593863939358721"><img data-src="https://img.yousazoe.top/uPic/img/blog/MV11/pVf7V5.jpg"></a></p><p>从虚构家庭这一形式来看，以道德卫道士的视野去指责这种所谓的虚伪家庭自然是错误的，因为家庭本就是围绕着空隙，围绕着某个崇高物建构而成的。正如同早年流行的鸡汤文摘里这样常见的写法：“你的父母也是第一次当父母，所以你要理解他们……”云云。即便是以血脉相承的、最封建、最传统的家庭，也依然围绕着某个不可触及之物、某个空隙所建构。如同黑胶唱片或是光盘中心的空洞一般，它们总围绕着这缝隙旋转。家庭这一共同体也围绕着某个崇高物建构，经济、血统、爱情等等……家庭是作为社会之镜像的缩影，而社会本身也围绕着那对抗性的空隙建构而成。恰恰是在这种扮演中，崇高物才得以获得崇高性。陶艺也是如此通过围绕着虚空建构，才升华成为艺术品。所以在动画中，这样的纯粹形式自然起到了某种作用：在外人眼中，这是再正常不过的家庭。尽管他们是假装的。甚至换句话说，这种“虚假”的家庭在实质上也与其他“真正的”家庭一般真实。</p><p><a href="https://mobile.twitter.com/Akeman02/status/1546438231452897285"><img data-src="https://img.yousazoe.top/uPic/img/blog/MV11/g8FN2V.jpg"></a></p><p>以观众的视角，我们也能在伪装成家庭的过程中看到主体间粘腻的爱欲交换，这些人们追求的所谓的“真实之物”，也恰恰是基于空洞的形式建构之上，正是在扮演、假装的过程中，某些东西早已通过意识形态的运作方式体现出来——我不信这个，但我知道别人信——我是假装成家庭的，但是别人以为我们真的是和睦家庭。正是在这看似互相欺骗的过程中，基于假定相信的主体，一些真实之物早已回溯性的产生。真实之物不是崇高客体，不是经济、血脉等等，而是这一形式带来的效果本身，通过维持“家庭”这一形式，这样的效果产生了：仿佛在这背后维系形式的总是某些更高层面的感情。而在体验过这种幻觉后，我们得以明白，每个家庭都如同“间谍过家家”一般，每个人都在尽力扮演好符号网络所给予他的社会角色，正是在这个端点上，在伪造某个形式的过程中，反而产生了背后有某种支撑物的幻觉。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV11/eJXlNA.jpg"></p><p>最后，尽管这部动画的一部分主题在于反战、弘扬和平，我们首先当然应该反抗侵略性的战争，但最想要和平的不是处于底层的群众，而恰恰是身居高位者——恰恰是其统治者最想以现有的制度令一切继续运行，正是在这种对和平主义的期盼下，本就腐朽的制度得以进入下一次再生产，人们才能怀着对战争的恐惧继续享受现有制度的糜烂。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV11/PJeexU.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.pixiv.net/artworks/97517830&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MV11/4cSL0y.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;虚假的共同体是否能构成所谓的“真正家庭”？从希区柯克的《史密斯夫妇》、以及福克斯的翻拍版本，再到今天的流行动画《间谍过家家》，我们似乎可以绘出一条探究婚姻维度底线之线。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>又拍云博客图床解决方案</title>
    <link href="https://yousazoe.top/archives/dfde53a2.html"/>
    <id>https://yousazoe.top/archives/dfde53a2.html</id>
    <published>2022-07-07T10:42:36.000Z</published>
    <updated>2022-07-29T03:00:04.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/3JAxCx.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Github + Jsdelivr 的图床解决方案在最近稳定性欠佳，为了提升网站的加载速度本站将开始使用又拍云作为博客图床。</p><span id="more"></span><h3 id="创建云存储"><a href="#创建云存储" class="headerlink" title="创建云存储"></a>创建云存储</h3><p>注册又拍云账号，在控制台选择 <code>云存储</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/GEQ0at.png"></p><p><code>云存储</code> 设置如下图所示：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/7tV9Ul.png"></p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>创建好服务后，其实已经可以通过测试域名访问云存储中的内容了：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/ZRDOiK.png"></p><p>好，我们按照正常流程走。绑定域名。输入需要绑定的域名后，会校验备案信息等，校验通过后绑定成功，此时点击 <code>CNAME</code> 按钮，会出现域名解析配置。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/T0G23t.png"></p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>将获取的域名解析配置复制后，进入你的域名的解析页面，我这里使用的是腾讯云的域名以及解析。设置如下：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/wH8wVI.png"></p><p>完成后，即可将将测试域名替换成你自己的域名访问资源，但是要等十分钟，域名解析需要十分钟左右生效。</p><h4 id="又拍云联盟"><a href="#又拍云联盟" class="headerlink" title="又拍云联盟"></a>又拍云联盟</h4><p>加入 <a href="https://www.upyun.com/league">又拍云联盟</a> 即可获得一定额度的存储空间以及流量，申请起来还是挺简单的。比较麻烦的点在于如何把 Logo 放在站点下，以我所使用的 Hexo + NexT 为例，打开 <code>themes/next-reloaded/layout/_partials/footer.swig</code> 修改：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/4bzzDx.png"></p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg"</span> <span class="attr">width</span>=<span class="string">"53"</span> <span class="attr">height</span>=<span class="string">"18"</span> <span class="attr">style</span>=<span class="string">"fill: currentColor; display: inline-block;"</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/Gg8q0f.png"></p><h3 id="uPic图床配置"><a href="#uPic图床配置" class="headerlink" title="uPic图床配置"></a>uPic图床配置</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG11/NG2mzd.png"></p><ul><li><code>空间名称</code>: 对象储存空间名称，可在又拍云控制台查看。<a href="https://blog.svend.cc/upic/tutorials/upyun_uss/#%F0%9F%A7%B0-%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%E3%80%81%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96">图例</a> </li><li><code>操作员</code>: 当前空间授权过的操作员。<a href="https://blog.svend.cc/upic/tutorials/upyun_uss/#%F0%9F%94%91-%E6%93%8D%E4%BD%9C%E4%BA%BA%E5%91%98%E9%85%8D%E7%BD%AE">图例</a> </li><li><code>操作员密码</code>: 对应的操作员密码。<a href="https://blog.svend.cc/upic/tutorials/upyun_uss/#%F0%9F%94%91-%E6%93%8D%E4%BD%9C%E4%BA%BA%E5%91%98%E9%85%8D%E7%BD%AE">图例</a> </li><li><code>域名</code>: 使用又拍云默认提供的测试域名或者你的自定义域名。测试域名可在控制台查看。域名需以http://或者https://开头。<a href="https://blog.svend.cc/upic/tutorials/upyun_uss/#%F0%9F%A7%B0-%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%E3%80%81%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96">图例</a> </li><li><code>保存路径</code>: 文件储存的路径（包括文件夹）。 支持 {year} {month} {day} {hour} {minute} {second} {since_second} {since_millisecond} {random} {filename} {.suffix} 等变量。比如：上传的图片为 uPic.jpg，设定为 “uPic/{filename}{.suffix}”，则会保存到 “uPic/uPic.jpg”。 </li><li>在<code>保存路径</code>输入框后面的是网址后缀: 用于自定义图片处理。在又拍云对象储存中可以配置图片处理-自定义版本。例如：规则名称为w的规则来标识水印版本，分隔符为!，则可以在网址后缀中填写!w。之后每次上传的图片生成连接后面都会追加上-w，即表示访问水印版本。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://swordpal.cn/posts/47264/">又拍云图床</a></li><li><a href="https://blog.svend.cc/upic/tutorials/upyun_uss/">uPic 图床配置教程 - 又拍云</a></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/BLOG11/3JAxCx.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;Github + Jsdelivr 的图床解决方案在最近稳定性欠佳，为了提升网站的加载速度本站将开始使用又拍云作为博客图床。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建 (Blog Building)" scheme="https://yousazoe.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Blog-Building/"/>
    
    
    <category term="Blog" scheme="https://yousazoe.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>你赢了？--First Strike</title>
    <link href="https://yousazoe.top/archives/4e597f2f.html"/>
    <id>https://yousazoe.top/archives/4e597f2f.html</id>
    <published>2022-07-01T00:53:10.000Z</published>
    <updated>2022-07-29T03:00:04.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT13/stWK9i.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>《先发制人》是一款快节奏实时策略游戏，在此游戏中，您可以从全世界最大的十二个核超级大国中选择一个扮演，然后努力成为整个世界毁灭时的最后一个幸存者。</p><span id="more"></span><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.cloudflare.steamstatic.com/steam/apps/587000/ss_6d95b6190af9e255c00dcb7d9be39979dfbddc02.600x338.jpg?t=1615819400"><source id="mp4" src="https://cdn.cloudflare.steamstatic.com/steam/apps/256685072/movie480_vp9.webm?t=1615365572" type="video/mp4"></video><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT13/lcaOwr.jpg"></p><h4 id="即时战略类核战游戏"><a href="#即时战略类核战游戏" class="headerlink" title="即时战略类核战游戏"></a>即时战略类核战游戏</h4><p>全世界已有数以百万计的指挥官玩《先发制人》。如今，该游戏以《先发制人：经典之战》重新回归。我们将这款标志性核战策略游戏重新打造。重建后，游戏机制更稳定，敌人狡猾并难以对付；呈现给各位玩家最好的《先发制人》。</p><p>《先发制人》是一款快节奏实时策略游戏，在该游戏中，投射导弹就像学习 ABC 一样简单。但一定要采取正确措施保证人民的安全。</p><p>从美国等知名超级大国和朝鲜等新兴核国家中选择一个扮演，然后明智地规划策略：扩张到其他国家，建造或拆除核武器，重建核武器库。或通过研究获得新型核技术、更好的侦察情报、自动化自卫序列等。</p><p>不管您是嗜血好战者，还是环保主义嬉皮士，现在都该亮牌了。《先发制人》将向您展示让事件升温究竟有多简单。您掌控着浮动在太空中这个宝贵但脆弱星球的命运，我们称它为地球。当整个世界毁灭时，您能存活下来吗？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT13/9AGvFH.jpg"></p><h4 id="游戏特点"><a href="#游戏特点" class="headerlink" title="游戏特点"></a>游戏特点</h4><ul><li><p>全世界已有数以百万计的指挥官玩《先发制人》。现在，随着《先发制人：末日终结》的推出，这款备受赞誉的策略型游戏最终登陆PC，您将体验到全新功能和精美的高清场景！</p></li><li><p>可扮演十二个核超级大国 - 选择自己要扮演的实际超级大国，包括美国、俄罗斯、中国或朝鲜等</p></li><li><p>毁灭性超级武器 - 建造十二个先进的火箭，如三叉戟和沙皇火箭，每个联盟都独一无二</p></li><li><p>建造火箭和导弹，征服新领地，研究新的毁灭性核技术。</p></li><li><p>控制世界 - 在三维地球上发射和防御核火箭。</p></li><li><p>全新的专属互不侵犯条约系统 - 寻找条约伙伴，联合对抗敌人</p></li><li><p>高清结构场景 - 全新场景，包括夜间照明、凹凸贴图、高清选项和仅适于PC的星群画面</p></li><li><p>快节奏策略游戏玩法 - 完成先发制人的每个回合需要半小时至一个小时。</p></li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT13/lcA99b.jpg"></p><h4 id="奖励和选择"><a href="#奖励和选择" class="headerlink" title="奖励和选择"></a>奖励和选择</h4><p>《先发制人》是全世界许多游戏大奖的入围者和获胜者，包括</p><ul><li><p>获胜者 “Most Innovative Game” - BAE Awards*</p></li><li><p>获胜者 “Game of the Year” - BOSA Awards*</p></li><li><p>获胜者 “Newcomer of the Year” - SwissICT Awards*</p></li><li><p>获胜者 “Best Mobile Game” - Indie Prize Amsterdam*</p></li><li><p>入围者 “Best Strategy Game” - BAE Awards*</p></li><li><p>入围者 “Best Hardcore Game” - Game Connection USA Awards*</p></li><li><p>入围者 “Most Innovative Game” - Game Connection USA Awards*</p></li><li><p>入围者 “Best Upcoming Game” - IMGA Awards*</p></li><li><p>入围者 “Most Meaningful Play” - IMGA Awards*</p></li><li><p>入围者 “Best International Game” - Ludicious Game Festival*</p></li><li><p>入围者 “Best Swiss Game” - SGDA Awards*</p></li><li><p>入围者 “Master of the Year” - BOSA Awards*</p></li></ul><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="高度简化的策略系统"><a href="#高度简化的策略系统" class="headerlink" title="高度简化的策略系统"></a>高度简化的策略系统</h4><p>高度简化的策略系统中玩家无需考虑资源问题，所要做的就是在自己的领地内适当管理建造导弹的数量与种类，以便及时对敌方的核武攻击做出有效防御并予以回击，同时积蓄力量主动出击一举摧毁敌方核武力量与领地。</p><p>游戏中导弹种类也被简化为仅有三种：用于导弹拦截防御的「短程巡航导弹」(Cruise)、射程可覆盖半个地球的「中程弹道导弹」 (IRBM) 以及在取得科技点升级后可以攻击全球的「洲际弹道导弹」 (ICBM) 。当某块领地正在执行或执行过某个动作后（如建造导弹、反导反击、进行技术研究）会有一段冷却时间，这段时间内该领地将不能对外产生任何反馈，合理分配动作的时机与先后是避免领地遭受打击的要诀。</p><p>扩张则是对领地附近的区域执行吞并的指令，国家的疆域越广阔拥有的核武库基数也就越大，能够取得更多的先机；同时，假若本土不幸遭受到一轮饱和打击，拥有广阔疆域也使得我方全军覆没的危险性大大降低。因此，及时进行扩张行动是每个玩家都需要尽快考虑的事。</p><p>除此之外，每局游戏中玩家还可为自己的国家选择两种超级武器的研发方向，通过研发解锁所有科技点来获得他们的使用权。这其中包括有最高技术先进性、可同时发动多处真假核打击的「全面攻击型三叉戟导弹」；能够使被攻击区域承受严重核污染、再也无法重新利用的「恐怖型镭炸弹」；一击便可摧毁整个大洲、威力无比强大的「沙皇氢弹」等众多强力武器，合理地使用它们将会是取得这场大战最终胜利的制胜秘诀。当玩家核武库中拥有超过9枚以上的导弹时，便可使用「全面核打击」的决战技能，将库存中的核导弹倾数发射集中攻击目标国，甚至可于一轮攻击中夷平目标，决定战争的胜负。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT13/HXYspz.jpg"></p><p>稍稍一提游戏的画面。游戏画面采用比较夸张的卡通渲染，没有过多的细节，不容易让人感到战争的凝重感和恐怖感；但核武攻击的画面依然很有气势，尤其是执行全面核攻击的时刻：漫天核弹划破天际，密密麻麻的轨迹线引向目标。最终导弹群在落地后引发大地剧烈震颤的场面，依然让人感到十分的爽快与震撼。</p><h4 id="战争游戏下的反战内核"><a href="#战争游戏下的反战内核" class="headerlink" title="战争游戏下的反战内核"></a>战争游戏下的反战内核</h4><p><strong>游戏中有两处细节我觉得值得一提：</strong></p><p>其一是《先发制人》中每次打击城市时升起的那一排几百万几千万死亡人数的数字。</p><p>很多玩家也许根本不会在意这个细节，然而只要细思就会感到不寒而栗：几个人的死亡令人感到恐惧、悲伤或是惋惜，成千上万人的死亡则令人感到麻木，而当达到百万千万数量级的死亡时，感官上便已失去实感，个人生命的价值已经被无限地淡化与忽视，众生皆如蝼蚁，那些逝去的灵魂不过只是计数器上一个个枯燥的数字罢了。人的生命，有时真的很不值钱。</p><p>其二是暂停时游戏界面上出现的时钟。那并非是普通的时钟，而是被称作「末日时钟」的概念形象。</p><blockquote><p>「末日时钟」(Doomsday Clock) 是一虚构钟面，由芝加哥大学的《原子科学家公报》杂志于1947年设立，标示出世界受核武威胁的程度：12时正象征核战爆发，杂志社因应世界局势将分针拨前或拨后，以此提醒各界正视问题。最近的两次调整—— 在2012年，指针被拨到11时55分；2015年1月22日，「末日时钟」被拨快了2分钟，距离「象征世界灾难末日的」午夜时分仅剩3分钟；2018年1月25日，提醒世人人类全体毁灭的象征性「末日时钟」被再度拨快30秒，距离象征人类末日的「午夜12时」仅剩2分钟，这是冷战以来最危险的情况。</p></blockquote><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT13/hQK7Sr.jpg"></p><p>核武平衡乃是维系当今世界大国和平的根本，然而，这些恐怖的毁灭性武器一如高悬于全人类头顶的达摩克利斯之剑，它们既是能够缔结和平的「卫士」，也是随时能让人类迈向毁灭深渊的「恶魔」。</p><p>空灵的声音配合漆黑的宇宙背景，这一下就让人仿佛置身其境，加上转动摄像头时不经意可以看见真实的太阳射线，这些画面真的是很让我非常爱不释手。每次释放全面核打击的时候，背景音乐的风格陡然改变，变得紧迫和悲壮，这意味着核打击给人们带来的，只有生灵涂炭，核战争结束后，没有任何赢家，在地球的角度，我们只是一个践踏生命的暴徒。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT13/evKWpd.jpg"></p><p>游戏制作组为本作加入的隐藏结局所反映的便是对这个问题的一种思考。为什么一定要疯狂地扩张军备？为什么一定要与其他国家无休止地勾心斗角？如果自一开始就做出牺牲与让步，主动销毁所有的核武库存，其他国家也会在您无私行为的感召下放弃对核武的执念，逐步削减自身的核武库，并带来「实现世界无核化」、取得真正和平的「真结局」。</p><p>这是一款表面鼓励玩家推进毁灭性的核子战争，实则拥有深刻反战内核的作品。（值得一提的是，制作组将自身收入的四分之一捐献于控核组织，是实打实地为实现和平理想做出了小小献力。）</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT13/nZvntN.jpg"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><p>当你拆下自己的核弹的那一刻，你才真正的赢了</p><p>You win when you disarm your nuke</p></blockquote><p>“您赢了”，后面是一个大大的问号。</p><p>核战争没有赢家。</p><p>是一个小游戏，但其反战的精神内核却引人深思。当人们的死亡变成一个数字的时候，战争的意义在哪里呢？</p><p>「向您致敬！在局势极其紧张的时候，您冒着极大的风险，销毁所有的核武器，向全世界表达了您的诚意。您的这一举措为全世界带来了和平！您是这场战斗的最终胜利者！」</p><p>也许这都不过是一厢情愿，也许这都只是美好的憧憬。但我愿意相信：</p><blockquote><p>进步的文明终会带来更高层次的道德与理性。</p><p>人性的真善美终会克服破坏与毁灭的天性。</p><p>愿世界永远和平！</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GT13/stWK9i.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;《先发制人》是一款快节奏实时策略游戏，在此游戏中，您可以从全世界最大的十二个核超级大国中选择一个扮演，然后努力成为整个世界毁灭时的最后一个幸存者。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Rendering Course by Wangningbei</title>
    <link href="https://yousazoe.top/archives/971404c0.html"/>
    <id>https://yousazoe.top/archives/971404c0.html</id>
    <published>2022-06-29T23:09:54.000Z</published>
    <updated>2022-07-29T03:00:04.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--[![](https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/uCRUgR.jpg)](https://twitter.com/UeVoxel/status/1541408464203042816)--><html><head></head><body><p><a href="https://twitter.com/UeVoxel/status/1541408464203042816"><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/EKUu6S.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>偶然间发现了王贝贝老师的渲染课程录播，虽然只更新了五篇但还是特开一篇文章用以复习回顾。</p><span id="more"></span><h3 id="渲染入门"><a href="#渲染入门" class="headerlink" title="渲染入门"></a>渲染入门</h3><h4 id="Lec1"><a href="#Lec1" class="headerlink" title="Lec1"></a>Lec1</h4><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=411172353&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br><h5 id="场景与渲染"><a href="#场景与渲染" class="headerlink" title="场景与渲染"></a>场景与渲染</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/4YWmAS.jpg"></p><p>材质描述的是几何体本身和光发生作用的时候呈现的颜色。</p><p>渲染过程涉及两个方面：</p><ul><li><strong>着色 Shading</strong></li><li><strong>光线传输 Light Transport</strong>：光线在场景中多次反弹的过程</li></ul><h5 id="ShaderToy示例"><a href="#ShaderToy示例" class="headerlink" title="ShaderToy示例"></a>ShaderToy示例</h5><p><a href="https://shadertoy.com/view/4sSfzK"><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/66ERs4.jpg"></a></p><h5 id="几何体"><a href="#几何体" class="headerlink" title="几何体"></a>几何体</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/Z8iNGf.jpg"></p><p>这些形状到底是怎么形成的？</p><ul><li><strong>显式</strong>：三角形、四边形等离散的</li><li><strong>隐式</strong>：写方程得到的（数据量小，相交求解方便）</li></ul><h6 id="隐式表面"><a href="#隐式表面" class="headerlink" title="隐式表面"></a>隐式表面</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/vtP9Um.jpg"></p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> Scene(<span class="type">vec3</span> p, <span class="type">mat3</span> localToWorld)</span><br><span class="line">{</span><br><span class="line">p = p * localToWorld;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ring</span></span><br><span class="line"><span class="type">vec3</span> t = p;</span><br><span class="line">t.y -= <span class="number">-.7</span>;</span><br><span class="line"><span class="type">float</span> r = Substract(Disc(t, <span class="number">0.9</span>, <span class="number">.1</span>), Cylinder(t, <span class="number">.7</span>, <span class="number">2.</span>));</span><br><span class="line"><span class="type">vec3</span> t2 = t - <span class="type">vec3</span>(<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.0</span>);</span><br><span class="line">Rotate(t2.xz, <span class="number">0.25</span> * MATH_PI);</span><br><span class="line">r = Substract(r, Box(t2, <span class="type">vec3</span>(<span class="number">.5</span>)));</span><br><span class="line">r = Union(r, Disc(t + <span class="type">vec3</span>(<span class="number">0.</span>, <span class="number">0.05</span>, <span class="number">0.</span>), <span class="number">0.85</span>, <span class="number">.05</span>));</span><br><span class="line"></span><br><span class="line">t = p;</span><br><span class="line">Rotate(t.yz, <span class="number">-.3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// body</span></span><br><span class="line"><span class="type">float</span> b = Sphere(t, <span class="number">.8</span>);</span><br><span class="line">b = Substract(b, Sphere(t - <span class="type">vec3</span>(<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">.5</span>), <span class="number">.5</span>));</span><br><span class="line">b = Substract(b, Sphere(t - <span class="type">vec3</span>(<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">-.7</span>), <span class="number">.3</span>));</span><br><span class="line">b = Substract(b, Box(t, <span class="type">vec3</span>(<span class="number">2.</span>, <span class="number">.03</span>, <span class="number">2.</span>)));</span><br><span class="line">b = Union(b, Sphere(t, <span class="number">.7</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ret = Union(r, b);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="显式表面"><a href="#显式表面" class="headerlink" title="显式表面"></a>显式表面</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/58EHxZ.jpg"></p><h6 id="隐式表达-vs-显式表达"><a href="#隐式表达-vs-显式表达" class="headerlink" title="隐式表达 vs 显式表达"></a>隐式表达 vs 显式表达</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/INiJqS.jpg"></p><h6 id="各种文件类型"><a href="#各种文件类型" class="headerlink" title="各种文件类型"></a>各种文件类型</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/VY2Zjf.jpg"></p><ul><li><code>.obj</code>：比较通用，但压缩上非常差</li><li><code>.fbx</code>：Unreal 或者 Unity 引擎可直接使用</li></ul><h6 id="一个模型究竟包含了哪些信息呢？"><a href="#一个模型究竟包含了哪些信息呢？" class="headerlink" title="一个模型究竟包含了哪些信息呢？"></a>一个模型究竟包含了哪些信息呢？</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/8oc0uj.jpg"></p><ul><li>一些点、点和点之间如何相连（拓扑关系）</li><li>点（vertex）：位置、法向（normalized）、uv 坐标等</li><li>拓扑：这些点组合成 polygon（三角形）</li></ul><h5 id="物体坐标系和世界坐标系"><a href="#物体坐标系和世界坐标系" class="headerlink" title="物体坐标系和世界坐标系"></a>物体坐标系和世界坐标系</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/3snwoY.jpg"></p><h5 id="相机（camera-x2F-sensor）"><a href="#相机（camera-x2F-sensor）" class="headerlink" title="相机（camera/sensor）"></a>相机（camera/sensor）</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/xUIile.jpg"></p><h6 id="正交-orthographic-vs-透视-perspective"><a href="#正交-orthographic-vs-透视-perspective" class="headerlink" title="正交(orthographic) vs 透视(perspective)"></a>正交(orthographic) vs 透视(perspective)</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/U3TDD0.jpg"></p><h6 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/lyh66k.jpg"></p><h6 id="相机坐标系"><a href="#相机坐标系" class="headerlink" title="相机坐标系"></a>相机坐标系</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/nmO3VS.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/5nhKma.jpg"></p><p>渲染常见有两种方式：<strong>光栅化</strong> 和 <strong>光线追踪</strong>。</p><p>需要说明的是这两种方法和是否使用 CPU、GPU 无关，看的是有没有硬件的支持。</p><h5 id="光栅化-rasterization"><a href="#光栅化-rasterization" class="headerlink" title="光栅化(rasterization)"></a>光栅化(rasterization)</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/1sF45v.jpg"></p><p>以物体为中心，遍历所有的物体（三角形）向屏幕投影。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/nE3lIb.jpg"></p><ul><li>通过 zbuffer 确定显示哪个点</li><li>光栅化从很久很久以前就有硬件支持了，比如 OpenGL、Direct3D 等</li></ul><h5 id="光线追踪-ray-tracing"><a href="#光线追踪-ray-tracing" class="headerlink" title="光线追踪(ray tracing)"></a>光线追踪(ray tracing)</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/qFDzV0.jpg"></p><ul><li>以屏幕为中心，遍历所有的像素，发射<strong>光线与场景求交</strong></li><li>对光线追踪的硬件支持时间上晚于光栅化（从 Optix 2010 年开始，DX12 开始支持是近几年的事情）</li><li>为什么？因为光线追踪太费了</li></ul><h6 id="为什么说光线追踪太费了呢"><a href="#为什么说光线追踪太费了呢" class="headerlink" title="为什么说光线追踪太费了呢"></a>为什么说光线追踪太费了呢</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/Rbf1uU.jpg"></p><p>光线与场景求交：找到光线与场景中某个三角形的交点</p><ul><li>发射光线</li><li>先找到三角形</li><li>找到交点</li></ul><p>如何找到三角形？可以遍历一遍（<code>O(n)</code>）；也可以借助于空间数据结构如 KD tree、BVH 等等（<code>O(logn)</code>）。</p><h6 id="光线与场景求交"><a href="#光线与场景求交" class="headerlink" title="光线与场景求交"></a>光线与场景求交</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/Bv3wVG.jpg"></p><h6 id="包围盒-bounding-box"><a href="#包围盒-bounding-box" class="headerlink" title="包围盒(bounding box)"></a>包围盒(bounding box)</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/LeLcuY.jpg"></p><h6 id="光线与三角形求交-BVH"><a href="#光线与三角形求交-BVH" class="headerlink" title="光线与三角形求交(BVH)"></a>光线与三角形求交(BVH)</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/kKSUEU.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Intersect</span>(Ray ray, BVH node) {</span><br><span class="line">    <span class="keyword">if</span> (ray misses node.box) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node is a leaf node)</span><br><span class="line">        test intersection with all objs;</span><br><span class="line">        <span class="keyword">return</span> closest intersection;</span><br><span class="line">    </span><br><span class="line">    hit1 = <span class="built_in">Intersect</span>(ray, node.child1);</span><br><span class="line">    hit2 = <span class="built_in">Intersect</span>(ray, node.child2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> the clser of hit1, hit2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="光线与三角形求交（简单方案）"><a href="#光线与三角形求交（简单方案）" class="headerlink" title="光线与三角形求交（简单方案）"></a>光线与三角形求交（简单方案）</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/7rl14G.jpg"></p><h5 id="光栅化-vs-光线追踪"><a href="#光栅化-vs-光线追踪" class="headerlink" title="光栅化 vs 光线追踪"></a>光栅化 vs 光线追踪</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/kZbE08.jpg"></p><ul><li>光栅化：速度快，全局光照、阴影等处理方式繁琐</li><li>光线追踪：准确，擅长镜面反射、阴影，计算全局光照、阴影等思路简单但是耗时</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/ZY4hBw.jpg"></p><h4 id="Lec2"><a href="#Lec2" class="headerlink" title="Lec2"></a>Lec2</h4><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=411225590&amp;page=2&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br><h5 id="各种各样的材质"><a href="#各种各样的材质" class="headerlink" title="各种各样的材质"></a>各种各样的材质</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/J53C9N.jpg"></p><p>现实世界中有各种各样的不同材质，材质该如何表达呢？</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/CBdKg6.jpg"></p><h5 id="材质的主要分类"><a href="#材质的主要分类" class="headerlink" title="材质的主要分类"></a>材质的主要分类</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/sd8lww.jpg"></p><p>材质是一个<strong>关于入射光和出射光的函数，双向反射分布函数</strong>（Bidirectional Reflection Distribution Function，BRDF）</p><h5 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/jCQ5yx.jpg"></p><h6 id="Shading-Normal"><a href="#Shading-Normal" class="headerlink" title="Shading Normal"></a>Shading Normal</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/GYe5jp.jpg"></p><p>着色是在局部坐标系下的，三角面片的割裂导致了右图的渲染效果。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/RT6/EriIIN.jpg"></p><h4 id="Lec3"><a href="#Lec3" class="headerlink" title="Lec3"></a>Lec3</h4><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=415024791&amp;page=3&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br><h3 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h3><h4 id="Lec4"><a href="#Lec4" class="headerlink" title="Lec4"></a>Lec4</h4><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=423088298&amp;page=4&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br><h4 id="Lec5"><a href="#Lec5" class="headerlink" title="Lec5"></a>Lec5</h4><iframe src="//player.bilibili.com/player.html?aid=463047883&amp;bvid=BV1rL411x7eh&amp;cid=426761029&amp;page=5&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <br></body></html>]]></content>
    
    
    <summary type="html">&lt;!--[![](https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/uCRUgR.jpg)](https://twitter.com/UeVoxel/status/1541408464203042816)--&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/UeVoxel/status/1541408464203042816&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/RT6/EKUu6S.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;偶然间发现了王贝贝老师的渲染课程录播，虽然只更新了五篇但还是特开一篇文章用以复习回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="光线追踪 (Ray Tracing)" scheme="https://yousazoe.top/categories/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
    <category term="Ray Tracing" scheme="https://yousazoe.top/tags/Ray-Tracing/"/>
    
  </entry>
  
  <entry>
    <title>日本独立游戏开发的概况及面向跨文化市场的挑战</title>
    <link href="https://yousazoe.top/archives/9523ea4f.html"/>
    <id>https://yousazoe.top/archives/9523ea4f.html</id>
    <published>2022-06-27T03:14:59.000Z</published>
    <updated>2022-07-29T03:00:04.305Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/ztlker.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>日本是电玩游戏产业代表性的大国，但日本的独立游戏，相较于全球，能见度与影响力就没那么强烈。在日本经营着独立游戏开发者社群的 Anne Ferrero，于 2022 年的 GDC，以《Big in Japan, Not in the West: The Difficults of Cross-Cultural Appeal》为题，分享了她收集与整理的日本独立游戏开发者概况，以及面向跨文化的全球市场时，所该注意的事项。</p><span id="more"></span><blockquote><p>授权转载自 <a href="https://igdshare.org/content/big_in_japan_not_in_west">IGDShare.org</a>，进行了简繁转换，并对一些词汇的不同用法做了修改。</p></blockquote><p>Anne 来自法国，曾在当地的电视台工作，自 2011 年起常驻于日本，与“<a href="https://www.archipel.jp/toco-toco">Archipel</a>”频道合作制作了一系列日本创作者的短篇纪录片。2019 年开始，担任日本独立开发者交流实体空间“<a href="https://asobu.dev/">asobu</a>”的社群经理。她在独立游戏界的代表作，是 2016 年推出的纪录片《<a href="https://branchingpaths.jp/">Branching Paths</a>》，Anne 花了两三年的时间，采访拍摄了多位日本独立游戏开发者，以及以日本为基地的海外独立游戏开发者，影片内容颇受好评，IGDSHARE 曾协助本片的翻译、并在台湾举办放映会。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/OCDMCz.jpg"></p><p>在谈论日本独立游戏的现况前，先简单介绍一下日本独立游戏的历史。就跟欧美早期有许多“卧室开发者”一样，日本在 1980 年代也有类似的开发者，将自己开发的游戏投稿到电脑杂志、相关竞赛，赚取稿费或奖金，并一步步迈向商业化。像是以《门门冒险（Door Door）》赚到成立 Chunsoft 公司的中村光一，或是从自制游戏攻略本转向独立游戏开发的 Gamefreak 公司等。</p><p>另一个分支，则是“同人”游戏，同样在 1980 年代开始发展，直到现在这样的社群文化都还持续着。同人游戏通常是业余、基于兴趣开发，在 Comiket 等贩售会或者专卖店进行贩售，发展出了像《东方 Project》系列、《寒蝉鸣泣之时》系列、《Fate》系列等等热门到变成商业化大作的系列。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/y9ZTB1.jpg"></p><p>时间进到 1990-2000 年代，这时期的主流独立游戏是各种小型的免费游戏，在个人网页提供下载，还有可以线上直接游玩的 Flash 游戏，代表作有《洞窟物语》、《La-Mulana》、《梦日记》等。</p><p>2000 年代之后，新兴的名词是“自制游戏”，性质跟上述的免费游戏其实没有太多差别，主要是因为影音分享网站“NicoNico 动画”使用了这个词汇而被广泛认知。“自制游戏”时期的特性是，通常是使用简易开发工具制作出来的 RPG/文字冒险类游戏，并在 NicoNico 影音网站上，借由游戏实况影片及弹幕(即时字幕留言)讨论创造话题，在年轻一代的玩家之间形成风潮。代表作《青鬼》红到改编成电影、动画、小说等跨媒体作品。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/jXqBVZ.jpg"></p><p>到了 2010 年起的近代，许多独立游戏也登上了智能手机平台，但因为功能型手机在日本没有快速被取代，所以在平台转移到智能手机这点，日本开发者们的速度比国外开发者慢了一些。代表作品有《妈妈藏走我的游戏机》、《猫咪收藏集》等。</p><p>最后，是“独立游戏”。当然，上述游戏都属于独立游戏的范畴，这里所指的，是采取欧美观点里的“Indie Game”。在这之前，日本开发者要制作游戏的话，通常只有两条路走，一是进到游戏公司作游戏，另一则是业余创作游戏。到了 2010 年代，欧美式的“独立游戏”观念传入日本后，才开始有较多的开发者尝试自己成立小型团队全职制作自己的游戏。成功案例包含《Downwell》、《Gnosia》、《天穗之咲稻姬》等游戏。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/vqaY57.jpg"></p><p>简单区分的话，同人游戏、自制游戏偏向业余同好基于兴趣的创作，独立游戏则是在兴趣同时，作为赖以维生的方式。这些不同的开发者与玩家族群虽然有一定程度的重叠，但彼此的社群与文化之间还是存在着一些隔阂。即使现在已经有不少日本独立游戏的成功典范，还是会有很多日本人认为独立游戏跟业余开发游戏没有太多差别。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/rcof02.jpg"></p><p>目前在日本有不少定期举辨的独立游戏相关活动，包含东京电玩展里面的独立游戏专区，或是专为独立游戏举办的 BitSummit，以及同时具备同人游戏贩售会与独立游戏展览的 Digital Game Expo 等等，在全球疫情之后，也有一些线上版的展会。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/UcPDVH.jpg"></p><p>接下来，是关于日本独立游戏界的从业概况。根据《<a href="https://head-high.com/survivalguide">独立游戏生存指南</a>》（一条贵彰著作）一书的调查，日本的独立游戏开发者大约有一万人，最主要的分布地则是有许多大公司的东京/横滨，和有着任天堂、CAPCOM 等公司的京都/大坂。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/cqsyb6.jpg"></p><p>Anne 透过 twitter 募集了 65 位开发者，参与独立游戏开发者概况的问卷调查。样本数不算多，无法完全呈现真实的产业概况，但仍然可以在一定程度上提供参考价值。受访者大多是单人开发，或是 5 人以下的小团队。年龄分布上，有 13 % 是 20 多岁，对于海外游戏与独立游戏有较多的接触，另外 85% 的开发者介于 30~49 岁之间，是受日本家用主机影响很深的世代，大多是在有着额外的工作或积蓄的情况下进行独立游戏开发。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/1LppKE.jpg"></p><p>在时间与财务上，全职独立开发与兼职独立开发占的比例差不多，分别是 37、35%，有 25% 的开发者则是纯兴趣式的在制作游戏。财务方面，有 58% 的开发者需要额外工作来赚取开发与生活所需费用，有 40 % 开发者是靠上一款游戏赚的钱作为下一款游戏的开发资金。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/PBiURZ.jpg"></p><p>在外部资源的支持上，日本独立开发者能获得的十分有限。发行商愿意给予的 MG (Minimum Guarantee，最低保证销售量) 通常很低，也几乎得不到来自政府与产业的协助；就算有公司愿意投资独立游戏，也都是投资给大公司出身的知名开发者，或者已经有成功实绩的手机游戏公司。不过在近期值得关注的是，漫画出版社“集英社”展现了对独立游戏的兴趣，成立独立游戏开发者的网络交流社群“Game Creators Camp”，并且主办或协办了游戏创作竞赛，有点类似他们举办漫画新人奖的方式，优胜者不但会有奖金，还可以获得商品化的全额或部分开发资金出资。</p><p>至于欧美兴盛一时的 Kickstarter 平台，要到 2017 年才接受日本人提案，在那之前只能透过欧美国家的代理人提案，大多数的独立开发者无力参与。实际上，也只有本来就已经很有名的日本游戏制作人，才有机会在 Kickstrter 上成功，而且这“有名”还必须要是在海外有名才行，只在日本有名是不够的，也因为主要的目标是海外玩家，很需要有懂英语的团队协助沟通。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/z4kl20.jpg"></p><p>日本当地当然也有集资平台，代表性的是 Campfire，有不少游戏在这个平台上成功集资，但可以创下的金额纪录就远不及 Kickstarter 了。会在上面集资的游戏，多半是群体比较小众但又死忠的类型，例如 VR 游戏、日式动画风游戏、卷轴式射击游戏等。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/rVp4XJ.jpg"></p><p>对日本独立游戏开发者来说，要他们进军海外市场，普遍会遇到的最大问题，就是语言隔阂。有 80% 的受访者认为他们无法顺利进行外语沟通，必须仰赖翻译工具协助理解。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/f17Wz7.jpg"></p><p>这对于资讯获取上，造成了很大的阻碍。在网络上，有许多免费提供的游戏开发、行销的教学文章或影片，但大多是以英文撰写，英文不好的话就难以阅读；然后，国际展会或竞赛的说明，多半仅提供英文版的说明，这也造成了日本独立游戏比较少参与国际竞赛；还有，游戏的开发工具本身的界面、以及使用文件，基本上也都是英文的。更糟的是，不佳的英语能力还可能造成资讯上的误解。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/kmpObo.jpg"></p><p>语言隔阂也会造成成本上的增加，当日文游戏想要卖到海外时，必然需要外语化的翻译。只需要少量翻译的游戏或许还好，但文字数量很高的 RPG 或文字冒险类游戏类型游戏，又是日本独立游戏的主流大宗，翻译上会增加不少开发成本，资金比较不足的团队可能就选择不做翻译，这也导致游戏失去了被海外发行商青睐的机会。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/eVUfxb.jpg"></p><p>在 Anne 所做的问券统计里，有 50% 的开发者会自行设法将游戏翻译成外国语言，19% 开发者的游戏翻译是由发行商负责，31% 的开发者选择不做翻译。而在翻译的语言选择上，比例最高的是英语，其次则是文化相近、翻译难度较低、市场规模也很大的中文。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/vCSIwu.jpg"></p><p>语言隔阂造成的另一个阻碍，是游戏的行销。即使游戏有办法做好翻译，但要向海外的玩家介绍游戏，需要的是更加灵活、即时的文字运用。像是怎么样正确的描述游戏、怎么样联系媒体、怎么样经营社区、怎么样跟粉丝互动等等。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/wSf36z.jpg"></p><p>在 Anne 所做的问券统计里，有 50% 的开发者会自行设法将游戏翻译成外国语言，19% 开发者的游戏翻译是由发行商负责，31% 的开发者选择不做翻译。而在翻译的语言选择上，比例最高的是英语，其次则是文化相近、翻译难度较低、市场规模也很大的中文。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/7E7wKZ.jpg"></p><p>语言隔阂造成的另一个阻碍，是游戏的行销。即使游戏有办法做好翻译，但要向海外的玩家介绍游戏，需要的是更加灵活、即时的文字运用。像是怎么样正确的描述游戏、怎么样联系媒体、怎么样经营社区、怎么样跟粉丝互动等等。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/6xt3GJ.jpg"></p><p>特别是在日文里，有许多只有日本人在用的“和制英语”，又或者日本玩家习惯使用的英文简称，国外玩家不见得看得懂。例如像《街头快打（Final Fight）》这种边走路边打人的游戏，在日本习惯称为“Belt Action / 带状卷轴动作游戏”，但英语圈并不会用这个词，而是用“Beat them up / 打爆他们”来称呼。又或者像“战略 RPG ”游戏，日本是用“SRPG”(Strategy RPG)，在英文圈则习惯用“Tacital RPG”来称呼。不只游戏类型的表述与缩写方式有歧异，像游戏预告片的英文，日本会习惯用“PV”(Promotion Video)，欧美则是会用 Trailer 这个字，跟海外玩家说“请看看我们游戏的最新 PV”时，他们可能会看不懂这是什么意思。</p><p>接着是受访者们选择的游戏主机平台。比例最高的是 PC/MAC，因为这是上架门槛最低的平台，但同时，日本的电脑游戏市场规模却很小，而且是远小于欧美国家的程度。要上主机的话，Switch 平台是首选，即使近年的 Xbox Game Pass 服务让独立游戏界受益不少，Xbox 系列主机在日本的市占率依然是低到不行，也因此影响了开发者们制作 Xbox 版游戏的意愿。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/7mJiRr.jpg"></p><p>在 PC 上，日本独立游戏最主要的销售平台是 Steam，其次是同人游戏的贩卖会、Itch.io 网站或免费下载。日本当地的数位贩售平台如 DLsite、DMM Games、Booth，也都有一定的使用量，但这些平台是包含影片、漫画、插画等作品的综合平台，主要内容也比较偏向成人游戏或同人游戏，不会有主流游戏大作在这边销售，国外消费者的比例也不高，因此吸引一般玩家的效果有限，只适合锁定特定群体的游戏。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/nfZkVh.jpg"></p><p>选择上架 GOG、Humble Store、Epic 等海外平台的比例又低了一阶，这跟这些平台并没有做好日文化、本身在日本就很少人用有关。</p><p>在发行与宣传上，高达 75% 的受访者在日本是自己发行游戏，而到了海外发行这边，交给发行商负责的比例提升了一些，但有 35% 的开发者选择不在海外发行。宣传方面，66% 的开发者自己负责游戏的宣传，但有 21% 的开发者并不特别宣传游戏；海外部分，不宣传的比例更高到过半，即使游戏有在海外平台上架了，因为不懂得怎么宣传或者不会用英语宣传，就只是单纯将游戏上架后，放着等愿者上钩。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/oXPHMj.jpg"></p><p>媒体联系方面，65% 左右的作品都会发新闻稿等相关资讯给日本国内媒体，但会联系海外媒体的比例则是反过来，主要原则还是不知道有哪些媒体、无法提供英文版新闻稿等语言隔阂因素。另外，大约 80 % 的开发者不会联系主动任何网红(不论国内外)，只被动的希望网红们可以去玩他们的游戏。有 86% 开发者不曾将游戏带到海外参展，即使有，也是以邻近的中国台湾地区、韩国为主。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/6im0il.jpg"></p><p>游戏宣传的管道，几乎全部的受访者都会透过 twitter 宣传，有七成以上会有网站页面，半数有做 Youtube 宣传影片，但剩余平台的使用比例就都不高，海外流行的 twitch 在日本的使用率是低到不行。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/m1RjA3.jpg"></p><p>日本有许多游戏媒体，如法米通、4gamer、Gamespark、电击、IGN Japan、Automaton、Gamecast 等等，这些媒体大多接受新闻稿投稿，有机会可以获得一至两篇的文章刊登曝光。一部分的日本游戏媒体会为游戏评论并且打分数，但只有 IGN Japan 的游戏评分会被列入 Metacritic 分数统计里。Automaton 则是较常报导海外独立游戏，也会将日文报导翻译成英文的媒体。然后，有不少欧美游戏媒体会录制影片或 podcast 型节目，日本游戏媒体这么做的很少，都还是维持在静态文字与图片报导的形式。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/KGCt85.jpg"></p><p>海外人士可能不知道，日本媒体经常会做“逆向输入”型的报导。就好像欧美媒体在介绍日本知名事物时，会形容“Big In Japan”那样，如果日本的游戏在海外有所回响，就会用“在海外受到瞩目”为主题来做报导，这是从音乐、影视、流行文化产业就很盛行的作法。</p><p>例如《ElecHead》这款日本独立游戏，被美国知名游戏开发者 Derek Yu 转推介绍后，就有日本媒体为此写了一篇“国产游戏被海外著名开发者夸赞”的报导。这也是一种向海外行销游戏所能带来的好处，毕竟独立游戏通常缺乏知名度或特殊的新闻点，较难吸引记者撰写报导，但要是在海外引起回响、被知名人士推荐，就构成了足以被写成新闻的题材。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/OrapWS.jpg"></p><p>可惜的是，并不是所有游戏都能够在全世界获得回响，即使游戏品质良好，还是会因为文化隔阂等因素，无法获得海外玩家的喜爱。像是《Unreal Life》，这是一款气氛渲染得很棒的像素画风冒险游戏，在日本获得不错的评价，也针对海外市场做了多国语言的翻译，但在 Steam 上，有 78% 的销售量是日本玩家购买，在 Switch 上更加极端，97% 的销售量来自日本。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/MgFvlu.jpg"></p><p>另一个例子是《Nkodice》，本作设计了一种特殊的骰子，骰子各面上标记的不是点数而是日文假名(字母)，玩法就是投掷骰子拼凑出单字，因为骰面上的假名经过刻意挑选，容易让玩家想要挑战骰出下流或搞笑的单字组合，在日本网络上成为一时爆红的话题。但这样的游戏，难以被直接翻译，就算要重新设计骰面、为不同语言进行在地化也不容易，是注定出不了日本的游戏。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/63umEM.jpg"></p><p>接下来要谈论的，是日本的学校与公司、产业间，对于独立游戏其实所知甚少。日本有不少大学有游戏相关科系，也有以游戏开发为主要授课内容的专门学校，但这些学校对于学生的期许或承诺，就是让他们毕业后可以进到游戏公司工作，并将就职率视为学校可以用来宣传的绩效。因此学生们在学的最后一年里，几乎都是在实习、面试，设法取得公司内定的流程中度过。当整个教育体系都这样引导学生时，自然很少有学生会有成为独立开发者的打算。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/cZzTZE.jpg"></p><p>而当开发者们进了游戏公司之后呢，大多数的公司并不鼓励甚至会禁止员工私下开发自己的游戏，即使有些开发者还是会私下制作游戏，也只能够用化名的方式发表。任天堂或 SONY 这种主机硬体商，为了充实自家平台的软件数，会对独立游戏提供一些协助，但其他游戏公司就比较少对独立开发者伸出援手，在日本最大的游戏开发者研讨会 CEDEC，也很少会有独立游戏开发的议题分享。</p><p>在整个产业面向，日本虽然有“Cool Japan”这种以“文化软实力”为主轴的推广计划，但多半只有大公司能从中获得助益，独立游戏能获得的官方支援相当少，就算是出国展览，也缺乏“国家馆”之类的集体出展单位，只能够单打独斗。</p><p>讲者对日本独立游戏开发者与社群提出了一些建议。首先是要有更多的翻译资源，像是国外教学文章的翻译或者影片的字幕，让不谙外语的人们，也能获取海外的相关知识，反过来也是，日本的游戏与相关宣传内容，都应该尽可能制作翻译版本，才能有效在海外扩散。然后是要有更多的区域或国家性的展览、发表会或者联合特卖，这可以让玩家们意识到这个国家也存在着独立开发的群体、有着哪些游戏。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/YcCdbr.jpg"></p><p>另外，也要设法促成更多海外交换学生或者海外移居工作的机会，特别是像日本这样社会相对封闭的国家，能够有人实际到国外生活与工作、再带着相关经验回来分享是很重要的。然后，也希望能有更多当地原生的孵化器或加速器单位出现，现在的孵化器或加速器单位有许多都是来自英语圈，日本当地的开发者比较不敢参与，也可能因为文化隔阂而合作困难。不过在 2021 年，日本终于有了第一个专为独立游戏团队服务的孵化器“<a href="https://igi.dev/">iGi</a>”（indie Game incubator），这是很好的现象。</p><p>最后的结论，还是要尽可能透过展览、宣传等方式，让大众有认识各式各样独立游戏与创作者的机会，当有更多的成功典范出现，就能够启发更多人投入创作、相互精进。跨文化的游戏多样性，也能够建立起全新的粉丝群，例如日系的 RPG 或是视觉小说，在二十年前可能只有日本当地市场，但现在，全世界都有这类游戏的粉丝，也有海外的开发者会去做类似风格的游戏。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/wPOjZz.jpg"></p><p>然后，创作者与作品都要试着跨出独立游戏圈与同温层，吸引一般玩家、主流媒体的关注，证明独立游戏创作也是一种堂堂正正的职业，就像是独立电影或独立音乐那样，是值得被社会重视、被政府与企业投资的文化产业。</p><p>而如果你是一名玩家，那就不要吝于谈论你喜爱的游戏或开发者，留下评论、推荐、分享转贴，不仅能带来宣传与扩散的效果，还能够为开发者带来很大的鼓舞！</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAE16/XqmrJa.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GAE16/ztlker.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;日本是电玩游戏产业代表性的大国，但日本的独立游戏，相较于全球，能见度与影响力就没那么强烈。在日本经营着独立游戏开发者社群的 Anne Ferrero，于 2022 年的 GDC，以《Big in Japan, Not in the West: The Difficults of Cross-Cultural Appeal》为题，分享了她收集与整理的日本独立游戏开发者概况，以及面向跨文化的全球市场时，所该注意的事项。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏分析与测评 (Game Analysis and Evaluation)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%B5%8B%E8%AF%84-Game-Analysis-and-Evaluation/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
    <category term="Japan" scheme="https://yousazoe.top/tags/Japan/"/>
    
  </entry>
  
  <entry>
    <title>记忆消散，思念永存--7 Years From Now</title>
    <link href="https://yousazoe.top/archives/5b6e89b1.html"/>
    <id>https://yousazoe.top/archives/5b6e89b1.html</id>
    <published>2022-06-17T13:22:44.000Z</published>
    <updated>2022-07-29T03:00:04.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/YMop7p.jpg)--><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GT12/Ppffq7.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>生活片段故事风格的冒险游戏，包含独特的体素画面与时间跳跃元素。陪伴高中生春人踏上旅程，寻找他有可能在七年前的一次事故中失去的记忆。</p><span id="more"></span><p><video id="video" width="1280px" height="400px" controls="" preload="none" poster="https://cdn.akamai.steamstatic.com/steam/apps/1562920/ss_3d51edd32f1c232e2d34f6dbd7d6777290db781f.600x338.jpg?t=1644419909">       <source id="mp4" src="https://cdn.akamai.steamstatic.com/steam/apps/256838864/movie480_vp9.webm?t=1623927587" type="video/mp4">       </video></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p>扮演高中生 Haruto Soraki 踏上旅程，寻找他有可能在七年前的一次事故中失去的记忆。从故乡开启旅程，与遗忘的朋友碰面，揭开小镇的黑暗秘密，倒流时光以赶超那些试图阻止你的人，想办法拼凑出七年前的真相。</p><p><strong>主要特色</strong></p><ul><li><p>独特像素风格的生活片段故事</p></li><li><p>探索城镇，并与镇民互动以推进故事的发展</p></li><li><p>调查神秘事件</p></li><li><p>揭开小镇的秘密</p></li><li><p>倒流时光，赶超你的敌人</p></li><li><p>破解失忆谜团，找出真相</p></li></ul><p><img data-src="https://p.qpic.cn/wegame/0/727dab91fd9fda00520bd50cd91902d0.jpg/1000"></p><h3 id="游戏实况"><a href="#游戏实况" class="headerlink" title="游戏实况"></a>游戏实况</h3><iframe src="//player.bilibili.com/player.html?aid=512535395&amp;bvid=BV1Cg411Q7qZ&amp;cid=749979228&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="游戏体验"><a href="#游戏体验" class="headerlink" title="游戏体验"></a>游戏体验</h3><h4 id="近乎完美的节奏把控"><a href="#近乎完美的节奏把控" class="headerlink" title="近乎完美的节奏把控"></a>近乎完美的节奏把控</h4><p>本作的节奏把控非常完美，正作每个小节衔接完整，并且常常在小节最后给出关键线索，让人欲罢不能想立刻开启下一章节的故事。笔者影响很深刻，第一次玩的时候打算从下午花两天打完，结果越玩越上头通宵通关（那时候还没出 DLC 只有正作）。</p><p>值得一提的还有游戏的BGM。音效的变化，是一个剧情类方向的特别之处。随着不同的音效，剧情往往也会走向一个不同的发展阶段，这也是对于剧情类走向的一个情感变化关键，在音效的交叉变化之中，就会有更多的代入感，能够吸引玩家们去深入剧情之中。玩家们在音效的变化中，而体会到剧情的斗转变化，从而更深的沉浸并感受出游戏情节的意义，这是音效在剧情游戏中起到的关键作用，能够加情感变化带到极致，以增添玩家们的代入感和沉浸感。下面放了游戏的 OST 以供鉴赏：</p>    <div id="aplayer-udtpAgoG" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2942950496" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"></div><h4 id="关于穿越的台本剧情"><a href="#关于穿越的台本剧情" class="headerlink" title="关于穿越的台本剧情"></a>关于穿越的台本剧情</h4><p>故事主体还是比较清晰的，在7年前由于某件事而失去了记忆，他拼命拜托父母，终于在春假期间回到了故乡，在与医生和旧友们的相处时间里，他一点点找回属于自己的记忆，不断地经历了一系列变故，朋友的牺牲，医院的阴谋，医生的实验……这些又在一次次的时空回溯中归于零点，当最后一丝记忆被他寻回时，关于医院的一切事实都浮出水面，而他却要面临一次抉择：留存回忆，还是改变过去。好在最后的结局是美好的，春人和葵还是完成了那个约定。</p><p>我也看了网上一些朋友对游戏台本的批评，认为其过于啰嗦和稚嫩，底层的逻辑撑不起整个故事。作为一个 AVG 的轻度玩家个人认为有些言重了，且不谈作者 fumi 是作为独立开发者全栈开发没有相对专业的文案台本，就”稚嫩”来说整个故事大部分都是围绕医院的孩子们，要求过于严谨的台本反而会给玩家一种疏远感，掐掉了没有玩法游戏的生命线：玩家对故事的代入感。</p><p>日式对话也许确实造成了本地化翻译比较难做，但不至于到无法接受的程度。至于故事的底层逻辑，我承认确实后面的设定有些跑远了，但没有明显的逻辑错误。正如科幻作品要落脚于人文主义的关怀，时光跳跃终究只是表面，内核依然是作者对友情和爱情羁绊能够跨越时空的赞扬和歌颂，当葵为了实现七年之后的诺言穿越成千上万次时，谁还会在意为什么一木的时光机不能像机器猫的抽屉一样随意穿越，又有哪位朋友在两人赴约于井时还会较真故事过于牵强而不是为最后的 HE 他们的爱情动容呢。</p><p><img data-src="https://p.qpic.cn/wegame/0/b01ace413057c9a72019a89029ad6fad.png/1000"></p><h4 id="线性流程与开放想象"><a href="#线性流程与开放想象" class="headerlink" title="线性流程与开放想象"></a>线性流程与开放想象</h4><p>严格来讲本作不能算一款游戏，它没有玩法，只有故事。</p><p>在线性的故事流程中，玩家所做的就是操作人物到指定地点交互。但除了前面说到的台本和音乐，玩家之所以拥有很强的代入感我觉得一部分要归功于体素的艺术风格。这里的体素风格只是作者身为独立开发者的无奈之举，但恰恰成为了类似于留白的点睛之笔，让玩家专注于剧情本身而非其他因素喧宾夺主，体素极具抽象的风格留给玩家更多的思考和想象空间，效果甚至要优于一些拥有优秀立绘的 AVG 作品。</p><p>简单的画面并不会影响剧情的跌宕起伏，单一的分支并不会减少玩家对于剧情的理解，反而更能体现其深刻。游戏一层一层的铺垫完美地让玩家跟角色的情感体验在同一个水平面上，或悲或喜，或惊或惧，像是没有屏幕的隔阂，我仿佛也能看到他们的笑容与眼泪，被他们的情感直直击中内心。</p><h3 id="插画鉴赏"><a href="#插画鉴赏" class="headerlink" title="插画鉴赏"></a>插画鉴赏</h3><p>因为游戏本身比较冷门所以同人不是很多，我尽可能的收集了一些自己比较喜欢的作品。</p><p><a href="https://twitter.com/arutarisa/status/1535547996829458432"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/ebyQUH.jpg"></a></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/c8cc3Q.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/35O8fh.jpg"></div></div></div></div><p><a href="https://twitter.com/hinata_ngm/status/926123260772720640"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/HZiD89.jpg"></a></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/6VI2Jt.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/gEE4mR.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/z2HK7C.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/3CUED7.jpg"></div></div></div></div><p><a href="https://twitter.com/imozabu/status/1006743473599287296"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/8YSDNI.jpg"></a></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/bUKzCS.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/LB73eM.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/4Gy313.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/hFeFTj.jpg"></div></div></div></div><p><a href="https://twitter.com/ccccccch1/status/1419655974780952577"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/NDq20J.jpg"></a></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/zR885n.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/0dKNTv.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/WWmnwf.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/amJR7p.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/IWnHaq.jpg"></div><div class="group-picture-column" style="width: 50%;"><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/q1PmBC.jpg"></div></div></div></div><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><p>“为了儿子的初恋而死，一定很帅吧！！！”</p><p>春人与葵梦幻般的初恋，是两个人不离不弃、无条件的相信对方一定会来拯救自己，以及用生命守护儿子初恋的立石，穿越时间也要让手术成功的一木父亲、义无反顾的相信并且帮助朋友的陆、门真、一木，在绝对理想的条件下共同创造出来的究极浪漫。</p><p>无私奉献的亲情、两小无猜的爱情、两肋插刀的友情，无不是让每一个人憧憬不已的感情，这种种感情交汇在一起不是层层叠加而是不断升华，让人越看下去越是陶醉，也越发心碎。</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;!--![](https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/YMop7p.jpg)--&gt;
&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GT12/Ppffq7.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;生活片段故事风格的冒险游戏，包含独特的体素画面与时间跳跃元素。陪伴高中生春人踏上旅程，寻找他有可能在七年前的一次事故中失去的记忆。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏追踪 (Game Tracker)" scheme="https://yousazoe.top/categories/%E6%B8%B8%E6%88%8F%E8%BF%BD%E8%B8%AA-Game-Tracker/"/>
    
    
    <category term="Game" scheme="https://yousazoe.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Qexo博客后端搭建</title>
    <link href="https://yousazoe.top/archives/e8ba704.html"/>
    <id>https://yousazoe.top/archives/e8ba704.html</id>
    <published>2022-06-12T12:56:16.000Z</published>
    <updated>2022-07-29T03:00:04.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/kebpM6.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在博客自动化的基础上加入 Qexo：一个快速、强大、漂亮的在线 Hexo 编辑器。</p><span id="more"></span><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/wpdQIZ.jpg"></p><h3 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h3><ul><li><p>自定义图床上传图片 </p></li><li><p>在线配置编辑</p></li><li><p>在线页面管理 </p></li><li><p>开放 API</p></li><li><p>自动检查更新</p></li><li><p>实验性的在线更新</p></li><li><p>自动填充 date 模板</p></li><li><p>基于时间戳的 abbrlink</p></li></ul><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><h4 id="Vercel-部署"><a href="#Vercel-部署" class="headerlink" title="Vercel 部署"></a>Vercel 部署</h4><h5 id="申请-MongoDB"><a href="#申请-MongoDB" class="headerlink" title="申请 MongoDB"></a>申请 MongoDB</h5><p>注册 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDB</a> 账号并创建免费 MongoDB 数据库，区域一定要选择 AWS / N. Virginia (us-east-1)。</p><p>在 Clusters 页面点击 CONNECT，按步骤设置允许所有 IP 地址的连接，创建数据库用户，并记录数据库连接信息，密码即为你所设置的值。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/2KVMrI.jpg"></p><h5 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h5><p>点击<a href="https://vercel.com/new/clone?repository-url=https://github.com/am-abudu/Qexo">开始部署</a>，部署到 Vercel</p><p>第一次部署会出现报错，原因在于没有设置环境变量（记得多看文档！）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[15:50:22.190] Cloning github.com/Yousazoe/Qexo (Branch: main, Commit: e9f1dc4)</span><br><span class="line">[15:50:22.766] Cloning completed: 575.787ms</span><br><span class="line">[15:50:24.432] Looking up build cache...</span><br><span class="line">[15:50:24.715] Build Cache not found</span><br><span class="line">[15:50:25.105] Running "vercel build"</span><br><span class="line">[15:50:25.540] Vercel CLI 24.2.5-canary.2 build (beta) — https://vercel.com/feedback</span><br><span class="line">[15:50:25.635] ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">[15:50:25.635] │ WARN! Due to `builds` existing in your configuration file, the Build and Development Settings defined in your Project Settings will not apply. Learn More: https://vercel.link/unused-build-settings │</span><br><span class="line">[15:50:25.636] └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">[15:50:26.204] Collecting asgiref==3.4.1</span><br><span class="line">[15:50:26.259]   Downloading asgiref-3.4.1-py3-none-any.whl (25 kB)</span><br><span class="line">[15:50:26.298] Collecting autopep8==1.5.7</span><br><span class="line">[15:50:26.311]   Downloading autopep8-1.5.7-py2.py3-none-any.whl (45 kB)</span><br><span class="line">[15:50:26.323]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 45.0/45.0 kB 4.3 MB/s eta 0:00:00</span><br><span class="line">[15:50:26.363] Collecting beautifulsoup4==4.10.0</span><br><span class="line">[15:50:26.376]   Downloading beautifulsoup4-4.10.0-py3-none-any.whl (97 kB)</span><br><span class="line">[15:50:26.392]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 97.4/97.4 kB 6.2 MB/s eta 0:00:00</span><br><span class="line">[15:50:26.444] Collecting boto==2.49.0</span><br><span class="line">[15:50:26.457]   Downloading boto-2.49.0-py2.py3-none-any.whl (1.4 MB)</span><br><span class="line">[15:50:26.497]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1.4/1.4 MB 36.1 MB/s eta 0:00:00</span><br><span class="line">[15:50:26.965] Collecting boto3==1.20.23</span><br><span class="line">[15:50:26.980]   Downloading boto3-1.20.23-py3-none-any.whl (131 kB)</span><br><span class="line">[15:50:26.988]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 131.8/131.8 kB 26.6 MB/s eta 0:00:00</span><br><span class="line">[15:50:27.537] Collecting botocore==1.23.23</span><br><span class="line">[15:50:27.552]   Downloading botocore-1.23.23-py3-none-any.whl (8.4 MB)</span><br><span class="line">[15:50:27.647]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 8.4/8.4 MB 91.5 MB/s eta 0:00:00</span><br><span class="line">[15:50:27.717] Collecting certifi==2021.5.30</span><br><span class="line">[15:50:27.732]   Downloading certifi-2021.5.30-py2.py3-none-any.whl (145 kB)</span><br><span class="line">[15:50:27.739]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 145.5/145.5 kB 31.7 MB/s eta 0:00:00</span><br><span class="line">[15:50:27.954] Collecting cffi==1.15.0</span><br><span class="line">[15:50:27.968]   Downloading cffi-1.15.0-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.whl (444 kB)</span><br><span class="line">[15:50:27.978]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 444.3/444.3 kB 59.5 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.015] Collecting charset-normalizer==2.0.4</span><br><span class="line">[15:50:28.028]   Downloading charset_normalizer-2.0.4-py3-none-any.whl (36 kB)</span><br><span class="line">[15:50:28.096] Collecting click==8.0.1</span><br><span class="line">[15:50:28.110]   Downloading click-8.0.1-py3-none-any.whl (97 kB)</span><br><span class="line">[15:50:28.116]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 97.4/97.4 kB 22.1 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.150] Collecting colorama==0.4.4</span><br><span class="line">[15:50:28.164]   Downloading colorama-0.4.4-py2.py3-none-any.whl (16 kB)</span><br><span class="line">[15:50:28.201] Collecting Deprecated==1.2.13</span><br><span class="line">[15:50:28.215]   Downloading Deprecated-1.2.13-py2.py3-none-any.whl (9.6 kB)</span><br><span class="line">[15:50:28.242] Collecting dj-database-url==0.5.0</span><br><span class="line">[15:50:28.256]   Downloading dj_database_url-0.5.0-py2.py3-none-any.whl (5.5 kB)</span><br><span class="line">[15:50:28.377] Collecting Django==3.0.5</span><br><span class="line">[15:50:28.391]   Downloading Django-3.0.5-py3-none-any.whl (7.5 MB)</span><br><span class="line">[15:50:28.476]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 7.5/7.5 MB 91.8 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.554] Collecting djongo==1.3.6</span><br><span class="line">[15:50:28.571]   Downloading djongo-1.3.6.tar.gz (331 kB)</span><br><span class="line">[15:50:28.580]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 331.6/331.6 kB 47.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.605]   Preparing metadata (setup.py): started</span><br><span class="line">[15:50:28.777]   Preparing metadata (setup.py): finished with status 'done'</span><br><span class="line">[15:50:28.820] Collecting django-cors-headers==3.10.1</span><br><span class="line">[15:50:28.834]   Downloading django_cors_headers-3.10.1-py3-none-any.whl (12 kB)</span><br><span class="line">[15:50:28.866] Collecting dnspython==1.16.0</span><br><span class="line">[15:50:28.889]   Downloading dnspython-1.16.0-py2.py3-none-any.whl (188 kB)</span><br><span class="line">[15:50:28.897]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 188.4/188.4 kB 37.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.939] Collecting gunicorn==20.1.0</span><br><span class="line">[15:50:28.956]   Downloading gunicorn-20.1.0-py3-none-any.whl (79 kB)</span><br><span class="line">[15:50:28.962]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 79.5/79.5 kB 19.5 MB/s eta 0:00:00</span><br><span class="line">[15:50:28.992] Collecting idna==3.2</span><br><span class="line">[15:50:29.008]   Downloading idna-3.2-py3-none-any.whl (59 kB)</span><br><span class="line">[15:50:29.014]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 59.6/59.6 kB 14.2 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.048] Collecting jmespath==0.10.0</span><br><span class="line">[15:50:29.062]   Downloading jmespath-0.10.0-py2.py3-none-any.whl (24 kB)</span><br><span class="line">[15:50:29.099] Collecting prettytable==2.2.0</span><br><span class="line">[15:50:29.114]   Downloading prettytable-2.2.0-py3-none-any.whl (23 kB)</span><br><span class="line">[15:50:29.177] Collecting pyasn1==0.4.8</span><br><span class="line">[15:50:29.192]   Downloading pyasn1-0.4.8-py2.py3-none-any.whl (77 kB)</span><br><span class="line">[15:50:29.198]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 77.1/77.1 kB 17.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.232] Collecting pycodestyle==2.7.0</span><br><span class="line">[15:50:29.245]   Downloading pycodestyle-2.7.0-py2.py3-none-any.whl (41 kB)</span><br><span class="line">[15:50:29.250]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 41.7/41.7 kB 10.0 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.276] Collecting pycparser==2.21</span><br><span class="line">[15:50:29.292]   Downloading pycparser-2.21-py2.py3-none-any.whl (118 kB)</span><br><span class="line">[15:50:29.298]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 118.7/118.7 kB 25.1 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.342] Collecting PyGithub==1.55</span><br><span class="line">[15:50:29.359]   Downloading PyGithub-1.55-py3-none-any.whl (291 kB)</span><br><span class="line">[15:50:29.369]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 291.7/291.7 kB 41.7 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.414] Collecting PyJWT==2.3.0</span><br><span class="line">[15:50:29.428]   Downloading PyJWT-2.3.0-py3-none-any.whl (16 kB)</span><br><span class="line">[15:50:29.883] Collecting pymongo==3.12.0</span><br><span class="line">[15:50:29.902]   Downloading pymongo-3.12.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (531 kB)</span><br><span class="line">[15:50:29.913]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 531.9/531.9 kB 61.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:29.970] Collecting PyNaCl==1.4.0</span><br><span class="line">[15:50:29.988]   Downloading PyNaCl-1.4.0-cp35-abi3-manylinux1_x86_64.whl (961 kB)</span><br><span class="line">[15:50:30.003]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 961.1/961.1 kB 77.6 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.065] Collecting python-dateutil==2.8.2</span><br><span class="line">[15:50:30.079]   Downloading python_dateutil-2.8.2-py2.py3-none-any.whl (247 kB)</span><br><span class="line">[15:50:30.087]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 247.7/247.7 kB 48.6 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.111] Collecting python-decouple==3.4</span><br><span class="line">[15:50:30.126]   Downloading python_decouple-3.4-py3-none-any.whl (9.5 kB)</span><br><span class="line">[15:50:30.212] Collecting pytz==2021.1</span><br><span class="line">[15:50:30.233]   Downloading pytz-2021.1-py2.py3-none-any.whl (510 kB)</span><br><span class="line">[15:50:30.244]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 510.8/510.8 kB 58.8 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.307] Collecting requests==2.26.0</span><br><span class="line">[15:50:30.321]   Downloading requests-2.26.0-py2.py3-none-any.whl (62 kB)</span><br><span class="line">[15:50:30.327]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 62.3/62.3 kB 13.6 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.361] Collecting rsa==4.7.2</span><br><span class="line">[15:50:30.376]   Downloading rsa-4.7.2-py3-none-any.whl (34 kB)</span><br><span class="line">[15:50:30.413] Collecting s3transfer==0.5.0</span><br><span class="line">[15:50:30.427]   Downloading s3transfer-0.5.0-py3-none-any.whl (79 kB)</span><br><span class="line">[15:50:30.433]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 79.2/79.2 kB 15.4 MB/s eta 0:00:00</span><br><span class="line">[15:50:30.464] Collecting six==1.16.0</span><br><span class="line">[15:50:30.480]   Downloading six-1.16.0-py2.py3-none-any.whl (11 kB)</span><br><span class="line">[15:50:30.521] Collecting soupsieve==2.2.1</span><br><span class="line">[15:50:30.534]   Downloading soupsieve-2.2.1-py3-none-any.whl (33 kB)</span><br><span class="line">[15:50:30.567] Collecting sqlparse==0.2.4</span><br><span class="line">[15:50:30.583]   Downloading sqlparse-0.2.4-py2.py3-none-any.whl (38 kB)</span><br><span class="line">[15:50:30.612] Collecting tcping==0.1.1rc1</span><br><span class="line">[15:50:30.626]   Downloading tcping-0.1.1rc1.tar.gz (4.1 kB)</span><br><span class="line">[15:50:30.631]   Preparing metadata (setup.py): started</span><br><span class="line">[15:50:30.800]   Preparing metadata (setup.py): finished with status 'done'</span><br><span class="line">[15:50:30.832] Collecting toml==0.10.2</span><br><span class="line">[15:50:30.845]   Downloading toml-0.10.2-py2.py3-none-any.whl (16 kB)</span><br><span class="line">[15:50:30.964] Collecting ujson==4.1.0</span><br><span class="line">[15:50:30.979]   Downloading ujson-4.1.0-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.whl (179 kB)</span><br><span class="line">[15:50:30.987]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 179.5/179.5 kB 31.3 MB/s eta 0:00:00</span><br><span class="line">[15:50:31.011] Collecting Unipath==1.1</span><br><span class="line">[15:50:31.025]   Downloading Unipath-1.1.tar.gz (30 kB)</span><br><span class="line">[15:50:31.034]   Preparing metadata (setup.py): started</span><br><span class="line">[15:50:31.200]   Preparing metadata (setup.py): finished with status 'done'</span><br><span class="line">[15:50:31.259] Collecting urllib3==1.26.7</span><br><span class="line">[15:50:31.272]   Downloading urllib3-1.26.7-py2.py3-none-any.whl (138 kB)</span><br><span class="line">[15:50:31.280]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 138.8/138.8 kB 27.9 MB/s eta 0:00:00</span><br><span class="line">[15:50:31.313] Collecting wcwidth==0.2.5</span><br><span class="line">[15:50:31.326]   Downloading wcwidth-0.2.5-py2.py3-none-any.whl (30 kB)</span><br><span class="line">[15:50:31.367] Collecting whitenoise==5.3.0</span><br><span class="line">[15:50:31.382]   Downloading whitenoise-5.3.0-py2.py3-none-any.whl (19 kB)</span><br><span class="line">[15:50:31.520] Collecting wrapt==1.13.3</span><br><span class="line">[15:50:31.533]   Downloading wrapt-1.13.3-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (81 kB)</span><br><span class="line">[15:50:31.539]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 81.3/81.3 kB 21.7 MB/s eta 0:00:00</span><br><span class="line">[15:50:31.576] Collecting Markdown==3.3.6</span><br><span class="line">[15:50:31.591]   Downloading Markdown-3.3.6-py3-none-any.whl (97 kB)</span><br><span class="line">[15:50:31.597]      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 97.8/97.8 kB 22.1 MB/s eta 0:00:00</span><br><span class="line">[15:50:31.626] Collecting html2text==2020.1.16</span><br><span class="line">[15:50:31.640]   Downloading html2text-2020.1.16-py3-none-any.whl (32 kB)</span><br><span class="line">[15:50:31.987] Requirement already satisfied: setuptools&gt;=3.0 in /usr/local/lib/python3.9/site-packages (from gunicorn==20.1.0-&gt;-r requirements.txt (line 18)) (58.1.0)</span><br><span class="line">[15:50:32.524] Collecting importlib-metadata&gt;=4.4</span><br><span class="line">[15:50:32.538]   Downloading importlib_metadata-4.11.4-py3-none-any.whl (18 kB)</span><br><span class="line">[15:50:32.616] Collecting zipp&gt;=0.5</span><br><span class="line">[15:50:32.633]   Downloading zipp-3.8.0-py3-none-any.whl (5.4 kB)</span><br><span class="line">[15:50:32.691] Using legacy 'setup.py install' for djongo, since package 'wheel' is not installed.</span><br><span class="line">[15:50:32.691] Using legacy 'setup.py install' for tcping, since package 'wheel' is not installed.</span><br><span class="line">[15:50:32.692] Using legacy 'setup.py install' for Unipath, since package 'wheel' is not installed.</span><br><span class="line">[15:50:32.914] Installing collected packages: wcwidth, Unipath, sqlparse, pytz, python-decouple, pyasn1, dj-database-url, certifi, boto, zipp, wrapt, whitenoise, urllib3, ujson, toml, soupsieve, six, rsa, pymongo, PyJWT, pycparser, pycodestyle, prettytable, jmespath, idna, html2text, gunicorn, dnspython, colorama, click, charset-normalizer, asgiref, tcping, requests, python-dateutil, importlib-metadata, Django, Deprecated, cffi, beautifulsoup4, autopep8, PyNaCl, Markdown, djongo, django-cors-headers, botocore, s3transfer, PyGithub, boto3</span><br><span class="line">[15:50:32.961]   Running setup.py install for Unipath: started</span><br><span class="line">[15:50:33.168]   Running setup.py install for Unipath: finished with status 'done'</span><br><span class="line">[15:50:35.005]   Running setup.py install for tcping: started</span><br><span class="line">[15:50:35.215]   Running setup.py install for tcping: finished with status 'done'</span><br><span class="line">[15:50:37.169]   Running setup.py install for djongo: started</span><br><span class="line">[15:50:37.439]   Running setup.py install for djongo: finished with status 'done'</span><br><span class="line">[15:50:38.307] Successfully installed Deprecated-1.2.13 Django-3.0.5 Markdown-3.3.6 PyGithub-1.55 PyJWT-2.3.0 PyNaCl-1.4.0 Unipath-1.1 asgiref-3.4.1 autopep8-1.5.7 beautifulsoup4-4.10.0 boto-2.49.0 boto3-1.20.23 botocore-1.23.23 certifi-2021.5.30 cffi-1.15.0 charset-normalizer-2.0.4 click-8.0.1 colorama-0.4.4 dj-database-url-0.5.0 django-cors-headers-3.10.1 djongo-1.3.6 dnspython-1.16.0 gunicorn-20.1.0 html2text-2020.1.16 idna-3.2 importlib-metadata-4.11.4 jmespath-0.10.0 prettytable-2.2.0 pyasn1-0.4.8 pycodestyle-2.7.0 pycparser-2.21 pymongo-3.12.0 python-dateutil-2.8.2 python-decouple-3.4 pytz-2021.1 requests-2.26.0 rsa-4.7.2 s3transfer-0.5.0 six-1.16.0 soupsieve-2.2.1 sqlparse-0.2.4 tcping-0.1.1rc1 toml-0.10.2 ujson-4.1.0 urllib3-1.26.7 wcwidth-0.2.5 whitenoise-5.3.0 wrapt-1.13.3 zipp-3.8.0</span><br><span class="line">[15:50:38.307] WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv</span><br><span class="line">[15:51:09.211] Traceback (most recent call last):</span><br><span class="line">[15:51:09.211]   File "/vercel/path0/manage.py", line 22, in &lt;module&gt;</span><br><span class="line">[15:51:09.211]     main()</span><br><span class="line">[15:51:09.212]   File "/vercel/path0/manage.py", line 18, in main</span><br><span class="line">[15:51:09.212]     execute_from_command_line(sys.argv)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py", line 401, in execute_from_command_line</span><br><span class="line">[15:51:09.212]     utility.execute()</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py", line 395, in execute</span><br><span class="line">[15:51:09.212]     self.fetch_command(subcommand).run_from_argv(self.argv)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 328, in run_from_argv</span><br><span class="line">[15:51:09.212]     self.execute(*args, **cmd_options)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 369, in execute</span><br><span class="line">[15:51:09.212]     output = self.handle(*args, **options)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 83, in wrapped</span><br><span class="line">[15:51:09.212]     res = handle_func(*args, **kwargs)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/core/management/commands/makemigrations.py", line 101, in handle</span><br><span class="line">[15:51:09.212]     loader.check_consistent_history(connection)</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/loader.py", line 283, in check_consistent_history</span><br><span class="line">[15:51:09.212]     applied = recorder.applied_migrations()</span><br><span class="line">[15:51:09.212]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/recorder.py", line 76, in applied_migrations</span><br><span class="line">[15:51:09.213]     if self.has_table():</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/recorder.py", line 56, in has_table</span><br><span class="line">[15:51:09.213]     return self.Migration._meta.db_table in self.connection.introspection.table_names(self.connection.cursor())</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/django/db/backends/base/introspection.py", line 48, in table_names</span><br><span class="line">[15:51:09.213]     return get_names(cursor)</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/django/db/backends/base/introspection.py", line 43, in get_names</span><br><span class="line">[15:51:09.213]     return sorted(ti.name for ti in self.get_table_list(cursor)</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/djongo/introspection.py", line 47, in get_table_list</span><br><span class="line">[15:51:09.213]     for c in cursor.db_conn.list_collection_names()</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/pymongo/database.py", line 880, in list_collection_names</span><br><span class="line">[15:51:09.213]     for result in self.list_collections(session=session, **kwargs)]</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/pymongo/database.py", line 842, in list_collections</span><br><span class="line">[15:51:09.213]     return self.__client._retryable_read(</span><br><span class="line">[15:51:09.213]   File "/usr/local/lib/python3.9/site-packages/pymongo/mongo_client.py", line 1514, in _retryable_read</span><br><span class="line">[15:51:09.214]     server = self._select_server(</span><br><span class="line">[15:51:09.214]   File "/usr/local/lib/python3.9/site-packages/pymongo/mongo_client.py", line 1346, in _select_server</span><br><span class="line">[15:51:09.214]     server = topology.select_server(server_selector)</span><br><span class="line">[15:51:09.214]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 244, in select_server</span><br><span class="line">[15:51:09.214]     return random.choice(self.select_servers(selector,</span><br><span class="line">[15:51:09.214]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 202, in select_servers</span><br><span class="line">[15:51:09.214]     server_descriptions = self._select_servers_loop(</span><br><span class="line">[15:51:09.214]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 218, in _select_servers_loop</span><br><span class="line">[15:51:09.214]     raise ServerSelectionTimeoutError(</span><br><span class="line">[15:51:09.214] pymongo.errors.ServerSelectionTimeoutError: connection closed,connection closed,connection closed, Timeout: 30s, Topology Description: &lt;TopologyDescription id: 62971a4e82b1c0159350eafa, topology_type: ReplicaSetNoPrimary, servers: [&lt;ServerDescription ('cluster0-shard-00-00.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;, &lt;ServerDescription ('cluster0-shard-00-01.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;, &lt;ServerDescription ('cluster0-shard-00-02.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;]&gt;</span><br><span class="line">[15:51:40.368] Traceback (most recent call last):</span><br><span class="line">[15:51:40.368]   File "/vercel/path0/manage.py", line 22, in &lt;module&gt;</span><br><span class="line">[15:51:40.368]     main()</span><br><span class="line">[15:51:40.368]   File "/vercel/path0/manage.py", line 18, in main</span><br><span class="line">[15:51:40.368]     execute_from_command_line(sys.argv)</span><br><span class="line">[15:51:40.368]   File "/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py", line 401, in execute_from_command_line</span><br><span class="line">[15:51:40.368]     utility.execute()</span><br><span class="line">[15:51:40.368]   File "/usr/local/lib/python3.9/site-packages/django/core/management/__init__.py", line 395, in execute</span><br><span class="line">[15:51:40.369]     self.fetch_command(subcommand).run_from_argv(self.argv)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 328, in run_from_argv</span><br><span class="line">[15:51:40.369]     self.execute(*args, **cmd_options)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 369, in execute</span><br><span class="line">[15:51:40.369]     output = self.handle(*args, **options)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/core/management/base.py", line 83, in wrapped</span><br><span class="line">[15:51:40.369]     res = handle_func(*args, **kwargs)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/core/management/commands/migrate.py", line 86, in handle</span><br><span class="line">[15:51:40.369]     executor = MigrationExecutor(connection, self.migration_progress_callback)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/executor.py", line 18, in __init__</span><br><span class="line">[15:51:40.369]     self.loader = MigrationLoader(self.connection)</span><br><span class="line">[15:51:40.369]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/loader.py", line 49, in __init__</span><br><span class="line">[15:51:40.369]     self.build_graph()</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/loader.py", line 212, in build_graph</span><br><span class="line">[15:51:40.370]     self.applied_migrations = recorder.applied_migrations()</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/recorder.py", line 76, in applied_migrations</span><br><span class="line">[15:51:40.370]     if self.has_table():</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/migrations/recorder.py", line 56, in has_table</span><br><span class="line">[15:51:40.370]     return self.Migration._meta.db_table in self.connection.introspection.table_names(self.connection.cursor())</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/backends/base/introspection.py", line 48, in table_names</span><br><span class="line">[15:51:40.370]     return get_names(cursor)</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/django/db/backends/base/introspection.py", line 43, in get_names</span><br><span class="line">[15:51:40.370]     return sorted(ti.name for ti in self.get_table_list(cursor)</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/djongo/introspection.py", line 47, in get_table_list</span><br><span class="line">[15:51:40.370]     for c in cursor.db_conn.list_collection_names()</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/pymongo/database.py", line 880, in list_collection_names</span><br><span class="line">[15:51:40.370]     for result in self.list_collections(session=session, **kwargs)]</span><br><span class="line">[15:51:40.370]   File "/usr/local/lib/python3.9/site-packages/pymongo/database.py", line 842, in list_collections</span><br><span class="line">[15:51:40.371]     return self.__client._retryable_read(</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/mongo_client.py", line 1514, in _retryable_read</span><br><span class="line">[15:51:40.371]     server = self._select_server(</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/mongo_client.py", line 1346, in _select_server</span><br><span class="line">[15:51:40.371]     server = topology.select_server(server_selector)</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 244, in select_server</span><br><span class="line">[15:51:40.371]     return random.choice(self.select_servers(selector,</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 202, in select_servers</span><br><span class="line">[15:51:40.371]     server_descriptions = self._select_servers_loop(</span><br><span class="line">[15:51:40.371]   File "/usr/local/lib/python3.9/site-packages/pymongo/topology.py", line 218, in _select_servers_loop</span><br><span class="line">[15:51:40.371]     raise ServerSelectionTimeoutError(</span><br><span class="line">[15:51:40.372] pymongo.errors.ServerSelectionTimeoutError: connection closed,connection closed,connection closed, Timeout: 30s, Topology Description: &lt;TopologyDescription id: 62971a6e87ecd8382d3ed4fa, topology_type: ReplicaSetNoPrimary, servers: [&lt;ServerDescription ('cluster0-shard-00-00.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;, &lt;ServerDescription ('cluster0-shard-00-01.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;, &lt;ServerDescription ('cluster0-shard-00-02.sw6pb.mongodb.net', 27017) server_type: Unknown, rtt: None, error=AutoReconnect('connection closed')&gt;]&gt;</span><br><span class="line">[15:51:40.836] Error! Command "./migrate.sh" exited with 1</span><br><span class="line">[15:51:40.936] Error: Command "vercel build" exited with 1</span><br></pre></td></tr></tbody></table></figure><p>重新进入项目，在项目设置界面添加环境变量 Environment Variables：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/RgYP06.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/ILxGE5.jpg"></p><p>在 Deployments 点击 Redeploy 开始部署，若没有 Error 信息即可打开域名进入初始化引导。</p><h4 id="友链管理"><a href="#友链管理" class="headerlink" title="友链管理"></a>友链管理</h4><p>这个教程将帮助你在几分钟内利用 Qexo 为博客接入友链系统。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/Kbv5v5.jpg"></p><h5 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h5><p>友链功能要求 Qexo &gt;= 1.5.0 且用户浏览器必须支持文件上传。</p><h5 id="添加友链"><a href="#添加友链" class="headerlink" title="添加友链"></a>添加友链</h5><ol><li><p>在 Qexo 侧边栏找到 <strong>友链</strong> 点击进入</p></li><li><p>点击右上角 <strong>新增友链</strong> 输入站点名称、链接等数据，其中链接及图片链接<strong>必须包含http协议头</strong>。</p></li><li><p>点击 <strong>确定</strong> 按键保存友链数据</p></li></ol><h5 id="接入博客"><a href="#接入博客" class="headerlink" title="接入博客"></a>接入博客</h5><ol><li>在根目录打开命令行，输入命令创建页面：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page links</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><p>打开 source/links/index.md 修改页面配置</p></li><li><p>在页面内引入 Qexo-Friends 将其中的 <code>${SITE}</code> 改为你的 Qexo 链接，例如 <a href="https://admin.mysite.com/">https://admin.mysite.com</a></p></li></ol><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"qexo-friends"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/qexo-static@1.1.3/hexo/friends/friends.css"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/qexo-static@1.1.3/hexo/friends/friends.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">loadQexoFriends</span>(<span class="string">"qexo-friends"</span>, <span class="string">"${SITE}"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>将博客推送至你的 Github 仓库</li></ol><h5 id="友链申请"><a href="#友链申请" class="headerlink" title="友链申请"></a>友链申请</h5><p>由 @Fgaoxing 适配的友链申请 API：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"friends-api"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/gh/Fgaoxing/blog-cdn@main/source/js/friends-api.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">qexo_friend_api</span>(<span class="string">"friends-api"</span>,<span class="string">"Qexo域名"</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="Github-配置"><a href="#Github-配置" class="headerlink" title="Github 配置"></a>Github 配置</h4><p>如果部署中遇到问题，可以访问 <a href="https://hexoplusplus.cronfly.workers.dev/?step=start">HPP校验助手</a> 自检配置，若确认无误，可检查仓库内是否有已经发布的文章</p><h5 id="Github-仓库"><a href="#Github-仓库" class="headerlink" title="Github 仓库"></a>Github 仓库</h5><p>您 Hexo 自动化部署所在的仓库：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">username/repo</span><br></pre></td></tr></tbody></table></figure><h5 id="项目分支"><a href="#项目分支" class="headerlink" title="项目分支"></a>项目分支</h5><p>您 Hexo 自动化部署所在仓库的分支：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">master</span><br></pre></td></tr></tbody></table></figure><h5 id="Github-密钥"><a href="#Github-密钥" class="headerlink" title="Github 密钥"></a>Github 密钥</h5><p>于 <a href="">Github 设置</a> 生成的 Token 需要 Repo 下的至少读取和写入权限，不建议给出所有权限：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">wrq_P8sYPlYA9fjMlOPEYSKA84xxxxxxxxxxxxxx</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/Qeoko9.jpg"></p><h5 id="仓库路径"><a href="#仓库路径" class="headerlink" title="仓库路径"></a>仓库路径</h5><p>您 Hexo 自动化部署所在仓库的路径 若为根目录请留空：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">path/</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义图床配置"><a href="#自定义图床配置" class="headerlink" title="自定义图床配置"></a>自定义图床配置</h4><p>Qexo 提供了强大的自定义图床功能，在配置完成图床设置后即可在文章/页面编辑界面上传图片。</p><h5 id="API-地址"><a href="#API-地址" class="headerlink" title="API 地址"></a>API 地址</h5><p>图床图片上传的 API：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://7bu.top/api/upload</span><br></pre></td></tr></tbody></table></figure><h5 id="POST-参数名"><a href="#POST-参数名" class="headerlink" title="POST 参数名"></a>POST 参数名</h5><p>图床图片上传 API 参数中图片文件的参数名：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">image</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/XI19al.jpg"></p><h5 id="JSON-路径"><a href="#JSON-路径" class="headerlink" title="JSON 路径"></a>JSON 路径</h5><p>图床 API 返回数据中图片 URL 所在的路径，若为整个返回值请留空。示例：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/MR7qoI.jpg"></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">data.url</span><br></pre></td></tr></tbody></table></figure><h5 id="自定义请求头"><a href="#自定义请求头" class="headerlink" title="自定义请求头"></a>自定义请求头</h5><p>POST 请求时附带的请求头，需要标准 JSON 格式，若不需要请留空。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{"key":"value"}</span><br></pre></td></tr></tbody></table></figure><h5 id="自定义-BODY"><a href="#自定义-BODY" class="headerlink" title="自定义 BODY"></a>自定义 BODY</h5><p>POST 请求时额外的请求主体，需要标准 JSON 格式，若不需要请留空。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{"key":"value"}</span><br></pre></td></tr></tbody></table></figure><h5 id="自定义前缀"><a href="#自定义前缀" class="headerlink" title="自定义前缀"></a>自定义前缀</h5><p>返回 URL 所需要添加的前缀，若不需要请留空。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">some_text_or_url</span><br></pre></td></tr></tbody></table></figure><h4 id="Vercel-相关配置"><a href="#Vercel-相关配置" class="headerlink" title="Vercel 相关配置"></a>Vercel 相关配置</h4><h5 id="VERCEL-TOKEN"><a href="#VERCEL-TOKEN" class="headerlink" title="VERCEL_TOKEN"></a>VERCEL_TOKEN</h5><p>您的 Vercel 账户密钥 在 <a href="https://vercel.com/account/tokens">此处</a> 生成：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/uPic@main/uPic/img/MsSR1F.png"></p><h5 id="PROJECT-ID"><a href="#PROJECT-ID" class="headerlink" title="PROJECT_ID"></a>PROJECT_ID</h5><p>您 Qexo 部署所在项目的 ID 位于 <code>Project Settings -&gt; General -&gt; Project ID</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">prj_xxxxxxx</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/FZFaPl.jpg"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="什么是-API-密钥"><a href="#什么是-API-密钥" class="headerlink" title="什么是 API 密钥"></a>什么是 API 密钥</h4><p>在您完成初始化之后可在设置界面修改/创建 API 密钥，用于 Webhook 中的身份验证。若留空系统会随机生成一个 API 密钥。</p><h4 id="Webhook-是什么"><a href="#Webhook-是什么" class="headerlink" title="Webhook 是什么"></a>Webhook 是什么</h4><p>Qexo 中的 Webhook 指 /api/webhook 用于自动化操作，目前可用于自动清除缓存。</p><h4 id="安装后出现-504-Time-out"><a href="#安装后出现-504-Time-out" class="headerlink" title="安装后出现 504 Time out"></a>安装后出现 504 Time out</h4><ol><li><p>您的数据库没有正确配置或没有允许所有 IP 白名单访问，可在 MongoDB 控制台进行修改，修改完成后一定要重新部署。</p></li><li><p>删除并重建数据库，注意区域一定要选择 AWS / N. Virginia (us-east-1)。</p></li></ol><h4 id="安装-x2F-更新后出现-5xx-错误"><a href="#安装-x2F-更新后出现-5xx-错误" class="headerlink" title="安装/更新后出现 5xx 错误"></a>安装/更新后出现 5xx 错误</h4><p>Qexo 每个 Release 都经过 Dev 分支的测试，一般情况下不会出现较大问题，如果你遇到了500等错误，请尝试以下步骤：</p><ol><li><p>检查数据库配置</p></li><li><p>清除浏览器缓存</p></li><li><p>在高级设置中点击“修复”按钮</p></li><li><p>若无法登录请使用API: yoursite.com/pub/fix?token={$APIKEY}</p></li><li><p>保留数据库配置的环境变量并重新 Fork 仓库部署</p></li><li><p>重新部署整个程序</p></li><li><p>尝试 Dev 分支</p></li></ol><h4 id="AssertionError-“xxx-object-…-its-id-attribute-is-set-to-None-”"><a href="#AssertionError-“xxx-object-…-its-id-attribute-is-set-to-None-”" class="headerlink" title="AssertionError(“xxx object … its id attribute is set to None.”)"></a>AssertionError(“xxx object … its id attribute is set to None.”)</h4><p>请检查你是否曾使用过 0.01 或 0.1 版本，这两个版本有严重问题，请重新创建数据库并部署。</p><h4 id="Github-配置校验错误"><a href="#Github-配置校验错误" class="headerlink" title="Github 配置校验错误"></a>Github 配置校验错误</h4><p>如果配置中遇到问题，可以访问 HPP校验助手 自检配置，若确认无误，可检查仓库内是否有已经发布的文章。</p><p>注意：Github 仓库一定为您 Hexo <strong>自动化部署</strong> 所在的仓库。</p><h4 id="Vercel-用量问题"><a href="#Vercel-用量问题" class="headerlink" title="Vercel 用量问题"></a>Vercel 用量问题</h4><p>Vercel 的无服务器函数用量对于 Qexo 来说是充裕的，但这依然抵挡不住有心之人的攻击行为，所以要保护好自己后台地址，不过好在 Vercel 不会随意扣费，所以在资源用完之后并不会产生费用，若依然不放心可以考虑部署在自己的服务器上。</p><h4 id="在线更新失败了"><a href="#在线更新失败了" class="headerlink" title="在线更新失败了"></a>在线更新失败了</h4><p>检查高级设置中的 <code>VERCEL_TOKEN</code> 和 <code>PROJECT_ID</code> 是否正确为 Qexo 的部署项目。</p><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>如果还有问题，可以发 <a href="https://github.com/Qexo/Qexo/issues">issue</a> 或加入 <a href="https://jq.qq.com/?_wv=1027&amp;k=rAcnhzqK">HexoPlusPlus交流群</a> 询问。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG10/wiBavp.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/BLOG10/kebpM6.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在博客自动化的基础上加入 Qexo：一个快速、强大、漂亮的在线 Hexo 编辑器。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建 (Blog Building)" scheme="https://yousazoe.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Blog-Building/"/>
    
    
    <category term="Blog" scheme="https://yousazoe.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Github Action自动化部署Hexo</title>
    <link href="https://yousazoe.top/archives/ae288086.html"/>
    <id>https://yousazoe.top/archives/ae288086.html</id>
    <published>2022-06-02T10:23:01.000Z</published>
    <updated>2022-07-29T03:00:04.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/hrLdxQ.jpg)--><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG9/xJkKWK.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>为了方便可以使用 GitHub Actions 实现博客自动发布，将静态博客页面部署到多个服务器上，比如 GitHub Pages，Gitee pages 以及云服务器上。本文介绍使用 GitHub Actions 实现将 Hexo 博客自动编译并发布到 GitHub Pages 上。</p><span id="more"></span><h3 id="SSH-秘钥"><a href="#SSH-秘钥" class="headerlink" title="SSH 秘钥"></a>SSH 秘钥</h3><p>生成秘钥用于仓库间的推送：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -f hexo-deploy-key -t rsa -C "youremail@something.com"</span><br></pre></td></tr></tbody></table></figure><p>以上命令会在当前路径下生成：秘钥 <code>hexo-deploy-key</code> 和公钥 <code>hexo-deploy-key.pub</code>，然后分别添加到对应的文件中。</p><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/uyWREQ.png)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG9/0uxZvn.jpg"></p><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/lWgKmq.png)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/BLOG9/uHOmky.jpg"></p><ul><li><p>页面文件仓库（即 <a href="https://yousazoe.top/">yousazoe.github.io</a>）: 在 <code>Settings &gt; Deploy keys</code> 中添加 <code>Deploy key</code>，内容为 <code>hexo-deploy-key.pub</code> 文件内容，同时勾选 <code>Allow write access</code> 选项</p></li><li><p>博客源文件库：在 <code>Settings &gt; Secrets</code> 中添加一个 Secret，名称为 <code>DEPLOY_KEY</code>，内容为 <code>hexo-deploy-key</code> 文件内容。后续在 Workflow 中通过名称 <code>DEPLOY_KEY</code> 使用这个密钥</p></li></ul><h3 id="Workflow-配置"><a href="#Workflow-配置" class="headerlink" title="Workflow 配置"></a>Workflow 配置</h3><p>在博客源文件库中新建文件 <code>.github/workflows/deploy.yml</code>，配置内容如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># This is a basic workflow to help you get started with Actions</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Blog</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Controls when the workflow will run</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># Triggers the workflow on push or pull request events but only for the main branch</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Allows you to run this workflow manually from the Actions tab</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># This workflow contains a single job called "build"</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="comment"># The type of runner that the job will run on</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Steps represent a sequence of tasks that will be executed as part of the job</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Runs a set of commands using the runners shell</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">'14'</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Npm</span> <span class="string">Install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Key</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_KEY:</span> <span class="string">${{</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">}}</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh</span></span><br><span class="line"><span class="string">          echo "$DEPLOY_KEY" &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.email "yourname@mail.com"</span></span><br><span class="line"><span class="string">          git config --global user.name "yourname"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate</span></span><br><span class="line"><span class="string">          gulp</span></span><br><span class="line"><span class="string">          hexo deploy</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Webhook-部署"><a href="#Webhook-部署" class="headerlink" title="Webhook 部署"></a>Webhook 部署</h3><ol><li><strong>Copy the Deploy Webhook URL.</strong></li></ol><p>You can find your site’s deploy Webhook under the “Settings” tab.</p><p><img data-src="https://www.21cloudbox.com/assets/deploy-webhook.png"></p><ol start="2"><li><strong>Paste the Deploy Webhook URL on “Payload URL” in your Github</strong></li></ol><p>Github &gt; Settings &gt; Webhooks &gt; “Payload URL”</p><p><img data-src="https://www.21cloudbox.com/assets/automatic-github-deployment-21yunbox.png"></p><ol start="3"><li><strong>Click “Add webhook”</strong></li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p><a href="https://printempw.github.io/use-github-actions-to-deploy-hexo-blog">使用GitHub Actions自动部署Hexo博客</a></p></li><li><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions">利用Github Actions自动部署Hexo博客</a></p></li><li><p><a href="https://frostming.com/2020/04-26/github-actions-deploy">使用GitHub Actions实现博客自动化部署</a></p></li><li><p><a href="https://blog.yrpang.com/posts/43978">使用shell脚本判断git状态</a></p></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/hrLdxQ.jpg)--&gt;
&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/BLOG9/xJkKWK.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;为了方便可以使用 GitHub Actions 实现博客自动发布，将静态博客页面部署到多个服务器上，比如 GitHub Pages，Gitee pages 以及云服务器上。本文介绍使用 GitHub Actions 实现将 Hexo 博客自动编译并发布到 GitHub Pages 上。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建 (Blog Building)" scheme="https://yousazoe.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Blog-Building/"/>
    
    
    <category term="Blog" scheme="https://yousazoe.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101-SUM</title>
    <link href="https://yousazoe.top/archives/692c2b09.html"/>
    <id>https://yousazoe.top/archives/692c2b09.html</id>
    <published>2022-05-30T03:55:26.000Z</published>
    <updated>2022-07-29T03:00:04.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/FT8rVmPVsAM_EJI.jpeg)--><html><head></head><body><p><a href="https://twitter.com/GhostDiegog/status/1530990215912796161"><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/L2LQex.jpg"></a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近打算重新温习一下 GAMES101 现代计算机图形学入门的课程内容，做一个总结与梳理比较重要的内容以便快速复习。</p><span id="more"></span><h3 id="Review-of-Linear-Algebra"><a href="#Review-of-Linear-Algebra" class="headerlink" title="Review of Linear Algebra"></a>Review of Linear Algebra</h3><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/Mv2YML.jpg"></p><h5 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/rsPhz6.jpg"></p><h5 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/Eq2asZ.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/WQA9js.jpg"></p><h5 id="Multiplication"><a href="#Multiplication" class="headerlink" title="Multiplication"></a>Multiplication</h5><h6 id="Dot-Product"><a href="#Dot-Product" class="headerlink" title="Dot Product"></a>Dot Product</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/H5ZZNT.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/M55P3m.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/F8m0gA.jpg"></p><br><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/JzARQV.jpg"></p><p>通过判断点乘的正负判断两个方向向量有多么接近：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">dotProduct &gt; <span class="number">0</span> ? forward: backward;</span><br></pre></td></tr></tbody></table></figure><h6 id="Cross-Product"><a href="#Cross-Product" class="headerlink" title="Cross Product"></a>Cross Product</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/UfjH0c.jpg"></p><p>叉乘向量的方向用右手螺旋定则判断，类似于大拇指点赞。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/VBr8px.jpg"></p><p>叉乘没有交换律，但分配律和结合律依然存在。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/aVaSnz.jpg"></p><br><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/jO9mVD.jpg"></p><p>叉积有两个作用：</p><ul><li><p>判定左右（不经过逆/顺时针旋转保持方向一致）</p></li><li><p>判定内外（叉乘符号保持一致）</p></li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/UkWAJ3.jpg"></p><h4 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h4><h5 id="Matrix-Matrix-Multiplication"><a href="#Matrix-Matrix-Multiplication" class="headerlink" title="Matrix-Matrix Multiplication"></a>Matrix-Matrix Multiplication</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/sFS3hi.jpg"></p><p>矩阵间的乘法规则为”前行乘后列”，算第几行第几列就去找左矩阵第几行和右矩阵第几列。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/KLYfOd.jpg"></p><p>矩阵间的乘法不满足交换律，但满足结合律和分配律。</p><h5 id="Transpose"><a href="#Transpose" class="headerlink" title="Transpose"></a>Transpose</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/EDUkgN.jpg"></p><p>矩阵转置就是把行列互换。</p><h5 id="Identity-Matrix"><a href="#Identity-Matrix" class="headerlink" title="Identity Matrix"></a>Identity Matrix</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/tcJP74.jpg"></p><p>只有对角线上有非零元素的矩阵被称为对角阵，单位矩阵则都为 1。矩阵与矩阵的逆相乘得到单位矩阵。</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><h4 id="2D-Transformation"><a href="#2D-Transformation" class="headerlink" title="2D Transformation"></a>2D Transformation</h4><h5 id="Scale-Matrix"><a href="#Scale-Matrix" class="headerlink" title="Scale Matrix"></a>Scale Matrix</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/QW5mmD.jpg"></p><h5 id="Reflection-Matrix"><a href="#Reflection-Matrix" class="headerlink" title="Reflection Matrix"></a>Reflection Matrix</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/khqZ8p.jpg"></p><h5 id="Shear-Matrix"><a href="#Shear-Matrix" class="headerlink" title="Shear Matrix"></a>Shear Matrix</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/FqUQm0.jpg"></p><p>水平方向的切变。</p><h5 id="Rotate-Matrix"><a href="#Rotate-Matrix" class="headerlink" title="Rotate Matrix"></a>Rotate Matrix</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/x32EbY.jpg"></p><p>旋转默认原点为中心逆时针方向，推导过程如下：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/owFh61.jpg"></p><h5 id="Homogenous-Coordinates"><a href="#Homogenous-Coordinates" class="headerlink" title="Homogenous Coordinates"></a>Homogenous Coordinates</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/hhC3la.jpg"></p><p>齐次坐标服务于平移变换，把二维的点增加一个纬度变成齐次坐标，所有变换形式上简化为一个矩阵乘以一个向量。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/YDMxaH.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/vtxLT9.jpg"></p><h5 id="2D-Transformation-1"><a href="#2D-Transformation-1" class="headerlink" title="2D Transformation"></a>2D Transformation</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/oiBuyw.jpg"></p><h5 id="Inverse-Transformation"><a href="#Inverse-Transformation" class="headerlink" title="Inverse Transformation"></a>Inverse Transformation</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/wwgGZt.jpg"></p><h5 id="Composing-Transforms"><a href="#Composing-Transforms" class="headerlink" title="Composing Transforms"></a>Composing Transforms</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/a1wpge.jpg"></p><p>变换顺序从右到左非常重要，可以视作交换律的不可用。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/y9Ehqx.jpg"></p><p>旋转时的中心点始终为原点，所以保证旋转时物体在原点，之后再做其他的变换操作。</p><h4 id="3D-Transform"><a href="#3D-Transform" class="headerlink" title="3D Transform"></a>3D Transform</h4><h5 id="Scale-amp-Translation"><a href="#Scale-amp-Translation" class="headerlink" title="Scale &amp; Translation"></a>Scale &amp; Translation</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/wA2t3n.jpg"></p><h5 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/tRdvON.jpg"></p><p>$Z x X = Y$</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/PSicRD.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/a9Xb48.jpg"></p><p>推导过程如下：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/UyCaw5.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/g8fDJB.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/BLyVmM.jpg"></p><iframe src="//player.bilibili.com/player.html?aid=511277281&amp;bvid=BV1Eu411r7GC&amp;cid=711633371&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="Viewing-Transform"><a href="#Viewing-Transform" class="headerlink" title="Viewing Transform"></a>Viewing Transform</h4><h5 id="View-x2F-Camera-Transform"><a href="#View-x2F-Camera-Transform" class="headerlink" title="View/Camera Transform"></a>View/Camera Transform</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/yt271p.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/y0xS1A.jpg"></p><p>相机身处原点，法向为 Y，朝向为 -Z 的标准位置。</p><h6 id="Model-Transform"><a href="#Model-Transform" class="headerlink" title="Model Transform"></a>Model Transform</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/6MnpzN.jpg"></p><p>视图矩阵需要先平移至原点，然后一次旋转到标准轴。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/sR9NiU.jpg"></p><p>齐次坐标先做平移后做旋转。</p><p>虽然任意轴旋转到标准轴很难推导，但是这个逆过程标准轴旋转到任意方向还算简单，又因为旋转矩阵的逆矩阵与转置矩阵相等最后可以推导出来。</p><h5 id="Projection-Transform"><a href="#Projection-Transform" class="headerlink" title="Projection Transform"></a>Projection Transform</h5><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/tb8cqJ.jpg"></p><p>透视投影(P)会有近大远小的现象，而正交投影(O)没有。</p><h6 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection"></a>Orthographic Projection</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/cOBpT0.jpg"></p><ul><li>相机从原点看向 -Z 方向，头顶朝向 Y 方向</li><li>扔掉 Z 轴</li><li>缩放变换 X、Y 至 [-1, 1]</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/7pBgEn.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/6SwU7k.jpg"></p><p>首先把立方体中心从负方向移到原点，然后再做一个缩放把长度变为 2。</p><h6 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h6><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/jJ5mwt.jpg"></p><p>透视投影可以拆分为两步：首先将 Frustum 挤成 Cuboid；然后直接用正交投影。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/UGHCMa.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/dkSMJM.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/9PsBuK.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/rn0dWQ.jpg"></p><p>使用 (0，0，n) 和 (0，0，f) 两个特殊点代入，就可以得出最终的矩阵</p><h4 id="Viewport-Transform"><a href="#Viewport-Transform" class="headerlink" title="Viewport Transform"></a>Viewport Transform</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/dbvGnd.jpg"></p><ul><li>长宽比：<strong>aspect ratio</strong></li><li>垂直可视角度：fovY(<strong>field-of-view</strong>)</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/RZTAcY.jpg"></p><h3 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h3><h4 id="Screen-Space"><a href="#Screen-Space" class="headerlink" title="Screen Space"></a>Screen Space</h4><ul><li>像素 (x, y) 的中心为 (x + 0.5, y + 0.5)。</li><li>以左下角为原点，屏幕的像素空间从 (0, 0) 到 (width - 1, height - 1)。</li></ul><h3 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h3><h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><h3 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h3></body></html>]]></content>
    
    
    <summary type="html">&lt;!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/FT8rVmPVsAM_EJI.jpeg)--&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/GhostDiegog/status/1530990215912796161&quot;&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/GAMES101-SUM/L2LQex.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;最近打算重新温习一下 GAMES101 现代计算机图形学入门的课程内容，做一个总结与梳理比较重要的内容以便快速复习。&lt;/p&gt;</summary>
    
    
    
    <category term="现代图形学入门 (GAMES101-Introduction to Computer Graphics)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-GAMES101-Introduction-to-Computer-Graphics/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>悲惨歌喉下的隐喻--Love, Death &amp; Robots Season 3</title>
    <link href="https://yousazoe.top/archives/3a2065a8.html"/>
    <id>https://yousazoe.top/archives/3a2065a8.html</id>
    <published>2022-05-23T12:27:55.000Z</published>
    <updated>2022-07-29T03:00:04.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10.webp)--><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/kPlPgz.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>艾美奖获奖动画选集《爱、死亡 &amp; 机器人》第三部回归，恐怖、想象力和美在新剧集中完美融合，从揭示古老的邪恶力量到喜剧般的末日，剧集以标志性的巧思和创造性的视觉效果，为观众带来令人震惊的奇幻、恐怖和科幻短篇故事。</p><span id="more"></span><h3 id="三个机器人：退场策略"><a href="#三个机器人：退场策略" class="headerlink" title="三个机器人：退场策略"></a>三个机器人：退场策略</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-1.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/qDsA3p.jpg"></p><h4 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h4><p>延续第一季《三个机器人》，三个机器人来到地球，深入调查末日后人类的情形，以洞悉初生机器人文化了解生存之道，可以确认的是他们眼前的地方人类都死亡，但透过满是枪枝的迹象，推理很多人类以为摆脱政府补助的医疗服务，有足够的子弹和鹿肉干就能建立乌托邦社会，人类将鹿灭杀殆尽，比猫大的动物无一幸免，然后突袭彼此此营地，他们瞄准窗外，不是因为鹿来寻仇，而是彼此杀戮。但利用这种野蛮方式而建立起的乌托邦只有穷人，因为缺乏经济和社会优势的人选择比较少，有钱人则是有复杂的生存策略，但尽管创造有主权的国度，还是免不了死亡，当中最主要是因为这里住的科技富豪被机器人给起义。</p><p>至于领袖们则是躲在深山堡垒等待外面混乱过去，虽然有系统维持农业食物，但因为被一种霉菌破坏，所以没食物后开始实施所谓的「极端主义」然后投票下个要被吃的人。例外还有 0.01% 的有钱人，他们有钱到可以直奔火星，宁愿花钱去火星也不要离在地球拯救家园，当中三个机器人他们发现一个发射的火星，很疑惑到底是谁移民火星，事实上人类没有抵达火星，反倒是一批猫殖民了火星。</p><h4 id="影评"><a href="#影评" class="headerlink" title="影评"></a>影评</h4><p>人类的灭绝是自己而来？从机器人的分析可以知道人类想要逃离政府束缚而建立的乌托邦，最主要是分成有钱人和穷人不同社会阶级的生存策略，但是我们从剧情中也能知道，穷人和有钱人的策略差异，<strong>带来的事实上都是相同的结果</strong>。我觉得地球会有文明末日是人类自己造成的，食物总有一天会殆尽，不管是鹿肉还是海上的海鲜，都会阻碍他们生存（就例如海洋过度捕捞和食物链塑胶微粒，都是在讽刺人类自食其果和人口过剩）。</p><p>这回归到地球文明灭绝而来？我想就是人类从开始在地球上生存而渐渐累积来的，直到最后一刻渴望求生的过程中，仍然没有改变，然后就被科技给起义灭绝，因而让机器人文化崛起，这其实就是象征着人类对机器人的「奴隶」，如果人类对他们的机器人奴隶表现出善意和同情，那么机器人也许可以在帮助人类度过世界末日的过程中发挥作用。</p><p>本集中利用四种四种不一样社会阶级的人在末日时还是只能以钱和地位来决定谁最有资格留下来的差异让观众知道，不管是哪一种阶级的人，下场都一样，因为在逃命的过程争中，人类不会互助，「菁英并不同情他们的烦恼」，如果这群超级有钱的人可以直奔火星，为什么不要把手上资源留下来拯救地球？<strong>这就是象征着贪婪和自私，不将手上资源去帮助别人</strong>。然而，在最后我们看到移民火星的是穿着太空衣的猫，根本不是人类，这也证实人类为了生存而付出的努力，结果都是徒劳的。</p><p>从第一季的《三个机器人》到第三季之间，因为在第一集中向机器人展示自己的同一只说话的猫现在正在火星上喝冰牛奶，这些猫仍在使用人形太空服，这意味着它们希望对自己的真实影响保密（毕竟它都可以先开头罩喝牛奶了，绝不是为了氧气）。因此，看起来猫透过伪装成人类多年来控制了地球上的一些重要资源，猫科动物很有可能利用世界末日的混乱来巩固自己的力量，并最终成为唯一在其他文明消亡时离开地球的生物，也意味着人类太傲慢把自己当成最优势的物种。</p><h3 id="差劲旅行"><a href="#差劲旅行" class="headerlink" title="差劲旅行"></a>差劲旅行</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-2.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/gNiule.jpg"></p><h4 id="剧情-1"><a href="#剧情-1" class="headerlink" title="剧情"></a>剧情</h4><p>从前，在远方的异域海洋，水手会猎捕大杰布鲨，危险航程中船只经常消失，有人说这样的船只是遇上「差劲旅行」，一艘船只在海上被「巨型甲壳类（萨纳帕德）」攻击过后，托林被要求这艘船带它去「费登岛」，托林偷偷和萨纳帕德达成协议不能吃他，并且要求把一把钥匙吐出来，原来这是一把可以拿到枪枝的钥匙，好让他可以和船上船员交涉，让他成为这船上的掌权者，首先他先用自己的势力把这艘船上的领袖丢去喂食萨纳帕德，随后托林选择要带萨纳帕德去无人岛而不是费登岛，因为至少不会让费登岛的人民被无辜吃掉，但去无人岛也会有风险。</p><p>不过大家似乎没有共识，在不记名的投票后，托林向大家宣布自己刚刚在纸张上做了只有自己认的出来的记号，并找出投票去费登岛的懦夫，然后一枪杀掉他们，丢去喂食萨纳帕德，但他这样做只为了争取更多时间，只是托林发现萨纳帕德已经开始产卵，需要更多食物，晚上，其他船员想要偷袭拖林将他打死，却也没想到拖林早算到这一招是先躲起来，最后一一将这些人枪杀。不过唯独落下一个躲起来的船员，最后托林向他坦承自己根本没在票上做过记号，因为所有人都选择去费登岛，于是托林将最后一个船员推下萨纳帕德的食物坑。而托林欺骗萨纳帕德说费登岛已经抵达时，放火烧掉整艘船和萨纳帕德，自己则是顺利逃脱。</p><h4 id="影评-1"><a href="#影评-1" class="headerlink" title="影评"></a>影评</h4><p>这一集是由大卫芬奇执导的一集，这是我全季最喜欢的一集之一，这一集结尾以全新的视角描绘了托林的行为，给观众的内心留下双方面的思辨。最初，托林似乎在抛弃道德线，只是为了确保自己的生存而努力。然而，最后，观众得知托林知道船上的船员已经注定没有生还的机会。然而，他们的死亡可以用来避免萨纳帕德攻击费登岛的无辜居民。而且，托林是船上唯一一个无情地采取必要行动阻止怪物前往费登岛的人。最终，托林成功地带领萨纳帕德离开了费登岛并让萨纳帕德灭亡，然而，托林也是该事件的唯一幸存者，<strong>这凸显了他行为的道德模棱两可</strong>。</p><p>某种程度，托林是用他的道德行为来掩盖自己的邪恶和自私，他是真的邪恶与自私吗？我觉得也不是，他牺牲自己必须承担的罪恶感来拯救岛上的人，因此在这过程中托林必须要用尽方法来神不知鬼不觉地一一将船员杀掉好喂食萨纳帕德，这是托林的一个策略，<strong>我觉得这种策略是托林让自己少点杀掉船员罪恶感的手段</strong>，因为如果是依照刚开始抽签的方式，其他人都会陷入怜悯和不自愿，这是托林自己感受过的，所以如果用了一些自己可以自我防卫的方式杀掉这些船员，那托林也就不会有深深的罪恶感去承担这些人的性命。</p><h3 id="机器的脉动"><a href="#机器的脉动" class="headerlink" title="机器的脉动"></a>机器的脉动</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-3.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/cQgi1h.jpg"></p><h4 id="剧情-2"><a href="#剧情-2" class="headerlink" title="剧情"></a>剧情</h4><p>当星球表面的探索以灾难告终时，玛莎发现自己刚刚的执着让自己陷入困境，并且波顿还因此死亡，她不仅没有设备可以回去安全基地，甚至还与基地失联，距离最近的登陆艇也还要41公里，最惨的是她的氧气设备受损，大量氧气外泄，最后她选择利用波顿的样气设备，并拖着波顿的尸体跋涉到安全地带。玛莎因为做手受伤，于是必须使用药物让自己不痛，尽管会有会扭曲思维的副作用，或许宁愿亢奋致死也是不错的选择。</p><p>路途中，玛莎听到有人在说话，声音似乎来自于波顿，她马上直觉是自己用药的幻觉，波顿声音一路上不停地说话，眼前浮出许多人物形象，甚至是已经死去的波顿，原来这又是幻觉让她把石头看成波顿。清醒过来后感受到手臂的疼痛，再次加强药物注射，透过波顿的一连串话语，让玛莎理解到这个艾欧卫星会有大量二氧化硫是因为这是个机器，没错，是机器在透过波顿跟她说话，随之因为氧气量过低而昏迷，这昏迷中她感受到波顿抱着她走了一段路，再醒来后，她发现脚下有一处热湖的地方，这是艾欧鼓励玛莎也跳进去加入她，实体组织将被摧毁，神经组织会得以保留，结果可能是生是死，玛莎也只能赌一把，可能永生不死或这只是一场梦，最后玛莎的意识也对地球求救。</p><h4 id="影评-2"><a href="#影评-2" class="headerlink" title="影评"></a>影评</h4><p>当涉及到视觉媒体时，「音诗」（交响诗）一词被广泛使用，但诗歌是这一集的全部基础，观众会发现这一集的对话几乎都是有点难懂的内容，有时有哲学、有时有科学、有时有一般对话，最主要这一集的台词都是「艾欧」喔直讲话而来的，这一集故事非常简短，虽然叙事并不多，但视觉效果很强，情感宣泄值得一游，虽然内容不太好嗑，但的确是蛮特别的科幻故事。</p><p>剧情中玛莎有幻觉吗？玛莎是否产生幻觉可能对观众来说是主观的，<strong>先来谈谈如果这一切是玛莎自己的幻想</strong>。然而，有迹象表明玛莎与艾欧一起经历的一切都是她想像中的虚构，可能是玛莎作为临终时的一种应对机制，例如她的氧气罐在残骸中受损，虽然她能够将她的管子连接到波顿，但不能保证缺氧可能会导致幻觉。再加上波顿为了减少手臂疼痛而注射过量吗啡，被警告可能导致行动功能丧失、幻觉和兴奋，到最后玛莎跳入热湖，相信她的意识会像波顿一样通过艾欧继续存在，这可能是要季兴奋下的症状，让她在没有痛苦的情况下死去。</p><p>再来就换个角度想，<strong>如果艾欧的存在不是幻觉</strong>，艾欧有没有骗玛莎自杀？如果艾欧是真的而不是幻觉，那么艾欧就有可能诱骗玛莎加入机器。在夜间，当波顿的尸体被艾欧升起时，玛莎则是也被不知觉的状况下来到热湖的悬崖边。醒来后，玛莎迅速耗尽氧气，这导致艾欧诱骗她加入艾欧不断扩大的意识。这一则故事看起来很像是外星科技的概念，因为是在一个艾欧卫星中，他们会来探索是因为要了解这个地方，因此艾欧说自己是一个机器，这让人直觉想到艾欧的存在是外星科技的存在。</p><p>由于我们在本集结尾听到了玛莎与她的卫星通讯的声音，我们知道她至少有一部分还活着，但这看起来比较像是玛莎的意识已经被艾欧吸收了，并且听那呼叫的声音语调也已经不像是玛莎，反倒是艾欧用玛莎的意识去对外交流，因此，最终，玛莎的肉身被摧毁，但她的意识仍然存在于艾欧中，所以艾欧用玛莎的声音对地球求救，似乎也意味着想要透过玛莎声音对地球更多人吸引去这个地方，让艾欧又可以吸收更多人的意识。</p><h3 id="迷你亡灵之夜"><a href="#迷你亡灵之夜" class="headerlink" title="迷你亡灵之夜"></a>迷你亡灵之夜</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-4.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/8YCw4w.jpg"></p><h4 id="剧情-3"><a href="#剧情-3" class="headerlink" title="剧情"></a>剧情</h4><p>在一对年轻夫妇的热情交流后意外释放诅咒在墓地中的僵尸。这种情况导致墓地的尸体变成僵尸并袭击了这对夫妇，很快，这对夫妻也变成了丧尸，半死不活的生物开始迅速扩散开来。第二天早上，僵尸袭击了两名正在慢跑的妇女，这些女性还以僵尸的身份复活，并加入了越来越多的僵尸群。没过多久，丧尸的势力越来越大，开始入侵医院、社区热点、火车站、体育赛事等多个地方，丧尸几乎遍及人类文明的每一个主要和偏远地区，甚至延伸到各国。</p><p>政治领导人利用广泛的军事力量来应对僵尸的威胁，然而，所有的武器和弹药都被证明对数百万在全球的僵尸无效，僵尸袭击了一家化工厂，一群警察试图用枪挡住他们，然而，情况升级为气体泄漏，僵尸在接触化学物质后肢解，随着世界末日的临近，一种新型的喷火巨型僵尸加剧了人类的困境，然而，美国总统最后一次尝试结束僵尸大灾难，与俄罗斯一起发动所有的核武毁掉僵尸，但也毁掉自己与地球。</p><h4 id="影评-3"><a href="#影评-3" class="headerlink" title="影评"></a>影评</h4><p>这一集还蛮有趣的，从少数僵尸到成群结队，再到巨大的变异变异体，不死族军队将人类推向了毁灭的边缘，迫使俄罗斯和美国将其所有核武库释放到地球上，<strong>人类在地球上的灭亡方式终究是宇宙风中的一个屁，显示地球在整个宇宙中渺小到毫不起眼</strong>。美国和俄罗斯为什么要使用核武？白宫是地球上被丧尸攻击的最后地点之一，但最终被占领，在恐慌的状态下，总统决定使用美国的核武对付丧尸，然而，发射核武器会迫使俄罗斯在这个迷你世界中发射核武器进行报复（这是政治的嘲讽），人类没有希望，核武器将摧毁几乎所有的东西，包括僵尸，但也包含地球与人类自己。</p><p>整集强调了对抗僵尸末日的徒劳，这一集叙事本身的直截了当嘲弄了僵尸类型的非原创性，毕竟丧尸末日这种题材很常见，这一集叙事手法并没有费心去充实人物，反倒是用迷你世界来呈现，在镜头的带动下观众会发现我们都是从上帝视角去观看，因此镜头被拉得远呈现视觉效果，仿佛巧妙地让观众在看事情更为宏观一些。</p><p>这一集的结局是毁灭性的核爆炸，然而，这一场景是从外太空呈现的，这减少了看似破坏性事件的影响，就如前面所提到的，<strong>人类在地球上的灭亡方式终究是宇宙风中的一个屁</strong>，僵尸不是带来末日的主要族群，反倒是人类发射了无数的核弹让地球与人类毁灭，这一集的形式呈现了最可爱，虽是本季最短的电影，但考虑到其轻快、画面般的结构和呈现方式，非常适合它，也很容易让观众记得。</p><h3 id="杀戮小队开杀"><a href="#杀戮小队开杀" class="headerlink" title="杀戮小队开杀"></a>杀戮小队开杀</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-5.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/cAjiAm.jpg"></p><h4 id="剧情-4"><a href="#剧情-4" class="headerlink" title="剧情"></a>剧情</h4><p>一群美国精英特种部队来到指定地点出任务，当中一个小队全军覆没，大家争论这是什么样的恐怖攻击时，突然凶手马上出现，竟然是一只基金改造过的熊，这只熊不仅刀枪不入，动作还很敏捷，在失去两名弟兄之时，一阵电频响起音频让它逃之夭夭，原来是莫里斯上士，并且还知道这只熊的来历是被地下研究出来的，代号叫「犬魔计画」，是昨天和他的小队出来巡逻时失控。莫里斯带着大家来到基地时，发现这里的人全被杀死，于是他们打算准备武器去跟「犬魔」对战，而当中出现了一个小小助手机器人朋友也来助阵。</p><p>只是一遇到犬魔出现，人类还是招架不住，反倒是机器人朋友勇敢奋战，眼看无处可去，他们只好用手上的武器疯狂射击犬魔，最终一颗大火箭射向犬魔的心脏，终于让犬魔分尸，但在佛伦交代完搞笑的遗言时，犬魔的身体掉出一颗炸弹，将这基地炸毁，因此最后无人幸存。</p><h4 id="影评-4"><a href="#影评-4" class="headerlink" title="影评"></a>影评</h4><p>这是我觉得看完比较无感的一集，有趣的是，由于基因改造灰熊是中央情报局的产物，是用来想要歼灭圣战士的产物，但士兵们基本上是被一个旨在「帮助他们」的实体杀死的，这也讽刺地诉说着，制造出来的怪物也不一定会帮助自己，反倒会害了自己，就像是现世报一样，想要害人之心本来就不可有，创造出来的暴力总有一天都会反噬到自己身上。</p><h3 id="虫群"><a href="#虫群" class="headerlink" title="虫群"></a>虫群</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-6.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/yZ6Uys.jpg"></p><h4 id="剧情-5"><a href="#剧情-5" class="headerlink" title="剧情"></a>剧情</h4><p>艾佛亚博士在外星中与外星生物做交流，最主要他是在这里研究「虫群」，这是外星生物无法理解他的目的，只觉得虫群不过是组织良好的动物而已，艾佛亚博士声称人类就是该找机会学习更多事物，艾佛亚博士进入了奇怪的生态系统。在里面，他遇到了另一个人，嘉琳娜，她多年来一直在研究虫群及其生物，虽然居住在虫群中的生物是无意识的寄生虫，但它们对被称为「女王」的巢穴思维做出了回应。</p><p>随着时间的推移，艾佛亚博士将他的目标定为研究嘉琳娜所知道的虫群。他解释说，透过利用虫群，人类可以培育出一个奴隶种族，可以用来增加人类在太空中的扩张。此外，从虫群中的外星人进化而来的新外星物种将成为人类追求的熟练士兵，并为混乱的人类时期带来稳定。尽管嘉琳娜对艾佛亚博士的计划持怀疑态度，但她同意帮助他，条件是不伤害虫群。嘉琳娜教艾佛亚博士如何用合成的费洛蒙控制类似机器体的外星虫，两人还试图取回一个女王的蛋。然而，虫群向人类释放了它的真实本性，导致两个有情物种之间发生了一场史诗般的对抗。</p><p>最后时刻，艾佛亚博士遭到武士虫种族的袭击，他为自己的生命而战，但许多虫给淹没，外星虫打败了艾佛亚博士并将他带到了巢穴中心，在那里他遇到了虫群的一个有知觉的分支。智能生命形式使用嘉林娜作为傀儡并与艾佛亚博士交谈。智能生物解释说，艾佛亚博士和嘉琳娜的行为触发了群体中的特定基因程序，从而导致了群体的产生，虫群感知到了人类构成的威胁，并创造了智能生物来应对外来威胁。智能虫群侮辱人类作为低等生物，并评论他们的智慧将导致他们的死亡，甚至说通过繁殖厉害的物种对付外来侵入，现在智能虫群打算要利用艾佛亚来繁殖人类成为寄生虫，但艾佛亚愿意跟她打赌，坚持认为人类绝对不会成为寄生虫。</p><h4 id="影评-5"><a href="#影评-5" class="headerlink" title="影评"></a>影评</h4><p>这一集是以布鲁斯斯特林1982 年广受好评的短篇小说《蜂群》为故事，这一集拥有本季所有短片中最逼真的人类动画。首先，艾佛亚博士来研究虫群的目的是为了要将这个有秩序的系统带回到人类的系统重新建立（需要虫卵带回去培育一个新虫群生态，让人类再次拥有权力的控制），因为人类扩张形成混乱，所以有妳股利量驾驭。嘉琳娜有说「那是剥削」，虫群之所以会和谐，我想是因为食物充足，没有斗争、没有不公平。因此看到艾佛亚博士与嘉琳娜在谈论要把这套系统给带回去人类世界时，嘉琳娜用了两种形容词「剥削」「傲慢」，这象征着刚来到这里的艾佛亚博士身上带着人类的气息，与这里的虫群生态相比，问题不在于系统，而是出自于人类自己，而艾佛亚博士来这里取虫卵为的是繁衍一个重生态，繁殖奴隶。</p><p>艾佛亚这样的举动<strong>是想要让人类可以优越化</strong>，当艾佛亚博士说「等你们毁灭人类之前，说不定….」，智能虫群反驳说到「你们很有可能会自我毁灭，智慧不是有利生存的特质」，这有点是在讽刺人类因为太过聪明所以会有很多小动作想要去掠夺其他资源或是占有，而且这种行为还会在人类之间存在，呼应到艾佛亚来这里说到人类扩张处于困乱的状态， 相较之下，虫群的存在就很单纯，也很好控制。</p><p>这一集的最后以探讨生物族群的「智慧」，虫群为艾佛亚博士提供了一个选择，艾佛亚即自愿让智能虫群繁殖人类，并且观看悲剧事件发生，但将其视为一项挑战，<strong>因为他内心其实还是认为人类是优越的种族</strong>。然而，这一集的结尾很有趣，因为智慧虫群说「我很高兴不需要吸收你，否则会想念彼此的谈话」，这智慧重群的言论与本集一开始时外星人和艾佛亚博士的情绪相呼应。因此，结局意味着艾佛亚博士其实是被外星人给设局进来这里的，因此看到这里，人类还是觉得自己是优越的智慧种族吗？我想虫群好像更胜一筹。</p><h3 id="梅森的老鼠"><a href="#梅森的老鼠" class="headerlink" title="梅森的老鼠"></a>梅森的老鼠</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-7.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/dNXPVf.jpg"></p><h4 id="剧情-6"><a href="#剧情-6" class="headerlink" title="剧情"></a>剧情</h4><p>农夫梅森实在受不了鼠患，于是拿着猎枪准备去跟老鼠大开杀戒，却没想到老鼠会拿武器反击，吓得梅森农夫找来陷阱科技公司来解决老鼠问题，他才不管这是不是人类造成的动物进化论，他只想要灭鼠器，于是推销员介绍一款TT6脉冲雷射灭鼠器，农夫不情愿地付了钱。再一次，看起来相当先进和足智多谋的老鼠们迅速战胜了灭鼠科技。于是，梅森购买了更先进防御系统（TT15机种），至此，农夫的谷仓已经变成了名副其实的战区，最后，梅森决定走进他的谷仓看看发生了什么事，他对里面发生的史诗般的残酷战斗感到震惊，老鼠们使用许多武器进行英勇的反攻，甚至还有简陋的坦克。最后，他们成功地破坏了TT15，但被斩首的机器继续试图杀死老鼠，梅森走到损坏的灭鼠机器前，用他的猎枪结束了这灭鼠器。为了表示感谢，老鼠们向农民提供了一杯饮料，这一集以和解的方式结束，梅森和老鼠们敬酒。</p><h4 id="影评-6"><a href="#影评-6" class="headerlink" title="影评"></a>影评</h4><p>「人类正在改造换整个环境，迫使动物们为了适应而做出改变等等之类的行为」隐喻这格世界中人类破坏了许多的生态，让有些物种为了生存只好和人类抢夺地盘和生存资源， 因而引发物种会和人类对战的情形，<strong>我想这是象征着大自然会反扑的概念</strong>，会有物种间的暴力对抗就在于人类破坏了之间的平衡。</p><p>另外，这个故事很细腻，也是我最喜欢的故事之一，梅森农夫最后出人意料地杀死了自己的机器TT15，<strong>即便农夫是很想要摆脱老鼠的威胁，但梅森似乎对TT15 所采取的野蛮暴力行为感到厌烦</strong>。在多个情况下，机器在杀死老鼠的同时很残忍，这让梅森非常反感，我想最终获胜的是「同理心」。机器对它的受害者毫无感觉并继续它的横冲直撞，但农夫，看到老鼠在不利的情况下激烈地战斗，开始为他们感到怜悯。梅森意识到TT15 造成的伤害比老鼠要大得多，在看到老鼠在「战场」上的英勇壮举后，<strong>他也获得了一些尊重</strong>。最后，梅森和老鼠，彼此之间的共同点比与机器的共同点要多。</p><p>这个故事其实也透露出<strong>这个世界间的暴力不停存在，因为彼此没有同理心和停下脚步去看</strong>，所以在梅森农夫跑去谷仓看到老鼠和机器人大战的时候，说到「这里就像第四次世界大战」，为什么不是说「第三次世界大战」？这是有用意的，因为这在很大程度上暗示现实生活中的人类可能会再次开战一次，或者可能两次，进一步暗示的世界大战的发生将是有道理的，为什么一家简单的害虫防治公司可以使用这种高科技武器，人类许多最伟大的技术进步都来自战争时期，再加上老鼠和其他动物变得越来越聪明，<strong>因此除虫公司需要变得更具创造性和破坏性，就因为彼此越来越暴力，武器越来越冲击，伤害到的就只有彼此，杀戮最终也会无止尽</strong>，因此农夫的举动也在暗示这个世界不需要战争，只需要彼此的同理心。</p><h3 id="隧道墓穴"><a href="#隧道墓穴" class="headerlink" title="隧道墓穴"></a>隧道墓穴</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-8.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/OeuL7B.jpg"></p><h4 id="剧情-7"><a href="#剧情-7" class="headerlink" title="剧情"></a>剧情</h4><p>一群特种部队去到一个隧道要营救人质，在暗不见天日的隧道里，他们发现奇怪的发光体类苔藓东西，也发现人质的尸体，但脸整个不见，身上的肉也被被啃食光剩下骨头，他们不解释是什么武器把人弄成这样，此时远方传来声响，使他们往前一探究竟，突然一个东西从上面掉下来，他们一看之下像是一种有人脸的蜘蛛蟑螂，随后满坑满谷的蜘蛛袭击而来，他们被迫一直开枪，好不容易先逃到一个空旷地方，蜘蛛也没有再跟上来，代表这些蜘蛛是看守隧道。</p><p>至于是看守什么？就是他们身后的这座古庙，哈波认为古庙那里一条隧道应该可以通到地面，不过在半路上，人脸蜘蛛已经追上来，哈波只能眼睁睁看着史宾斯死去，他们也只剩一点点弹药，此时古庙传来声音，巨大的铁链也在拖动，定睛一看才发现这里有着被禁锢的古恶灵，当祂发出一阵电波时，让他们两个脑中浮现这千年长老神（克苏鲁）的回忆，并被洗脑要释放祂，哈波想要阻止长官，于是不得不对长官开枪。哈波看着长老神的眼睛也被洗脑，最终哈波挖掉自己双眼，走回地面。</p><h4 id="影评-7"><a href="#影评-7" class="headerlink" title="影评"></a>影评</h4><p>「上帝已死，接受眼前的困境吧」看起来这个被困住的古恶灵是一种邪神长老神，以祂的形象来看似乎是克苏鲁邪神，克苏鲁神话中的众神之所以被定位为「邪神」，是源自于洛夫克拉夫特的这段记述：「<strong>人类跟宇宙比起来毫无意义，如果真的有神的话，根本不可能帮助如此渺小的人类，除非…他们怀有恶意。</strong>」，这对照到哈波对史宾斯说的那句「上帝已死，接受眼前的困境吧」，也就隐喻出「没有会拯救人的神」这件事。</p><p>所以最后他们遇到这个克苏鲁，虽然他是神，但也应验着即便是神，根本不会帮人类，在这一集的最后，士官和哈波面对这个克苏鲁都是透过祂的眼睛被洗脑，盯着这个可怕的神祗是变成疯狂的起始，尤其是当你遇到克苏鲁的时候，虽然我们不能肯定地说士官和哈波遇到的世不是可怕的恐怖是克苏鲁，然而，被困在神庙中的神看起来很像克苏鲁，主要是因为背上巨大翅膀、和克苏鲁一样的触手和多只眼睛。</p><p>盯着克苏鲁的眼睛会让任何正常的凡人发疯，然而，也有人对克苏鲁的描绘是「<strong>克苏鲁的苦恐怖是无法言喻的，但或许真正的恐怖，其实源自于人类对未知的恐惧</strong>。」就如同士官会被洗脑一样，前面经过一连串的未知堆叠起来的恐惧，来到直接面对克苏鲁，还被克苏鲁强迫看完这牵连来的作恶，恐惧在士官内心中爆发，所以也被洗脑释放祂。至于哈波最后是不是还活着出来？是的，在最后一幕中我们可以看到哈波走在外面的世界，但眼睛挖掉，这不是被克苏鲁搞的，<strong>而是哈波选择挖掉自己的眼睛不被克苏鲁影响和洗脑，也不被搞疯，这是唯一不被影响且可以活命的机会</strong>。我想，透过挖掉眼睛这个举动来看，<strong>我们能知道我们面对外面的世界都是「看得太多、感受得太多」，所以会被洗脑和支配思想</strong>。 </p><h3 id="吉巴罗"><a href="#吉巴罗" class="headerlink" title="吉巴罗"></a>吉巴罗</h3><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10-9.jpeg)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV10/Tkd2wd.jpg"></p><h4 id="剧情-8"><a href="#剧情-8" class="headerlink" title="剧情"></a>剧情</h4><p>一群骑士护送着重要人士在树林里稍作休息，在湖边，吉巴罗偷捡了一块小金块，触动了湖中的水妖，全身黄金闪亮水妖以声音蛊惑人心并开始自相残杀，全部往湖里奔去，血染这座湖，本身是耳聋的吉巴罗不懂发生什么事，水妖对于吉巴罗完全不为所动有点疑惑但也瞬间对他迷恋，吉巴罗最后驾着马逃离，却因为太着急而撞到一棵树。吉巴罗停留在树林里，睡着之际，水妖也来到他身边，甚至搂着他睡觉。醒来，吉巴罗发现水妖身上有着许多黄金麟片，兴奋地追上去，不管多危险的地方都能想尽办法追上去。在女妖对吉巴罗摩蹭之际，吉巴罗突袭女妖，并且将她身上的金饰一一掏空，把女妖推下水，女妖随着瀑布回流到湖中血染湖水，让吉巴罗喝下后突然耳聋被治愈了，但对声音不知所措的吉巴罗反倒是师空地在树林里狂奔、自残。水中康复醒来后的女妖发现身上的黄金鳞片全被拔光，于是难过地大喊着，听得到声音的吉巴罗变得被女妖声音蛊惑，最终也最终也沉没于湖底。</p><h4 id="影评-8"><a href="#影评-8" class="headerlink" title="影评"></a>影评</h4><p>吉巴罗战友的死让他可以自由地拿走他认为合适的任何战利品，多亏了他的耳聋，这才阻止了他被女妖的声音给蛊惑，但也正因为如此，他们才对彼此产生了迷恋。然而，吉巴罗被蛊惑的契机不是因为声音，却也被眼前的金银财宝蛊惑，<strong>搭配上他所有战友都死去，没人跟他抢，因此面对眼前满是金饰的女妖来说，这会放大吉巴罗的贪欲</strong>。</p><p>女妖本身也是有欲望的，她的欲望来自于有人不会被她的声音所伤害到，所以她是不是真的有爱上吉巴罗，我想是的，这就是为什么她会主动去亲吻吉巴罗，尽管她伤害了吉巴罗，让他满嘴是血，但还是有着非常强烈的渴望，我在想这也是为什么湖底会有成千上万的男人尸体，这些或许都是女妖本身想要得到的到的爱情，想要找到那个可以不会被她声音伤害的人，只是可悲的是，吉巴罗对她的迷恋是多亏了她美丽华丽的鳞片。之后吉巴罗的下场也是很神转折，因为喝了水妖的血，所以治愈了吉巴罗的耳聋。水妖这举动是想要帮吉巴罗治愈他嘴上的伤？还是想要故意治好他的耳聋？我选择后者，因为水妖最后还是因为自己身上的黄金鳞片的消失而生气想要报复，迫使他越来越深入湖中死掉，直到他成为众多成为她猎物男人中的一员。</p><p>这一集无疑是所有故事中最具视觉创意的，介于其极其逼真的动画和画面色彩渲染，尤其是热带环境（还有爱心型的湖，象征着水妖渴望有男人可以陪伴她），以及非传统的电影风格之间，这一集采用快速快门速度、疯狂编辑和大量相机抖动来看吉巴罗在树林中的视角，有效地传达了场景的感官迷失和纯粹的陌生感。金色的女人，一个奇特但不可否认的诱人妖精，是本季迄今为止最令人印象深刻和令人难忘的CGI 表现。</p><p>原本以为《吉巴罗》会是一段爱情故事，但最终其实是一部讲述性别关系，以及殖民者的掠夺与文化入侵的作品。身上穿戴各种金银财宝的湖妖就是原住民的代表，原本她以为聋骑士是个好人、主动接近他，但没想到过没多久就显露出本性。而最终湖妖在被血色染红的湖水中所产开的反击，则是原生居民在家园遭到蹂躏后，忍无可忍地对侵略者做出的反扑。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV10.webp)--&gt;
&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MV10/kPlPgz.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;艾美奖获奖动画选集《爱、死亡 &amp;amp; 机器人》第三部回归，恐怖、想象力和美在新剧集中完美融合，从揭示古老的邪恶力量到喜剧般的末日，剧集以标志性的巧思和创造性的视觉效果，为观众带来令人震惊的奇幻、恐怖和科幻短篇故事。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>Cherno OpenGL教程</title>
    <link href="https://yousazoe.top/archives/cbd8aac2.html"/>
    <id>https://yousazoe.top/archives/cbd8aac2.html</id>
    <published>2022-05-11T15:39:16.000Z</published>
    <updated>2022-07-26T02:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/K4DxcL.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。</p><span id="more"></span><h3 id="欢迎来到OpenGL"><a href="#欢迎来到OpenGL" class="headerlink" title="欢迎来到OpenGL"></a>欢迎来到OpenGL</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=465609139&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>在这个视频中，主要包括 OpenGL 实际是什么、怎么使用它以及它能为我们做什么和它不是什么等等，这个系列也是如此。</p><h4 id="什么是OpenGL"><a href="#什么是OpenGL" class="headerlink" title="什么是OpenGL"></a>什么是OpenGL</h4><p>首先如果你听过 OpenGL 但不确定它是什么，你可能想到与图形有关的，那就是 OpenGL。OpenGL 是一种图形接口，现在 API 代表应用程序接口，基本上就是一大堆我们能够调用的函数去做一些事情。在这种情况下，由于 OpenGL 是一种图形 API，它允许我们做一些与图形相关的事情，特别的是它允许我们访问 GPU 也就是显卡，图形处理单元（Graphics Processing Unit）。</p><p>调用显卡也更好地绘制图形，所以实际上为了利用电脑或其他设备（比如手机）中强大的图形处理器，需要调用一些 API 访问固件。OpenGL 正好是允许访问和操作 GPU 的许多接口中的一种，当然我们也有一些其他的接口，比如 Direct3D、Vulcan 和 Metal 等等，所以某种角度来说 OpenGL 允许我们控制显卡。</p><h4 id="关于OpenGL误解"><a href="#关于OpenGL误解" class="headerlink" title="关于OpenGL误解"></a>关于OpenGL误解</h4><p>让我们来澄清一些人关于 OpenGL 的误解。</p><p>首先，许多人称它为一个类库或一种引擎或一些其他的框架，但这些都不是。OpenGL 核心本身只是一种规范，和 CPP 规范差不多。实际上它没有确定任何代码和类似的事情本身就是规范，比如“嘿，这个函数应该存在，需要这些参数并且返回这个值”，它只是一种你能利用这种 API 做什么规范，没有任何具体的实现，这意味它绝不是一个类库，因为 OpenGL 本身没有代码，它只是一种规范。</p><br><p>去哪儿下载 OpenGL 是另一个常见的问题。</p><p>然而，答案是你不需要真的去下载 OpenGL，它本身只是一种规范。那么，谁去实现它呢，谁去为你调用的 OpenGL 函数写代码呢？这个答案是 GPU 制造商，所以如果你使用的是 NVIDIA 显卡，那么你的显卡驱动（也就是 NVIDIA 驱动）实际上包含了 OpenGL 的实现，每个显卡制造商比如 AMD、Intel 等都会有它们自己的实现，每家关于 OpenGL 的实现都会有些不同，这也就是有些游戏能在 NVIDIA 驱动的显卡上运行但在一个 AMD 电视或者其他显卡设备上运行有些区别、甚至会出现问题的原因。</p><p>但不管怎么说，关键在于你的显卡制造商实现的 OpenGL，这又可能导致下一个有关 OpenGL 常见的误解：它是开源的。我不知道人们为什么会这么觉得，也许是名字中带着“Open”，但是它根本不是开源的，你看不到 OpenGL 的源码，因为首先它是由 GPU 制造商实现的，它们肯定不会发布它们的驱动源码。</p><br><p>OpenGL 提供了什么能激发和导致许多人不幸地说 OpenGL 是无与伦比的？原因在于它是跨平台的，所以你的 OpenGL 代码可以在 Windows、Mac、Linux 和 Android 上正常执行，以至于人们立马就会意识到 OpenGL 比 Direct3D 更优越，因为它能在所有平台上运行，但是请不要这么说。</p><p>从我 EA 技术中心并处理过许多引擎中图形接口的经验来看，因为 OpenGL 是跨平台的 API，而制作一款游戏不会只涉及实现一个独立的图形 API。如果游戏引擎是跨平台的，那意味着它不仅实现了 Xbox，也包括其他一些平台，它们不得不实现大量其他的图形接口。</p><p>因此，我们面临的问题是图形 API 是为特定平台设计的。例如 Direct3D 是微软为 Windows 设计的，它在 Windows 上的表现要比跨平台的 API 好些。现在请记住，实际编写这些代码的人不是微软，即使微软的确为了更好的代码质量和 GPU 制造商合作过。所以关于 API 的比较是没有任何意义的，因为通常平台原生的东西会更健壮更友好。</p><br><p>就 OpenGL 的复杂性而言，它可以说是现在可以学习的最简单的 API 了，所以 OpenGL 是绝对值得学习的。Vulkan 是另一个跨平台的 API，但它更底层更严谨，不适合初学者直接入门，老实说我并不想使用 Vulkan 去开发游戏，OpenGL 更加稳定。</p><h4 id="传统与现代OpenGL"><a href="#传统与现代OpenGL" class="headerlink" title="传统与现代OpenGL"></a>传统与现代OpenGL</h4><p>另外本系列学习的主要是现代 OpenGL。OpenGL 于 90 年代发布，那时的情况和现在大不相同，那时的 GPU 是可编程的，十分灵活，制造商给了程序员和开发者更多的控制权。</p><p>传统 OpenGL 和现代 OpenGL 之间最大的区别就是着色器。如果你对图形学感兴趣的话可能听说过着色器，它可能有点像 shadow 这个单词或者是光源，有些人将它和光源或其他比较。抛开这些，着色器是程序，它是在你 GPU 上运行的代码，这就是着色器，它是在你 GPU 上运行的一段程序。。</p><p>那么如果你用 C++、Java 或 C# 或不管什么语言写代码，这段代码都会运行在你的 CPU 上。但当我们开始处理图形的大部分时间里，我们想要更为精确的控制显卡运行，可能要将大部分代码从 CPU 转到 GPU 上，因为它在 GPU 上运行更快，这就是着色器存在的意义：允许我们在 GPU 上运行代码。所以可编程的着色器是最大的区别。</p><h3 id="设置OpenGL和C-中创建一个窗口"><a href="#设置OpenGL和C-中创建一个窗口" class="headerlink" title="设置OpenGL和C++中创建一个窗口"></a>设置OpenGL和C++中创建一个窗口</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=466583251&amp;page=2&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>上一节我们只说了 OpenGL 到底是什么以及这个系列实际会讲什么。今天我们的任务是让我的操作系统为我创造一个窗口，在未来我们可能会在窗口内绘制图形。</p><br><p>我们会使用一个向我提供窗口创建和窗口管理的实际代码类库，不管 Windows、Mac 还是 Linux。GLFW 就是满足上述条件的类库，我喜欢这个类库的原因是它确实是一个轻量级类库，它虽然不如 SDL 那么全面（实际上它就是个渲染器），但依然可以创建窗口、OpenGL context 以及给我们访问一些类似输入之类的基础东西。</p><h4 id="下载类库"><a href="#下载类库" class="headerlink" title="下载类库"></a>下载类库</h4><p>由于我使用的是 Mac，所以使用 brew 下载：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">brew install glew</span><br><span class="line">brew install glfw   </span><br></pre></td></tr></tbody></table></figure><p>下载后默认的路径为 <code>/usr/local/Cellar/</code>。</p><h4 id="配置CMake文件"><a href="#配置CMake文件" class="headerlink" title="配置CMake文件"></a>配置CMake文件</h4><p>我将项目名称设置为 <code>OpenGL</code>，在 CLion 中配置：</p><figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(OpenGL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add head file</span></span><br><span class="line"><span class="keyword">set</span>(GLEW_H /usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/<span class="keyword">include</span>/GL)</span><br><span class="line"><span class="keyword">set</span>(GLFW_H /usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">7</span>/<span class="keyword">include</span>/GLFW)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${GLEW_H}</span> <span class="variable">${GLFW_H}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add target link</span></span><br><span class="line"><span class="keyword">set</span>(GLEW_LINK /usr/local/Cellar/glew/<span class="number">2.2</span>.<span class="number">0</span>_1/lib/libGLEW.<span class="number">2.2</span>.dylib)</span><br><span class="line"><span class="keyword">set</span>(GLFW_LINK /usr/local/Cellar/glfw/<span class="number">3.3</span>.<span class="number">7</span>/lib/libglfw.<span class="number">3</span>.dylib)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">${OPENGL}</span> <span class="variable">${GLEW_LINK}</span> <span class="variable">${GLFW_LINK}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(OpenGL <span class="variable">${SOURCE_FILES}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (APPLE)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(OpenGL <span class="string">"-framework OpenGL"</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(OpenGL <span class="string">"-framework GLUT"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></tbody></table></figure><h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><p>复制下面内容到 <code>main.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行代码，我们会得到一个黑色的窗口。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/w5XRfu.jpg"></p><h4 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h4><p>下面我们用传统 OpenGL 设定三个顶点，绘制一个三角形：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;glew.h&gt;</span><br><span class="line">#include &lt;glfw3.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    /* Initialize the library */</span><br><span class="line">    if(!glfwInit())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    /* Create a Windowed mode and its OpenGL context */</span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);</span><br><span class="line">    if(!window)</span><br><span class="line">    {</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /* Make the window's context current */</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    /* Loop until the user closes the window */</span><br><span class="line">    while(!glfwWindowShouldClose(window))</span><br><span class="line">    {</span><br><span class="line">        /* Render here */</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="addition">+       glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="addition">+       glVertex2f(-0.5f, -0.5f);</span></span><br><span class="line"><span class="addition">+       glVertex2f( 0.0f,  0.5f);</span></span><br><span class="line"><span class="addition">+       glVertex2f( 0.5f, -0.5f);</span></span><br><span class="line"><span class="addition">+       glEnd();</span></span><br><span class="line"></span><br><span class="line">        /* Swap front and back buffers */</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        /* Poll for and events */</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/HgBwvC.jpg"></p><h3 id="在C-中使用现代OpenGL"><a href="#在C-中使用现代OpenGL" class="headerlink" title="在C++中使用现代OpenGL"></a>在C++中使用现代OpenGL</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=3&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="顶点缓冲区和在现代OpenGL中画一个三角形"><a href="#顶点缓冲区和在现代OpenGL中画一个三角形" class="headerlink" title="顶点缓冲区和在现代OpenGL中画一个三角形"></a>顶点缓冲区和在现代OpenGL中画一个三角形</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=4&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>现代 OpenGL 比那种传统 OpenGL 更具可编程性，它的扩展性更好也更加强大，你可以用它做许多事情，但代价是在绘制一个简单三角形前，我们实际上需要做很多设置。而前面我们已经用传统方法简单绘制了三角形，非常简单并且不需要什么设置。</p><p>让我们聊聊需要什么东西才可以绘制一个三角形。对于现代 OpenGL 而言，首先我们需要能够创建一个顶点缓冲区，然后还要创建一个着色器（之后可能会单独讲一下图形渲染管线是如何运行的，特别是 OpenGL）。让我们快速地说一下这两个东西是什么吧。</p><h4 id="顶点缓冲区与着色器"><a href="#顶点缓冲区与着色器" class="headerlink" title="顶点缓冲区与着色器"></a>顶点缓冲区与着色器</h4><p>顶点缓冲区基本上就是去掉 vertex，它只是一个内存缓冲区，一个内存字节数组，从字面上讲就是一块用来存字节的内存。但是顶点缓冲区又和 C++ 中像字符数组的内存缓冲区不太一样，它是 OpenG 中的内存缓冲区，这意味着它实际上在显卡显存（Video RAM）上。</p><p>所以这里的基本思路就是我要定义一些数据来表示三角形，我要把它放入显卡的 VRAM 中，然后还需要发出 DrawCall 绘制指令。实际上我们还需要告诉显卡如何读取和解释这些数据，以及如何把它放到我们屏幕上，一旦我们发出 DrawCall 指令，我们需要告诉显卡：好了，一旦你在显卡端获得了这些数据，我要你像这样把它摆出来，我希望你把它画出来在屏幕上给我显示一个三角形。所以我们需要告诉显卡怎么做，需要对显卡编程，这就是着色器，着色器只是一个运行在显卡上的程序，它是一堆我们可以编写的在显卡上以一种非常特殊的方式运行的代码。</p><br><p>听起来很复杂，但是不要想太多。简而言之我们有一个可以指定的内存，还有一些我可以指定的数据，告诉显卡：嘿，这是数据。然后从显卡那边说：好了，现在读一下这些数据并解释一下（例如屏幕上的位置），可能的话把它们连成一个三角形。这就是整件事的原理，也是 OpenGL 渲染的流程。</p><p>要注意 OpenGL 是作为一个状态机来运行的，这意味着你不必把它当作一个对象或任何类似的东西来对待，你所做的是设置一系列的状态，然后当你说一些事比如给我画一个三角形，这是非常 contextual 的。我的意思是，我不只是说，嘿，给我画一个三角形，然后传递 OpenGL 需要绘制三角形的所有东西。实际上它已经知道画三角形需要什么了，因为那是状态的一部分。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><p>让我们来创建这个顶点缓冲区来看看能做些什么。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line"><span class="built_in">glVertex2f</span>(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line"><span class="built_in">glVertex2f</span>( <span class="number">0.0f</span>,  <span class="number">0.5f</span>);</span><br><span class="line"><span class="built_in">glVertex2f</span>( <span class="number">0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></tbody></table></figure><p>这是之前使用传统 OpenGL 绘制三角形的代码。现代 OpenGL 需要创建顶点缓冲区，发送到 OpenGL 显存，然后发出一个 DrawCall 指令说：嘿，请画出我的缓冲区。</p><p>首先我们要创建自己的缓冲区，这个过程非常简单，只需要调用 <code>glGenBuffers()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/BeAao9.jpg"></p><p>第一个参数指定需要几个缓冲区；第二个参数指定返回整数的内存地址，这也是生成的缓冲区的 id。记住 OpenGL 是作为一个状态机工作，这意味着你可以生成一切，而 OpenGL 中生成所有东西都分配了一个唯一的标识符，它只是一个整数，也是你实际对象的 id，当你想要使用这个对象的时候就用这个数字。</p><p>因为我要渲染我的三角形，需要说明用哪个缓冲区来渲染三角形，只需要传递这个整数即可。现在我们有了这个 id，一旦创建缓冲区后，我们现在就要选择那个缓冲区。选择（Selecting）在 OpenGL 中被称为绑定（Binding）:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/Nby7Um.jpg"></p><p>下一步是指定数据。一个简单的方式是在声明数据的时候直接把顶点数据填充进去：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着调用 <code>glBufferData()</code> ，查阅文档：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/lRZ6V5.jpg"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/oHw927.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure><p>很好，现在我们为 OpenGL 指定了 <code>positions</code>，通常还需要创建一个索引缓冲区，也都是后话了。不过我们还没有着色器，去解释如何用这些数据进行绘制，我们将在下一期讨论那个问题。今天我们要做的只是想看看能不能把它绘制出来。</p><p>在没有索引缓冲区的情况下我们可以调用 <code>glDrawArrays()</code> 绘制指定图元：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/* Render here */</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="deletion">-glVertex2f(-0.5f, -0.5f);</span></span><br><span class="line"><span class="deletion">-glVertex2f( 0.0f,  0.5f);</span></span><br><span class="line"><span class="deletion">-glVertex2f( 0.5f, -0.5f);</span></span><br><span class="line"><span class="deletion">-glEnd();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br></pre></td></tr></tbody></table></figure><p>我喜欢用 Photoshop 打比方。如果我选择一个图层，然后在该图层上用画笔绘制一些东西，它只会影响这一图层。然而如果我没有选择任何东西或者选错了东西，它不会影响到我想绘制的那个图层。OpenGL 也是一样，在使用它之前你需要选择或绑定所有东西，因为这就是它的运行原理，它是上下文相关的，它是一个状态机。</p><h3 id="OpenGL中顶点的属性和布局"><a href="#OpenGL中顶点的属性和布局" class="headerlink" title="OpenGL中顶点的属性和布局"></a>OpenGL中顶点的属性和布局</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=5&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>上一节我们讨论了顶点缓冲区，但实际上有一些部分我们忽略了：顶点属性和着色器。今天我们将学习顶点属性。</p><h4 id="顶点属性"><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h4><p>所以什么是顶点属性？OpenGL 渲染管线的工作原理是我们为我们的显卡提供数据，我们在显卡上存储一些内存，它包含了我们想要绘制的所有数据；然后我们使用一个着色器在显卡上读取数据，并且完全显示在屏幕上。</p><p>通常我们绘制几何图元的方式就是使用一个叫顶点缓冲区的东西，也就是一个存储在显卡上的内存缓冲区，所以当对着色器编程时实际上是从读取顶点缓冲区开始的，它需要知道缓冲区的布局，这个缓冲区包含的浮点数指定了每个顶点的位置、纹理坐标、法线之类的。</p><h4 id="代码实践-1"><a href="#代码实践-1" class="headerlink" title="代码实践"></a>代码实践</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在我继续之前想先定义顶点是什么意思，因为人们在错误的使用这个词。</p><p>顶点与位置无关，顶点就是几何图形上的一个点。大多数人在视觉上对它们的明显印象是通过它的位置，所以如果我给你画一个三角形，你会看到三个顶点。但顶点不是位置，一个顶点可以不仅仅包含一个位置，顶点可以包含位置更多的数据例如纹理坐标、法线、颜色等等，它们可能都在一个顶点。所以我们需要告诉 OpenGL 外面的数据布局，调用 <code>glVertexAttribPointer()</code> 函数。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/6aOZAB.jpg"></p><ul><li><p><code>index</code>：Specifies the index of the generic vertex attribute to be modified.</p><p>基本上我们的着色器读取所有这些的方式是通过索引。一般来说如果我们有一个位置在索引 0 处，我们需要把它作为索引 0 来引用；而当我们有三种属性，我想让我的位置在下标 0，纹理坐标在索引 1，法线在索引 2.所以当我开始从着色器和显卡读取数据时，然后进入那个缓冲区，我可以简单地引用它们。这就是索引，它只是缓冲区实际属性的索引。</p></li><li><p><code>size</code>：Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant <code>GL_BGRA</code> is accepted by <code>glVertexAttribPointer</code>. The initial value is 4.</p><p>这里的 <code>size</code> 可能有点误导人，它是每个通用顶点属性的组件数，只能是 1，2，3，4。所以这个 <code>size</code> 和字节没有关系，和它们实际占用了多少内存也没关系。在本例中每个顶点的坐标有 x 和 y 两组分量，所以 <code>size</code> 为 2。</p></li><li><p><code>type</code>：Specifies the data type of each component in the array. The symbolic constants <code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>, <code>GL_UNSIGNED_SHORT</code>, <code>GL_INT</code>, and <code>GL_UNSIGNED_INT</code> are accepted by <code>glVertexAttribPointer</code> and <code>glVertexAttribIPointer</code>. Additionally <code>GL_HALF_FLOAT</code>, <code>GL_FLOAT</code>, <code>GL_DOUBLE</code>, <code>GL_FIXED</code>, <code>GL_INT_2_10_10_10_REV</code>, <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> and <code>GL_UNSIGNED_INT_10F_11F_11F_REV</code> are accepted by <code>glVertexAttribPointer</code>. <code>GL_DOUBLE</code> is also accepted by <code>glVertexAttribLPointer</code> and is the only token accepted by the <em><code>type</code></em> parameter for that function. The initial value is <code>GL_FLOAT</code>.</p><p>这里是我们指定数据类型 <code>type</code>，在本例中则是位置的浮点类型 <code>GL_FLOAT</code>。</p></li><li><p><code>normalized</code>：For <code>glVertexAttribPointer</code>, specifies whether fixed-point data values should be normalized (<code>GL_TRUE</code>) or converted directly as fixed-point values (<code>GL_FALSE</code>) when they are accessed.</p><p>标准化其实不用太担心，如果我们处理的是浮点数，因为它们已经被规范化了。假设我们要指定一个颜色字节在 0 到 255 之间，它在我们的实际着色器作为一个浮点数需要被规范化到 0 到 1 之间，这不是一个你可以在 CPU 上做的事情，但你可以让 OpenGL 替你做。</p></li><li><p><code>stride</code>：Specifies the byte offset between consecutive generic vertex attributes. If <em><code>stride</code></em> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</p><p><code>stride</code> 指针会让很多人感到困惑，如文档所示它就是连续通用顶点属性之间的字节偏移量，也可以理解为每个顶点之间的字节数。举个例子我们有位置 <code>vec3</code>、纹理坐标 <code>vec2</code> 和法线  <code>vec3</code>，那么我们的 stride 就是 3 * 4 + 2 * 4 + 3 * 4 = 32 字节，它是每个顶点的字节大小。</p><p>如果我们想从一个顶点跳到下一个顶点，我需要在缓冲区中加上 32 个字节。所以如果我们有一个指针指向缓冲区的开始，然后经过缓冲区的 32 个字节，我应该在下一个顶点的起点，这就是 stride。</p></li><li><p><code>pointer</code>:Specifies an offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the <code>GL_ARRAY_BUFFER</code> target. The initial value is 0.</p><p><code>pointer</code> 文档的表述上第一个组件的一个偏移量，它是指向实际属性的指针。不要管有多少个顶点，聚焦于一个顶点，里面包含位置、纹理坐标和法线。对于位置偏移量为 0，因为它是缓冲区的第一个字节；然后我们前进 12 个字节到达纹理坐标，所以对于我的纹理坐标属性这个值（pointer）是 12；最后再前进 8 字节得到顶点的法线，所以对于顶点法线属性 20 是这个 pointer 的值。</p></li></ul><p>最后别忘了调用 <code>glEnableVertexAttribArray()</code> 去启用 <code>glVertexAttribPointer()</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p>这两段代码告诉 OpenGL 缓冲区的布局是什么，理论上如果有一个着色器就可以看到在屏幕上看到三角形了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">            <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">             <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">             <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/yW5FoQ.jpg"></p><h3 id="OpenGL中着色器的原理"><a href="#OpenGL中着色器的原理" class="headerlink" title="OpenGL中着色器的原理"></a>OpenGL中着色器的原理</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=6&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们讨论的都是关于着色器。</p><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>每个新手脑海里的第一个问题是什么是着色器？</p><p>着色器就是一个运行在显卡上的程序代码，它是我们可以在计算机上以文本或者字符串形式编写的代码，然后我们可以把它给 OpenGL 发到显卡上像其他程序一样编译链接，最后运行它，不同的是它是在我们的显卡上运行而不是 C++ 那样在我们的 CPU 上。那么为什么我们需要程序完全在显卡上运行呢？</p><p>究其原因是我们希望能够告诉显卡该做些什么，显卡处理图形的速度要快得多，我们想要利用显卡的能力在屏幕上绘制图形。这并不意味着所有的工作必须在显卡上完成，CPU 有自己擅长的部分，也许之后我们可以将结果数据发送给显卡同时仍然在 CPU 上进行处理。</p><h4 id="着色器类型"><a href="#着色器类型" class="headerlink" title="着色器类型"></a>着色器类型</h4><p>对于大多数图形编程，我们会把重点放在两种着色器：顶点着色器和片段着色器（又称像素着色器）。</p><p>虽然还没有正式讲过标准图形渲染管线，但是我们应该对它大致是如何工作的应该了解：我们在 CPU 上写了一堆数据，向显卡发送这些数据并且发出一个叫做 DrawCall 指令的东西，也绑定了某些状态，最后我们进入了着色器阶段，GPU 实际处理 DrawCall 指令并在屏幕上绘制一些东西。这个特定的过程基本上就是渲染管道，我们如何在屏幕上从数据到结果的。</p><p>现在当显卡开始绘制三角形时，着色器就派上用场了。顶点着色器和片段着色器是渲染管线两种不同的着色器类型，所以当我们真正发出 DrawCall 指令时，顶点着色器会被调用，然后片段着色器会被调用，最后我们会在屏幕上看到结果。</p><br><h5 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h5><p>那么顶点着色器是做什么的？</p><p>它会被我们渲染的每个顶点调用，在这个例子中我们有一个三角形三个顶点，这意味着顶点着色器会被调用三次，每个顶点调用一次。顶点着色器的主要目的是告诉 OpenGL 你希望这个顶点在屏幕空间的什么位置。再强调一次，顶点着色器的主要目的是提供那些顶点的位置，如果有必要我们需要能够提供一些变换以便 OpenGL 能把这些数字转化成屏幕坐标，这样我们就能在窗口中看到我们的图形在对的位置。</p><h5 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h5><p>一旦顶点着色器运行结束，我们就进入了管道的下一个阶段：片段着色器或者像素着色器。</p><p>虽然片段和像素在术语上有点小差别，但现在你可以把像素当成片段或者把片段想象成像素，因为片段着色器会为每个需要光栅化的像素运行一次。我们的窗口基本上是由像素组成的，我们指定的那三个顶点组成我们的三角形现在需要用实际的像素填充，这就是光栅化阶段所做的。</p><p>片段着色器或像素着色器就是对三角形中需要填充的每个像素调用一次，主要决定这个像素是什么颜色，这就是它的作用，它决定了像素的输出颜色，这样像素就可以用正确的颜色着色。形象一点可以把它想象成一本涂色本，当你只有东西的轮廓时需要给它上色，这就是片段着色器的职责。</p><br><p>相比于顶点着色器，片段着色器里面的东西代价要高得多，因为它会为每个像素运行。</p><p>话虽如此，有些东西显然需要按像素计算例如光源。如果你在计算光源，每个像素都有一个颜色值，这个值是由很多东西决定：光源、环境、纹理、提供给表面的材质……所有这些一起来确定一个特定像素的正确颜色。显然这取决于一些输入，例如相机的位置在哪里，而这些所有的东西结束后你在片段着色器中的决定仅仅是单个像素的颜色，这就是片段着色器的作用。</p><h3 id="OpenGL中写一个着色器"><a href="#OpenGL中写一个着色器" class="headerlink" title="OpenGL中写一个着色器"></a>OpenGL中写一个着色器</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=7&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>让我们开始写一些着色器代码吧。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先创建一个 <code>CreateShader()</code> 创建着色器函数，传入两个着色器字符串，这些字符串都是实际的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>和创建缓冲区一致，我们需要返回一个整型作为标识符，当我们想绑定的时候可以绑定那个缓冲区 id。</p><p>所以我们要做的第一件事就是创建一个程序，基本上我们只需要输入 <code>glCreateProgram()</code>，该函数不需要传入整数引用之类的东西，它会返回一个无符号的整数（顺带一提，这里和后面不使用 OpenGL 自带类型的原因是个人处理多种类型的图形 API，更倾向于 C++ 类型）：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br></pre></td></tr></tbody></table></figure><p>接下来我们需要做的是创建我们的两个着色器对象：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br></pre></td></tr></tbody></table></figure><p>考虑到这个工作在今后的复用性，可以另创建一个函数 <code>CompileShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后可以加一个初始化函数，查找字符串中的第一个字符然后返回它的内存地址：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// const char* src = &amp;source[0];</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br></pre></td></tr></tbody></table></figure><p>最后就是调用 <code>glShaderSource()</code> 和 <code>glCompileShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到 <code>CreateShader()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个过程很像 C++编译中将两个不同的文件链接在一起，以便可以同时使用它们：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="built_in">glValidateProgram</span>(program);</span><br></pre></td></tr></tbody></table></figure><p>最后我们实际上现在可以删了我们的着色器，因为它们已经被链接到一个程序中，所以我们可以删除这些中间文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fs);</span><br></pre></td></tr></tbody></table></figure><p>最终我们的函数源码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>让我们快速做一下这个错误处理。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译着色器实际上不会返回任何东西，所以如果任何东西出错我们无法检索找出问题。但我们可以通过调用 <code>glGetShaderiv()</code> 实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br></pre></td></tr></tbody></table></figure><p>判断 <code>result</code>，检索错误信息的长度并输出信息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to complie "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="着色器编写"><a href="#着色器编写" class="headerlink" title="着色器编写"></a>着色器编写</h4><p>首先 <code>#version 330 core</code> 意味着我们将使用 GLSL（OpenGL 的着色器），其次指定位置和颜色：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line">std::string vertexShader = R"(</span><br><span class="line">    <span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">gl_Position</span> = position;</span><br><span class="line">    }</span><br><span class="line">)";</span><br><span class="line"></span><br><span class="line">std::string fragmentShader = R"(</span><br><span class="line">    <span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()</span><br><span class="line">    {</span><br><span class="line">        color = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    }</span><br><span class="line">)";</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span>(result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">" shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Window"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    };</span><br><span class="line">  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    std::string vertexShader =</span><br><span class="line">    <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"layout(location = 0) in vec4 position;\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"{\n"</span></span><br><span class="line">    <span class="string">"   glPosition = position;\n"</span></span><br><span class="line">    <span class="string">"}\n"</span>;</span><br><span class="line">  </span><br><span class="line">    std::string fragmentShader =</span><br><span class="line">    <span class="string">"#version 450 core\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"layout(location = 0) out vec4 colour;\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"{\n"</span></span><br><span class="line">    <span class="string">"   colour = vec4(1.0, 0.0, 0.0, 1.0);\n"</span></span><br><span class="line">    <span class="string">"}\n"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="整理错误"><a href="#整理错误" class="headerlink" title="整理错误"></a>整理错误</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Failed to compile vertex shader!</span><br><span class="line">ERROR: 0:1: '' :  version '330' is not supported</span><br><span class="line">ERROR: 0:1: '' : syntax error: #version</span><br><span class="line">ERROR: 0:3: 'layout' : syntax error: syntax error</span><br><span class="line"></span><br><span class="line">Failed to compile fragment shader!</span><br><span class="line">ERROR: 0:1: '' :  version '450' is not supported</span><br><span class="line">ERROR: 0:1: '' : syntax error: #version</span><br><span class="line">ERROR: 0:3: 'layout' : syntax error: syntax error</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/Kc02rp.jpg"></p><p>在 <a href="https://stackoverflow.com/questions/62990972/why-is-opengl-giving-me-the-error-error-01-version-330-is-not-support">stackoverflow</a> 有人遇到了相同的问题，解决方法如下：</p><ol><li>add these line of code in front of <code>glCreateWindow</code></li><li>add VAO as @Ali ASkari memtion above (Modern OpenGL requires a VAO be defined and bound if you are using the core profile.)</li></ol><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// GLEW</span><br><span class="line">#include &lt;glew.h&gt;</span><br><span class="line"></span><br><span class="line">// GLFW</span><br><span class="line">#include &lt;glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">static unsigned int CompileShader(unsigned int type, const std::string&amp; source)</span><br><span class="line">{</span><br><span class="line">    unsigned int id = glCreateShader(type);</span><br><span class="line">    const char* src = source.c_str();</span><br><span class="line">    glShaderSource(id, 1, &amp;src, nullptr);</span><br><span class="line">    glCompileShader(id);</span><br><span class="line"></span><br><span class="line">    // TODO: Error handling</span><br><span class="line">    int result;</span><br><span class="line">    glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    if (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        int length;</span><br><span class="line">        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line">        char* message = (char*)alloca(length * sizeof(char));</span><br><span class="line">        glGetShaderInfoLog(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "Failed to complie " &lt;&lt; (type == GL_VERTEX_SHADER ? "vertex" : "fragment") &lt;&lt; "shader!" &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        glDeleteShader(id);</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">static unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader)</span><br><span class="line">{</span><br><span class="line">    unsigned int program = glCreateProgram();</span><br><span class="line">    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    glAttachShader(program, vs);</span><br><span class="line">    glAttachShader(program, fs);</span><br><span class="line">    glLinkProgram(program);</span><br><span class="line">    glValidateProgram(program);</span><br><span class="line"></span><br><span class="line">    glDeleteShader(vs);</span><br><span class="line">    glDeleteShader(fs);</span><br><span class="line"></span><br><span class="line">    return program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    /* Initialize the library */</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">    if(!glfwInit())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span></span><br><span class="line"><span class="addition">+   glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span></span><br><span class="line"><span class="addition">+   #ifdef __APPLE__</span></span><br><span class="line"><span class="addition">+       std::cout &lt;&lt; "I'm apple machine" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+       glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line"><span class="addition">+   #endif</span></span><br><span class="line">    unsigned int width = 800;</span><br><span class="line">    unsigned int height = 600;</span><br><span class="line">    /* Create a Windowed mode and its OpenGL context */</span><br><span class="line">    window = glfwCreateWindow(width, height, "Hello World", NULL, NULL);</span><br><span class="line">    if(!window)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; " can't create window!!!" &lt;&lt; std::endl;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    unsigned int major = glfwGetWindowAttrib(window, GLFW_CONTEXT_VERSION_MAJOR);</span><br><span class="line">    unsigned int minor = glfwGetWindowAttrib(window, GLFW_CONTEXT_VERSION_MINOR);</span><br><span class="line">    std::cout &lt;&lt; "opengl shader version: " &lt;&lt; major &lt;&lt; "." &lt;&lt; minor &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    /* Make the window's context current */</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(glewInit() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    float positions[6] = {</span><br><span class="line">            -0.5f, -0.5f,</span><br><span class="line">             0.0f,  0.5f,</span><br><span class="line">             0.5f, -0.5f</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="addition">+   unsigned int VBO, VAO;</span></span><br><span class="line"><span class="addition">+   glGenBuffers(1, &amp;VBO);</span></span><br><span class="line"><span class="addition">+   glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="addition">+   glBindVertexArray(VAO);</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glEnableVertexAttribArray(0);</span><br><span class="line">    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);</span><br><span class="line"></span><br><span class="line">    std::string vertexShader = R"(</span><br><span class="line">        #version 330 core</span><br><span class="line"></span><br><span class="line">        layout(location = 0) in vec4 position;</span><br><span class="line"></span><br><span class="line">        void main()</span><br><span class="line">        {</span><br><span class="line">            gl_Position = position;</span><br><span class="line">        }</span><br><span class="line">    )";</span><br><span class="line"></span><br><span class="line">    std::string fragmentShader = R"(</span><br><span class="line">        #version 330 core</span><br><span class="line"></span><br><span class="line">        layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line">        void main()</span><br><span class="line">        {</span><br><span class="line">            color = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">        }</span><br><span class="line">    )";</span><br><span class="line"></span><br><span class="line">    unsigned int shader = CreateShader(vertexShader, fragmentShader);</span><br><span class="line">    glUseProgram(shader);</span><br><span class="line"></span><br><span class="line">    /* Loop until the user closes the window */</span><br><span class="line">    while(!glfwWindowShouldClose(window))</span><br><span class="line">    {</span><br><span class="line">        /* Render here */</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line"></span><br><span class="line">        /* Swap front and back buffers */</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        /* Poll for and events */</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="addition">+   glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="addition">+   glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line">    glDeleteProgram(shader);</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/Pw7Ynd.jpg"></p><h3 id="OpenGL中如何处理着色器"><a href="#OpenGL中如何处理着色器" class="headerlink" title="OpenGL中如何处理着色器"></a>OpenGL中如何处理着色器</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=8&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>个人习惯将两个着色器合并到一个只有顶点和片段着色器的文件中。不管怎样，让我们进入代码展示这一切的原理。</p><h4 id="着色器合并"><a href="#着色器合并" class="headerlink" title="着色器合并"></a>着色器合并</h4><p>首先我们实际上要做的是创建一个包含这两个着色器的文件，以便我们了解是如何处理它们的。</p><p>在项目目录中创建一个放置资源的 <code>res</code> 文件夹，在该文件夹下创建专门放置着色器的 <code>shaders</code> 文件夹，在之后我们可能会有像纹理之类的其他资源。最后在 <code>shaders/</code> 下新建文件 <code>Basic.shader</code>：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/eQxGQ8.jpg"></p><p>现在我们有了一个着色器文本，你可以看到它没有显示 C++ 图标，这非常重要因为我们不想把它编译成 C++ 代码。将之前的着色器代码复制粘贴到文件中：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">gl_Position</span> = position;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment  </span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    color = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们就无需在两个不同的着色器文件之间切换，并且很简单干净有条理。</p><h4 id="着色器读取与使用"><a href="#着色器读取与使用" class="headerlink" title="着色器读取与使用"></a>着色器读取与使用</h4><p>下面我们要做的就是读取这个文件，然后把它分成两块字符串，一个是我们的片段着色器，而另一个就是我们的顶点着色器源码。引入头文件 <code>#include&lt;fstream&gt;</code>，打开文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::fstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以现在我们需要做的就是一行一行地浏览那个文件，然后只去检查是否是指定的着色器类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">            <span class="comment">// set mode to vertex</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>添加着色器类型并在分支设定正确的类型：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">    NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">            type = ShaderType::VERTEX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">            type = ShaderType::FRAGMENT;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;          </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">std::string VertexSource;</span><br><span class="line">std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::VERTEX;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::FRAGMENT;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line"><span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 Mac 出现的各种错误太多了，相同代码跑不通太浪费时间了，所以还是转到了 Windows 上：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/yJD0q1.jpg"></p><h3 id="OpenGL中的索引缓冲区"><a href="#OpenGL中的索引缓冲区" class="headerlink" title="OpenGL中的索引缓冲区"></a>OpenGL中的索引缓冲区</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=9&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们会讨论索引缓冲区。</p><h4 id="绘制四边形"><a href="#绘制四边形" class="headerlink" title="绘制四边形"></a>绘制四边形</h4><p>在我们讨论索引缓冲区为什么用它以及它到底是什么之前，让我们先考虑一个图形编程的基础的问题：去画一个正方形。</p><p>显然我们可以通过拼接两个三角形实现，先画出来第一个三角形：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/0vR4BK.jpg"></p><p>回到我们的代码增加另一个三角形的三个顶点（其中两个顶点与第一个三角形重合）：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+float positions[12] = {</span></span><br><span class="line">    -0.5f, -0.5f,</span><br><span class="line">     0.5f, -0.5f,</span><br><span class="line">     0.5f,  0.5f,</span><br><span class="line"></span><br><span class="line"><span class="addition">+    0.5f,  0.5f,</span></span><br><span class="line"><span class="addition">+   -0.5f,  0.5f,</span></span><br><span class="line"><span class="addition">+   -0.5f, -0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>同时更改一下缓冲区的设置：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">unsigned int buffer;</span><br><span class="line">glGenBuffers(1, &amp;buffer);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="addition">+glBufferData(GL_ARRAY_BUFFER, 6 * 2 * sizeof(float), positions, GL_STATIC_DRAW);</span></span><br></pre></td></tr></tbody></table></figure><p>由于我们绘制的是六个顶点，所以这里也要改：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/3huSYC.jpg"></p><p>这里不是正方形的原因是因为窗口原因。</p><p>很酷！我们已经画出了一个正方形，它并不太难，但是绘制这个正方形的方式有些东西不太理想：我们的两个顶点是完全一样的，也就是在复制我们的内存，我们在显存中存储相同顶点的相同字节，存储了多次。因为显存并不是无限的，而我们想要降低它的内存使用。</p><h4 id="索引缓冲区"><a href="#索引缓冲区" class="headerlink" title="索引缓冲区"></a>索引缓冲区</h4><p>所以我们能做的就是使用一个叫做索引缓冲区的东西，这允许我们重用现有的顶点。对于矩形或者正方形而言可能还好，它看起来可能并不浪费，因为它没有太多的东西。然而当它换成游戏中的 3D 模型如宇宙飞船，每一个组成那个飞船的独立三角形会被连接到另一个三角形，这意味着你已经立马重复了至少两个顶点，每个顶点再包含法线、切线、纹理坐标的数据，那么你不得不复制整个缓冲区，它一次又一次地构成了那个实际的顶点，那是完全不现实的。</p><p>让我们来转换一下这种顶点缓冲，添加一个索引缓冲区并删除那些重复的冗余内存。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着创建一个无符号整型数组 <code>indices</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 0</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 1</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>,<span class="comment">// 2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span><span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这实际就是一个索引缓冲区，我们需要说明 OpenGL 如何去渲染这个三角形或者正方形，而不是给它提供冗余或重复的顶点位置。在这个例子中我们只有位置，但实际应用中可能会有更多的数据。</p><p>现在我们需要把它们发送到显卡上，并且告诉 OpenGL 用它们去渲染。而我们实现的方式非常类似于创建顶点缓冲区：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure><p><code>ibo</code> 代表索引缓冲区对象，表示这个特定的索引缓冲区。这里唯一的区别是把 <code>GL_ARRAY_BUFFER</code> 换为 <code>GL_ELEMENT_ARRAY_BUFFER</code>，<code>positions</code> 替换为之前的 <code>indices</code>。</p><p>需要说明一下我们会在所有这些例子中使用 <code>unsigned int</code>，因为在这种情况下不会有任何的性能差异，这里的关键是必须使用无符号类型。</p><br><p>最后需要改变的是我们的 DrawCall：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line"><span class="addition">+glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</span></span><br></pre></td></tr></tbody></table></figure><p><code>count</code> 就是我们需要绘制的 6 个索引，绘制索引的数量而非我们绘制顶点的数量；<code>type</code> 就是在索引缓冲区中的数据类型，在本例中是 <code>GL_UNSIGNED_INT</code>；最后是指向那个索引缓冲区的指针，而前面我们已经绑定了 <code>ibo</code>，所以这里可以填 <code>nullptr</code>。这就是我们绘制三角形的实际 DrawCall 指令。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/o35r1Y.jpg"></p><p>运行程序，你可以看到我们得到了一个漂亮的矩形。</p><p>我们已经删除了任何重复的顶点，在顶点缓冲区中得到了完全唯一的顶点，之后创建了一个索引以便多次绘制顶点；然后我们用 <code>ibo</code> 绑定代码把索引缓冲区发送给显卡；最终我们使用 <code>glDrawElements()</code> 绘制图形。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">std::string VertexSource;</span><br><span class="line">std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::VERTEX;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::FRAGMENT;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line"><span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> positions[] = {</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 0</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 1</span></span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>,<span class="comment">// 2</span></span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span><span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenGL中处理错误"><a href="#OpenGL中处理错误" class="headerlink" title="OpenGL中处理错误"></a>OpenGL中处理错误</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=10&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们要讨论的都是错误，我们怎么知道我们做错了什么以及如何尽快地调试并修复它。</p><h4 id="glGetError"><a href="#glGetError" class="headerlink" title="glGetError"></a>glGetError</h4><p>我们有两种主要的方式来检查 OpenGL 中的错误，其中一个一个叫做 <code>glGetError()</code>，它是一个我们可以调用的 OpenGL 内置函数。它能够兼容所有版本并且原理相对简单：在我们调用 OpenGL 时如果发生错误，内存中有一个标志会被内部设置，其会说明发生了什么类型的错误，并且当我们调用 <code>glGetError()</code> 时它会返回一个标志（或者说错误码）。如果我们继续调用 <code>glGetError()</code> 它会把所有标志返回给我们，因为我们可能会产生多个类型的错误。</p><br><p>回到上次渲染正方形的代码，我们可以更改索引缓冲区类型导致错误：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</span></span><br><span class="line"><span class="addition">+glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/JPc6wC.jpg"></p><p>可以看到小小的改动得到的就是黑屏，我们的矩形根本没有渲染，这太糟糕了。</p><h4 id="glDebugMessageCallback"><a href="#glDebugMessageCallback" class="headerlink" title="glDebugMessageCallback"></a>glDebugMessageCallback</h4><p>在最近的 OpenGL 4.3 中添加了一个新的函数 <code>glDebugMessageCallback()</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/gh0Yuv.jpg"></p><p>查阅文档，可以发现它允许我们指定一个指向 OpenGL 的函数指针，当错误发生时 OpenGL 会调用我们的那个函数。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/2wm6Fo.jpg"></p><p>唯一的问题在于兼容性，它只在 4.3 及以上版本，所以你不能再早期版本中使用它。优点也很明显，它不会仅仅给你一个错误码，会提供更详细的信息。根据我的经验， <code>glDebugMessageCallback()</code> 总体上非常好，比 <code>glGetError()</code> 好得多。但今天我们只讨论 <code>glGetError()</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/00vAdR.jpg"></p><p>可以创建一个循环调用的报错函数 <code>GLClearError()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// while (glGetError() != GL_NO_ERROR);</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glGetError</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来创建另一个打印出实际错误的函数 <code>GLCheckError()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在让我们调用一下刚才的函数：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+GLClearError();</span></span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span><br><span class="line"><span class="addition">+GLCheckError();</span></span><br></pre></td></tr></tbody></table></figure><p>首先排除其他的错误，相当于调试的断言。通过这样的方式我们可以确保所有的错误实际上都是来自这个函数。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/CdVZjC.jpg"></p><p>可以看到错误代码是 1280。在源码中搜索 1280 找不到任何东西，因为 OpenGL 采用的是十六进制表示错误码。所以我们可以换为十六进制：0x0500。再返回 <code>&lt;glew.h&gt;</code> 文件检索：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL_INVALID_ENUM 0x0500</span></span><br></pre></td></tr></tbody></table></figure><p>500 意味着无效的枚举，而 <code>GL_INT</code>确实是我们实际传递的无效枚举，它应该是无符号整型。</p><p>实际上 <code>glClearError()</code> 和 <code>glCheckError()</code> 还是比较笨重，并且让扩展变得更加困难。但我们实际上可以做的就是得到实际的调试器，暂时执行并在导致错误的代码行上中断。我们可以通过使用断言来实现这一点，如果那个条件是 false，你通常要么将消息写入控制台，要么只是停止程序的执行并且在那行中断。</p><p>为此我需要修改 <code>GLCheckError()</code> 变为 <code>GLLogCall()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着在头文件下面定义宏断言：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  ASSERT(x) <span class="keyword">if</span> (!(x))   __debugbreak();</span></span><br></pre></td></tr></tbody></table></figure><p>这是 MSVC 特有的，在 clang、gcc 或者其他编译器中都不起作用。最后插入断言：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">GLClearError();</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);</span><br><span class="line"><span class="deletion">-GLCheckError();</span></span><br><span class="line"><span class="addition">+ASSERT(GLLogCall());</span></span><br></pre></td></tr></tbody></table></figure><p>为了方便起见定义宏 <code>GLCall()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError(); x; ASSERT(GLLogCall())</span></span><br></pre></td></tr></tbody></table></figure><p>更改调用：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo@main/uPic/img/e6c9d24egy1h2lt68j6klj211x0kiq6s-20220526221235055.jpg"></p><p>最后加一些调试信息：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError();  x;  ASSERT(GLLogCall(#x, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">"): "</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">" "</span> &lt;&lt; file &lt;&lt; <span class="string">":"</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/EKV7FE.jpg"></p><h3 id="OpenGL中的统一变量"><a href="#OpenGL中的统一变量" class="headerlink" title="OpenGL中的统一变量"></a>OpenGL中的统一变量</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=11&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们要讨论的是统一变量。</p><p>那么首先统一变量是一个非常单一的概念，它对于我们而言实际上是一种从 CPU 端获取数据的方式。在本例中是从 C++ 到我们的着色器，所以我们实际上把它当一个变量使用。</p><h4 id="颜色变量"><a href="#颜色变量" class="headerlink" title="颜色变量"></a>颜色变量</h4><p>回到着色器我们创建一个 <code>u_Color</code> 并赋值：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="addition">+uniform vec4 u_Color;</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line"><span class="deletion">-   color = vec4(0.0, 0.2, 0.8, 1.0);</span></span><br><span class="line"><span class="addition">+   color = u_Color;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每个统一变量都有一个 id，这样我们就可以引用它了。而我们查找 id 的方式通常是通过它的名称，所以我们基本上就是问我们的着色器 <code>u_Color</code> 变量的位置。</p><p>在更现代的 OpenGL 版本，你实际上可以设置和索引。所以从 4.3 开始你可以指定一个明确的统一变量位置，这是一种非常现代的新功能。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">ShaderProgramSource source = ParseShader("res/shader/basic.shader");</span><br><span class="line">unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);</span><br><span class="line">GLCall(glUseProgram(shader));</span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(int location = glGetUniformLocation(shader, "u_Color"));</span></span><br><span class="line"><span class="addition">+ASSERT(location != -1);</span></span><br><span class="line"><span class="addition">+GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line"></span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><p>总结一下，我通过使用实际的着色器 id 编写 <code>glUseProgram()</code> 绑定着色器，获取这个颜色变量的实际位置。而当我获取那个位置的时候，就调用 <code>glUniform4f()</code> 在着色器中设置我的数据。如果一切顺利，我应该将这个颜色值写入我的矩形每个像素的实际输出颜色：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/zZJOiw.jpg"></p><p>可以看到我们得到了与之前完全相同的结果，为了区分明显一点修改颜色：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line"><span class="addition">+GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/GiuTRy.jpg"></p><h4 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h4><p>好了，那么现在做点更令人兴奋的事情吧：让我们这个颜色动起来并且在渲染循环中随时间改变它。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+float r = 0.0f;</span></span><br><span class="line"><span class="addition">+float increment = 0.05f;</span></span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span></span><br><span class="line">GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span><br><span class="line"></span><br><span class="line"><span class="addition">+if (r &gt; 1.0f)</span></span><br><span class="line"><span class="addition">+increment = -0.05f;</span></span><br><span class="line"><span class="addition">+else if (r &lt; 0.0f)</span></span><br><span class="line"><span class="addition">+increment = 0.05f;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+r += increment;</span></span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">GLCall(glDeleteProgram(shader));</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行程序会发现颜色变化比较快，因为我们没有限制帧率：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"><span class="addition">+glfwSwapInterval(1);</span></span><br></pre></td></tr></tbody></table></figure><p>该设置可以同步我们主频的帧率，得到更平滑的动画。</p><h3 id="OpenGL中的顶点数组"><a href="#OpenGL中的顶点数组" class="headerlink" title="OpenGL中的顶点数组"></a>OpenGL中的顶点数组</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=12&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们会讲 OpenGL 的顶点数组。</p><h4 id="顶点数组"><a href="#顶点数组" class="headerlink" title="顶点数组"></a>顶点数组</h4><p>我们讲了很多 OpenGL 的基本概念甚至一般的图形编程，但 OpenGL 实际上有一个顶点数组。乍一看你可能会说顶点数组、顶点缓冲区它们之间的区别是什么，它们听起来非常相似。确实如此，并且这并不是 DirectX 等其他渲染接口中真正存在的东西，它是 OpenGL 独有的，也可以说是 OpenGL 的一个原始接口。它们基本上是一种通过特定的规范绑定顶点缓冲区的方式，用于实际顶点缓冲区的布局。</p><p>在我们的代码中，我们创建了 <code>buffer</code> 包含所有的顶点数据，然后创建缓冲区之后也做了绑定，启用了顶点属性指定实际数据的布局。现在一个顶点数组对象允许我们通过 <code>glVertexAttribArray()</code> 绑定指定的顶点规范到实际的顶点缓冲区，可能对于 OpenGL 的初学者比较难以理解，如果屏幕上有多个对象、多个网格、多个顶点缓冲区，需要我们绑定顶点和索引缓冲区，然后绘制实际的对象。</p><p>但我们绑定顶点缓冲区之后，我们实际也需要指定布局，让我们看看解绑一切会发生什么：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">GLCall(int location = glGetUniformLocation(shader, "u_Color"));</span><br><span class="line">ASSERT(location != -1);</span><br><span class="line">GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(glUseProgram(0));</span></span><br><span class="line"><span class="addition">+GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));</span></span><br><span class="line"><span class="addition">+GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));</span></span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line">/* Loop until the user closes the window */</span><br></pre></td></tr></tbody></table></figure><p>这里我基本上解绑了所有的东西，到了绘制的时候我们需要实际上绑定我们需要的所有东西，让 DrawCall 工作以此正确渲染所有东西：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">GLCall(glUseProgram(shader));</span><br><span class="line">GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));</span></span><br><span class="line"><span class="addition">+GLCall(glEnableVertexAttribArray(0));</span></span><br><span class="line"><span class="addition">+GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span></span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们绑定着色器，设置统一变量，绑定顶点缓冲区，设置顶点缓冲区的布局，最后绑定索引缓冲区调用 <code>glDrawElements()</code>。运行这段代码看看会发生什么：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/ZuZbei.jpg"></p><p>得到了和之前一样的结果，完美。这里值得商榷的是这里：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><p>我们是否每次都要这样做？答案是肯定的，因为如果我们用不同的布局绘制另一个对象，它们可能已经改变了。所以顶点数组对象实际上就是包含这种状态的对象，因此如果我们正确地利用顶点数组对象例如为几何体的每个部分创建不同的顶点数组对象，然后只需要绑定顶点数组对象就完事儿了，因为顶点数组对象将包含顶点缓冲区之间的绑定、布局。</p><p>因此，我们的绘制方式从绑定我们的着色器、绑定我们的顶点缓冲区、设置顶点布局、绑定我们的索引缓冲区、然后发出实际的 DrawCall 指令变为了绑定我们的着色器、<strong>绑定顶点数组</strong>、绑定索引缓冲区、最终发出实际的 DrawCall 指令。所以绑定顶点缓冲区并设置其布局变为了绑定顶点数组对象，因为它包含了我们实际需要的所有状态。</p><br><p>我需要在这里提一件事情，从技术上讲顶点数组对象是必须的，它们现在正在被使用，这就是为什么我说即使我们没有创建它们这个状态仍由顶点数组对象保持。这个东西是 OpenGL 兼容性配置文件，默认情况下兼容性配置文件实际上为我们创建了一个顶点数组对象。</p><p>然而，核心配置文件没有。所以我们实际上需要自己显式地创建一个 OpenGL 顶点数组对象，绑定它确保一切正常。如果我们正在使用核心配置文件，需要手动处理：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line"><span class="addition">+glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span></span><br><span class="line"><span class="addition">+glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span></span><br><span class="line"><span class="addition">+glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure><p>前两行确定 OpenGL 的主次版本为 3.3，后一行则设置我的 OpenGL 配置为核心配置文件 <code>GLFW_OPENGL_CORE_PROFILE</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/ehr3l7.png"></p><p>运行程序触发了断言，当我们尝试启用这个 <code>vertexAttribArray</code> 的时候没有绑定顶点数组对象，因此我们无法指定顶点属性类型的规范或者 <code>enableVertexAttribArray</code>。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/I0TkZU.png"></p><p>那么我们需要做的就是在核心配置文件中实际创建那个 VAO，也就是顶点数组对象：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">unsigned int indices[] = {</span><br><span class="line">0, 1, 2,</span><br><span class="line">2, 3, 0</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="addition">+unsigned int vao;</span></span><br><span class="line"><span class="addition">+GLCall(glGenVertexArrays(1, &amp;vao));</span></span><br><span class="line"><span class="addition">+GLCall(glBindVertexArray(vao));</span></span><br><span class="line"></span><br><span class="line">unsigned int buffer;</span><br></pre></td></tr></tbody></table></figure><p>再次运行程序不再报错，这就是我们显式地创建一个 vao。有意思的是我们甚至可以删掉部分绑定的代码，程序依然可运行：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+GLCall(glBindVertexArray(0));</span></span><br><span class="line">GLCall(glUseProgram(0));</span><br><span class="line">GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));</span><br><span class="line">GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));</span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line"></span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">GLCall(glClear(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">GLCall(glUseProgram(shader));</span><br><span class="line">GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line"><span class="deletion">-GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));</span></span><br><span class="line"><span class="deletion">-GLCall(glEnableVertexAttribArray(0));</span></span><br><span class="line"><span class="deletion">-GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+GLCall(glBindVertexArray(vao));</span></span><br><span class="line">GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));</span><br><span class="line"></span><br><span class="line">GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure><p>当我们绑定顶点数组和缓冲区的时候，实际上没有链接两者。但当我们指定这个 <code>vertexAttribPointer</code> 的时候，我们说的是这个顶点数组索引为 0 的位置将实际绑定到当前绑定的 <code>GL_ARRAY_BUFFER</code> 插槽。</p><h4 id="应用策略"><a href="#应用策略" class="headerlink" title="应用策略"></a>应用策略</h4><p>那么我们应该一直使用顶点数组对象吗？</p><p>答案是视情况而定。如果我们使用当前的核心配置文件，我们必须创建一个顶点数组的对象；如果我们只使用兼容性配置文件，这并不意味着没有顶点数组对象，这只意味着我们有一个默认的顶点数组对象，它被绑定并设置为供我们使用。</p><ul><li>PlanA 是技术上你可以创造一个顶点数组对象，在你整个项目过程中都把它放在一边。因此始终有一个绑定的顶点数组对象，然后你可以在绘制几何体之前绑定一个顶点缓冲区并指定一个顶点布局。</li><li>PlanB 则是对于你创建的几何体的每一块创建一个顶点数组对象，然后指定那个规范一次，你就可以启用任何你需要的 vertexAttribArray 了，可以根据需要多次指定 <code>glVertexAttribPointer()</code> 把那些都设置好。然后在执行所有这些操作之前，你将看到绑定顶点缓冲区，到了绘制的时候只需每次绘制几何体之前绑定不同的顶点数组对象、将其绑定到索引缓冲区中，就可以调用 <code>glDrawElements</code> 或者任何绘制函数。</li></ul><p>所以你可以在整个项目上有一个全局 VAO，然后每次绑定不同的缓冲区和不同的顶点规范；或者你对每个几何体都有单独的 VAO。哪一个更好，还是很难回答。</p><p>在很久之前 NVIDIA 做过研究全局 VAO 然后每次绑定一切速度更快。最近我没有做过相关的基准测试，但是我还是建议使用 VAO，OpenGL 也建议去使用它们。但这个世界很复杂，与理想情况下 VAO 的工作原理略有不同，所以我的建议是如果你真的关心性能需要从这一切中挤出最后一点性能，实际上你需要做一些测试，在你的环境中、你的平台上、你的设备中等等实际生产环境中进行尝试两种方案孰优孰劣。</p><h3 id="抽象顶点索引缓冲区成类"><a href="#抽象顶点索引缓冲区成类" class="headerlink" title="抽象顶点索引缓冲区成类"></a>抽象顶点索引缓冲区成类</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=13&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="错误处理类抽象"><a href="#错误处理类抽象" class="headerlink" title="错误处理类抽象"></a>错误处理类抽象</h4><p>新建 <code>Renderer.h</code> 和 <code>Renderer.cpp</code>，将之前的错误处理代码放到新文件中。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  ASSERT(x) <span class="keyword">if</span> (!(x))   __debugbreak();</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GLCall(x) GLClearError();  x;  ASSERT(GLLogCall(#x, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><code>Renderer.h</code> 头文件包含了之前宏定义、断言以及函数的声明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="type">const</span> GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[OpenGL Error] ("</span> &lt;&lt; error &lt;&lt; <span class="string">"): "</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">" "</span> &lt;&lt; file &lt;&lt; <span class="string">":"</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Renderer.cpp</code> 则是函数的实现。</p><h4 id="VertexBuffer类抽象"><a href="#VertexBuffer类抽象" class="headerlink" title="VertexBuffer类抽象"></a>VertexBuffer类抽象</h4><p>同理新建 <code>VertexBuffer.h</code> 和 <code>VertexBuffer.cpp</code> 两个文件。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBuffer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> <span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">VertexBuffer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>其中 <code>Vertexbuffer.h</code> 包含一个成员变量 <code>m_RendererID</code>、构造函数、析构函数以及绑定/解绑函数的声明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line">VertexBuffer::<span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> size)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">VertexBuffer::~<span class="built_in">VertexBuffer</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="IndexBuffer类抽象"><a href="#IndexBuffer类抽象" class="headerlink" title="IndexBuffer类抽象"></a>IndexBuffer类抽象</h4><p>同理新建 <code>IndexBuffer.h</code> 和 <code>IndexBuffer.cpp</code> 两个文件。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexBuffer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count);</span><br><span class="line">    ~<span class="built_in">IndexBuffer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Count; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>Indexbuffer.h</code> 包含两个成员变量 <code>m_RendererID</code> <code>m_Count</code>、构造函数、析构函数以及绑定/解绑函数的声明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line">IndexBuffer::<span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    : <span class="built_in">m_Count</span>(count)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(GLuint))</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, count * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), data, GL_STATIC_DRAW))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">IndexBuffer::~<span class="built_in">IndexBuffer</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类"><a href="#应用类" class="headerlink" title="应用类"></a>应用类</h4><p>最终封装之后 <code>Application.cpp</code> 代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">std::string VertexSource;</span><br><span class="line">std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::VERTEX;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::FRAGMENT;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ss[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(type)] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glCompileShader</span>(id))</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result))</span><br><span class="line"><span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length))</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* message = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message))</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(id))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, vs))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, fs))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glLinkProgram</span>(program))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glValidateProgram</span>(program))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(vs))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(fs))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> positions[] = {</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 0</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 1</span></span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>,<span class="comment">// 2</span></span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span><span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="literal">nullptr</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">const</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="type">const</span> <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">"u_Color"</span>))</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line">ib.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">increment = <span class="number">-0.05f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDeleteProgram</span>(shader))</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenGL中的缓冲区和布局的抽象"><a href="#OpenGL中的缓冲区和布局的抽象" class="headerlink" title="OpenGL中的缓冲区和布局的抽象"></a>OpenGL中的缓冲区和布局的抽象</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=14&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>首先我们抽象顶点数组的目的是什么？</p><p>对我们来说，顶点数组需要做的是将顶点缓冲区与某种布局联系在一起，所以顶点缓冲区就是有数据的缓冲区，它们没有实际的概念比如前三个浮点数是位置，没有类型或者大小之类的概念，它只是实际数据的普通缓冲区。每个字节是什么、这些顶点有多大等等才是顶点数组真正代表的，它应该把缓冲区和实际布局联系在一起。</p><p>顶点数组对象是 OpenGL 存储那种状态的方式，那么当我们考虑创建这个接口时，我们需要做的是需要一些东西来创建一个顶点数组。</p><h4 id="顶点数组布局类"><a href="#顶点数组布局类" class="headerlink" title="顶点数组布局类"></a>顶点数组布局类</h4><p>新建顶点数组布局类 <code>VertexBufferLayout.h</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexBufferElement</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> normalized;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetSizeOfType</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> GL_FLOAT:          <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> GL_UNSIGNED_INT:   <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> GL_UNSIGNED_BYTE:  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBufferLayout</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Stride;</span><br><span class="line">    std::vector&lt;VertexBufferElement&gt; m_Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VertexBufferLayout</span>()</span><br><span class="line">        : <span class="built_in">m_Stride</span>(<span class="number">0</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// static_assert(false);</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    {</span><br><span class="line">        m_Elements.<span class="built_in">push_back</span>({ GL_FLOAT, count, GL_FALSE });</span><br><span class="line">        m_Stride += count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_FLOAT);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    {</span><br><span class="line">        m_Elements.<span class="built_in">push_back</span>({ GL_UNSIGNED_INT, count, GL_FALSE });</span><br><span class="line">        m_Stride += count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_INT);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    {</span><br><span class="line">        m_Elements.<span class="built_in">push_back</span>({ GL_UNSIGNED_BYTE, count, GL_TRUE });</span><br><span class="line">        m_Stride += count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_BYTE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetStride</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Stride; }</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> std::vector&lt;VertexBufferElement&gt; <span class="title">GetElements</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Elements; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="顶点数组类抽象"><a href="#顶点数组类抽象" class="headerlink" title="顶点数组类抽象"></a>顶点数组类抽象</h4><p>新建 <code>VertexArray.h</code> 和 <code>VertexArray.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBufferLayout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexArray</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VertexArray</span>();</span><br><span class="line">    ~<span class="built_in">VertexArray</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>头文件包含了成员变量 <code>m_RendererID</code>、构造函数、析构函数、缓冲区添加函数以及绑定/解绑函数的声明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexArray.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line">VertexArray::<span class="built_in">VertexArray</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">VertexArray::~<span class="built_in">VertexArray</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">Bind</span>();</span><br><span class="line">    vb.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; elements = layout.<span class="built_in">GetElements</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; elements.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; element = elements[i];</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(i))</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(i, element.count, element.type, element.normalized, layout.<span class="built_in">GetStride</span>(), (<span class="type">const</span> <span class="type">void</span>*)offset))</span><br><span class="line"></span><br><span class="line">        offset += element.count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(element.type);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-1"><a href="#应用类-1" class="headerlink" title="应用类"></a>应用类</h4><p>最后用封装好的类替换之前 <code>Application.cpp</code> 中的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexArray.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">std::string VertexSource;</span><br><span class="line">std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">{</span><br><span class="line">NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::string line;</span><br><span class="line">std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">ShaderType type = ShaderType::NONE;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::VERTEX;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">type = ShaderType::FRAGMENT;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ss[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(type)] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glCompileShader</span>(id))</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result))</span><br><span class="line"><span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length))</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* message = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message))</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(id))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, vs))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, fs))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glLinkProgram</span>(program))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glValidateProgram</span>(program))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(vs))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(fs))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line">{</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> positions[] = {</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 0</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 1</span></span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>,<span class="comment">// 2</span></span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span><span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line"><span class="function"><span class="type">const</span> VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">va.<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">"res/shader/basic.shader"</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">const</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="type">const</span> <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">"u_Color"</span>))</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">va.<span class="built_in">Bind</span>();</span><br><span class="line">ib.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">increment = <span class="number">-0.05f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDeleteProgram</span>(shader))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenG中抽象着色器"><a href="#OpenG中抽象着色器" class="headerlink" title="OpenG中抽象着色器"></a>OpenG中抽象着色器</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=15&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>着色器需要什么？</p><p>第一步首先我们希望能够传递一个文件或者字符串，把它作为着色器来编译；第二步我们希望能够绑定和解绑着色器；第三步则是我们需要能够设置着色器中各种不同的统一变量，这可能就是我们现在正在研究的东西。</p><h4 id="着色器抽象"><a href="#着色器抽象" class="headerlink" title="着色器抽象"></a>着色器抽象</h4><p>那么，让我们开始深入重构代码吧。</p><p>新建文件 <code>Shader.h</code> 和 <code>Shader.cpp</code> 抽象着色器类。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">{</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_FilePath;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m_UniformLocationCache;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath);</span><br><span class="line">    ~<span class="built_in">Shader</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set uniforms</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Shader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line">Shader::<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath)</span><br><span class="line">    : <span class="built_in">m_FilePath</span>(filepath), <span class="built_in">m_RendererID</span>(<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="type">const</span> ShaderProgramSource source = <span class="built_in">ParseShader</span>(filepath);</span><br><span class="line">    m_RendererID = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Shader::~<span class="built_in">Shader</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteProgram</span>(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(<span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(<span class="built_in">GetUniformLocation</span>(name), v0, v1, v2, v3))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (m_UniformLocationCache.<span class="built_in">find</span>(name) != m_UniformLocationCache.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> m_UniformLocationCache[name];</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="type">const</span> <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>()))</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Warning: uniform '"</span> &lt;&lt; name &lt;&lt; <span class="string">"' doesn't exist!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ShaderProgramSource <span class="title">Shader::ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">    {</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"#shader"</span>) != std::string::npos)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"vertex"</span>) != std::string::npos)</span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">"fragment"</span>) != std::string::npos)</span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            ss[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(type)] &lt;&lt; line &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> { ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glCompileShader</span>(id))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result))</span><br><span class="line">    <span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length))</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* message = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message))</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to compile "</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">"vertex"</span> : <span class="string">"fragment"</span>) &lt;&lt; <span class="string">"shader!"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(id))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, vs))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glAttachShader</span>(program, fs))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glLinkProgram</span>(program))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glValidateProgram</span>(program))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(vs))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteShader</span>(fs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-2"><a href="#应用类-2" class="headerlink" title="应用类"></a>应用类</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexArray.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Shader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> positions[] = {</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 0</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>,<span class="comment">// 1</span></span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>,<span class="comment">// 2</span></span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span><span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line"><span class="function"><span class="type">const</span> VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">va.<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">"res/shader/basic.shader"</span>)</span></span>;</span><br><span class="line">shader.<span class="built_in">Bind</span>();</span><br><span class="line">shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">va.<span class="built_in">Unbind</span>();</span><br><span class="line">shader.<span class="built_in">Unbind</span>();</span><br><span class="line">vb.<span class="built_in">Unbind</span>();</span><br><span class="line">ib.<span class="built_in">Unbind</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line"></span><br><span class="line">shader.<span class="built_in">Bind</span>();</span><br><span class="line">shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">va.<span class="built_in">Bind</span>();</span><br><span class="line">ib.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">increment = <span class="number">-0.05f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/0vC2xI.png"></p><h3 id="OpenGL写一个基础的渲染器类"><a href="#OpenGL写一个基础的渲染器类" class="headerlink" title="OpenGL写一个基础的渲染器类"></a>OpenGL写一个基础的渲染器类</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=16&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们的目标是剔除在主文件中遗留的 OpenGL 调用。</p><p>虽然前面几节我们用 <code>VertexBuffer</code>、<code>IndexBuffer</code>、<code>VertexArray</code>、<code>Shader</code> 等类抽象 OpenGL 代码，但是还有相当一部分遗留在 <code>Application.cpp</code> 中，例如 DrawCall 指令。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "VertexArray.h"</span></span><br><span class="line"><span class="addition">+#include "IndexBuffer.h"</span></span><br><span class="line"><span class="addition">+#include "Shader.h"</span></span><br><span class="line"></span><br><span class="line">#define  ASSERT(x) if (!(x))   __debugbreak();</span><br><span class="line">#define  GLCall(x) GLClearError();  x;  ASSERT(GLLogCall(#x, __FILE__, __LINE__))</span><br><span class="line"></span><br><span class="line">void GLClearError();</span><br><span class="line">bool GLLogCall(const char* function, const char* file, int line);</span><br><span class="line"></span><br><span class="line"><span class="addition">+class Renderer</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+public:</span></span><br><span class="line"><span class="addition">+   void Clear() const;</span></span><br><span class="line"><span class="addition">+   void Draw(const VertexArray&amp; va, const IndexBuffer&amp; ib,const Shader&amp; shader) const;</span></span><br><span class="line"><span class="addition">+};</span></span><br></pre></td></tr></tbody></table></figure><p>让我们想一想，在 OpenGL 绘制一些东西我们实际需要什么。我们需要顶点数组和索引缓冲区以及着色器，顶点数组实际已经绑定了顶点缓冲区，</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Clear</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Draw</span><span class="params">(<span class="type">const</span> VertexArray&amp; va, <span class="type">const</span> IndexBuffer&amp; ib, <span class="type">const</span> Shader&amp; shader)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line">    shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    va.<span class="built_in">Bind</span>();</span><br><span class="line">    ib.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, ib.<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>复制完 <code>Application.cpp</code> 中的绑定代码后并不打算解绑。在更传统的情况下，OpenGL 中解绑不是严格必要的，它可能会减少一些 bug，但从根本上来说在 OpenGL 中解绑东西只是浪费性能，你不需要这么做，因为在我们绘制下一个东西之前我们会把这些东西都绑定起来，所以解绑没有意义。更复杂的系统可能会在调试模式下会有解绑，但暂时我们还是简单处理。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">constexpr float positions[] = {</span><br><span class="line">-0.5f, -0.5f,// 0</span><br><span class="line"> 0.5f, -0.5f,// 1</span><br><span class="line"> 0.5f,  0.5f,// 2</span><br><span class="line">-0.5f,  0.5f// 3</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">const unsigned int indices[] = {</span><br><span class="line">0, 1, 2,</span><br><span class="line">2, 3, 0</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">unsigned int vao;</span><br><span class="line">GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line">const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 2 * sizeof(float));</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">Shader shader("res/shader/basic.shader");</span><br><span class="line">shader.Bind();</span><br><span class="line">shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line">va.Unbind();</span><br><span class="line">shader.Unbind();</span><br><span class="line">vb.Unbind();</span><br><span class="line">ib.Unbind();</span><br><span class="line"></span><br><span class="line"><span class="addition">+Renderer renderer;</span></span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line"><span class="addition">+renderer.Clear();</span></span><br><span class="line"><span class="deletion">-GLCall(glClear(GL_COLOR_BUFFER_BIT))</span></span><br><span class="line"></span><br><span class="line">shader.Bind();</span><br><span class="line">shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-va.Bind();</span></span><br><span class="line"><span class="deletion">-ib.Bind();</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr))</span></span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="OpenGL中的纹理"><a href="#OpenGL中的纹理" class="headerlink" title="OpenGL中的纹理"></a>OpenGL中的纹理</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=17&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们会讨论 OpenGL 中的纹理。</p><h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><p>当大部分人想到纹理的时候，他们真的只会想到在一个游戏中的 3D 对象上呈现图像（当然不一定非得是 3D 对象）。而你们在 Ps 或画图等等中创建的图像，让它出现在你们的图形应用程序中，那就是纹理的本质，或者至少是大部分人眼中的纹理。</p><p>现在，除了这些，关于纹理的理解比我刚才描述的要多得多。纹理可以用于很多事情，当后面讲到一些非常复杂的图形技术时我们会提到，但现在我只想让你们把纹理看作当渲染时是我们可以使用的图像。那么我实际能做的就是设计或创造某种图像，不管是一张照片还是画布上一条弯弯曲曲的线亦或是纯色以及任意类似的颜色，我都可以在我的电脑中创建任何图像文件，然后把它上传到我的显存中，然后在我的着色器中使用它来绘制我现在正在做的任何东西。</p><p>这可能像在我们的 OpenGL 程序中画一个矩形一样简单，它包含了渲染纹理的元素，这样我们就可以在游戏中看到纹理。或者也可能是更复杂的东西，就像使用预先计算好的数学值将其融入到我们的纹理中，然后在着色器中对它们进行采样，这样我们可以做一些很酷的灯光效果。但现在，它只会在 OpenGL 应用中从计算机获取图像到表面。</p><h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><p>回到项目，添加 <code>res/textures/Checkerboard.png</code>：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/X8XHLg.png"></p><p>首先我们需要以某种方式将 PNG 图像加载到 CPU 内存中，可以使用 <code>stb_image</code> 库加载 PNG。我们给它一个文件路径，它会给我们一个指向 RGBA 像素缓冲区的指针；然后我们会取那个像素数组把它上传到我们的显卡；最后当它绘制时就可以修改着色器来读取那个纹理，片段着色器实际计算出每个像素应该是什么，构成那个纹理每部分的颜色是什么。</p><ul><li><a href="https://github.com/nothings/stb">stb</a></li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/Z8UO7K.png"></p><p>复制 <code>stb_image.h</code> 中的代码到项目的 <code>vendor/stb_images/stb_image.h</code>。新建 <code>stb_image.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stb_image.h"</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="纹理类抽象"><a href="#纹理类抽象" class="headerlink" title="纹理类抽象"></a>纹理类抽象</h4><p>新建文件 <code>Texture.h</code> 和 <code>Texture.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_FilePath;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> m_LocalBuffer;</span><br><span class="line">    <span class="type">int</span> m_Width, m_Height, m_BPP;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path);</span><br><span class="line">    ~<span class="built_in">Texture</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Width; }</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> m_Height; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>slot</code> 就是绑定纹理的插槽。在 OpenGL 我们有各种各样的插槽可以绑定纹理，Windows 上经典的现代显卡会有 32 个纹理插槽，而在诸如安卓等移动设备上可能有八个插槽，这取决于你们的实际显卡以及它们的 OpenGL 实现。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Texture.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"vendor/stb_images/stb_image.h"</span></span></span><br><span class="line"></span><br><span class="line">Texture::<span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path)</span><br><span class="line">    : <span class="built_in">m_FilePath</span>(path), <span class="built_in">m_RendererID</span>(<span class="number">0</span>), <span class="built_in">m_LocalBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">m_Width</span>(<span class="number">0</span>), <span class="built_in">m_Height</span>(<span class="number">0</span>), <span class="built_in">m_BPP</span>(<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="number">1</span>);</span><br><span class="line">    m_LocalBuffer = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;m_Width, &amp;m_Height, &amp;m_BPP, <span class="number">4</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_RendererID))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Width, m_Height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_LocalBuffer)</span><br><span class="line">        <span class="built_in">stbi_image_free</span>(m_LocalBuffer);</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Texture::~<span class="built_in">Texture</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDeleteTextures</span>(<span class="number">1</span>, &amp;m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Texture::Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glActiveTexture</span>(GL_TEXTURE0 + slot))</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Texture::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li><code>stbi_set_flip_vertically_on_load(1)</code> 用于垂直翻转我们的纹理，OpenGL 希望我们的纹理像素从左下角开始。</li><li><code>glTexParameteri(...)</code> 用于纹理比实际大或者小时，需要放大或者缩小</li></ul><h4 id="应用类-3"><a href="#应用类-3" class="headerlink" title="应用类"></a>应用类</h4><p>回到 <code>Application.cpp</code> 加入纹理：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBufferLayout.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IndexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexArray.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Shader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Texture.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> positions[] = {</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="comment">// 0</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,<span class="comment">// 1</span></span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="comment">// 2</span></span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span><span class="comment">// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line"><span class="function"><span class="type">const</span> VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">va.<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">"res/shader/basic.shader"</span>)</span></span>;</span><br><span class="line">shader.<span class="built_in">Bind</span>();</span><br><span class="line">shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Texture <span class="title">texture</span><span class="params">(<span class="string">"res/textures/Checkerboard.png"</span>)</span></span>;</span><br><span class="line">texture.<span class="built_in">Bind</span>();</span><br><span class="line">shader.<span class="built_in">SetUniform1i</span>(<span class="string">"u_Texture"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">va.<span class="built_in">Unbind</span>();</span><br><span class="line">shader.<span class="built_in">Unbind</span>();</span><br><span class="line">vb.<span class="built_in">Unbind</span>();</span><br><span class="line">ib.<span class="built_in">Unbind</span>();</span><br><span class="line"></span><br><span class="line">Renderer renderer;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line">renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">shader.<span class="built_in">Bind</span>();</span><br><span class="line">shader.<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">increment = <span class="number">-0.05f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意这里调用了 <code>Shader.h</code> 的新增代码：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">struct ShaderProgramSource</span><br><span class="line">{</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Shader</span><br><span class="line">{</span><br><span class="line">private:</span><br><span class="line">    std::string m_FilePath;</span><br><span class="line">    unsigned int m_RendererID;</span><br><span class="line">    std::unordered_map&lt;std::string, int&gt; m_UniformLocationCache;</span><br><span class="line">public:</span><br><span class="line">    Shader(const std::string&amp; filepath);</span><br><span class="line">    ~Shader();</span><br><span class="line"></span><br><span class="line">    void Bind() const;</span><br><span class="line">    void Unbind() const;</span><br><span class="line"></span><br><span class="line">    // Set uniforms</span><br><span class="line"><span class="addition">+   void SetUniform1i(const std::string&amp; name, int value);</span></span><br><span class="line"><span class="addition">+   void SetUniform1f(const std::string&amp; name, float value);</span></span><br><span class="line">    void SetUniform4f(const std::string&amp; name, float v0, float v1, float v2, float v3);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ShaderProgramSource ParseShader(const std::string&amp; filepath) const;</span><br><span class="line">    unsigned int CompileShader(unsigned int type, const std::string&amp; source);</span><br><span class="line">    unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader);</span><br><span class="line">  </span><br><span class="line">    int GetUniformLocation(const std::string&amp; name);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include "Shader.h"</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">Shader::Shader(const std::string&amp; filepath)</span><br><span class="line">    : m_FilePath(filepath), m_RendererID(0)</span><br><span class="line">{</span><br><span class="line">    const ShaderProgramSource source = ParseShader(filepath);</span><br><span class="line">    m_RendererID = CreateShader(source.VertexSource, source.FragmentSource);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Shader::~Shader()</span><br><span class="line">{</span><br><span class="line">    GLCall(glDeleteProgram(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Shader::Bind() const</span><br><span class="line">{</span><br><span class="line">    GLCall(glUseProgram(m_RendererID))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Shader::Unbind() const</span><br><span class="line">{</span><br><span class="line">    GLCall(glUseProgram(0))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="addition">+void Shader::SetUniform1i(const std::string&amp; name, int value)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+   GLCall(glUniform1i(GetUniformLocation(name), value))</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+void Shader::SetUniform1f(const std::string&amp; name, float value)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+   GLCall(glUniform1f(GetUniformLocation(name), value))</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line">void Shader::SetUniform4f(const std::string&amp; name, float v0, float v1, float v2, float v3)</span><br><span class="line">{</span><br><span class="line">    GLCall(glUniform4f(GetUniformLocation(name), v0, v1, v2, v3))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int Shader::GetUniformLocation(const std::string&amp; name)</span><br><span class="line">{</span><br><span class="line">    if (m_UniformLocationCache.find(name) != m_UniformLocationCache.end())</span><br><span class="line">        return m_UniformLocationCache[name];</span><br><span class="line">  </span><br><span class="line">    GLCall(const int location = glGetUniformLocation(m_RendererID, name.c_str()))</span><br><span class="line">    if (location == -1)</span><br><span class="line">        std::cout &lt;&lt; "Warning: uniform '" &lt;&lt; name &lt;&lt; "' doesn't exist!" &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return location;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ShaderProgramSource Shader::ParseShader(const std::string&amp; filepath) const</span><br><span class="line">{</span><br><span class="line">    std::ifstream stream(filepath);</span><br><span class="line"></span><br><span class="line">    enum class ShaderType</span><br><span class="line">    {</span><br><span class="line">        NONE = -1, VERTEX = 0, FRAGMENT = 1</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[2];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    while (getline(stream, line))</span><br><span class="line">    {</span><br><span class="line">        if (line.find("#shader") != std::string::npos)</span><br><span class="line">        {</span><br><span class="line">            if (line.find("vertex") != std::string::npos)</span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            else if (line.find("fragment") != std::string::npos)</span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">        }</span><br><span class="line">        else</span><br><span class="line">        {</span><br><span class="line">            ss[static_cast&lt;int&gt;(type)] &lt;&lt; line &lt;&lt; '\n';</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return { ss[0].str(), ss[1].str() };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned int Shader::CompileShader(unsigned int type, const std::string&amp; source)</span><br><span class="line">{</span><br><span class="line">    const unsigned int id = glCreateShader(type);</span><br><span class="line">    const char* src = source.c_str();</span><br><span class="line">    GLCall(glShaderSource(id, 1, &amp;src, nullptr))</span><br><span class="line">    GLCall(glCompileShader(id))</span><br><span class="line"></span><br><span class="line">    // TODO: Error handling</span><br><span class="line">    int result;</span><br><span class="line">    GLCall(glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result))</span><br><span class="line">    if (result == GL_FALSE)</span><br><span class="line">    {</span><br><span class="line">        int length;</span><br><span class="line">        GLCall(glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length))</span><br><span class="line"></span><br><span class="line">        char* message = static_cast&lt;char*&gt;(malloc(length * sizeof(char)));</span><br><span class="line">        GLCall(glGetShaderInfoLog(id, length, &amp;length, message))</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "Failed to compile " &lt;&lt; (type == GL_VERTEX_SHADER ? "vertex" : "fragment") &lt;&lt; "shader!" &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        GLCall(glDeleteShader(id))</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned int Shader::CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader)</span><br><span class="line">{</span><br><span class="line">    const unsigned int program = glCreateProgram();</span><br><span class="line">    const unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    const unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    GLCall(glAttachShader(program, vs))</span><br><span class="line">    GLCall(glAttachShader(program, fs))</span><br><span class="line">    GLCall(glLinkProgram(program))</span><br><span class="line">    GLCall(glValidateProgram(program))</span><br><span class="line"></span><br><span class="line">    GLCall(glDeleteShader(vs))</span><br><span class="line">    GLCall(glDeleteShader(fs))</span><br><span class="line"></span><br><span class="line">    return program;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>着色器 <code>basic.shader</code> 代码如下：</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">gl_Position</span> = position;</span><br><span class="line">    v_TexCoord = texCoord;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> u_Color;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Texture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(u_Texture, v_TexCoord);</span><br><span class="line">    color = texColor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/YGUC1V.png"></p><p>最终我们把纹理图片渲染到屏幕上的一个四边形上。</p><h3 id="OpenGL中的混合"><a href="#OpenGL中的混合" class="headerlink" title="OpenGL中的混合"></a>OpenGL中的混合</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=18&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>上一期其实我们在渲染纹理时遇到了一些问题，我们启用了一个叫混合的东西，设置了一个混合函数，这就随机得到了我们的纹理：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br></pre></td></tr></tbody></table></figure><h4 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h4><p>什么是混合？为什么我们的纹理渲染一开始就不正确？</p><p>混合很简单。本质上，当我们渲染一些部分或完全透明的东西时我们会想到 Ps 降低透明度，而图形编程必须告诉电脑你真正想让它做什么，因为它不知道你们想做什么。默认情况下 OpenGL 不执行任何混合，它只需要你们渲染的东西，然后把它渲染成不透明的东西。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/vwl5Lr.png"></p><p>之前我们渲染了红色方块，在它上面我们以某种形式渲染了一个半透明的蓝色方块（不透明的蓝色方块会直接覆盖红色方块），我们期望得到这两种颜色的组合：紫色。如果我们现实生活中拿红玻璃和蓝玻璃然后把它们像这样叠在一起，我们会看到穿过的光实际上是紫色的，那就是我们用眼睛所看到的。</p><ul><li>所以混合只决定了我们如何将输出颜色与目标缓冲区中已经存在的颜色结合起来</li><li>我们的输出颜色为片段着色器中输出的颜色，也被称为 source</li><li>在这个例子中我们把它画到一个已经存在的缓冲区上，也就是我们的目标 destination：红色方块</li></ul><h4 id="混合控制"><a href="#混合控制" class="headerlink" title="混合控制"></a>混合控制</h4><p>那么我们如何控制这两种颜色混合的方式呢？ 我们在 OpenGL 在有三种不同的方法，他们做的事情非常不同：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/D87pvb.png"></p><ul><li>首先，启用和禁用 <code>glEnable(GL_BLEND)</code>、<code>glDisable(GL_BLEND)</code>，参数 <code>GL_BLEND</code>。默认情况下不会启用混合</li><li><code>glBlendFunc(src, dest)</code> 指定如何将两种颜色混合在一起（丢掉 <code>dest</code> 并用 <code>src</code> 覆盖），其中 RGB 因子将乘以所有颜色通道，所以 <code>src</code> 默认为 1 而 <code>dest</code> 默认为 0</li><li><code>glBlendEquation(mode)</code> 混合不等式，参数 <code>mode</code> 为组合方式（默认为 <code>GL_FUNC_ADD</code>）</li></ul><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/si3fQb.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/yVc389.png"></p><h3 id="OpenGL中的数学"><a href="#OpenGL中的数学" class="headerlink" title="OpenGL中的数学"></a>OpenGL中的数学</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=19&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="GLM库"><a href="#GLM库" class="headerlink" title="GLM库"></a>GLM库</h4><p><a href="https://github.com/g-truc/glm"><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/ojMTaf.png"></a></p><p>在 Release 界面下载最新的 zip 文件：</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/0AXDNJ.png"></p><p>下载完毕之后将 <code>glm</code> 复制粘贴到 <code>src/vendor</code> 中。</p><p>glm 是一个只包含头文件的库，这意味着没有 cpp 文件不需要编译它，所以我们不需要链接到库直接使用。右键项目属性，在 <code>C/C++</code> 找到附加包含目录，添加 <code>src/vendor</code>。</p><h4 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h4><p>投影矩阵是我们告诉窗口的一种方式，告诉它我们想要如何将所有不同的顶点映射到它。所以我们有一个填充了顶点位置顶点缓冲区这样的概念，但是我们需要把它转换到 2D 平面，因为当我们把它绘制在笔记本电脑屏幕或电脑显示器上时需要以 2D 的方式绘制出来。</p><p>那么想象一个 3D 世界，我们有一个 3D 世界的数学表示，但我们需要把它绘制在 2D 表面上。数学上我们如何从 3D 几何图形到 2D 平面图形的？那就是投影矩阵的用处。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "glm/glm.hpp"</span></span><br><span class="line"><span class="addition">+#include "glm/gtc/matrix_transform.hpp"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">constexpr float positions[] = {</span><br><span class="line">-0.5f, -0.5f, 0.0f, 0.0f,// 0</span><br><span class="line"> 0.5f, -0.5f, 1.0f, 0.0f,// 1</span><br><span class="line"> 0.5f,  0.5f, 1.0f, 1.0f,// 2</span><br><span class="line">-0.5f,  0.5f, 0.0f, 1.0f// 3</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">const unsigned int indices[] = {</span><br><span class="line">0, 1, 2,</span><br><span class="line">2, 3, 0</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">GLCall(glEnable(GL_BLEND))</span><br><span class="line">GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">unsigned int vao;</span><br><span class="line">GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line">const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">glm::mat4 proj = glm::ortho(-2.0f, 2.0f, -1.5f, 1.5f, -1.0f, 1.0f);</span><br><span class="line"></span><br><span class="line">Shader shader("res/shader/basic.shader");</span><br><span class="line">shader.Bind();</span><br><span class="line"><span class="deletion">-shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">texture.Bind();</span><br><span class="line">shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">va.Unbind();</span><br><span class="line">shader.Unbind();</span><br><span class="line">vb.Unbind();</span><br><span class="line">ib.Unbind();</span><br><span class="line"></span><br><span class="line">Renderer renderer;</span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">renderer.Clear();</span><br><span class="line"></span><br><span class="line">shader.Bind();</span><br><span class="line"><span class="deletion">-shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一个正交矩阵本质上就是把所有的坐标映射到 2D 屏幕上的一种方法，离得更远的物体并不会变小。这和我们习惯的透视投影是相反的。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#shader vertex</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) in vec4 position;</span><br><span class="line">layout(location = 1) in vec2 texCoord;</span><br><span class="line"></span><br><span class="line">out vec2 v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="addition">+uniform mat4 u_MVP;</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">    gl_Position = position;</span><br><span class="line">    v_TexCoord = texCoord;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec4 color;</span><br><span class="line"></span><br><span class="line">in vec2 v_TexCoord;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_Color;</span><br><span class="line">uniform sampler2D u_Texture;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">    vec4 texColor = texture(u_Texture, v_TexCoord);</span><br><span class="line">    color = texColor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>MVP</code> 是我们的模型 (Model) 视图 (View) 投影 (Projection) 矩阵，后面会讲到这些（请复习 GAMES101）。</p><p>接着在顶点着色器用这个矩阵乘以我的顶点位置，每个顶点运行一次基于我们提供的正交矩阵将它移到合适的空间。</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">gl_Position</span> = u_MVP * position;</span><br><span class="line">    v_TexCoord = texCoord;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了设置 <code>u_MVP</code>，我们需要在 <code>Shader.h</code> 中补充 <code>SetUniformMat4f()</code> 方法：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "glm/glm.hpp"</span></span><br><span class="line"></span><br><span class="line">struct ShaderProgramSource</span><br><span class="line">{</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Shader</span><br><span class="line">{</span><br><span class="line">private:</span><br><span class="line">    std::string m_FilePath;</span><br><span class="line">    unsigned int m_RendererID;</span><br><span class="line">    std::unordered_map&lt;std::string, int&gt; m_UniformLocationCache;</span><br><span class="line">public:</span><br><span class="line">    Shader(const std::string&amp; filepath);</span><br><span class="line">    ~Shader();</span><br><span class="line"></span><br><span class="line">    void Bind() const;</span><br><span class="line">    void Unbind() const;</span><br><span class="line"></span><br><span class="line">    // Set uniforms</span><br><span class="line">    void SetUniform1i(const std::string&amp; name, int value);</span><br><span class="line">    void SetUniform1f(const std::string&amp; name, float value);</span><br><span class="line">    void SetUniform4f(const std::string&amp; name, float v0, float v1, float v2, float v3);</span><br><span class="line"><span class="addition">+   void SetUniformMat4f(const std::string&amp; name, const glm::mat4&amp; matrix);</span></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ShaderProgramSource ParseShader(const std::string&amp; filepath) const;</span><br><span class="line">    unsigned int CompileShader(unsigned int type, const std::string&amp; source);</span><br><span class="line">    unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader);</span><br><span class="line">  </span><br><span class="line">    int GetUniformLocation(const std::string&amp; name);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>Shader.cpp</code> 中实现方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniformMat4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::mat4&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">GetUniformLocation</span>(name), <span class="number">1</span>, GL_FALSE, &amp;matrix[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后返回 <code>Application.cpp</code>：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "glm/glm.hpp"</span></span><br><span class="line"><span class="addition">+#include "glm/gtc/matrix_transform.hpp"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">constexpr float positions[] = {</span><br><span class="line">-0.5f, -0.5f, 0.0f, 0.0f,// 0</span><br><span class="line"> 0.5f, -0.5f, 1.0f, 0.0f,// 1</span><br><span class="line"> 0.5f,  0.5f, 1.0f, 1.0f,// 2</span><br><span class="line">-0.5f,  0.5f, 0.0f, 1.0f// 3</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">const unsigned int indices[] = {</span><br><span class="line">0, 1, 2,</span><br><span class="line">2, 3, 0</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">GLCall(glEnable(GL_BLEND))</span><br><span class="line">GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">unsigned int vao;</span><br><span class="line">GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line">const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line"><span class="addition">+const glm::mat4 proj = glm::ortho(-2.0f, 2.0f, -1.5f, 1.5f, -1.0f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">Shader shader("res/shader/basic.shader");</span><br><span class="line">shader.Bind();</span><br><span class="line">// shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span><br><span class="line"><span class="addition">+shader.SetUniformMat4f("u_MVP", proj);</span></span><br><span class="line"></span><br><span class="line">const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">texture.Bind();</span><br><span class="line">shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">va.Unbind();</span><br><span class="line">shader.Unbind();</span><br><span class="line">vb.Unbind();</span><br><span class="line">ib.Unbind();</span><br><span class="line"></span><br><span class="line">Renderer renderer;</span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">renderer.Clear();</span><br><span class="line"></span><br><span class="line">shader.Bind();</span><br><span class="line">// shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line">renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/ocURfe.png"></p><p>最终我们得到了横纵比 4:3 的纹理图形。</p><h3 id="OpenGL中的投影矩阵"><a href="#OpenGL中的投影矩阵" class="headerlink" title="OpenGL中的投影矩阵"></a>OpenGL中的投影矩阵</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=20&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>投影矩阵本质上是一种数学，将空间中所有 3D 点转换成 2D 窗口中的东西，这就是投影矩阵。</p><p>投影矩阵的实际变换就是把所有那些位置转换成所谓的标准坐标，也就是某种标准化空间，然后映射到我们的窗口。标准空间意味着在每个 xyz 轴上都有一个 -1 和 1 之间的坐标系统，所以我想说的是一个窗口的图像分辨率在点上无关紧要。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/QawyIY.png"></p><p>我们有正交投影和透视投影。</p><p>正交投影通常用于 2D 渲染，当然也可用于 3D 对关卡编辑器或 3D 建模程序等有用。透视投影通常用于 3D，尤其是拥有深度概念 z 的时候。（后面就是更改矩阵实践体验，没有什么东西了）</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line">#include "glm/glm.hpp"</span><br><span class="line">#include "glm/gtc/matrix_transform.hpp"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="addition">+constexpr float positions[] = {</span></span><br><span class="line"><span class="addition">+100.0f, 100.0f, 0.0f, 0.0f,// 0</span></span><br><span class="line"><span class="addition">+200.0f, 100.0f, 1.0f, 0.0f,// 1</span></span><br><span class="line"><span class="addition">+200.0f, 200.0f, 1.0f, 1.0f,// 2</span></span><br><span class="line"><span class="addition">+100.0f, 200.0f, 0.0f, 1.0f// 3</span></span><br><span class="line"><span class="addition">+};</span></span><br><span class="line"></span><br><span class="line">const unsigned int indices[] = {</span><br><span class="line">0, 1, 2,</span><br><span class="line">2, 3, 0</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">GLCall(glEnable(GL_BLEND))</span><br><span class="line">GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">unsigned int vao;</span><br><span class="line">GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line">const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line"><span class="addition">+const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f);</span></span><br><span class="line"><span class="addition">+glm::vec4 vp(100.0f, 100.0f, 0.0f, 1.0f);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+glm::vec4 result = proj * vp;</span></span><br><span class="line"></span><br><span class="line">Shader shader("res/shader/basic.shader");</span><br><span class="line">shader.Bind();</span><br><span class="line">// shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span><br><span class="line">shader.SetUniformMat4f("u_MVP", proj);</span><br><span class="line"></span><br><span class="line">const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">texture.Bind();</span><br><span class="line">shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">va.Unbind();</span><br><span class="line">shader.Unbind();</span><br><span class="line">vb.Unbind();</span><br><span class="line">ib.Unbind();</span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">Renderer renderer;</span><br><span class="line">renderer.Clear();</span><br><span class="line"></span><br><span class="line">shader.Bind();</span><br><span class="line">// shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line">renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/ffGrQb.png"></p><h3 id="OpenGL中的模型视图投影矩阵"><a href="#OpenGL中的模型视图投影矩阵" class="headerlink" title="OpenGL中的模型视图投影矩阵"></a>OpenGL中的模型视图投影矩阵</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=21&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>在我们的着色器代码中或者在 C++ 的 glm 代码中，它可以是 pvm：投影 x 视图 x 模型。而像 Direct3D 和 DirectX 因为它们确实处理的矩阵是行主序的，那么就是 mvp：模型 x 视图 x 投影。</p><h4 id="视图矩阵"><a href="#视图矩阵" class="headerlink" title="视图矩阵"></a>视图矩阵</h4><p>OpenGL 中没有相机这个东西，我们能做的就是移动几何体和顶点。所以为了模拟相机向左移动，我们需要做的是将所有东西向右移动，可以算一种逆向运算。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line">#include "glm/glm.hpp"</span><br><span class="line">#include "glm/gtc/matrix_transform.hpp"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">constexpr float positions[] = {</span><br><span class="line">100.0f, 100.0f, 0.0f, 0.0f,// 0</span><br><span class="line">200.0f, 100.0f, 1.0f, 0.0f,// 1</span><br><span class="line">200.0f, 200.0f, 1.0f, 1.0f,// 2</span><br><span class="line">100.0f, 200.0f, 0.0f, 1.0f// 3</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">const unsigned int indices[] = {</span><br><span class="line">0, 1, 2,</span><br><span class="line">2, 3, 0</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">GLCall(glEnable(GL_BLEND))</span><br><span class="line">GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">unsigned int vao;</span><br><span class="line">GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line">const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f);</span><br><span class="line"><span class="addition">+const glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+glm::mat4 mvp = proj * view;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-glm::vec4 result = proj * vp;</span></span><br><span class="line"></span><br><span class="line">Shader shader("res/shader/basic.shader");</span><br><span class="line">shader.Bind();</span><br><span class="line">// shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);</span><br><span class="line"><span class="addition">+shader.SetUniformMat4f("u_MVP", mvp);</span></span><br><span class="line"></span><br><span class="line">const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">texture.Bind();</span><br><span class="line">shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">va.Unbind();</span><br><span class="line">shader.Unbind();</span><br><span class="line">vb.Unbind();</span><br><span class="line">ib.Unbind();</span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">Renderer renderer;</span><br><span class="line">renderer.Clear();</span><br><span class="line"></span><br><span class="line">shader.Bind();</span><br><span class="line">// shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"></span><br><span class="line">renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/nivCms.png"></p><p>数学上将相机向左移动就是将所有矩阵向右移动，如果使用相机类应该将这些接口封装好等待调用即可。</p><h4 id="模型矩阵"><a href="#模型矩阵" class="headerlink" title="模型矩阵"></a>模型矩阵</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f);</span><br><span class="line">const glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));</span><br><span class="line"><span class="addition">+const glm::mat4 model = glm::translate(glm::mat4(1.0f), glm::vec3(200, 200, 0));</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+const glm::mat4 mvp = proj * view * model;</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/jaskyZ.png"></p><h3 id="OpenGL中的ImGui"><a href="#OpenGL中的ImGui" class="headerlink" title="OpenGL中的ImGui"></a>OpenGL中的ImGui</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=22&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们会整合一些 ImGui 的东西，它本质上是一个我们可以在 OpenGL、DirectX 以及任何渲染接口中使用的 GUI 图形用户接口库。 它的大多数接口是独立的，这是我们在屏幕上绘制 UI 界面的一种方式。</p><h4 id="ImGui"><a href="#ImGui" class="headerlink" title="ImGui"></a>ImGui</h4><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/7wLmw4.png"></p><ul><li><a href="https://github.com/ocornut/imgui">Dear ImGui</a></li></ul><p>在 Release 界面下载 zip 源码，我们关心的是 OpenGL 的例子 <code>imgui-1.88/examples/example_glfw_opengl3</code> 和根目录下的头文件。所以拷贝两者到 <code>src/vendor/imgui</code> 下。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/qFRSBN.png"></p><p>注意，最新版本的 ImGui 中的 impl 两个实现文件已转移到主目录的 <code>backends</code> 下面。实在搞不懂可以参考该分支 <a href="https://github.com/speauty/ChernoOpenGL/tree/baf72ce8e59fe1ea025ab7b453660c948f7cb68d">ChernoOpenGL</a> 的配置。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line">#include "glm/glm.hpp"</span><br><span class="line">#include "glm/gtc/matrix_transform.hpp"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "imgui/imgui.h"</span></span><br><span class="line"><span class="addition">+#include "imgui/imgui_impl_glfw.h"</span></span><br><span class="line"><span class="addition">+#include "imgui/imgui_impl_opengl3.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">constexpr float positions[] = {</span><br><span class="line">100.0f, 100.0f, 0.0f, 0.0f,// 0</span><br><span class="line">200.0f, 100.0f, 1.0f, 0.0f,// 1</span><br><span class="line">200.0f, 200.0f, 1.0f, 1.0f,// 2</span><br><span class="line">100.0f, 200.0f, 0.0f, 1.0f// 3</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">const unsigned int indices[] = {</span><br><span class="line">0, 1, 2,</span><br><span class="line">2, 3, 0</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">GLCall(glEnable(GL_BLEND))</span><br><span class="line">GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">unsigned int vao;</span><br><span class="line">GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line">const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 720.0f, -1.0f, 1.0f);</span><br><span class="line">const glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));</span><br><span class="line">const glm::mat4 model = glm::translate(glm::mat4(1.0f), glm::vec3(200, 200, 0));</span><br><span class="line"></span><br><span class="line">glm::mat4 mvp = proj * view * model;</span><br><span class="line"></span><br><span class="line">Shader shader("res/shader/basic.shader");</span><br><span class="line">shader.Bind();</span><br><span class="line">shader.SetUniformMat4f("u_MVP", mvp);</span><br><span class="line"></span><br><span class="line">const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">texture.Bind();</span><br><span class="line">shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">va.Unbind();</span><br><span class="line">shader.Unbind();</span><br><span class="line">vb.Unbind();</span><br><span class="line">ib.Unbind();</span><br><span class="line"></span><br><span class="line"><span class="addition">+ImGui::CreateContext();</span></span><br><span class="line"><span class="addition">+ImGui_ImplGlfw_InitForOpenGL(window, true);</span></span><br><span class="line"><span class="addition">+ImGui::StyleColorsDark();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+const char* glsl_version = "#version 330";</span></span><br><span class="line"><span class="addition">+ImGui_ImplOpenGL3_Init(glsl_version);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line"><span class="addition">+glm::vec3 translation(200, 200, 0);</span></span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">Renderer renderer;</span><br><span class="line">renderer.Clear();</span><br><span class="line"></span><br><span class="line"><span class="addition">+ImGui_ImplOpenGL3_NewFrame();</span></span><br><span class="line"><span class="addition">+ImGui_ImplGlfw_NewFrame();</span></span><br><span class="line"><span class="addition">+ImGui::NewFrame();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+glm::mat4 model = glm::translate(glm::mat4(1.0f), translation);</span></span><br><span class="line"><span class="addition">+glm::mat4 mvp = proj * view * model;</span></span><br><span class="line"></span><br><span class="line">shader.Bind();</span><br><span class="line">// shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);</span><br><span class="line"><span class="addition">+shader.SetUniformMat4f("u_MVP", mvp);</span></span><br><span class="line"></span><br><span class="line">renderer.Draw(va, ib, shader);</span><br><span class="line"></span><br><span class="line">vb.Bind();</span><br><span class="line">ib.Bind();</span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+ImGui::Begin("ImGui");</span></span><br><span class="line"><span class="addition">+ImGui::SliderFloat3("Translation", &amp;translation.x, 0.0f, 960.0f);</span></span><br><span class="line"><span class="addition">+ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);</span></span><br><span class="line"><span class="addition">+ImGui::End();</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ImGui::Render();</span></span><br><span class="line"><span class="addition">+ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+ImGui_ImplOpenGL3_Shutdown();</span></span><br><span class="line"><span class="addition">+ImGui_ImplGlfw_Shutdown();</span></span><br><span class="line"><span class="addition">+ImGui::DestroyContext();</span></span><br><span class="line"></span><br><span class="line">glfwDestroyWindow(window);</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/Tm0yJg.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/lwzpBj.png"></p><h3 id="批量渲染对象"><a href="#批量渲染对象" class="headerlink" title="批量渲染对象"></a>批量渲染对象</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=23&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>今天我们要讲的是如何在屏幕上渲染多个目标。</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "VertexBuffer.h"</span><br><span class="line">#include "VertexBufferLayout.h"</span><br><span class="line">#include "IndexBuffer.h"</span><br><span class="line">#include "VertexArray.h"</span><br><span class="line">#include "Shader.h"</span><br><span class="line">#include "Texture.h"</span><br><span class="line"></span><br><span class="line">#include "glm/glm.hpp"</span><br><span class="line">#include "glm/gtc/matrix_transform.hpp"</span><br><span class="line"></span><br><span class="line">#include "imgui/imgui.h"</span><br><span class="line">#include "imgui/imgui_impl_glfw.h"</span><br><span class="line">#include "imgui/imgui_impl_opengl3.h"</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">constexpr float positions[] = {</span><br><span class="line"><span class="addition">+-50.0f, -50.0f, 0.0f, 0.0f,// 0</span></span><br><span class="line"><span class="addition">+ 50.0f, -50.0f, 1.0f, 0.0f,// 1</span></span><br><span class="line"><span class="addition">+ 50.0f,  50.0f, 1.0f, 1.0f,// 2</span></span><br><span class="line"><span class="addition">+-50.0f,  50.0f, 0.0f, 1.0f// 3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">const unsigned int indices[] = {</span><br><span class="line">0, 1, 2,</span><br><span class="line">2, 3, 0</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">GLCall(glEnable(GL_BLEND))</span><br><span class="line">GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">unsigned int vao;</span><br><span class="line">GLCall(glGenVertexArrays(1, &amp;vao))</span><br><span class="line">GLCall(glBindVertexArray(vao))</span><br><span class="line"></span><br><span class="line">VertexArray va;</span><br><span class="line">const VertexBuffer vb(positions, static_cast&lt;unsigned long long&gt;(4) * 4 * sizeof(float));</span><br><span class="line"></span><br><span class="line">VertexBufferLayout layout;</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">layout.Push&lt;float&gt;(2);</span><br><span class="line">va.AddBuffer(vb, layout);</span><br><span class="line"></span><br><span class="line">const IndexBuffer ib(indices, 6);</span><br><span class="line"></span><br><span class="line">const glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 720.0f, -1.0f, 1.0f);</span><br><span class="line"><span class="addition">+const glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, 0));</span></span><br><span class="line"></span><br><span class="line">Shader shader("res/shader/basic.shader");</span><br><span class="line">shader.Bind();</span><br><span class="line"></span><br><span class="line">const Texture texture("res/textures/Checkerboard.png");</span><br><span class="line">texture.Bind();</span><br><span class="line">shader.SetUniform1i("u_Texture", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">va.Unbind();</span><br><span class="line">shader.Unbind();</span><br><span class="line">vb.Unbind();</span><br><span class="line">ib.Unbind();</span><br><span class="line"></span><br><span class="line">ImGui::CreateContext();</span><br><span class="line">ImGui_ImplGlfw_InitForOpenGL(window, true);</span><br><span class="line">ImGui::StyleColorsDark();</span><br><span class="line"></span><br><span class="line">const char* glsl_version = "#version 330";</span><br><span class="line">ImGui_ImplOpenGL3_Init(glsl_version);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float r = 0.0f;</span><br><span class="line">float increment = 0.05f;</span><br><span class="line"><span class="addition">+glm::vec3 translationA(200, 200, 0);</span></span><br><span class="line"><span class="addition">+glm::vec3 translationB(400, 400, 0);</span></span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line">Renderer renderer;</span><br><span class="line">renderer.Clear();</span><br><span class="line"></span><br><span class="line">ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">ImGui_ImplGlfw_NewFrame();</span><br><span class="line">ImGui::NewFrame();</span><br><span class="line"></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+glm::mat4 model = glm::translate(glm::mat4(1.0f), translationA);</span></span><br><span class="line"><span class="addition">+glm::mat4 mvp = proj * view * model;</span></span><br><span class="line"><span class="addition">+shader.Bind();</span></span><br><span class="line"><span class="addition">+shader.SetUniformMat4f("u_MVP", mvp);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+renderer.Draw(va, ib, shader);</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+glm::mat4 model = glm::translate(glm::mat4(1.0f), translationB);</span></span><br><span class="line"><span class="addition">+glm::mat4 mvp = proj * view * model;</span></span><br><span class="line"><span class="addition">+shader.Bind();</span></span><br><span class="line"><span class="addition">+shader.SetUniformMat4f("u_MVP", mvp);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+renderer.Draw(va, ib, shader);</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (r &gt; 1.0f)</span><br><span class="line">increment = -0.05f;</span><br><span class="line">else if (r &lt; 0.0f)</span><br><span class="line">increment = 0.05f;</span><br><span class="line"></span><br><span class="line">r += increment;</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">ImGui::Begin("ImGui");</span><br><span class="line"><span class="addition">+ImGui::SliderFloat3("Translation A", &amp;translationA.x, 0.0f, 960.0f);</span></span><br><span class="line"><span class="addition">+ImGui::SliderFloat3("Translation B", &amp;translationB.x, 0.0f, 960.0f);</span></span><br><span class="line">ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", static_cast&lt;double&gt;(1000.0f / ImGui::GetIO().Framerate), static_cast&lt;double&gt;(ImGui::GetIO().Framerate));</span><br><span class="line">ImGui::End();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ImGui::Render();</span><br><span class="line">ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ImGui_ImplOpenGL3_Shutdown();</span><br><span class="line">ImGui_ImplGlfw_Shutdown();</span><br><span class="line">ImGui::DestroyContext();</span><br><span class="line"></span><br><span class="line">glfwDestroyWindow(window);</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际上有两种不同的策略，但这里我们不必浪费内存，选择通过采用不同的模型矩阵实现批量渲染对象。</p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/qbCBaJ.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/gKsQud.png"></p><h3 id="为OpenGL建立一个测试框架"><a href="#为OpenGL建立一个测试框架" class="headerlink" title="为OpenGL建立一个测试框架"></a>为OpenGL建立一个测试框架</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=24&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><p>现在我们的应用程序只是为 OpenGL 创建了一堆接口类，比如顶点缓冲区、顶点数组、索引缓冲区、纹理之类的东西，然后我们就有了这个 <code>Application.cpp</code> 文件也就是一些对 OpenGL 的调用。但我真正想做的是让我们有能力进行不同的测试，也就是说不同的应用领域不同的场景我们可以在每一个测试或者场景中循环，并且它的实现非常简单，我们只是在 ImGui 添加一个菜单显示所有可用的场景或测试或示例。</p><h4 id="测试基类"><a href="#测试基类" class="headerlink" title="测试基类"></a>测试基类</h4><p>在 <code>src/</code> 下创建 <code>tests</code> 文件夹，新建 <code>Test.h</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Test</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>{}</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> </span>{}</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> </span>{} </span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过该测试基类我们可以自由分配堆栈资源而不必手动释放，因为其生命周期与该类同步，创建和销毁直接调用构造函数和析构函数。</p><h4 id="颜色测试"><a href="#颜色测试" class="headerlink" title="颜色测试"></a>颜色测试</h4><p>新建 <code>TestClearColor.h</code> 和 <code>TestClearColor.cpp</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TestClearColor</span> : <span class="keyword">public</span> Test</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TestClearColor</span>();</span><br><span class="line">        ~<span class="built_in">TestClearColor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">float</span> m_ClearColor[<span class="number">4</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* m_Label;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>头文件 <code>TestClearColor.h</code> 的变量 <code>m_ClearColor[4]</code> 就是颜色的 RGBA，<code>m_Label</code> 为 UI 的标题字符串。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"TestClearColor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    TestClearColor::<span class="built_in">TestClearColor</span>()</span><br><span class="line">        : m_ClearColor{ <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span> }, <span class="built_in">m_Label</span>(<span class="string">"ClearColor"</span>)</span><br><span class="line">    {</span><br><span class="line">      </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TestClearColor::~<span class="built_in">TestClearColor</span>()</span><br><span class="line">    {</span><br><span class="line">      </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">      </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(m_ClearColor[<span class="number">0</span>], m_ClearColor[<span class="number">1</span>], m_ClearColor[<span class="number">2</span>], m_ClearColor[<span class="number">3</span>]))</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ImGui::<span class="built_in">ColorEdit4</span>(m_Label, m_ClearColor);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-4"><a href="#应用类-4" class="headerlink" title="应用类"></a>应用类</h4><p>重新整理应用类 <code>Application.cpp</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Shader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"glm/glm.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui_impl_glfw.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui_impl_opengl3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"tests/TestClearColor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/* Initialize the library */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a Windowed mode and its OpenGL context */</span></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glfwTerminate</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the window's context current */</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line">ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* glsl_version = <span class="string">"#version 330"</span>;</span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_Init</span>(glsl_version);</span><br><span class="line"></span><br><span class="line">test::TestClearColor test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Render here */</span></span><br><span class="line">Renderer renderer;</span><br><span class="line">renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">test.<span class="built_in">OnUpdate</span>(<span class="number">0.0f</span>);</span><br><span class="line">test.<span class="built_in">OnRender</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">test.<span class="built_in">OnImGuiRender</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">Render</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap front and back buffers */</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll for and events */</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/pot3Qe.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/zJz366.png"></p><h3 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=25&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="测试菜单"><a href="#测试菜单" class="headerlink" title="测试菜单"></a>测试菜单</h4><p>在 <code>Test.h</code> 中新加入 <code>TestMenu</code> 测试菜单类：</p><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"><span class="addition">+#include &lt;iostream&gt;</span></span><br><span class="line"><span class="addition">+#include &lt;string&gt;</span></span><br><span class="line"><span class="addition">+#include &lt;vector&gt;</span></span><br><span class="line"><span class="addition">+#include &lt;functional&gt;</span></span><br><span class="line"></span><br><span class="line">namespace test</span><br><span class="line">{</span><br><span class="line">    class Test</span><br><span class="line">    {</span><br><span class="line">    public:</span><br><span class="line">        Test() = default;</span><br><span class="line">        virtual ~Test() = default;</span><br><span class="line"></span><br><span class="line">        virtual void OnUpdate(float deltaTime) {}</span><br><span class="line">        virtual void OnRender() {}</span><br><span class="line">        virtual void OnImGuiRender() {} </span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="addition">+   class TestMenu : public Test</span></span><br><span class="line"><span class="addition">+   {</span></span><br><span class="line"><span class="addition">+   public:</span></span><br><span class="line"><span class="addition">+       TestMenu(Test*&amp; currentTestPointer);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       void OnImGuiRender() override;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       template&lt;typename T&gt;</span></span><br><span class="line"><span class="addition">+       void RegisterTest(const std::string&amp; name)</span></span><br><span class="line"><span class="addition">+       {</span></span><br><span class="line"><span class="addition">+           std::cout &lt;&lt; "Registering test " &lt;&lt; name &lt;&lt; std::endl;</span></span><br><span class="line"><span class="addition">+           m_Tests.push_back(std::make_pair(name, [](){ return new T(); }));</span></span><br><span class="line"><span class="addition">+       }</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+   private:</span></span><br><span class="line"><span class="addition">+       Test*&amp; m_CurrentTest;</span></span><br><span class="line"><span class="addition">+       std::vector&lt;std::pair&lt;std::string, std::function&lt;Test*()&gt;&gt;&gt; m_Tests;</span></span><br><span class="line"><span class="addition">+   };</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>新建 <code>Test.cpp</code> 实现方法：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    TestMenu::<span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer)</span><br><span class="line">        : <span class="built_in">m_CurrentTest</span>(currentTestPointer)</span><br><span class="line">    {</span><br><span class="line">      </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestMenu::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; test : m_Tests)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(test.first.<span class="built_in">c_str</span>()))</span><br><span class="line">                m_CurrentTest = test.<span class="built_in">second</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-5"><a href="#应用类-5" class="headerlink" title="应用类"></a>应用类</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line">#include "Shader.h"</span><br><span class="line"></span><br><span class="line">#include "imgui/imgui.h"</span><br><span class="line">#include "imgui/imgui_impl_glfw.h"</span><br><span class="line">#include "imgui/imgui_impl_opengl3.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "tests/Test.h"</span></span><br><span class="line">#include "tests/TestClearColor.h"</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLCall(glEnable(GL_BLEND))</span><br><span class="line">GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ImGui::CreateContext();</span><br><span class="line">ImGui_ImplGlfw_InitForOpenGL(window, true);</span><br><span class="line">ImGui::StyleColorsDark();</span><br><span class="line"></span><br><span class="line">const char* glsl_version = "#version 330";</span><br><span class="line">ImGui_ImplOpenGL3_Init(glsl_version);</span><br><span class="line"></span><br><span class="line"><span class="addition">+test::Test* currentTest = nullptr;</span></span><br><span class="line"><span class="addition">+test::TestMenu* testMenu = new test::TestMenu(currentTest);</span></span><br><span class="line"><span class="addition">+currentTest = testMenu;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+testMenu-&gt;RegisterTest&lt;test::TestClearColor&gt;("Clear Color");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Loop until the user closes the window */</span><br><span class="line">while (!glfwWindowShouldClose(window))</span><br><span class="line">{</span><br><span class="line">/* Render here */</span><br><span class="line"><span class="addition">+GLCall(glClearColor(0.0f, 0.0f, 0.0f, 1.0f));</span></span><br><span class="line"></span><br><span class="line">Renderer renderer;</span><br><span class="line">renderer.Clear();</span><br><span class="line"></span><br><span class="line">ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">ImGui_ImplGlfw_NewFrame();</span><br><span class="line">ImGui::NewFrame();</span><br><span class="line"></span><br><span class="line"><span class="addition">+if (currentTest)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+currentTest-&gt;OnUpdate(0.0f);</span></span><br><span class="line"><span class="addition">+currentTest-&gt;OnRender();</span></span><br><span class="line"><span class="addition">+ImGui::Begin("ImGui-Test");</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+if (currentTest != testMenu &amp;&amp; ImGui::Button("&lt;-"))</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+delete currentTest;</span></span><br><span class="line"><span class="addition">+currentTest = testMenu;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+currentTest-&gt;OnImGuiRender();</span></span><br><span class="line"><span class="addition">+ImGui::End();</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ImGui::Render();</span><br><span class="line">ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Swap front and back buffers */</span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">/* Poll for and events */</span><br><span class="line">glfwPollEvents();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+delete currentTest;</span></span><br><span class="line"><span class="addition">+if (currentTest != testMenu)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+delete testMenu;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ImGui_ImplOpenGL3_Shutdown();</span><br><span class="line">ImGui_ImplGlfw_Shutdown();</span><br><span class="line">ImGui::DestroyContext();</span><br><span class="line"></span><br><span class="line">glfwDestroyWindow(window);</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/27j93i.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/86K1aB.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/XIghUi.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/aZhz8W.png"></p><h3 id="创建一个纹理测试"><a href="#创建一个纹理测试" class="headerlink" title="创建一个纹理测试"></a>创建一个纹理测试</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=26&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="纹理测试类"><a href="#纹理测试类" class="headerlink" title="纹理测试类"></a>纹理测试类</h4><p>新建纹理测试类 <code>TestTexture2D.h</code> 和 <code>TestTexture2D.cpp</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBuffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"VertexBufferLayout.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Texture.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TestTexture2D</span> : <span class="keyword">public</span> Test</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::unique_ptr&lt;VertexArray&gt; m_VAO;</span><br><span class="line">        std::unique_ptr&lt;IndexBuffer&gt; m_IndexBuffer;</span><br><span class="line">        std::unique_ptr&lt;VertexBuffer&gt; m_VertexBuffer;</span><br><span class="line">        std::unique_ptr&lt;Shader&gt; m_Shader;</span><br><span class="line">        std::unique_ptr&lt;Texture&gt; m_Texture;</span><br><span class="line"></span><br><span class="line">        glm::mat4 m_Proj, m_View;</span><br><span class="line">        glm::vec3 m_TranslationA, m_TranslationB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TestTexture2D</span>();</span><br><span class="line">        ~<span class="built_in">TestTexture2D</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实就是把之前 <code>Application.cpp</code> 清理的琐碎代码整合到一个抽象类中供测试菜单调用：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"TestTexture2D.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Renderer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"imgui/imgui.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"glm/glm.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"glm/gtc/matrix_transform.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">{</span><br><span class="line">TestTexture2D::<span class="built_in">TestTexture2D</span>()</span><br><span class="line">        :<span class="built_in">m_Proj</span>(glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">960.0f</span>, <span class="number">0.0f</span>, <span class="number">720.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)),</span><br><span class="line">        <span class="built_in">m_View</span>(glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>))),</span><br><span class="line">        <span class="built_in">m_TranslationA</span>(glm::<span class="built_in">vec3</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>)), <span class="built_in">m_TranslationB</span>(glm::<span class="built_in">vec3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">0</span>))</span><br><span class="line">{</span><br><span class="line">        <span class="type">float</span> positions[] = {</span><br><span class="line">            <span class="number">100.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">// 0</span></span><br><span class="line">            <span class="number">200.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">// 1</span></span><br><span class="line">            <span class="number">200.0f</span>, <span class="number">200.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">// 2</span></span><br><span class="line">            <span class="number">100.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">// 3</span></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> indices[] = {</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND))</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line">        m_VAO = std::<span class="built_in">make_unique</span>&lt;VertexArray&gt;();</span><br><span class="line"></span><br><span class="line">        m_VertexBuffer = std::<span class="built_in">make_unique</span>&lt;VertexBuffer&gt;(positions, <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>) * <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">        VertexBufferLayout layout;</span><br><span class="line">        layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">        layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">        m_VAO-&gt;<span class="built_in">AddBuffer</span>(*m_VertexBuffer, layout);</span><br><span class="line"></span><br><span class="line">        m_IndexBuffer = std::<span class="built_in">make_unique</span>&lt;IndexBuffer&gt;(indices, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        m_Shader = std::<span class="built_in">make_unique</span>&lt;Shader&gt;(<span class="string">"res/shader/Basic.shader"</span>);</span><br><span class="line">        m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        m_Shader-&gt;<span class="built_in">SetUniform4f</span>(<span class="string">"u_Color"</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        m_Shader-&gt;<span class="built_in">SetUniform1i</span>(<span class="string">"u_Texture"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        m_Texture = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">"res/textures/Checkerboard.png"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>))</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constexpr</span> Renderer renderer;</span><br><span class="line"></span><br><span class="line">        m_Texture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationA);</span><br><span class="line">            <span class="type">const</span> glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line"></span><br><span class="line">            m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">            m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">"u_MVP"</span>, mvp);</span><br><span class="line"></span><br><span class="line">            renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationB);</span><br><span class="line">            <span class="type">const</span> glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line"></span><br><span class="line">            m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">            m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">"u_MVP"</span>, mvp);</span><br><span class="line"></span><br><span class="line">            renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">"m_TranslationA"</span>, &amp;m_TranslationA.x, <span class="number">0.0f</span>, <span class="number">960.0f</span>);</span><br><span class="line">        ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">"m_TranslationB"</span>, &amp;m_TranslationB.x, <span class="number">0.0f</span>, <span class="number">960.0f</span>);</span><br><span class="line">        ImGui::<span class="built_in">Text</span>(<span class="string">"Application average %.3f ms/frame (%.1f FPS)"</span>, <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(ImGui::<span class="built_in">GetIO</span>().Framerate));</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="应用类-6"><a href="#应用类-6" class="headerlink" title="应用类"></a>应用类</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;GL/glew.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include "Renderer.h"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include "imgui/imgui.h"</span><br><span class="line">#include "imgui/imgui_impl_glfw.h"</span><br><span class="line">#include "imgui/imgui_impl_opengl3.h"</span><br><span class="line"></span><br><span class="line">#include "tests/TestClearColor.h"</span><br><span class="line"><span class="addition">+#include "tests/TestTexture2D.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">/* Initialize the library */</span><br><span class="line">if (!glfwInit())</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Create a Windowed mode and its OpenGL context */</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr);</span><br><span class="line">if (!window)</span><br><span class="line">{</span><br><span class="line">GLCall(glfwTerminate())</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/* Make the window's context current */</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">glfwSwapInterval(1);</span><br><span class="line"></span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLCall(glEnable(GL_BLEND))</span><br><span class="line">GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ImGui::CreateContext();</span><br><span class="line">ImGui_ImplGlfw_InitForOpenGL(window, true);</span><br><span class="line">ImGui::StyleColorsDark();</span><br><span class="line"></span><br><span class="line">const char* glsl_version = "#version 330";</span><br><span class="line">ImGui_ImplOpenGL3_Init(glsl_version);</span><br><span class="line"></span><br><span class="line">test::Test* currentTest = nullptr;</span><br><span class="line">test::TestMenu* testMenu = new test::TestMenu(currentTest);</span><br><span class="line">currentTest = testMenu;</span><br><span class="line"></span><br><span class="line">testMenu-&gt;RegisterTest&lt;test::TestClearColor&gt;("Clear Color");</span><br><span class="line"><span class="addition">+</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/am6Cqa.png"></p><p><img data-src="https://img.yousazoe.top/uPic/img/blog/CPP7/PFW6aM.png"></p><h3 id="如何让统一变量更快"><a href="#如何让统一变量更快" class="headerlink" title="如何让统一变量更快"></a>如何让统一变量更快</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=27&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="批渲染"><a href="#批渲染" class="headerlink" title="批渲染"></a>批渲染</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=28&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=29&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="纹理-1"><a href="#纹理-1" class="headerlink" title="纹理"></a>纹理</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=30&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="动态几何"><a href="#动态几何" class="headerlink" title="动态几何"></a>动态几何</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=31&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=32&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br><h3 id="挑战一小时完成批渲染器"><a href="#挑战一小时完成批渲染器" class="headerlink" title="挑战一小时完成批渲染器"></a>挑战一小时完成批渲染器</h3><iframe src="https://player.bilibili.com/player.html?aid=549962056&amp;bvid=BV1Ni4y1o7Au&amp;cid=468375043&amp;page=33&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/CPP7/K4DxcL.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这是 TheCherno 的 OpenGL 系列教程。关于这个系列，我在 GitHub 和码云上自建了源码仓库，如果有需要的朋友可以去看看。&lt;/p&gt;</summary>
    
    
    
    <category term="Cherno的C++笔记 (Cherno C++)" scheme="https://yousazoe.top/categories/Cherno%E7%9A%84C-%E7%AC%94%E8%AE%B0-Cherno-C/"/>
    
    
    <category term="OpenGL" scheme="https://yousazoe.top/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>如何用很短的代码创造「秋日氛围感」？</title>
    <link href="https://yousazoe.top/archives/781b26a.html"/>
    <id>https://yousazoe.top/archives/781b26a.html</id>
    <published>2022-05-07T13:00:37.000Z</published>
    <updated>2022-07-29T03:00:04.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/view3.jpg"></p><span id="more"></span><h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>两三个月前，我和匡冶去上海出差，周日下午坐高铁回北京。忙活了一周，我们俩都精疲力竭地坐在高铁上。还有 3 个小时才到北京，不如写点代码消磨时间，也算放松一下身心。正好聊到 Minecraft （“别人的世界”） 和 MagicaVoxel，于是我们决定来个 Hackathon，用 Taichi 整个 GPU 光线追踪体素渲染器。在快到北京南站之前，我们有了第一版雏形：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507213539823.gif"></p><p>Taichi 是嵌入在 Python 中的并行编程语言，这使得我们的渲染器几乎可以在任何操作系统上运行，并且和 Python 很容易地交互。据我们所知，目前 Python 生态系统里面还没有工具能够实现跨平台的 GPU 光线追踪体素渲染器。Taichi 只需要大约 300 行代码就可以实现这个渲染器 ¹。</p><p>写完代码，我们才发现一个更严峻的问题：对我们老图形程序员来说，造个光线追踪渲染器容易，渲染出好看的图反而更难。加上写 UI 是个工作量很大的事情，我们只支持一个体素一个体素地编辑，这得猴年马月才能做出想要的结果…</p><p>好在 “批量操作体素” 这个事情本身也是可以写代码完成的。Minecraft 大神们可以用各种搭建技法创建自己的体素世界，咱没那个技法，要不直接写代码生成吧！开动！</p><h3 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h3><p>做任何事情之前先要有个美好的愿景，才能确保自己在正确的方向上。在网上找了一些 Voxel 大佬的艺术作品，发现森林是一个常见题材。于是我找了找森林的照片，找到一张秋天的，意境很不错：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/image-20220507210543397.png"></p><p>于是我决定照着这张照片和一些体素艺术家的作品，还原一个秋天的场景，再用光线追踪渲染出来，应该会挺有意思~</p><p>以下内容只需要一些基础的 Python 知识就可以阅读。Taichi 是一个嵌入在 Python 中的编程语言，能够让你的程序被 GPU 加速。</p><h3 id="运行代码，3D-漫游！"><a href="#运行代码，3D-漫游！" class="headerlink" title="运行代码，3D 漫游！"></a>运行代码，3D 漫游！</h3><p>Follow 完这篇教程，你会得到一个 3D 场景并在里面漫游。代码是跨平台的，我的 Macbook 笔记本上也可以运行（20 FPS）。如果你有 RTX 3090 之类的核武器那运行得会更流畅。我的笔记本上移动相机的时候会稍有噪点，停下来很快就收敛了。</p><p>如果你想体验这个场景，浏览完整的 91 行代码，可以 clone 作品仓库 ²。如果你想创建自己的场景，可以从我们的模板仓库 ³ 开始。</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzkzNDI3NDY4Mw==&amp;mid=2247493185&amp;idx=1&amp;sn=3a51e2134ccc671bac407342d5e4fa0f&amp;chksm=c2bd1555f5ca9c434a224a3339cea37a24d00d532e35a99a46be2531b9156f7d3a50dd167641&amp;scene=21#wechat_redirect">首届 Taichi 体素创意大赛</a>正在如火如荼地进行，更多规则请见 GitHub，欢迎有兴趣的同学参加，一起切磋代码技能。</p><p>*另外有同学反馈表示 1.0.1 在某些环境上有些 Vulkan 兼容性的问题，使用 1.0.0 就可以解决。输入命令行 pip install taichi==1.0.0 即可。同时，这个 bug 已经修复了，下一个版本会 ship 这个 bug fix。</p><p>*相关 issue：<a href="https://github.com/taichi-dev/taichi/issues/4891">https://github.com/taichi-dev/taichi/issues/4891</a></p><h3 id="用体素搭建秋日小树林"><a href="#用体素搭建秋日小树林" class="headerlink" title="用体素搭建秋日小树林"></a>用体素搭建秋日小树林</h3><p>先分析一下“愿景图”，里面有几个关键元素：枫(?)树，铺满落叶的地面和体积雾。我们的渲染器并不支持体积雾，好在我们可以用一个 45° 的斜阳（directional_light）加上偏黄的色温来模拟这个场景。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scene <span class="keyword">import</span> Scene</span><br><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line"><span class="keyword">from</span> taichi.math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">scene = Scene(voxel_edges=<span class="number">0</span>, exposure=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 创建场景，指定体素描边宽度和曝光值</span></span><br><span class="line">scene.set_floor(<span class="number">0</span>, (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line"><span class="comment"># 地面高度</span></span><br><span class="line">scene.set_background_color((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.4</span>))</span><br><span class="line"><span class="comment"># 天空颜色</span></span><br><span class="line">scene.set_directional_light((<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>), <span class="number">0.2</span>, (<span class="number">1</span>, <span class="number">0.8</span>, <span class="number">0.6</span>))</span><br><span class="line"><span class="comment"># 光线方向和颜色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_voxels</span>():</span><br><span class="line">    scene.set_voxel(vec3(<span class="number">0</span>), <span class="number">1</span>, vec3(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 在 (0, 0, 0) 加入一个白色 (1, 1, 1) 的体素！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">initialize_voxels()</span><br><span class="line"></span><br><span class="line">scene.finish()</span><br></pre></td></tr></tbody></table></figure><p>你就能得到如下场景：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/TAICHI-V1-0.png"></p><h4 id="基座"><a href="#基座" class="headerlink" title="基座"></a><strong>基座</strong></h4><p>看了几个大佬的体素作品，发现他们常用的一个技法是 “蛋糕切块”，也就是通过截面表现一些平时不容易看到的东西，比如说土地内部的结构，作为作品的基座：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211542014.png"></p><p>那我们依葫芦画瓢，做一个泥土的基座。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211604350.png"></p><p>其实也不是太难，我们一层一层来。如果只考虑相同颜色的一层，那其实就是一个立方体，带上一些随机性。</p><p>我们首先要实现一个函数，来生成一个从 (pos[0], pos[1], pos[2]) 开始，大小是 size[0] x size[1] x size[2] 的立方体。当然，我们可以指定颜色 color。为了增加真实感，我们不能让这个立方体看起来太完美，所以加上一些噪声 color_noise：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_block</span>(<span class="params">pos, size, color, color_noise</span>):</span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> ti.grouped(</span><br><span class="line">            ti.ndrange((pos[<span class="number">0</span>], pos[<span class="number">0</span>] + size[<span class="number">0</span>]),</span><br><span class="line">                       (pos[<span class="number">1</span>], pos[<span class="number">1</span>] + size[<span class="number">1</span>]),</span><br><span class="line">                       (pos[<span class="number">2</span>], pos[<span class="number">2</span>] + size[<span class="number">2</span>]))):</span><br><span class="line">        scene.set_voxel(I, <span class="number">1</span>, color + color_noise * ti.random())</span><br></pre></td></tr></tbody></table></figure><p>这里利用过了一个技巧：<code>ti.ndrange</code>，它能够在一行中实现一个多层 for 循环（否则要写 3 层 for loop，比较麻烦）。配上 <code>ti.grouped</code>，我们将 <code>i</code>, <code>j</code>, <code>k</code> 三个循环变量塞到一个向量 <code>I = (i, j, k)</code> 里面。</p><p>有了这个函数，我们就可以绘制一个大大的方块：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_voxels</span>():</span><br><span class="line">    create_block(pos=ivec3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                 size=ivec3(<span class="number">20</span>, <span class="number">40</span>, <span class="number">30</span>),</span><br><span class="line">                 color=vec3(<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.3</span>),</span><br><span class="line">                 color_noise=vec3(<span class="number">0.1</span>))</span><br></pre></td></tr></tbody></table></figure><p>注意</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211835057.png"></p><p>紧接着，我们只要用一个 4 层的 for 循环，把每一层绘制出来：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_voxels</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        create_block(ivec3(-<span class="number">60</span>, -(i + <span class="number">1</span>)**<span class="number">2</span> - <span class="number">40</span>, -<span class="number">60</span>),</span><br><span class="line">                     ivec3(<span class="number">120</span>, <span class="number">2</span> * i + <span class="number">1</span>, <span class="number">120</span>),</span><br><span class="line">                     vec3(<span class="number">0.5</span> - i * <span class="number">0.1</span>) * vec3(<span class="number">1.0</span>, <span class="number">0.8</span>, <span class="number">0.6</span>),</span><br><span class="line">                     vec3(<span class="number">0.05</span> * (<span class="number">3</span> - i)))</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211903427.png"></p><p>现在有个问题：地表颜色有点淡，我们来加一层地表：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211924785.png"></p><p>好的，说回来，我们并不是在做蛋糕，但是这个蛋糕形状的底座作为整个作品的基座还是不错的。于是，我们的基座就这样完成了！</p><h4 id="树和落叶"><a href="#树和落叶" class="headerlink" title="树和落叶"></a>树和落叶</h4><p>有了基座，我们来点树。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507211952667.png"></p><p>首先，因为我们有很多树，代码行数也有限，我们需要有个画树的函数：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_tree</span>(<span class="params">pos, height, radius, color</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><p>四个参数：</p><ul><li><code>pos</code>: 树根的位置</li><li><code>height</code>：树的高度</li><li><code>radius</code>：树叶半径</li><li><code>color</code>：树叶颜色</li></ul><p>我们一步步来。先搞个树干。这个比较简单，reuse 我们之前的 <code>create_block</code> 就好：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_tree</span>(<span class="params">pos, height, radius, color</span>):</span><br><span class="line">    create_block(pos, ivec3(<span class="number">3</span>, height - radius * <span class="number">0.5</span>, <span class="number">3</span>), vec3(<span class="number">0.7</span>), vec3(<span class="number">0.3</span>))</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212119872.png"></p><p>只有光秃秃的树干好像还有些枯燥。我们来加点叶子。这里我们加一个函数。先假设一棵树的叶子分布的区域是一个圆柱，圆柱中的每一个 voxel 都有一定概率存在或者不存在。我们希望这个概率离圆柱重心越远，就越小。于是我们得到了下面这个函数：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_leaves</span>(<span class="params">pos, radius, color</span>):</span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> ti.grouped(</span><br><span class="line">            ti.ndrange((-radius, radius), (-radius, radius),</span><br><span class="line">                       (-radius, +radius))):</span><br><span class="line">        f = I / radius</span><br><span class="line">        d = vec2(f[<span class="number">0</span>], f[<span class="number">2</span>]).norm() <span class="comment"># 到圆柱中轴线的距离</span></span><br><span class="line">        prob = <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span> - d)**<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> ti.random() &lt; prob:</span><br><span class="line">            scene.set_voxel(pos + I, <span class="number">1</span>, color + (ti.random() - <span class="number">0.5</span>) * <span class="number">0.2</span>)</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212148520.png"></p><p>好吧，看起来不是很自然… 通过一些脑补出来的数学函数和一些噪声，我们稍微优化一下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_leaves</span>(<span class="params">pos, radius, color</span>):</span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> ti.grouped(</span><br><span class="line">            ti.ndrange((-radius, radius), (-radius, radius),</span><br><span class="line">                       (-radius, +radius))):</span><br><span class="line">        f = I / radius</span><br><span class="line">        h = <span class="number">0.5</span> - <span class="built_in">max</span>(f[<span class="number">1</span>], -<span class="number">0.5</span>) * <span class="number">0.5</span></span><br><span class="line">        d = vec2(f[<span class="number">0</span>], f[<span class="number">2</span>]).norm()</span><br><span class="line">        prob = <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span> - d)**<span class="number">2</span> * h  <span class="comment"># xz mask</span></span><br><span class="line">        prob *= h  <span class="comment"># y mask</span></span><br><span class="line">        <span class="comment"># noise</span></span><br><span class="line">        prob += ti.sin(f[<span class="number">0</span>] * <span class="number">5</span> + pos[<span class="number">0</span>]) * <span class="number">0.02</span></span><br><span class="line">        prob += ti.sin(f[<span class="number">1</span>] * <span class="number">9</span> + pos[<span class="number">1</span>]) * <span class="number">0.01</span></span><br><span class="line">        prob += ti.sin(f[<span class="number">2</span>] * <span class="number">10</span> + pos[<span class="number">2</span>]) * <span class="number">0.03</span></span><br><span class="line">        <span class="keyword">if</span> prob &lt; <span class="number">0.1</span>:</span><br><span class="line">            prob = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">if</span> ti.random() &lt; prob:</span><br><span class="line">            scene.set_voxel(pos + I, <span class="number">1</span>, color + (ti.random() - <span class="number">0.5</span>) * <span class="number">0.2</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个函数还有些复杂，但是整体的思路是对于树叶区域的每个体素，计算一个概率，概率和这个体素在空间中的位置有一些关系，还有一些噪声。加上其他细节，就大功告成啦！</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212259763.png"></p><p>我们只要多调用几次 create_tree，就有了一片小树林。注意优化一下每棵树的位置、高度、颜色：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">create_tree(ivec3(-<span class="number">20</span>, -<span class="number">40</span>, <span class="number">25</span>), <span class="number">65</span>, <span class="number">35</span>, vec3(<span class="number">1.0</span>, <span class="number">0.3</span>, <span class="number">0.15</span>))</span><br><span class="line">create_tree(ivec3(<span class="number">45</span>, -<span class="number">40</span>, -<span class="number">45</span>), <span class="number">15</span>, <span class="number">10</span>, vec3(<span class="number">0.8</span>, <span class="number">0.4</span>, <span class="number">0.1</span>))</span><br><span class="line">create_tree(ivec3(<span class="number">20</span>, -<span class="number">40</span>, <span class="number">0</span>), <span class="number">45</span>, <span class="number">25</span>, vec3(<span class="number">1.0</span>, <span class="number">0.4</span>, <span class="number">0.1</span>))</span><br><span class="line">create_tree(ivec3(<span class="number">30</span>, -<span class="number">40</span>, -<span class="number">20</span>), <span class="number">25</span>, <span class="number">15</span>, vec3(<span class="number">1.0</span>, <span class="number">0.4</span>, <span class="number">0.1</span>))</span><br><span class="line">create_tree(ivec3(<span class="number">30</span>, -<span class="number">40</span>, <span class="number">30</span>), <span class="number">45</span>, <span class="number">25</span>, vec3(<span class="number">1.0</span>, <span class="number">0.4</span>, <span class="number">0.1</span>))</span><br></pre></td></tr></tbody></table></figure><p>树的部分收工！</p><h4 id="围栏"><a href="#围栏" class="headerlink" title="围栏"></a>围栏</h4><p>最后一步了，其实也比较简单，就是沿着一个方向加入一段长条，然后每隔一段距离加个小竖条就行：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_fence</span>(<span class="params">start, direction, length</span>):</span><br><span class="line">    color = vec3(<span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">0.2</span>)</span><br><span class="line">    create_block(start, direction * length + ivec3(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>), color, vec3(<span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line">    fence_dist = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length // fence_dist + <span class="number">1</span>):</span><br><span class="line">        create_block(start + direction * i * fence_dist + ivec3(<span class="number">1</span>, -<span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">                     ivec3(<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>), color, vec3(<span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212415607.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212430778.png"></p><p>至此，我们完成了<strong>基座</strong>、<strong>树和落叶</strong>、<strong>围栏</strong>，收工！</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212535555.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212600089.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212628999.png"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/640-20220507212657240.png"></p><h3 id="我也要玩！"><a href="#我也要玩！" class="headerlink" title="我也要玩！"></a>我也要玩！</h3><p>参赛用到的体素渲染器只需要 Python 环境，支持 Windows、Mac、Linux，没有 GPU 的话也可以运行。</p><p>复制文末链接 ⁴，即可查看更多参赛教程及内部测试时候的作品集 ⁵（都有源代码）。</p><p>以上。</p><p>99 行代码的体素大赛截止时间是 5 月 18 日，优秀作品有纪念奖品哦！（可惜我不能参赛，要不然 Switch 一定是我的 hhh）</p><p>只要会 Python，并且有一颗喜欢创造的心，相信你一定能创建出自己喜欢的体素作品！</p><p><strong>References</strong></p><ol><li><p><a href="https://github.com/taichi-dev/voxel-challenge/blob/main/renderer.py">https://github.com/taichi-dev/voxel-challenge/blob/main/renderer.py</a></p></li><li><p><a href="https://github.com/yuanming-hu/voxel-art">https://github.com/yuanming-hu/voxel-art</a></p></li><li><p><a href="https://github.com/taichi-dev/voxel-challenge/">https://github.com/taichi-dev/voxel-challenge/</a></p></li><li><p><a href="https://github.com/taichi-dev/community/blob/main/events/voxel-challenge/reference-zh_cn.md">https://github.com/taichi-dev/community/blob/main/events/voxel-challenge/reference-zh_cn.md</a></p></li><li><p><a href="https://github.com/taichi-dev/voxel-challenge/issues/1">https://github.com/taichi-dev/voxel-challenge/issues/1</a></p></li></ol><p>本文转载自胡渊鸣的知乎文章《99 行代码能干啥？造个体素小世界！》，摘录了创造体素秋景的教程，完整内容请点击“<a href="https://zhuanlan.zhihu.com/p/507362284">阅读原文</a>”查看。也期待大家参与比赛、创造自己的体素小世界！</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/view3.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="太极图形学 (TaiChi Computer Graphics)" scheme="https://yousazoe.top/categories/%E5%A4%AA%E6%9E%81%E5%9B%BE%E5%BD%A2%E5%AD%A6-TaiChi-Computer-Graphics/"/>
    
    
    <category term="Computer Graphics" scheme="https://yousazoe.top/tags/Computer-Graphics/"/>
    
    <category term="Taichi" scheme="https://yousazoe.top/tags/Taichi/"/>
    
    <category term="Voxel" scheme="https://yousazoe.top/tags/Voxel/"/>
    
  </entry>
  
  <entry>
    <title>恋如花期，爱情美在两人共同绽放之时--《花束般的恋爱》</title>
    <link href="https://yousazoe.top/archives/3610aecb.html"/>
    <id>https://yousazoe.top/archives/3610aecb.html</id>
    <published>2022-05-05T15:42:43.000Z</published>
    <updated>2022-07-29T03:00:04.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV9.webp)--><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV9/MahDG4.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>山音麦和八谷绢因错过尾班车而相遇，在深夜咖啡馆聊起文学、电影和音乐，喜好竟奇蹟地相似，二人瞬间坠入爱河。他们毕业后开始一边兼职工作，一边开始同居生活，更一起养拾回来的街猫，最大的目标就是维持俩口子的日常。 但时日流逝，不想改变也得改变。他失约于《牯岭街》， 她独赏郭利斯马基黑色幽默。五年盛放，世上唯一的花未必结果，爱情若只如初见。</p><span id="more"></span><h3 id="命运邂逅"><a href="#命运邂逅" class="headerlink" title="命运邂逅"></a>命运邂逅</h3><blockquote><p>「有种说法是一起吃三次饭，还是没告白的话就只能当普通朋友。」</p></blockquote><p>如果是其他人的剧本，这部片可能只会是典型的日本纯爱电影，但在编剧坂元裕二的执笔，加上导演土井裕泰对于戏剧性精准的执行之下，揉合出近来在我心中最出色的爱情电影。坂元裕二是出了名的金句王，他的戏剧作品中总是满满的金句，除了上面写到的「三次饭局论」，电影中还有「吐司掉地论」、「花语记忆论」，这些都来自于他对生活的洞见，看到有人可以把生活里被忽略的小细节写出来，还可以延伸出人生哲学，令人不禁佩服他敏锐的观察力。</p><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p2625028951.webp)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV9/bDYvok.jpg"></p><blockquote><p>「相遇总是藏着别离，开始是结束的开端。」</p></blockquote><p>就像金句总是会现身在坂元裕二的周遭，很多美好的事物也会在我们身边无预警的出现，如果有掌握住就可以拾成一把花束，像是那稍纵即逝的缘份。宫崎骏大家都能聊，但《攻壳机动队》的押井守可就不是人人都能搭上话题，要不是女主角绢在查觉到这么一点不一样时就及时上前搭话，也不会有后面这段恋情。而在多聊一些之后又发现两人更多相似之处，像是错过同一场展览、一样会用电影票根当书签、家里有几乎一样的藏书，连对剪刀石头布都有同一套哲学理论，各种契合都轻轻推了他们一把，命运既然让这两人遇上了，就很难不让他们在一起吧。</p><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p2625028954.webp)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV9/6332Wu.jpg"></p><h3 id="爱如花期"><a href="#爱如花期" class="headerlink" title="爱如花期"></a>爱如花期</h3><blockquote><p>「我要在几%不到的恋爱生存率下存活下来。」</p></blockquote><p>因为种种个性和兴趣上的契合，他们以相当高的机率在一起，但又有多少机率能够一起走到最后呢？两人开始同居后，日日恩爱夜夜缠绵，一起经历找工作的困顿期，一路相互扶持，过着连天使都嫉妒的生活。只是工作后开始慢慢印证了「恋爱这种东西，可不能一人一半，恋爱就是一人一份。」，两人不再像以前一样天天腻在一块，而是在自己的空间各自度过。他们的争吵总是悄悄的来又迅速的离开，也没有彼此越看越不顺眼，根本没有征兆称得上是分开的理由。</p><p>那到底是什么拆散了他们？剧本故意排除一般爱情电影会出现的「外力」，像是第三者介入、生活出现困难、健康状况恶化、家庭反对等等，让我们专心聚焦在两个人的改变上。曾经是聊起来就像势均力敌的抛接球，现在则是球被晾在一边泄了气，球员也懒得动了。我想大家看到这边会有不同看法，觉得是麦在工作上的「变」影响到生活，或是绢心态上的「不变」已经跟不上现实，但在结尾安排他们因为「耳机成对论」而撞见，证明他们还是像电影前段一样契合，单纯只是爱在他们心中开出一朵不具名的花，花语是「我爱你，但也不爱你了」。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p2617652208.webp"></p><h3 id="恋如雨止"><a href="#恋如雨止" class="headerlink" title="恋如雨止"></a>恋如雨止</h3><blockquote><p>「我们一路走来的风景很美，就只差了一步。」</p></blockquote><p>两人在谈分手时的那场戏，再次见证坂原裕二对笔下角色一点也不心软，让正在分手的两人遇见热恋时的彼此，怎么会有如此残忍的安排！看着有说有笑的年轻情侣仿佛看到了自己，想到从一开始的等待对方告白，到后来同样在等待对方把分手说出口，这难熬的时刻他们脑中应该是不断的在想，到底有什么方法可以不要改变吧，毕竟谁都不想让手臂上的成对刺青变成食言的证明。只是那些永远不变的改变，谁都阻止不了它的出现，只差最后一步却再也走不下去，食之无味弃之可惜的抉择，做什么决定都无法再完美。</p><p>看完《花束般的恋爱》，想到当年看完《乐来越爱你》的惆怅，明明是百年奇遇的天作之合，却还是敌不过爱情的质变，半衰期总是在你还没意识时就已经到来。不管是剧情本身有多贴近我们对爱情的认知，或是刻意放进许多流行文化，让我们意识到年代和我们是如此接近(《牯岭街少年杀人事件》的重映和《萨尔达传说旷野之息》都是在 2017 年 3 月的事)，并借此意识到时间的流动，去比对两人前后的变化。菅田将晖在戏外采访给麦的一句话是：「不是像花束一样的爱，而是希望成为花束。」就像最后 Google 街景见证了他们最热恋的时光，或许爱情在我们眼中最美的不是一起走到最后，而是两人最用力绽放的时候吧。</p><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/p2675132273.webp)--><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MV9/dm4GNq.jpg"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MV9.webp)--&gt;
&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MV9/MahDG4.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;山音麦和八谷绢因错过尾班车而相遇，在深夜咖啡馆聊起文学、电影和音乐，喜好竟奇蹟地相似，二人瞬间坠入爱河。他们毕业后开始一边兼职工作，一边开始同居生活，更一起养拾回来的街猫，最大的目标就是维持俩口子的日常。 但时日流逝，不想改变也得改变。他失约于《牯岭街》， 她独赏郭利斯马基黑色幽默。五年盛放，世上唯一的花未必结果，爱情若只如初见。&lt;/p&gt;</summary>
    
    
    
    <category term="影视杂谈 (Video Talk)" scheme="https://yousazoe.top/categories/%E5%BD%B1%E8%A7%86%E6%9D%82%E8%B0%88-Video-Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>Build and Run Pilot Engine</title>
    <link href="https://yousazoe.top/archives/69c425a2.html"/>
    <id>https://yousazoe.top/archives/69c425a2.html</id>
    <published>2022-05-01T08:42:50.000Z</published>
    <updated>2022-07-29T03:00:04.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104-pa1.png"></p><span id="more"></span><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h3><ul><li>Building Pilot engine development environment for upcoming programming assignments</li><li>Getting familiar with Smartchair (Assignment Submission Platform) submission flow</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Building Pilot engine development environment</p><h4 id="Downloading-Source-Code"><a href="#Downloading-Source-Code" class="headerlink" title="Downloading Source Code"></a>Downloading Source Code</h4><h4 id="Install-CMake"><a href="#Install-CMake" class="headerlink" title="Install CMake"></a>Install CMake</h4><p>Pilot Engine uses CMake to generate project files. Please refer <a href="https://cmake.org/download/">https://cmake.org/download/</a> for downloading and installing CMake</p><h4 id="Build-and-Run-Pilot"><a href="#Build-and-Run-Pilot" class="headerlink" title="Build and Run Pilot"></a>Build and Run Pilot</h4><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p><strong>Visual Studio 2019 or later</strong> is the recommended IDE on Windows.</p><h6 id="Generate-the-project-files-with-CMake"><a href="#Generate-the-project-files-with-CMake" class="headerlink" title="Generate the project files with CMake"></a>Generate the project files with CMake</h6><ul><li><p>Run the following command from <strong>Pilot root directory</strong>:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -S engine/ -B build</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h6 id="Open-Pilot-sln-with-Visual-Studio"><a href="#Open-Pilot-sln-with-Visual-Studio" class="headerlink" title="Open Pilot.sln with Visual Studio"></a>Open Pilot.sln with Visual Studio</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img10.jpg"></p><h6 id="Set-PilotEditor-project-as-Startup-Project"><a href="#Set-PilotEditor-project-as-Startup-Project" class="headerlink" title="Set PilotEditor project as Startup Project"></a>Set PilotEditor project as Startup Project</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img12.jpg"></p><h6 id="Build-Solution"><a href="#Build-Solution" class="headerlink" title="Build Solution"></a>Build Solution</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img14.jpg"></p><h6 id="Run-PilotEditor"><a href="#Run-PilotEditor" class="headerlink" title="Run PilotEditor"></a>Run PilotEditor</h6><ul><li>You can use keyboard shortcut F5 (Start debugging) or Ctrl + F5 (Start Without debugging).</li></ul><h5 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h5><p>Xcode is the recommended IDE on MacOS</p><h6 id="Generate-the-project-files-with-CMake-1"><a href="#Generate-the-project-files-with-CMake-1" class="headerlink" title="Generate the project files with CMake"></a>Generate the project files with CMake</h6><ul><li><p>Run the following command from Pilot root directory:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -S engine/ -B build -G <span class="string">"Xcode"</span></span></span><br></pre></td></tr></tbody></table></figure></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img16.jpg"></p><h6 id="Open-Pilot-xcodeproj-with-Xcode"><a href="#Open-Pilot-xcodeproj-with-Xcode" class="headerlink" title="Open Pilot.xcodeproj with Xcode"></a>Open Pilot.xcodeproj with Xcode</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img18.jpg"></p><h6 id="Set-PilotEditor-project-as-Startup-Project-1"><a href="#Set-PilotEditor-project-as-Startup-Project-1" class="headerlink" title="Set PilotEditor project as Startup Project"></a>Set PilotEditor project as Startup Project</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img20.jpg"></p><h6 id="Build-Solution-1"><a href="#Build-Solution-1" class="headerlink" title="Build Solution"></a>Build Solution</h6><ul><li>You can use keyboard shortcut ⌘B (Cmd + B)</li></ul><h6 id="Run-PilotEditor-1"><a href="#Run-PilotEditor-1" class="headerlink" title="Run PilotEditor"></a>Run PilotEditor</h6><ul><li>You can use keyboard shortcut ⌘R (Cmd + R)</li></ul><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><p>VSCode is the recommended IDE on Linux.</p><p>Following procedures were tested on Ubuntu 20.04 LTS.</p><h6 id="Configure-development-environment"><a href="#Configure-development-environment" class="headerlink" title="Configure development environment"></a>Configure development environment</h6><ul><li>Follow the instruction in README.md.</li></ul><h6 id="Open-the-root-directory-with-VSCode"><a href="#Open-the-root-directory-with-VSCode" class="headerlink" title="Open the root directory with VSCode"></a>Open the root directory with VSCode</h6><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img22.jpg"></p><h6 id="Build-Solution-2"><a href="#Build-Solution-2" class="headerlink" title="Build Solution"></a>Build Solution</h6><ul><li>Terminal → Run build task → build linux debug</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img61.jpg"></p><h6 id="Run-PilotEditor-2"><a href="#Run-PilotEditor-2" class="headerlink" title="Run PilotEditor"></a>Run PilotEditor</h6><ul><li>Run → Run Without Debugging</li></ul><h4 id="Play-around-in-PilotEditor"><a href="#Play-around-in-PilotEditor" class="headerlink" title="Play around in PilotEditor"></a>Play around in PilotEditor</h4><h5 id="Editor-Mode"><a href="#Editor-Mode" class="headerlink" title="Editor Mode"></a>Editor Mode</h5><ul><li>Translate, rotate, and scale game objects</li><li>Add and delete game objects</li><li>Reload and save current level</li></ul><h5 id="Game-Mode"><a href="#Game-Mode" class="headerlink" title="Game Mode"></a>Game Mode</h5><ul><li>Controlling the robot (ASWD to run and press shift for sprint)</li></ul><h4 id="Submission"><a href="#Submission" class="headerlink" title="Submission"></a>Submission</h4><ul><li>After running PilotEditor successfully, choose your favorite view and take a screenshot.</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/img63.jpg"></p><ul><li><p>Submit the screenshot image on Smartchair.</p><p>For SmartChair operating instructions, please refer:</p><ul><li><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_SmartChair_Submission_Guide.pdf">https://cdn.boomingtech.com/games104_static/upload/GAMES104_SmartChair_Submission_Guide.pdf</a></li></ul></li></ul><h4 id="Deadline"><a href="#Deadline" class="headerlink" title="Deadline"></a>Deadline</h4><ul><li>Deadline for submmision: <strong>GMT+8 20::00::00 Apr 18, 2022</strong></li></ul><h3 id="Grading-and-Q-amp-A"><a href="#Grading-and-Q-amp-A" class="headerlink" title="Grading and Q&amp;A"></a>Grading and Q&amp;A</h3><ul><li>The objectives for this assignment are building development environment and getting familiar with Smartchair submission flow. So this assignment will not be graded.</li><li>If you have any question during building Pilot development envrionment, you can ask in our Wechat Course Group or post on our course forum. Course Team and Course Supporters will answer.<ul><li><strong>Course Forum</strong> : <a href="https://games-cn.org/forums/forum/games104-forum/">https://games-cn.org/forums/forum/games104-forum/</a></li><li><strong>Wechat Course Group</strong> : Please add <strong>gameswebinar</strong> as Friend and send “<strong>104</strong>“ to enter the course group</li></ul></li></ul><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><ul><li>Each assignments must be accomplished independently.</li><li>Please submit your assignment before the deadline.</li></ul><br><center><a class="btn" href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_PA01.pdf">            <i class="fas fa-download"></i>GAMES104_PA01          </a></center></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104-pa1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
  <entry>
    <title>Rendering on Game Engine</title>
    <link href="https://yousazoe.top/archives/7d19d591.html"/>
    <id>https://yousazoe.top/archives/7d19d591.html</id>
    <published>2022-04-05T12:21:32.000Z</published>
    <updated>2022-07-29T03:00:04.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0001.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的渲染实践。</p><span id="more"></span><!--suppress ALL --><iframe src="//player.bilibili.com/player.html?aid=767919594&amp;bvid=BV14r4y1p7tt&amp;cid=570873645&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="Rendering-System-in-Games"><a href="#Rendering-System-in-Games" class="headerlink" title="Rendering System in Games"></a>Rendering System in Games</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0002.jpg"></p><p>从游戏刚刚开始的时候，我们就和绘制渲染走在一起。</p><p>最早的游戏需要显示在示波器上，而那时我们就已经想努力表现画面了。到了红白机时代即使硬件只能显示几种颜色，人们依旧构建了绘制系统奉献了诸多优秀的游戏。实际上现代游戏的绘制系统越来越丰富，越来越复杂，很多人提到游戏引擎下意识会说：“游戏引擎是不是就是绘制引擎？”。游戏引擎显然不止绘制，但它从技术难度和专业壁垒来讲确实是非常重要的一环。</p><p>那么这里顺带一提，没有渲染系统的游戏也是存在的：文字游戏。</p><h4 id="Rendering-on-Graphics-Theory"><a href="#Rendering-on-Graphics-Theory" class="headerlink" title="Rendering on Graphics Theory"></a>Rendering on Graphics Theory</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0003.jpg"></p><p>GAMES101 课程给大家系统地讲了计算机图形学的一些理论，这些算法是游戏渲染的基础。但同时游戏的渲染也存在一些区别：</p><ul><li>图形学解决的问题是明确的</li><li>图形学不会特别关注硬件是如何实现的，而更关注算法和数学上的正确性</li><li>实时 Realtime（30 FPS）/ 交互 Interactive（10 FPS）/ 离线渲染 Offline Rendering</li></ul><h4 id="Challenges-on-Game-Rendering"><a href="#Challenges-on-Game-Rendering" class="headerlink" title="Challenges on Game Rendering"></a>Challenges on Game Rendering</h4><p>在游戏中的绘制系统我们遇到的挑战都有什么呢？</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0004.jpg"></p><p>第一个挑战是游戏中需要处理的物体对象和各种效果是极其复杂的。举个例子，在我的场景中有成千上万的对象，并且每个对象的形式都不尽相同：植被、角色、天空云……我们需要用到的算法也随之不同，整体上还要加大量的后处理和光照运算，所以游戏的绘制系统是一个 All in One 的组合。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0005.jpg"></p><p>第二个挑战是我们并不是跑在一个理想的设备上，我们的任务不是验证其正确性而是让它跑在现代的设备上。所有的算法必须基于这些 PC、主机或者小小的 Switch 上面，所以需要我们对硬件的了解非常深，适配当代的硬件。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0006.jpg"></p><p>第三个挑战是在图形学效果不错的帧率放到游戏中可能就不够看了，并且帧率必须要稳定。近年的游戏给我们的时间越来越少，画面要求却越来越高。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0007.jpg"></p><p>最后一个挑战是显卡可以 100% 吃掉，但 CPU 的利用率却提不起来。所以在真实的游戏引擎中我们不能像计算机图形学项目那样把所有计算资源全部吃掉，需要留给前面说的游戏逻辑、物理、人工智能等等系统。</p><h4 id="Rendering-on-Game-Engine"><a href="#Rendering-on-Game-Engine" class="headerlink" title="Rendering on Game Engine"></a>Rendering on Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0008.jpg"></p><p>在讲之前需要说明，接下来要讲的所有东西它不是一个理论模型，它是一个工程实践经过这个行业近三十年迭代优化的软件工程系统，属于实践科学。</p><h4 id="Outline-of-Rendering"><a href="#Outline-of-Rendering" class="headerlink" title="Outline of Rendering"></a>Outline of Rendering</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0009.jpg"></p><p>如何把游戏引擎的渲染系统简化到四节课中呢？</p><ol><li><p><strong>Basics of Game Rendering</strong></p><p>基础 GPU 硬件、渲染数据组织结构、可见性裁剪等基础内容</p></li><li><p><strong>Materials, Shaders and Lighting</strong></p><p>现代游戏的光照模型、标准的材质系统、着色模型等行业标杆内容</p></li><li><p><strong>Special Rendering</strong></p><p>地形系统、天空/烟雾系统以及后处理系统等重要的引擎子系统内容</p></li><li><p><strong>Pipeline</strong></p><p>渲染管线以及前沿渲染技术</p></li></ol><h4 id="What-is-not-Included"><a href="#What-is-not-Included" class="headerlink" title="What is not Included"></a>What is not Included</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0010.jpg"></p><p>卡通化渲染、二维渲染引擎、毛发皮肤材质渲染等等由于课程安排原因暂时无法涉及。</p><h3 id="Building-Blocks-of-Rendering"><a href="#Building-Blocks-of-Rendering" class="headerlink" title="Building Blocks of Rendering"></a>Building Blocks of Rendering</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0011.jpg"></p><h4 id="Rendering-Pipeline-and-Data"><a href="#Rendering-Pipeline-and-Data" class="headerlink" title="Rendering Pipeline and Data"></a>Rendering Pipeline and Data</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0012.jpg"></p><p>渲染其实看起来也没那么难，就是空间上的顶点连城一个个的面，这些面经过一个投影矩阵投到我的屏幕上，再光栅化成一个个小像素点，在每个像素点上找到对应的材质、纹理渲染成各种各样的颜色，最后做出我们的效果。</p><h4 id="Computation-Projection-and-Rasterization"><a href="#Computation-Projection-and-Rasterization" class="headerlink" title="Computation - Projection and Rasterization"></a>Computation - Projection and Rasterization</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0013.jpg"></p><p>这里面我们可以看到绘制最核心的工作是 Computation，最基础的则是投影和光栅化。这些在 101 课程中讲得比较多，我们找一个相机位置进行（正交/透视）投影，然后得到屏幕空间的三角形之后把它光栅化成一个一个的像素，这就是我们的投影。</p><h4 id="Computation-Shading"><a href="#Computation-Shading" class="headerlink" title="Computation - Shading"></a>Computation - Shading</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0014.jpg"></p><p>投影光栅化之后就开始对它进行着色绘制。这里我们取一段简单的代码示例，可以发现它的运算也就几种：从常量里取常量，例如屏幕的长宽像素都是常数；中间会做大量加减乘除运算，例如 Phong 模型需要知道法线在哪里、光线在哪里、眼睛在哪里就可以算出来光有多少会被衰减掉；图中的小球上有很多花纹需要存到二维的贴图上……这些东西就像炒一盘菜，用这几种数学运算、常数变量的访问才能得到想要的结果。</p><h4 id="Computation-Texture-Sampling"><a href="#Computation-Texture-Sampling" class="headerlink" title="Computation - Texture Sampling"></a>Computation - Texture Sampling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0015.jpg"></p><p>这个东西听上去很简单，但这里面 Texture 的过程十分的复杂。</p><p>我们在人身上贴个花纹做个砖墙，离你很近的时候会看到一个一个的像素，但离你非常非常远的时候在屏幕上看到的像素其实隔了很多像素。这个时候如果我们不去对它低频滤波的话，那么当砖墙由近及远移动的时候画面会一直在抖动：走样。</p><p>在纹理上我们每一张贴图会存很多很多层，当我作为一个屏幕上小小的像素点取一个纹理的时候实际上要取四个点对它进行插值，然后还要每层三次双线性差值。图中也表明了要取 8 个像素点，所以纹理映射一次需要 3 + 3 + 1 = 7 次插值。</p><h4 id="Understand-the-Hardware"><a href="#Understand-the-Hardware" class="headerlink" title="Understand the Hardware"></a>Understand the Hardware</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0016.jpg"></p><p>所以要隆重介绍今天的主角：GPU 或者大家平时讲的显卡。</p><p>显卡是一个非常了不起的发明创造，现代很多引擎能够有突飞猛进的变化就是因为独立显卡的出现许多复杂的运算可以通过更高效的机器处理，这样极大地解放了 CPU，游戏画面也越来越精细。</p><p>如果你想成为一名游戏引擎的图形程序员，那这是你最好的伙伴。</p><h4 id="SIMD-and-SIMT"><a href="#SIMD-and-SIMT" class="headerlink" title="SIMD and SIMT"></a>SIMD and SIMT</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0017.jpg"></p><p>要想了解显卡，首先要建立两个概念：SIMD（Single Instruction Multiple Data）和 SIMT（Single Instruction Multiple Threads）。</p><p>听上去很高大上，其实 SIMD 就是 CPU 广泛使用的单指令多数据数据运算，例如做一次加法运算它的 <code>x</code>、<code>y</code>、<code>z</code>、<code>w</code> 四个坐标同时运算，一个指令完成四个加法或者四个减法。想象一下我们在渲染的时候就是有大量的矩阵、坐标运算，SIMD 就是我们最好的朋友。</p><p>但是在现代显卡里 SIMT 的概念更有趣值得了解。它的想法是如果我的计算内核做的很小但有很多个，这样一条指令可以在很多核上做同样的指令操作。假设我有 100 个核，一条指令就可以做 100 个数的加减乘除，我的计算效率可以 * 4 * 100 = 400。现代显卡类似于一个大蜂巢，里面包含了无数个小小的核，也是为什么现代显卡算力强的原因。</p><p>SIMT 结构给我们一个启示，在做绘制渲染的时候要尽可能用同样的代码让大家一起跑，每个人分别访问自己的数据，这样会在显卡上跑得非常快远远超过在 CPU 上算出来的东西，这是做图形程序最重要要掌握的概念。</p><h4 id="GPU-Architecture"><a href="#GPU-Architecture" class="headerlink" title="GPU Architecture"></a>GPU Architecture</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0018.jpg"></p><p>有了这些概念就可以窥探一下现代 GPU 的架构了。</p><p>这张图是十年前 N 卡的费米架构。一块显卡上放了很多的内核，但它分成一组一组的，每一组叫作 GPC（Graphics Processing Cluster）图形处理集群。在图形处理集群里面可以看到很多的 SM（Streaming Multiprocessor），这些 SM 包含了许多小内核，N 卡一般放的是 CUDA 内核。这些内核会处理大量的数学运算，其专门的硬件会支持前面提到的纹理采样的工作，包括比较复杂的数学运算也是由 RT Core 去做支撑。</p><h4 id="Data-Flow-from-CPU-to-GPU"><a href="#Data-Flow-from-CPU-to-GPU" class="headerlink" title="Data Flow from CPU to GPU"></a>Data Flow from CPU to GPU</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0019.jpg"></p><p>我们的数据在计算机里流动的时候是有成本的。</p><p>从计算机诞生开始的时候用的是冯诺依曼架构：计算和数据分开。这个架构会让硬件设计变得比较简单，但带来的问题是我每一个计算都需要去找数据，而找数据并在计算单元中搬来搬去这件事又特别特别慢。</p><p>所以游戏引擎设计中有一个原则就是数据尽量单向传输，CPU 送到显卡，尽可能不要从显卡里读数据。</p><h4 id="Be-Aware-of-Cache-Efficiency"><a href="#Be-Aware-of-Cache-Efficiency" class="headerlink" title="Be Aware of Cache Efficiency"></a>Be Aware of Cache Efficiency</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0020.jpg"></p><p>下一个概念是 Cache 缓存。</p><p>缓存对现代计算的影响是非常非常大的，可能远远超过大家的想象。在 CPU 上如果做一次加减乘除，可能一个 clock 就做完了；但是 A + B 的 A 找不到了，要从内存里取数据实际上要等 100 多个时钟周期。</p><p>做计算的时候如果数据恰好都在缓存上，我们称为 cache-hit 缓存被命中；数据不在缓存中则称为 cache-miss。所以在计算机图形中如果纹理没做好老是让计算机产生 cache-miss 效率会直线下降。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0021.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0022.jpg"></p><p>支持游戏的硬件结构一直在变，从 DX11 时代就可以做细分曲面、更加灵活的 Shader，到今天可以更灵活处理的 Mesh Shader。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0023.jpg"></p><p>主机是 UMA 内存共享的架构，对于引擎而言又是另一种情况。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0024.jpg"></p><p>移动端的游戏则更加考虑手机处理芯片的能力，许多采用的是 Tiled-Based Rendering。游戏引擎的架构都是和硬件的架构息息相关的，所以在讲渲染之前特别希望先了解一下显卡是如何工作的。</p><h3 id="Renderable"><a href="#Renderable" class="headerlink" title="Renderable"></a>Renderable</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0025.jpg"></p><h4 id="Mesh-Render-Component"><a href="#Mesh-Render-Component" class="headerlink" title="Mesh Render Component"></a>Mesh Render Component</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0026.jpg"></p><p>上节课我们讲到 GameObject 构建了这个世界，但需要区分逻辑表达的游戏对象和真实绘制的东西。</p><p>在 Mesh Render Component 中一般会存 Renderable 可绘制物体，这是我们绘制系统的核心数据对象。</p><h4 id="Building-Blocks-of-Renderable"><a href="#Building-Blocks-of-Renderable" class="headerlink" title="Building Blocks of Renderable"></a>Building Blocks of Renderable</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0027.jpg"></p><p>那么一个 Renderable 是怎么来的呢？</p><p>先来看物体本身吧，以图中这个士兵角色为例，他有 Mesh 网格和几何形体，每一个 Mesh 有各种各样的金属皮肤材质，这些材质上还有许多花纹 Texture，其实还有 Normal 去表达 Mesh 表达不了的细节……这就是 Renderable 最简单的一个 Building Block。</p><h4 id="Mesh-Primitive"><a href="#Mesh-Primitive" class="headerlink" title="Mesh Primitive"></a>Mesh Primitive</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0028.jpg"></p><p>Mesh 在引擎中是怎么表达呢？</p><p>首先我们需要先定义一个 Mesh Primitive，最简单的顶点应该包含位置、法线朝向、uv 以及其他各种各样的属性。而每三个顶点放在一起则构成了一个三角形，许多三角形放在一起就形成了表面外观。</p><figure class="highlight glsl"><table><tbody><tr><td class="code"><pre><span class="line">struct Vertex</span><br><span class="line">{</span><br><span class="line">    Vector3 m_position;</span><br><span class="line">    <span class="comment">// other data</span></span><br><span class="line">    UByte4 m_color;</span><br><span class="line">    Vector3 m_normal;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct Triangle</span><br><span class="line">{</span><br><span class="line">    Vertex m_vertex[<span class="number">3</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Vertex-and-Index-Buffer"><a href="#Vertex-and-Index-Buffer" class="headerlink" title="Vertex and Index Buffer"></a>Vertex and Index Buffer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0029.jpg"></p><p>但是上面的存储方式很笨，如果同学们写过 OpenGL 或者 DirectX 基础的图形学代码就会知道我们会把数据用 Index Data 和 Vertex Data 去定义。我们把所有的顶点放在一起，三角形不会再把顶点数据再存一遍，而只存顶点的索引值。</p><p>实际模型中会发现很多顶点是被很多三角形公用的，数学也可以算出来顶点数量大约是三角面的一半，而三角形又有三个顶点，理论上使用 Index 这种存储方法可以节约六倍以上。</p><h4 id="Why-We-Need-Per-Vertex-Normal"><a href="#Why-We-Need-Per-Vertex-Normal" class="headerlink" title="Why We Need Per-Vertex Normal"></a>Why We Need Per-Vertex Normal</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0030.jpg"></p><p>为什么每个顶点都要存一个法向？</p><p>这里面有一个很简单的数学知识，虽然三角形三个顶点可以算出顶点朝向在大部分情况下是对的，但一旦表面是硬表面有一条折线的时候，我们会发现两个顶点的位置是重合的法向却完全不一样。</p><p>所以在写游戏引擎的绘制系统定义顶点数据时一定要单独定义法向方向。</p><h4 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0031.jpg"></p><p>材质系统来自于我们真实的生活，表达上接近于我们在物理世界对物体的感知。</p><p>这些材质系统需要和后面物理系统的物理材质做一些区分，物理材质更多的是表达物体的摩擦系数、弹性等等……和这里的材质相近，但在现代引擎的绘制系统定义的只是视觉材质，物理材质则会单独定义。</p><h4 id="Famous-Material-Models"><a href="#Famous-Material-Models" class="headerlink" title="Famous Material Models"></a>Famous Material Models</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0032.jpg"></p><p>材质系统经过图形学发展，从经典的 Phong 模型到现在的 Physically Based Rendering PBR 模型，包括一些特殊的效果如半透明材质，我们其实已经积累了很多非常优质的材质模型。</p><h4 id="Various-Texture-in-Materials"><a href="#Various-Texture-in-Materials" class="headerlink" title="Various Texture in Materials"></a>Various Texture in Materials</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0033.jpg"></p><p>有了这些材质模型，我们需要纹理。</p><p>表达材质的时候纹理扮演了非常非常重要的作用，现代引擎里你觉得材质像金属还是非金属表面并不是由材质的参数决定的，很多时候是由纹理决定的。</p><h4 id="Variety-of-Shaders"><a href="#Variety-of-Shaders" class="headerlink" title="Variety of Shaders"></a>Variety of Shaders</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0034.jpg"></p><p>那是不是我们有了材质的表达、纹理、Mesh 就能绘制出我的东西呢？ 这里面有个无名英雄：Shader。</p><h3 id="Render-Objects-in-Engine"><a href="#Render-Objects-in-Engine" class="headerlink" title="Render Objects in Engine"></a>Render Objects in Engine</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0035.jpg"></p><h4 id="Coordinate-System-and-Transformation"><a href="#Coordinate-System-and-Transformation" class="headerlink" title="Coordinate System and Transformation"></a>Coordinate System and Transformation</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0036.jpg"></p><p>先来做个投影变换吧。</p><p>首先给物体乘模型矩阵从自身的坐标系移到世界坐标系；之后确定相机位置用一个视图矩阵再投影到相机坐标系；最后再选择正交或者透视投影变成屏幕坐标系里的东西。</p><h4 id="Object-with-Many-Materials"><a href="#Object-with-Many-Materials" class="headerlink" title="Object with Many Materials"></a>Object with Many Materials</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0037.jpg"></p><p>接下来先把 Vertex Buffer、Index Buffer 这些 Mesh 的东西提交上去，然后把材质参数、Texture 和 Shader 提交给显卡，一个物体就被绘制出来了。</p><p>这样我们就从一个抽象的 GameObject 游戏对象变成了一个 Renderable 绘制物体。</p><h4 id="How-to-Display-Different-Textures-on-a-Single-Model"><a href="#How-to-Display-Different-Textures-on-a-Single-Model" class="headerlink" title="How to Display Different Textures on a Single Model"></a>How to Display Different Textures on a Single Model</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0038.jpg"></p><p>但有些聪明的小伙伴会发现，这个物体并不是单一材质纹理的，这些数据又该如何去整理呢？这里我们想引入一个非常重要的概念：SubMesh。</p><p>现代游戏引擎中对一个 GO 会根据它材质的不同切分成子 Mesh，每个 SubMesh 会对应自己的材质纹理和着色器代码。但是一般会把它的顶点、三角形全部放到一个大的 Buffer 里面去，每个 SubMesh 只需要存一个偏移量就好了。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0039.jpg"></p><p>但在绘制多个对象的时候如果每一个 GO 都存储整套 Mesh 和材质，这个数据量会非常的大。仔细观察这些 Mesh 和贴图，你会发现它们其实都是一样的，那我们怎么节约这个空间呢？</p><h4 id="Resource-Pool"><a href="#Resource-Pool" class="headerlink" title="Resource Pool"></a>Resource Pool</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0040.jpg"></p><p>现代引擎中我们一般的做法是建立一个 Pool，把所有的 Mesh、Texture 放在一起。</p><h4 id="Instance-Use-Handle-to-Reuse-Resources"><a href="#Instance-Use-Handle-to-Reuse-Resources" class="headerlink" title="Instance: Use Handle to Reuse Resources"></a>Instance: Use Handle to Reuse Resources</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0041.jpg"></p><p>这样的话当我绘制一个拥有各种各样小兵的场景，你会发现它只是通过一个指引指向了各自所需要的材质、Mesh 网格。这是游戏引擎很经典的架构：Instance 实例化。</p><h4 id="Sort-by-Material"><a href="#Sort-by-Material" class="headerlink" title="Sort by Material"></a>Sort by Material</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0042.jpg"></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Initalize Resource Pools</span><br><span class="line">Load Resource</span><br><span class="line"></span><br><span class="line">Sort <span class="built_in">all</span> Submeshes by Materials</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each Materials</span><br><span class="line">   Update Parameters</span><br><span class="line">   Update Textures</span><br><span class="line">   Update Shader</span><br><span class="line">   Update VetexBuffer</span><br><span class="line">   Update IndexBuffer</span><br><span class="line">   <span class="keyword">for</span> each Submeshes</span><br><span class="line">      Draw Primitive</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><h4 id="GPU-Batch-Rendering"><a href="#GPU-Batch-Rendering" class="headerlink" title="GPU Batch Rendering"></a>GPU Batch Rendering</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0043.jpg"></p><p>实际上很多子物体是一模一样的，这些物体依次设置 VertexBuffer、IndexBuffer 也是很浪费的。所以我们现在可以一个 DrawCall 设置一次 VB、IB 把成百上千个东西全部创建出来，这就是 GPU Batch Rendering 的思想。</p><p>总结下来就是现在的游戏引擎架构中，我们会尽可能把绘制计算交给 GPU 而非 CPU。</p><h3 id="Visibility-Culling"><a href="#Visibility-Culling" class="headerlink" title="Visibility Culling"></a>Visibility Culling</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0044.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0045.jpg"></p><p>现在我们已经可以绘制画面了，但它并不高效。</p><p>事件锥实际上是一个锥形的东西，绝大部分东西我们是看不见的。如图当相机开始移动的时候，其实 7～80% 的空间我们是看不见的，那里面的物体、地形、粒子效果可以不绘制。<strong>可见性裁剪</strong> 是游戏系统中很基层的底层系统。</p><h4 id="Culling-One-Object"><a href="#Culling-One-Object" class="headerlink" title="Culling One Object"></a>Culling One Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0046.jpg"></p><p>那这个可见性裁剪如何去实现呢？</p><p>上节课我们讲过每个物体都有包围盒，当我们给一个四棱锥的 view frustum 可以判断包围盒是不是在事件锥里面，这其实就是 Culling 一个最基础的思想。</p><h4 id="Using-the-Simplest-Bound-to-Create-Culling"><a href="#Using-the-Simplest-Bound-to-Create-Culling" class="headerlink" title="Using the Simplest Bound to Create Culling"></a>Using the Simplest Bound to Create Culling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0047.jpg"></p><p>包围盒是一个非常重要的概念。</p><p>它有很多种形式，最基础的是把整个物体包围进球里的 Bounding Sphere，也有更常用的 AABB 轴对称包围盒，存储两个端点就可以构建出 AABB Box，而且它的计算效率也是最高的。 有的时候我们的包围盒是贴着物体，被称为 Oriented Bounding Box：OBB；还有用凸包 Convex Hull 的包围盒……</p><p>所以其实无论我们在做什么，对物体形状的表达是非常复杂的。例如一个角色包含几万个面，不可能和这几万个面进行一一计算，而包围盒大致表真判断结果是很多计算的基础。</p><h4 id="Hierarchical-View-Frustum-Culling"><a href="#Hierarchical-View-Frustum-Culling" class="headerlink" title="Hierarchical View Frustum Culling"></a>Hierarchical View Frustum Culling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0048.jpg"></p><p>上节课我们还讲了对空间里的物体进行各种各样的划分，诸如四叉树、BVH 可以让 Culling 运算一层层去问，计算复杂度也会下降非常多。</p><h4 id="Construction-and-Insertion-of-BVH-in-Game-Engine"><a href="#Construction-and-Insertion-of-BVH-in-Game-Engine" class="headerlink" title="Construction and Insertion of BVH in Game Engine"></a>Construction and Insertion of BVH in Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0049.jpg"></p><p>BVH 算是现代游戏引擎最普遍的选择。</p><p>虽然它很简单也不是最高效的算法，但现代游戏里”动”的东西很多，当 BVH 构建好但节点发生变动，重新构建的成本要尽可能的低。</p><h4 id="PVS-Potential-Visibility-Set"><a href="#PVS-Potential-Visibility-Set" class="headerlink" title="PVS(Potential Visibility Set)"></a>PVS(Potential Visibility Set)</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0050.jpg"></p><p>其中我想介绍一个非常有意思的算法：PVS。</p><p>我们首先用 BSP-Tree 把空间划分成一个个小的格子，每个格子通过 Portal 连接。假设现在我们身处豪华的大平层，有很多房间，那么身处任意一个房间通过 Portal 看到的房间是固定的。</p><h4 id="Portal-and-PVS-Data"><a href="#Portal-and-PVS-Data" class="headerlink" title="Portal and PVS Data"></a>Portal and PVS Data</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0051.jpg"></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> each portals</span><br><span class="line">   getSamplingPoints();</span><br><span class="line">   <span class="keyword">for</span> each portal faces</span><br><span class="line">      <span class="keyword">for</span> each leaf</span><br><span class="line">         do ray casting between portal face <span class="keyword">and</span> leaf</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>所以 PVS 的想法非常淳朴，身处某个房间通过门或窗最多能看到哪几个房间。如图你站在七号房间，最多只能看到 6-1-2-3 四个房间，意味着只需要渲染这四个房间。</p><h4 id="The-Idea-of-Using-PVS-in-Stand-alone-Games"><a href="#The-Idea-of-Using-PVS-in-Stand-alone-Games" class="headerlink" title="The Idea of Using PVS in Stand-alone Games"></a>The Idea of Using PVS in Stand-alone Games</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0052.jpg"></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> each GreenBoxs</span><br><span class="line">   <span class="keyword">for</span> each BlueCells</span><br><span class="line">      do ray casting between box <span class="keyword">and</span> cell</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>其实真正应用 PVS 的已经不多了，但这个思想非常有用，帮助我们对资源进行调度。</p><h4 id="GPU-Culling"><a href="#GPU-Culling" class="headerlink" title="GPU Culling"></a>GPU Culling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0053.jpg"></p><p>随着硬件性能发生突飞猛进的变化，越来越多的 Culling 已经不再用这些传统的算法裁剪，GPU Based Culling 就可以完成。</p><h3 id="Texture-Compression"><a href="#Texture-Compression" class="headerlink" title="Texture Compression"></a>Texture Compression</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0054.jpg"></p><h4 id="Texture-Compression-1"><a href="#Texture-Compression-1" class="headerlink" title="Texture Compression"></a>Texture Compression</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0055.jpg"></p><p>游戏引擎里一般不会以图片的形式存储纹理，取而代之会把纹理进行压缩。 绘制系统中不能用那些非常好的算法，因为这些算法不能随机访问，而且计算复杂度非常高。 </p><h4 id="Block-Compression"><a href="#Block-Compression" class="headerlink" title="Block Compression"></a>Block Compression</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0056.jpg"></p><p>我们一般采取的策略是 Block Based，把图片切成一个个小块再压缩。</p><p>这里介绍一个非常经典的算法，假设我有一个 4x4 的小色块，找出颜色最鲜艳和最暗淡的点，我们认为其他点都是这两个点的差值。因为很多图片相邻像素都有关联度，所以可以通过两个极值的比例关系近似表达这个像素的颜色。</p><p>其实整个计算机图形学的 Texture Compression 都是基于这个这个 Block Compression 思想。</p><h3 id="Authoring-Tools-of-Modeling"><a href="#Authoring-Tools-of-Modeling" class="headerlink" title="Authoring Tools of Modeling"></a>Authoring Tools of Modeling</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0057.jpg"></p><h4 id="Modeling-Polymodeling"><a href="#Modeling-Polymodeling" class="headerlink" title="Modeling - Polymodeling"></a>Modeling - Polymodeling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0058.jpg"></p><p>构建一个模型最经典的是 3DMAX、MAYA 以及现在越来越流行的 BLENDER，点线面去构建各种各样酷炫的模型。</p><h4 id="Modeling-Sculpting"><a href="#Modeling-Sculpting" class="headerlink" title="Modeling - Sculpting"></a>Modeling - Sculpting</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0059.jpg"></p><p>ZBrush 雕刻性的素材生成工具正在替代传统建模方式。</p><p>真实世界塑造形体的时候雕刻家会不断把材料切削掉成自己的形状，实际上这种雕刻行为在计算机里可以更自由，构建更加自由的形体。</p><h4 id="Modeling-Scanning"><a href="#Modeling-Scanning" class="headerlink" title="Modeling - Scanning"></a>Modeling - Scanning</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0060.jpg"></p><p>实体扫描建模得益于深度学习算法的提升，可以得到高精度细腻的网格，远远超过手工构建。</p><h4 id="Modeling-Procedural-Modeling"><a href="#Modeling-Procedural-Modeling" class="headerlink" title="Modeling - Procedural Modeling"></a>Modeling - Procedural Modeling</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0061.jpg"></p><p>通过一些算法或者规则自动生成网格的程序化建模可以把我们的艺术家从繁琐的细节工作解放出来，专注于创意本身。</p><h4 id="Comparison-of-Authoring-Methods"><a href="#Comparison-of-Authoring-Methods" class="headerlink" title="Comparison of Authoring Methods"></a>Comparison of Authoring Methods</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0062.jpg"></p><p>这四种方法各有利弊。</p><h3 id="Cluster-Based-Mesh-Pipeline"><a href="#Cluster-Based-Mesh-Pipeline" class="headerlink" title="Cluster-Based Mesh Pipeline"></a>Cluster-Based Mesh Pipeline</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0063.jpg"></p><h4 id="Sculpting-Tools-Create-Infinite-Details"><a href="#Sculpting-Tools-Create-Infinite-Details" class="headerlink" title="Sculpting Tools Create Infinite Details"></a>Sculpting Tools Create Infinite Details</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0064.jpg"></p><h4 id="Cluster-Based-Mesh-Pipeline-1"><a href="#Cluster-Based-Mesh-Pipeline-1" class="headerlink" title="Cluster-Based Mesh Pipeline"></a>Cluster-Based Mesh Pipeline</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0065.jpg"></p><p>Cluster-Based Mesh Pipeline 是一种新的模型表达管线。</p><p>它的基本思想是当我面对一个非常精细的模型时，我把它分成一个一个的小 Cluster。这样做的目的在于现代计算机显卡已经能够基于数据非常高效的创建几何细节，而传统管线则要预先把 VertexBuffer、IndexBuffer 构建好。</p><h4 id="Programmable-Mesh-Pipeline"><a href="#Programmable-Mesh-Pipeline" class="headerlink" title="Programmable Mesh Pipeline"></a>Programmable Mesh Pipeline</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0066.jpg"></p><p>随着硬件的发展，MeshShader 可以用一个算法基于数据凭空生成很多的几何，还可以根据相机的远近选择精度。 </p><h4 id="GPU-Culling-in-Cluster-Based-Mesh"><a href="#GPU-Culling-in-Cluster-Based-Mesh" class="headerlink" title="GPU Culling in Cluster-Based Mesh"></a>GPU Culling in Cluster-Based Mesh</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0067.jpg"></p><h4 id="Nanite"><a href="#Nanite" class="headerlink" title="Nanite"></a>Nanite</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0068.jpg"></p><p>Nanite 则是在此基础上更符合工业化更加成熟，也是现代游戏引擎发展的一个重要方向。</p><h4 id="Take-Away"><a href="#Take-Away" class="headerlink" title="Take Away"></a>Take Away</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0069.jpg"></p><ol><li><p>游戏引擎的绘制系统是工程科学，非常依赖于现代图形硬件的理解</p></li><li><p>游戏引擎需要解决的核心是模型、材质和网格这些数据之间的关系</p></li><li><p>绘制时尽可能通过一些运算把绘制减到越少越好</p></li><li><p>绘制和一些复杂处理尽可能从 CPU 移到 GPU</p></li></ol><h3 id="PILOT"><a href="#PILOT" class="headerlink" title="PILOT"></a>PILOT</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0070.jpg"></p><h4 id="Pilot-Engine-Editor-and-Game"><a href="#Pilot-Engine-Editor-and-Game" class="headerlink" title="Pilot Engine - Editor and Game"></a>Pilot Engine - Editor and Game</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0071.jpg"></p><h4 id="Pilot-Engine-Source-Code"><a href="#Pilot-Engine-Source-Code" class="headerlink" title="Pilot Engine - Source Code"></a>Pilot Engine - Source Code</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0072.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0073.jpg"></p><h4 id="Pilot-Engine-Download"><a href="#Pilot-Engine-Download" class="headerlink" title="Pilot Engine Download"></a>Pilot Engine Download</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0074.jpg"></p><h4 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0075.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0076.jpg"></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0077.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0078.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0079.jpg"></p><br><center><a class="btn" href="https://slides.games-cn.org/course/GAMES104_Lecture04.pdf">            <i class="fas fa-download"></i>GAMES104_Lecture_04          </a></center></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture04_page-0001.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的渲染实践。&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
  <entry>
    <title>How to Build a Game World</title>
    <link href="https://yousazoe.top/archives/a8468b72.html"/>
    <id>https://yousazoe.top/archives/a8468b72.html</id>
    <published>2022-03-28T13:46:17.000Z</published>
    <updated>2022-07-29T03:00:04.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的数据组织和管理。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=640213987&amp;bvid=BV1YY4y1p74P&amp;cid=561986062&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="How-to-bring-the-game-world-to-life"><a href="#How-to-bring-the-game-world-to-life" class="headerlink" title="How to bring the game world to life"></a>How to bring the game world to life</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0002.jpg"></p><p>上一节课我们介绍了游戏引擎的基本结构。</p><p>有了这些知识只是知道这栋大厦长得是什么样子，但是我们并不知道里面的砖石、水电是怎么 work 的。而今天我们将带大家了解怎么去构建一个游戏世界。</p><h4 id="Dynamic-Game-Objects"><a href="#Dynamic-Game-Objects" class="headerlink" title="Dynamic Game Objects"></a>Dynamic Game Objects</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0003.jpg"></p><p>首先的话我们需要对游戏世界进行拆解。</p><p>如图所示，坦克、士兵等动态的游戏对象是我们最容易关注的东西，在现代游戏引擎里被称为 Dynamic Game Objects。</p><h4 id="Static-Game-Object"><a href="#Static-Game-Object" class="headerlink" title="Static Game Object"></a>Static Game Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0004.jpg"></p><p>另一类与之相对的就是静态物体。</p><p>例如高高的瞭望塔、机场的机棚、房子等，虽然这些物体无法交互，但是整个构成了游戏的各种各样的 GamePlay 元素。</p><h4 id="Environments"><a href="#Environments" class="headerlink" title="Environments"></a>Environments</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0005.jpg"></p><p>除了静态物和动态物之外还有无处不在的地形系统，它是支撑前面两者的托盘。</p><h4 id="Other-Game-Object"><a href="#Other-Game-Object" class="headerlink" title="Other Game Object"></a>Other Game Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0006.jpg"></p><p>游戏中还存在大量的物体例如检测体、空气墙等等，甚至玩法规则本身也可以抽象成一个物体。</p><h4 id="Everything-is-a-Game-Object"><a href="#Everything-is-a-Game-Object" class="headerlink" title="Everything is a Game Object"></a>Everything is a Game Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0007.jpg"></p><p>无论你是静态的还是动态的，我们都会把它统一抽象为 <strong>游戏对象</strong>（Game Object）。现代游戏引擎中我们一般会把所有的这些东西全部统一抽象成 GO。</p><h4 id="How-to-Describe-a-Game-Object"><a href="#How-to-Describe-a-Game-Object" class="headerlink" title="How to Describe a Game Object"></a>How to Describe a Game Object</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0008.jpg"></p><h4 id="How-Do-We-Describe-a-Drone-in-Reality"><a href="#How-Do-We-Describe-a-Drone-in-Reality" class="headerlink" title="How Do We Describe a Drone in Reality"></a>How Do We Describe a Drone in Reality</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0009.jpg"></p><p>当我们在游戏世界描述物体的时候可以归类成两类：属性（property）和行为（behavior）。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0010.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Drone</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/* Properties */</span> </span><br><span class="line">Vector3 position;</span><br><span class="line"><span class="type">float</span> health;</span><br><span class="line">    <span class="type">float</span> fuel;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Behavior */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scout</span><span class="params">()</span></span>;</span><br><span class="line">... </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0011.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArmedDrone</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/* Properties */</span> </span><br><span class="line">Vector3 position;</span><br><span class="line"><span class="type">float</span> health;</span><br><span class="line">    <span class="type">float</span> fuel;</span><br><span class="line">    <span class="type">float</span> ammo;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Behavior */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fire</span><span class="params">()</span></span>;</span><br><span class="line">... </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基于此我们可以做更多的变换，比如设计一款查打一体的无人机。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0012.jpg"></p><p>如果大家有一定的语言基础就会意识到，可以用对象的派生和继承关系定义一个无人机 <code>Drone</code> 类，然后再派生一个查打一体无人机 <code>ArmedDrone</code>。这也是非常经典的面向对象的行为方式。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0013.jpg"></p><p>这个方法虽然简单易懂，但是缺陷在于随着我们的游戏世界越做越复杂，这些物体并没有特别清晰的父子关系。</p><h4 id="Component-Base"><a href="#Component-Base" class="headerlink" title="Component Base"></a>Component Base</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0014.jpg"></p><p>现代游戏引擎的常用解决方法是 <strong>组件化</strong>。</p><p>我们把对象的行为拆分为无数的组件，如图所示玩具挖土机的铲子可以换成各种各样的部件，组件可以把同一个基础的物体变为各种各样的物体。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0015.jpg"></p><p>同样的，在玩现代射击游戏中我们可以定制枪械的组件和模块。</p><h4 id="Components-of-a-Drone"><a href="#Components-of-a-Drone" class="headerlink" title="Components of a Drone"></a>Components of a Drone</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0016.jpg"></p><p>回到无人机的案例，我们可以将它的行为和属性拆分为组件：</p><ul><li>Transform</li><li>Motor</li><li>Model</li><li>Animation Physics</li><li>AI</li></ul><p>这些属性和行为都变成一个一个的小组件，最终拼接为自己的无人机。</p><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0017.jpg"></p><p>代码实现只需 <code>ComponentBase</code> 的基类，它统一好每个基础行为接口。然后位移、模型、动画这些类全部派生自这个基类，各种各样的小组件就可以协同工作。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0018.jpg"></p><p>再回到无人机的例子，我们只需替换 AI 模块和战斗模块就拼接为查打一体的无人机。</p><p>所以现代游戏引擎的核心理念是尽可能符合大家的直觉，整个基础结构需要让开发者好维护好理解，同时要交给大量的艺术家和设计师去使用。如第一节课所述，游戏引擎架构它不是技术炫耀体，它是一个生产力工具，大家方便理解才是架构设计的底层需求。</p><h4 id="Components-in-Commercial-Engines"><a href="#Components-in-Commercial-Engines" class="headerlink" title="Components in Commercial Engines"></a>Components in Commercial Engines</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0019.jpg"></p><p>Unity 和 Unreal 等商业引擎都会去提供 Component 的概念。</p><p>需要注意的是 Unreal 的 UObject 不是我们讲的 GO，更像是高级语言的 Object 用于确定对象生命周期的管理。而真正的 GO 则更像是 Actor。</p><h4 id="Takeaways"><a href="#Takeaways" class="headerlink" title="Takeaways"></a>Takeaways</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0020.jpg"></p><ul><li>Everything is a game object in the game world</li><li>Game object could be described in component-based way</li></ul><h3 id="How-to-Make-the-World-Alive"><a href="#How-to-Make-the-World-Alive" class="headerlink" title="How to Make the World Alive"></a>How to Make the World Alive</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0021.jpg"></p><h4 id="Object-based-Tick"><a href="#Object-based-Tick" class="headerlink" title="Object-based Tick"></a>Object-based Tick</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0022.jpg"></p><p>我把每一个 GO 的 Component 依次 Tick 一遍，游戏世界就动起来了，也非常符合我们的直觉。</p><h4 id="Component-based-Tick"><a href="#Component-based-Tick" class="headerlink" title="Component-based Tick"></a>Component-based Tick</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0023.jpg"></p><p>但是在现代游戏引擎中我们一般不是按照每个对象 Tick，而是把一个个系统 Tick。</p><h4 id="Objected-based-Tick-vs-Component-based-Tick"><a href="#Objected-based-Tick-vs-Component-based-Tick" class="headerlink" title="Objected-based Tick vs. Component-based Tick"></a>Objected-based Tick vs. Component-based Tick</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0024.jpg"></p><p>这可能有些反直觉，我们可以举一个例子。</p><p>汉堡的直觉制作方法是每个人烤面包、烤牛肉、洗蔬菜，最后组装在一起。而这样的生产效率并不高，现代工业的核心概念是流水线，最高效的方法是有人专门去烤面包，有人专门去洗蔬菜……大家配合好最后组装成汉堡。</p><h3 id="How-to-Explode-an-Ammo-in-a-Game"><a href="#How-to-Explode-an-Ammo-in-a-Game" class="headerlink" title="How to Explode an Ammo in a Game"></a>How to Explode an Ammo in a Game</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0025.jpg"></p><h4 id="Hardcode"><a href="#Hardcode" class="headerlink" title="Hardcode"></a>Hardcode</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0026.jpg"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bomb::explode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span>(go_type)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> GoType.humen_type:</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* process soldier */</span></span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">case</span> GoType.drone_type:</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* process drone */</span></span><br><span class="line">            ...</span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">case</span> GoType.tank_type:    </span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* process tank */</span></span><br><span class="line">            ...</span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">case</span> GoType.stone_type:</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* process stone */</span></span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0027.jpg"></p><p>现代游戏引擎使用事件系统来优雅地解决这个问题，在系统架构中被称为解耦合。</p><h4 id="Events-mechanism-in-Commercial-Engines"><a href="#Events-mechanism-in-Commercial-Engines" class="headerlink" title="Events mechanism in Commercial Engines"></a>Events mechanism in Commercial Engines</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0028.jpg"></p><h3 id="How-to-Manage-Game-Objects"><a href="#How-to-Manage-Game-Objects" class="headerlink" title="How to Manage Game Objects"></a>How to Manage Game Objects</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0029.jpg"></p><p>很多游戏的 GO 动辄成百上千个，那我发生的每一件事情是如何通知的呢？</p><h4 id="Scene-Management"><a href="#Scene-Management" class="headerlink" title="Scene Management"></a>Scene Management</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0030.jpg"></p><ul><li>每个游戏 GO 会有一个唯一的编号 UID（类比资源管理的 GUID）</li><li>每个物体在空间上都会有位置 position</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0031.jpg"></p><p>最简单的方式就是分而治之划格子，但当场景分布不均匀时可能会出现问题。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0032.jpg"></p><p>就像我们的地图一样，整个世界很大，但是我们可以把世界分成国家、国家分成行省、行省分成城镇、城镇分成区块……假设有一件事件发生，我只需要在某个区块去找就可以了。</p><p>这样一个 Hierarchical 的场景管理方法就是一个非常有效的场景管理方法。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0033.jpg"></p><p>回到刚才的示例，以空间四叉进行划分形成树状结构，也就是数据结构中典型的四叉树。</p><h4 id="Spatial-Data-Structures"><a href="#Spatial-Data-Structures" class="headerlink" title="Spatial Data Structures"></a>Spatial Data Structures</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0034.jpg"></p><p>这其中也分很多流派，有二叉树、八叉树等等。现在游戏引擎比较流行 BVH 层次包围盒技术可以帮助我们快速定位，空间上的数据管理是场景管理的核心。</p><h4 id="Takeaways-1"><a href="#Takeaways-1" class="headerlink" title="Takeaways"></a>Takeaways</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0035.jpg"></p><ul><li>Everything is an object</li><li>Game object could be described in the component-based way</li><li>States of game objects are updated in tick loops</li><li>Game objects interact with each other via event mechanism</li><li>Game objects are managed in a scene with efficient strategies</li></ul><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0036.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0037.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0038.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0039.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0040.jpg"></p><ul><li><strong>如果一个 tick 时间过长怎么办？</strong></li></ul><p>一个比较简单的解决方案是直接跳过 tick。如果某个 tick 计算过于复杂，我们不必要把这些计算放在一帧处理而是分成几批，差个五帧处理完，而五帧在人的视觉中也就 0.2s 左右可以接受。</p><ul><li><strong>空气墙和其他 GO 有什么区别？</strong></li></ul><p>空气墙其实并不是一个很好的例子，游戏中我们用到最多的是透明的 Trigger。空气墙大部分情况作为一个 GO 就解决掉了，有时也会分为许多小 GO，作为引擎开发者不需要考虑这些策略，只需要知道空气墙一般使用最简单的形体来构建即可。</p><ul><li><strong>tick 时，渲染线程和逻辑线程怎么同步？</strong></li></ul><p>一般来讲渲染线程和逻辑线程会分开，而 <code>tickLogic()</code> 会比 <code>tickRender()</code> 早一点。</p><ul><li><strong>空间划分怎么处理动态的游戏对象？</strong></li></ul><p>树的数据结构可以插入或者删除，前面提到的 BVH、BSP 等等都存在更新问题。一般会选择更新轻量化的算法与数据结构以提高效率，所以引擎推荐支持两到三种经典的空间划分算法，游戏产品根据自己的需求去选择。</p><ul><li><strong>组件模式有什么缺点？</strong></li></ul><p>组件模式的第一个缺点是组件模式如果是很基础的实现，它的效率肯定没有直接写一个 class 效率高。后面讲的 ECS 会把同样的组件、数据全放在一起，用方法快速处理这些数据，避免了切换成本过高。</p><p>组件模式的第二个缺点是组件之间需要有一套通讯接口机制，而这个机制在高频调用时对效率的影响是非常大的。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03_page-0041.jpg"></p><br><center><a class="btn" href="https://slides.games-cn.org/course/GAMES104_Lecture03.pdf">            <i class="fas fa-download"></i>GAMES104_Lecture_03          </a></center></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture03.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的数据组织和管理。&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
  <entry>
    <title>Document Style Guide</title>
    <link href="https://yousazoe.top/archives/73e9efed.html"/>
    <id>https://yousazoe.top/archives/73e9efed.html</id>
    <published>2022-03-27T13:35:36.000Z</published>
    <updated>2022-07-29T03:00:04.325Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MD3.png)--><html><head></head><body><p><img data-src="https://img.yousazoe.top/uPic/img/blog/MD3/w6tG5r.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>中文技术文档的写作规范。</p><span id="more"></span><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><h4 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h4><p>标题分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><p>下面是示例。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题</span></span><br></pre></td></tr></tbody></table></figure><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>（1）一级标题下，不能直接出现三级标题。</p><p>示例：下面的文章结构，缺少二级标题。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></tbody></table></figure><p>（2）标题要避免孤立编号（即同级标题只有一个）。</p><p>示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">## 二级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题 B</span></span><br></pre></td></tr></tbody></table></figure><p>（3）下级标题不重复上一级标题的名字。</p><p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">## 概述</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 概述</span></span><br></pre></td></tr></tbody></table></figure><p>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</p><p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p><p>示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">结构一</span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 B</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 C</span></span><br><span class="line"></span><br><span class="line">结构二</span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（1）A**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（2）B**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（3）C**</span></span><br></pre></td></tr></tbody></table></figure><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h4><p>（1）全角中文字符与半角英文字符之间，应有一个半角空格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：本文介绍如何快速启动Windows系统。</span><br><span class="line"></span><br><span class="line">正确：本文介绍如何快速启动 Windows 系统。</span><br></pre></td></tr></tbody></table></figure><p>（2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</span><br><span class="line"></span><br><span class="line">正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。</span><br></pre></td></tr></tbody></table></figure><p>半角的百分号，视同阿拉伯数字。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">正确：今年我国经济增长率是6.5%。</span><br><span class="line"></span><br><span class="line">正确：今年我国经济增长率是 6.5%。</span><br></pre></td></tr></tbody></table></figure><p>（3）英文单位若不翻译，单位前的阿拉伯数字与单位符号之间，应留出适当的空隙。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例1：一部容量为 16 GB 的智能手机</span><br><span class="line"></span><br><span class="line">例2：1 h = 60 min = 3,600 s</span><br></pre></td></tr></tbody></table></figure><p>（4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：他的电脑是 MacBook Air 。</span><br><span class="line"></span><br><span class="line">正确：他的电脑是 MacBook Air。</span><br></pre></td></tr></tbody></table></figure><h4 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h4><p>（1）避免使用长句。</p><p>不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</span><br><span class="line"></span><br><span class="line">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</span><br></pre></td></tr></tbody></table></figure><p>逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。</p><p>（2）尽量使用简单句和并列句，避免使用复合句。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">并列句：他昨天生病了，没有参加会议。</span><br><span class="line"></span><br><span class="line">复合句：那个昨天生病的人没有参加会议。</span><br></pre></td></tr></tbody></table></figure><p>（3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：请确认没有接通装置的电源。</span><br><span class="line"></span><br><span class="line">正确：请确认装置的电源已关闭。</span><br></pre></td></tr></tbody></table></figure><p>（4）避免使用双重否定句。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：没有删除权限的用户，不能删除此文件。</span><br><span class="line"></span><br><span class="line">正确：用户必须拥有删除权限，才能删除此文件。</span><br></pre></td></tr></tbody></table></figure><h4 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h4><p>（1）尽量不使用被动语态，改为使用主动语态。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：假如此软件尚未被安装，</span><br><span class="line"></span><br><span class="line">正确：假如尚未安装这个软件，</span><br></pre></td></tr></tbody></table></figure><p>（2）不使用非正式的语言风格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</span><br><span class="line"></span><br><span class="line">正确：无法参加本次活动，我深感遗憾。</span><br></pre></td></tr></tbody></table></figure><p>（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：这是唯二的快速启动的方法。</span><br><span class="line"></span><br><span class="line">正确：这是仅有的两种快速启动的方法。</span><br></pre></td></tr></tbody></table></figure><p>（4）用对“的”、“地”、“得”。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">她露出了开心的笑容。</span><br><span class="line">（形容词＋的＋名词）</span><br><span class="line"></span><br><span class="line">她开心地笑了。</span><br><span class="line">（副词＋地＋动词）</span><br><span class="line"></span><br><span class="line">她笑得很开心。</span><br><span class="line">（动词＋得＋副词）</span><br></pre></td></tr></tbody></table></figure><p>（5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</span><br><span class="line"></span><br><span class="line">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</span><br></pre></td></tr></tbody></table></figure><p>（6）名词前不要使用过多的形容词。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</span><br><span class="line"></span><br><span class="line">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</span><br></pre></td></tr></tbody></table></figure><h4 id="英文处理"><a href="#英文处理" class="headerlink" title="英文处理"></a>英文处理</h4><p>（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">英文：...information stored in random access memory (RAMs)...</span><br><span class="line"></span><br><span class="line">中文：⋯⋯存储在随机存取存储器（RAM）里的信息⋯⋯</span><br></pre></td></tr></tbody></table></figure><p>（2）外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">U.S.A.</span><br><span class="line">Apple, Inc.</span><br></pre></td></tr></tbody></table></figure><p>（3）表示中文时，英文省略号（<code>...</code>）应改为中文省略号（<code>⋯⋯</code>）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">英文：5 minutes later...</span><br><span class="line"></span><br><span class="line">中文：5 分钟过去了⋯⋯</span><br></pre></td></tr></tbody></table></figure><p>（4）英文书名或电影名改用中文表达时，双引号应改为书名号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">英文：He published an article entitled "The Future of the Aviation".</span><br><span class="line"></span><br><span class="line">中文：他发表了一篇名为《航空业的未来》的文章。</span><br></pre></td></tr></tbody></table></figure><p>（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</span><br></pre></td></tr></tbody></table></figure><p>（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。</span><br><span class="line"></span><br><span class="line">“online transaction processing”（在线事务处理）不是专有名词，不应大写。</span><br></pre></td></tr></tbody></table></figure><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><h4 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h4><ul><li>一个段落只能有一个主题，或一个中心句子。</li><li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li><li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li><li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li><li>段落之间使用一个空行隔开。</li><li>段落开头不要留出空白字符。</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用第三方内容时，应注明出处。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">One man’s constant is another man’s variable. — Alan Perlis</span><br></pre></td></tr></tbody></table></figure><p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">本文转载自 WikiQuote</span><br></pre></td></tr></tbody></table></figure><p>使用外部图片时，必须在图片下方或文末标明来源。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">本文部分图片来自 Wikipedia</span><br></pre></td></tr></tbody></table></figure><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><h4 id="半角数字"><a href="#半角数字" class="headerlink" title="半角数字"></a>半角数字</h4><p>阿拉伯数字一律使用半角形式，不得使用全角形式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：这件商品的价格是１０００元。</span><br><span class="line"></span><br><span class="line">正确：这件商品的价格是 1000 元。</span><br></pre></td></tr></tbody></table></figure><h4 id="千分号"><a href="#千分号" class="headerlink" title="千分号"></a>千分号</h4><p>数值为千位以上，应添加千分号（半角逗号）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">XXX 公司的实收资本为 ￥1,258,000 人民币。</span><br></pre></td></tr></tbody></table></figure><p>对于 4 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于 4 位以上的数值，应添加千分号。</p><h4 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h4><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$1,000</span><br><span class="line">1,000 美元</span><br></pre></td></tr></tbody></table></figure><p>英文的货币名称，建议参考国际标准 <a href="https://en.wikipedia.org/wiki/ISO_4217">ISO 4217</a>。</p><h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>表示数值范围时，用波浪线（<code>～</code>）或一字线（<code>—</code>）连接。参见《标点符号》一节的“连接号”部分。</p><p>带有单位或百分号时，两个数字建议都要加上单位或百分号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">132 kg～234 kg</span><br><span class="line"></span><br><span class="line">67%～89%</span><br></pre></td></tr></tbody></table></figure><h4 id="变化程度的表示法"><a href="#变化程度的表示法" class="headerlink" title="变化程度的表示法"></a>变化程度的表示法</h4><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">增加到过去的两倍</span><br><span class="line">（过去为一，现在为二）</span><br><span class="line"></span><br><span class="line">增加了两倍</span><br><span class="line">（过去为一，现在为三）</span><br></pre></td></tr></tbody></table></figure><p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">降低到百分之八十</span><br><span class="line">（定额是一百，现在是八十）</span><br><span class="line"></span><br><span class="line">降低了百分之八十</span><br><span class="line">（原来是一百，现在是二十）</span><br></pre></td></tr></tbody></table></figure><p>不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><h4 id="原则-2"><a href="#原则-2" class="headerlink" title="原则"></a>原则</h4><p>（1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。</p><p>（2）如果整句为英文，则该句使用英文/半角标点。</p><p>（3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</p><p>（4）点号（句号、逗号、顿号、分号、冒号）不得出现在标题的末尾，而标号（引号、括号、破折号、省略号、书名号、着重号、间隔号、叹号、问号）可以。</p><h4 id="句号"><a href="#句号" class="headerlink" title="句号"></a>句号</h4><p>（1）中文语句的结尾处应该用全角句号（<code>。</code>）。</p><p>（2）句子末尾用括号加注时，句号应在括号之外。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）</span><br><span class="line"></span><br><span class="line">正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。</span><br></pre></td></tr></tbody></table></figure><h4 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h4><p>（1）逗号（<code>，</code>）表示句子内部的一般性停顿。</p><p>（2）注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p><h4 id="顿号"><a href="#顿号" class="headerlink" title="顿号"></a>顿号</h4><p>（1）句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></tbody></table></figure><p>（2）英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.</span><br></pre></td></tr></tbody></table></figure><p>（3）中文句子内部的并列词，最后一个尽量使用（<code>和</code>）来连接，使句子读起来更加连贯，下面两个句子都可以，第二个更优。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里，以及百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></tbody></table></figure><h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>（1）分号（<code>；</code>）表示复句内部并列分句之间的停顿。</p><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>（1）引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</span><br></pre></td></tr></tbody></table></figure><p>（2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</span><br></pre></td></tr></tbody></table></figure><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>（1）补充说明时，使用全角圆括号（<code>（）</code>），括号前后不加空格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</span><br></pre></td></tr></tbody></table></figure><p>（2）几种括号的中英文名称。</p><table><thead><tr><th></th><th>英文</th><th>中文</th></tr></thead><tbody><tr><td><code>{ }</code></td><td>braces 或 curly brackets</td><td>大括号</td></tr><tr><td><code>[ ]</code></td><td>square brackets 或 brackets</td><td>方括号</td></tr><tr><td><code>&lt; &gt;</code></td><td>angled brackets</td><td>尖括号</td></tr><tr><td><code>( )</code></td><td>parentheses</td><td>圆括号</td></tr></tbody></table><h4 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h4><p>（1）全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：请确认以下几项内容：时间、地点、活动名称和来宾数量。</span><br></pre></td></tr></tbody></table></figure><p>（2）表示时间时，应使用半角冒号（<code>:</code>）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：早上 8:00</span><br></pre></td></tr></tbody></table></figure><h4 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h4><p>（1）省略号（<code>⋯⋯</code>）表示语句未完、或者语气的不连续。</p><p>（2）省略号占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p><p>（3）省略号不应与“等”这个词一起使用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨⋯⋯</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</span><br></pre></td></tr></tbody></table></figure><h4 id="感叹号"><a href="#感叹号" class="headerlink" title="感叹号"></a>感叹号</h4><p>（1）应该使用平静的语气叙述，尽量避免使用感叹号（<code>！</code>）。</p><p>（2）不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p><h4 id="破折号"><a href="#破折号" class="headerlink" title="破折号"></a>破折号</h4><p>（1）破折号<code>————</code>一般用于进一步解释。</p><p>（2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</span><br><span class="line"></span><br><span class="line">例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。</span><br></pre></td></tr></tbody></table></figure><h4 id="连接号"><a href="#连接号" class="headerlink" title="连接号"></a>连接号</h4><p>（1）连接号用于连接两个类似的词。</p><p>（2）以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p><ul><li>两个名词的复合</li><li>图表编号</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：氧化-还原反应</span><br><span class="line"></span><br><span class="line">例句：图 1-1</span><br></pre></td></tr></tbody></table></figure><p>（3）数值范围（例如日期、时间或数字）应该使用波浪连接号（<code>～</code>）或一字号（<code>—</code>），占一个全角字符的位置。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：2009 年～2011 年</span><br></pre></td></tr></tbody></table></figure><p>注意，波浪连接号前后两个值都建议加上单位。</p><p>（4）波浪连接号也可以用汉字“至”代替。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">例句：周围温度：-20 °C 至 -10 °C</span><br></pre></td></tr></tbody></table></figure><h3 id="文档体系"><a href="#文档体系" class="headerlink" title="文档体系"></a>文档体系</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li><p><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</p></li><li><p><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</p></li><li><p>入门篇</p><p>（Basics）： [必备] [目录] 又称“使用篇”，提供初级的使用教程</p><ul><li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li><li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li><p><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称“开发篇”，提供中高级的开发教程</p></li><li><p><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</p></li><li><p><strong>FAQ</strong>：[可选] [文件] 常见问题解答</p></li><li><p>附录</p><p>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容</p><ul><li><strong>Glossary</strong>：[可选] [文件] 名词解释</li><li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li><li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li><li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li><li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li></ul></li></ul><p>下面是两个真实范例，可参考。</p><ul><li><a href="https://redux.js.org/introduction/getting-started">Redux 手册</a></li><li><a href="http://flight-manual.atom.io/">Atom 手册</a></li></ul><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：名词解释.md</span><br><span class="line"></span><br><span class="line">正确：glossary.md</span><br></pre></td></tr></tbody></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">错误：TroubleShooting.md</span><br><span class="line"></span><br><span class="line">正确：troubleshooting.md</span><br></pre></td></tr></tbody></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">不佳：advanced_usage.md</span><br><span class="line"></span><br><span class="line">正确：advanced-usage.md</span><br></pre></td></tr></tbody></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.taodocs.com/p-51273.html">产品手册中文写作规范</a>, by 华为</li><li><a href="http://guide.daocloud.io/dcs/%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83%E5%92%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83-9153803.html">写作规范和格式规范</a>, by DaoCloud</li><li><a href="http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf">技术写作技巧在日汉翻译中的应用</a>, by 刘方</li><li><a href="https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf">简体中文规范指南</a>, by lengoo</li><li><a href="https://open.leancloud.cn/copywriting-style-guide.html">文档风格指南</a>, by LeanCloud</li><li><a href="https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit">豌豆荚文案风格指南</a>, by 豌豆荚</li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines">中文文案排版指北</a>, by sparanoid</li><li><a href="http://w3c.github.io/clreq/">中文排版需求</a>, by W3C</li><li><a href="http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html">为什么文件名要小写？</a>, by 阮一峰</li><li><a href="https://developers.google.com/style/">Google Developer Documentation Style Guide</a>, by Google</li><li><a href="http://www.moe.gov.cn/ewebeditor/uploadfile/2015/01/13/20150113091154536.pdf">出版物上数字用法的规定（国家标准GBT15835－2011）</a></li><li><a href="https://zh.wikisource.org/zh-hans/GB_3100-1993_%E5%9B%BD%E9%99%85%E5%8D%95%E4%BD%8D%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8">GB 3100-1993 国际单位制及其应用</a></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;!--![](https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/MD3.png)--&gt;
&lt;p&gt;&lt;img data-src=&quot;https://img.yousazoe.top/uPic/img/blog/MD3/w6tG5r.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;中文技术文档的写作规范。&lt;/p&gt;</summary>
    
    
    
    <category term="写作技巧 (Write Skill)" scheme="https://yousazoe.top/categories/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7-Write-Skill/"/>
    
    
    <category term="Write" scheme="https://yousazoe.top/tags/Write/"/>
    
    <category term="Markdown" scheme="https://yousazoe.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Layered Architecture of Game Engine</title>
    <link href="https://yousazoe.top/archives/df41bbe4.html"/>
    <id>https://yousazoe.top/archives/df41bbe4.html</id>
    <published>2022-03-21T14:53:31.000Z</published>
    <updated>2022-07-29T03:00:04.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><html><head></head><body><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0001.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的分层架构。</p><span id="more"></span><iframe src="//player.bilibili.com/player.html?aid=382628067&amp;bvid=BV12Z4y1B7th&amp;cid=560857068&amp;page=1&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0002.jpg"></p><p>同学们开始学习游戏引擎知识的时候，大家第一个困惑是恐惧感。那么多的文件，那么多的代码我该从何开始？这其实是学习游戏引擎一个很天然的感觉，而对一个事物的认知讲究由浅入深。</p><h3 id="A-Glance-of-Game-Engine-layers"><a href="#A-Glance-of-Game-Engine-layers" class="headerlink" title="A Glance of Game Engine layers"></a>A Glance of Game Engine layers</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0003.jpg"></p><p>所以先不用着急，先浮光掠影感受一下一个游戏引擎大概有哪些层次，下面来做一个快速的旅行。</p><h4 id="Tool-Layer"><a href="#Tool-Layer" class="headerlink" title="Tool Layer"></a>Tool Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0004.jpg"></p><p>一个现代游戏引擎下载下来首先看到的不是源代码，是各种各样的编辑器。</p><p>我们可以在里面编辑我们的关卡、做角色动画……看上去眼花缭乱，编辑器本身功能非常丰富，拖拖拽拽好像真的可以做出想象中的游戏世界。这是大家对游戏引擎的最直观的第一印象，所以这个时候接触了引擎的最上层：<strong>工具层</strong>（<strong>Tool Layer</strong>）。</p><h4 id="Function-Layer"><a href="#Function-Layer" class="headerlink" title="Function Layer"></a>Function Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0005.jpg"></p><p>做一款游戏首先要绘制出来，游戏的绘制过程本质上是把一个虚拟的三维世界转换为一帧一帧的二维图像，也就是<strong>渲染</strong> (Rendering)；这里面所有的东西不一定都是静止的，我们可能还需要一些<strong>动画</strong> (Animation) 让它们动起来；如果这个世界需要碰撞，<strong>物理</strong> (Physics) 的表达必不可少；除此之外可能还需要<strong>脚本</strong> (Script)、<strong>状态机</strong> (FSM)、AI 等等……</p><h4 id="Resource-Layer"><a href="#Resource-Layer" class="headerlink" title="Resource Layer"></a>Resource Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0006.jpg"></p><p>游戏引擎不是只通过一堆代码就可以跑起来，其中还包含了大量的数据和文件。</p><p>而这些数据和文件来自不同的软件，例如 Photoshop、3dMax、Maya 等。这么多的图形、几何、音视频和各种复杂的数据，在游戏引擎里是由 <strong>资源层</strong>（<strong>Resource Layer</strong>） 负责加载、管理这些资源。 </p><h4 id="Core-Layer"><a href="#Core-Layer" class="headerlink" title="Core Layer"></a>Core Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0007.jpg"></p><p>到这里对于普通开发者引擎已经可以跑了，但可以观察到上面的动画、物理、渲染等系统会频繁调用一些很底层的代码，例如最基础的容器的创建、内存的分配和线程管理。</p><p>这些东西好像并没有出现在功能层或是资源层，意味着我们触碰到引擎的 <strong>核心层</strong>（<strong>Core Layer</strong>）。核心层就像一个工具箱或者瑞士军刀，上面的游戏相关的逻辑管理全部是架在底座 Core 下面。</p><h4 id="Platform-Layer"><a href="#Platform-Layer" class="headerlink" title="Platform Layer"></a>Platform Layer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0008.jpg"></p><p>还有一个非常容易被忽略的分层：<strong>平台层</strong>（<strong>Platform Layer</strong>）。</p><p>游戏引擎生产的游戏最终是会发布给用户的，但用户的设备千千万万，有人可能是 PC，有的人可能是 iMac，还有的人可能是手机。输入设备的不同也会产生显著影响，常见的键盘鼠标显然要与手柄分开，更有甚者可能会使用体感设备。</p><p>所以无论来自什么样的输入设备，到我的游戏世界里面都要翻译成一个统一的语言。而这种平台的差异不仅体现在硬件设备上，还包括软件的发布平台比如我们的 STEAM 和 EPIC，它们的接口和收费模型完全不一样。</p><h4 id="3rd-Party-Libraries"><a href="#3rd-Party-Libraries" class="headerlink" title="3rd Party Libraries"></a>3rd Party Libraries</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0009.jpg"></p><h4 id="Explore-Game-Engine-layers"><a href="#Explore-Game-Engine-layers" class="headerlink" title="Explore Game Engine layers"></a>Explore Game Engine layers</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0010.jpg"></p><h4 id="Practice-is-the-Best-Way-to-Learn"><a href="#Practice-is-the-Best-Way-to-Learn" class="headerlink" title="Practice is the Best Way to Learn"></a>Practice is the Best Way to Learn</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0011.jpg"></p><p>人们常说实践是最好的老师，那么现在有一个挑战：如何在引擎中写出一个简单的角色动画控制器？</p><h3 id="Resource-Layer-1"><a href="#Resource-Layer-1" class="headerlink" title="Resource Layer"></a>Resource Layer</h3><h4 id="How-to-Access-My-Data"><a href="#How-to-Access-My-Data" class="headerlink" title="How to Access My Data"></a>How to Access My Data</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0012.jpg"></p><p>首先拜托美术同学用三维建模软件制作了角色，还做了很多的贴图和动画。</p><p>这些资源每个的数据格式都是不一样的：<code>.max</code>、<code>.maya</code>……这些数据肯定不可能在引擎中一一打开读取这些数据格式，并且这些数据格式实际上是为自己的工具服务的，其中包含了大量无效的信息，如果全部在引擎中加载效率会非常低。所以我们会对 Resource 做一步转换，变为引擎的高效格式：<strong>资产</strong>（<strong>Access</strong>）。</p><p>所以第一步是要把这些数据进行引擎化，变成我们的资产。</p><h4 id="Runtime-Asset-Manager"><a href="#Runtime-Asset-Manager" class="headerlink" title="Runtime Asset Manager"></a>Runtime Asset Manager</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0013.jpg"></p><p>当我们把原始散乱的文件变成引擎的资产时，会发现其实还需要一个实时的资产管理器。</p><p>这些资产在 Runtime Resource Management 中它们会互相指向对方，这个时候在游戏引擎设计中会经常有一个重要的 handle 系统。简单解释它就像一个邮箱，我始终有邮箱的钥匙，这样邮箱主人有没有、邮箱主人在不在只要问这个邮箱就知道了。</p><h4 id="Manage-Asset-Life-Cycle"><a href="#Manage-Asset-Life-Cycle" class="headerlink" title="Manage Asset Life Cycle"></a>Manage Asset Life Cycle</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0014.jpg"></p><p>简而言之，资源层在游戏中最核心的是管理所有这些资产的生命周期。</p><p>为什么资产的生命周期如此重要？可能大家没有注意，现代游戏关卡中随着进度的推进许多资产会无效，同时要加载许多新的资产，其中的关系是非常复杂的。</p><p>同样的 GC 垃圾回收概念也是如此，现代游戏如果 GC 做不好会让整个系统效率变得非常低下。</p><h3 id="Function-Layer-1"><a href="#Function-Layer-1" class="headerlink" title="Function Layer"></a>Function Layer</h3><h4 id="How-to-Make-the-World-Alive"><a href="#How-to-Make-the-World-Alive" class="headerlink" title="How to Make the World Alive"></a>How to Make the World Alive</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0015.jpg"></p><p>那怎么让角色动起来呢？</p><p>这里面有一个很重要的概念：Tick。它会每隔一个非常短的时间把世界往前推一小格，可以类比普朗克时间，我们认为任何一个物理过程不可能小于普朗克时间。</p><p>在游戏中的话每经历一个 Tick 我们的系统会把该做的事情做完，比如读入输入输出、动一下相机、动一下人物和角色、绘制一帧的画面、做一下 Memory GC…..整个逻辑往前走一点，在游戏的世界其实就是利用现代计算机非常高的计算速度每隔 1/30 秒把整个世界的逻辑和绘制全部跑了一遍，这就是 Tick 的魔力。</p><h4 id="Dive-into-Ticks"><a href="#Dive-into-Ticks" class="headerlink" title="Dive into Ticks"></a>Dive into Ticks</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0016.jpg"></p><p>现代游戏引擎的 <code>mian()</code> 函数中一般会出现两个非常重要的函数：<code>tickLogic()</code> 和 <code>tickRender()</code>。我们以模拟世界为先，随后再把它表现渲染出来。</p><h4 id="Tick-the-Animation-and-Renderer"><a href="#Tick-the-Animation-and-Renderer" class="headerlink" title="Tick the Animation and Renderer"></a>Tick the Animation and Renderer</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0017.jpg"></p><p>动画的基础理论是视觉残留，而这一点在现代游戏中会充分利用。</p><h4 id="Heavy-duty-Hotchpotch"><a href="#Heavy-duty-Hotchpotch" class="headerlink" title="Heavy-duty Hotchpotch"></a>Heavy-duty Hotchpotch</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0018.jpg"></p><h4 id="Multi-Threading"><a href="#Multi-Threading" class="headerlink" title="Multi-Threading"></a>Multi-Threading</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0019.jpg"></p><p>现代计算机架构逐渐从单核走向多核，未来的多核时代会是游戏引擎很重要的一个方向。</p><p>最早的游戏引擎是单线程的，后面多核最简单的做法是把 <code>Logic()</code> 和 <code>Render()</code> 分到两个线程里面去。现在的商业引擎则会把一些特别容易并行化的物理或动画计算单独 Fork 出来分散到线程中，如中图所示。</p><p>未来引擎架构则考量能否把 Job 任务变成原子的，把每个核物尽其用安排满满的。</p><h3 id="Core-Layer-1"><a href="#Core-Layer-1" class="headerlink" title="Core Layer"></a>Core Layer</h3><h4 id="Math-Library"><a href="#Math-Library" class="headerlink" title="Math Library"></a>Math Library</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0020.jpg"></p><p>核心层最容易引起关注的就是数学库。</p><p>游戏引擎中大部分的数学并不是特别的高深，大学的线性代数基本上够用了。那为什么游戏引擎里这些数学库会单独列出来呢？</p><h4 id="Math-Efficiency"><a href="#Math-Efficiency" class="headerlink" title="Math Efficiency"></a>Math Efficiency</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0021.jpg"></p><p>这就牵扯到游戏引擎中一个独特的需求：游戏引擎的一切都是为效率服务的，它是一个 Real-Time 的 Application，所有用户的输入和反馈必须是实时的，玩家对效率是非常敏感的。一个经典的例子就是 Quake 引擎中的求倒数平方根：<a href="https://www.yousazoe.top/archives/e094b83a.html">Fast Inverse Square Root — a Quake III Algorithm</a>。</p><p>SIMD 也是现代计算机需要注意的一个东西。在游戏引擎中很多时候就是矩阵和向量的加减乘除，于是诞生了 Single Instruction Multiple Data 的概念，也是在数学库中广泛使用的技术。</p><h4 id="Data-Structure-and-Containers"><a href="#Data-Structure-and-Containers" class="headerlink" title="Data Structure and Containers"></a>Data Structure and Containers</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0022.jpg"></p><p>核心层不止数学，它为上层的所有逻辑提供基础服务，其中最重要的就是数据结构。</p><p>C++ 的 STL 提供了标准容器，那为什么引擎核心层还要再做一遍？不难发现当容器被高频访问、添加删除数据时，它会在内存中产生大量碎片，访问效率会受到影响。 </p><h4 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0023.jpg"></p><p>所以游戏引擎的开发可以类比于操作系统，尤其是在内存管理方面。C++17 或者 C++21的高端功能许多人学得感觉云里雾里，但实际上的底层逻辑无非三条：</p><ul><li>把数据放在一起</li><li>尽可能顺序访问数据</li><li>尽可能一起读写数据</li></ul><h4 id="Foundation-of-Game-Engine"><a href="#Foundation-of-Game-Engine" class="headerlink" title="Foundation of Game Engine"></a>Foundation of Game Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0024.jpg"></p><h3 id="Platform-Layer-1"><a href="#Platform-Layer-1" class="headerlink" title="Platform Layer"></a>Platform Layer</h3><h4 id="Target-on-Different-Platform"><a href="#Target-on-Different-Platform" class="headerlink" title="Target on Different Platform"></a>Target on Different Platform</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0025.jpg"></p><p>不同的平台甚至连文件路径的格式都不一样，但又不可能把引擎中的这些代码从头到尾改一遍，这个时候平台层就会变得非常重要。</p><p>平台层本质上就是人们在上面写核心写功能，可以无视这些平台的区别而直接写它核心的逻辑。平台无关性就是把所有平台的差异全部掩盖掉，这一层也是现代游戏引擎非常核心的东西。</p><h4 id="Graphics-API"><a href="#Graphics-API" class="headerlink" title="Graphics API"></a>Graphics API</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0026.jpg"></p><p>现代游戏引擎中有一个非常重要的东西：Render Hardware Interface（RHI），它重新定义图形 API，把各个硬件的 SDK 区别封装起来。所以平台层是一个很容易被大家忽略的一层，但其实也是体现引擎水平高下很重要的一层。</p><h4 id="Hardware-Architecture"><a href="#Hardware-Architecture" class="headerlink" title="Hardware Architecture"></a>Hardware Architecture</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0027.jpg"></p><h3 id="Tool-Layer-1"><a href="#Tool-Layer-1" class="headerlink" title="Tool Layer"></a>Tool Layer</h3><h4 id="Allow-Anyone-to-Create-Game"><a href="#Allow-Anyone-to-Create-Game" class="headerlink" title="Allow Anyone to Create Game"></a>Allow Anyone to Create Game</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0028.jpg"></p><p><strong>Unleash the Creativity</strong></p><ul><li>Build upon game engine</li><li>Create, edit and exchange game play assets</li></ul><p>工具层代码选择以开发效率优先如 C++ 和 QT，而不是以运行效率为优先。</p><h4 id="Digital-Content-Creation"><a href="#Digital-Content-Creation" class="headerlink" title="Digital Content Creation"></a>Digital Content Creation</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0029.jpg"></p><p>DCC（Digital Content Creation），翻译一下就是别人开发的资产生产工具。大名鼎鼎的 MAYA、3DMAX、Houdini 生产的数字资产通过一条 Asset Conditioning Pipline 导出管线变为引擎统一的 Asset。</p><h3 id="Why-Layered-Architecture"><a href="#Why-Layered-Architecture" class="headerlink" title="Why Layered Architecture"></a>Why Layered Architecture</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0030.jpg"></p><p>那么引擎为什么要分层呢？主要有两点：</p><ul><li>Decoupling 复杂度</li><li>Response 不断变化的需求</li></ul><p>各个层次之间的调用一般只允许上面的层次调用下面的层次，而绝对不允许反向调用。</p><h3 id="Mini-Engine-Pilot"><a href="#Mini-Engine-Pilot" class="headerlink" title="Mini Engine - Pilot"></a>Mini Engine - Pilot</h3><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0031.jpg"></p><h4 id="Neat-PILOT-Engine"><a href="#Neat-PILOT-Engine" class="headerlink" title="Neat PILOT Engine"></a>Neat PILOT Engine</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0032.jpg"></p><h4 id="Release-Plan"><a href="#Release-Plan" class="headerlink" title="Release Plan"></a>Release Plan</h4><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0034.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0035.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0036.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0037.jpg"></p><p><img data-src="https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0038.jpg"></p><br><a class="btn" href="https://slides.games-cn.org/course/GAMES104_Lecture02.pdf">            <i class="fas fa-download"></i>GAMES104_Lecture_02          </a></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/Yousazoe/picgo-repo/img/GAMES104_Lecture02_page-0001.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识。通过该课程，你能够对游戏引擎建立起一个全面且完整的了解。本节主要是介绍游戏引擎的分层架构。&lt;/p&gt;</summary>
    
    
    
    <category term="现代游戏引擎从入门到实践 (GAMES104-Modern Game Engines-Theory and Practice)" scheme="https://yousazoe.top/categories/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-GAMES104-Modern-Game-Engines-Theory-and-Practice/"/>
    
    
    <category term="Game Engine" scheme="https://yousazoe.top/tags/Game-Engine/"/>
    
  </entry>
  
</feed>
